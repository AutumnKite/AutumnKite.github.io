<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AtCoder Grand Contest 031 题解</title>
    <url>/atcoder-agc031/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc031">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---colorful-subsequence">A - Colorful Subsequence</h3>
<h4 id="题意">题意</h4>
<p>给定一个长度为 <span class="math inline">\(N\)</span> 的字符串 <span class="math inline">\(S\)</span>，求有多少非空子序列满足该子序列中的字符两两不同。对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p>子序列不要求连续。</p>
<p><span class="math inline">\(N\le 10^5\)</span></p>
<h4 id="题解">题解</h4>
<p>令 <span class="math inline">\(c_i\)</span> 为字符 <span class="math inline">\(i\)</span> 的出现次数。则答案为所有 <span class="math inline">\(c_i+1\)</span> 的乘积。</p>
<p>由于子序列非空，答案需要减 <span class="math inline">\(1\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc031/submissions/17404180">代码</a></p>
<h3 id="b---reversi">B - Reversi</h3>
<h4 id="题意-1">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个石子，第 <span class="math inline">\(i\)</span> 个石子颜色为 <span class="math inline">\(C_i\)</span>。可以执行若干次以下操作：</p>
<ul>
<li>选择两个颜色相同的石子，将这两个石子之间的石子的颜色都染成这两个石子的颜色。</li>
</ul>
<p>求可以得到的不同序列数量。对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(N\le 2\times 10^5\)</span></p>
<h4 id="题解-1">题解</h4>
<p>最后的序列一定是若干段颜色相同的段组成的。</p>
<p>令 <span class="math inline">\(f_i\)</span> 为以 <span class="math inline">\(i\)</span> 作为最后一段结尾的序列数量。则有 <span class="math display">\[f_i=\sum_{c_j=c_i,c_{j-1}\ne c_j} f_{j-1}\]</span></p>
<p>简单维护即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc031/submissions/17404842">代码</a></p>
<h3 id="c---differ-by-1-bit">C - Differ by 1 Bit</h3>
<h4 id="题意-2">题意</h4>
<p>给定 <span class="math inline">\(N,A,B\)</span>，求一个 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(2^N-1\)</span> 的排列 <span class="math inline">\(P\)</span>，满足：</p>
<ul>
<li><span class="math inline">\(P_0=A,P_{2^N-1}=B\)</span></li>
<li>对于任意 <span class="math inline">\(0\le i &lt; 2^N-1\)</span>，<span class="math inline">\(P_i\)</span> 和 <span class="math inline">\(P_{i+1}\)</span> 二进制表示恰好有一位不同。</li>
</ul>
<p>或输出无解。</p>
<p><span class="math inline">\(N\le 17\)</span></p>
<h4 id="题解-2">题解</h4>
<p>显然 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(B\)</span> 在二进制表示下有偶数位不同时一定无解。这是因为共修改了 <span class="math inline">\(2^N-1\)</span> 次，而 <span class="math inline">\(2^N-1\)</span> 是奇数，不可能最后有偶数位不同。否则我们可以构造证明有解。</p>
<p>记 <span class="math inline">\(p\)</span> 为 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(B\)</span> 的任意一位不同的二进制位。那么我们可以将第 <span class="math inline">\(p\)</span> 位与 <span class="math inline">\(A\)</span> 相同的数放在前半部分，与 <span class="math inline">\(B\)</span> 相同的数放在后半部分。</p>
<p>我们可以枚举中间分界处的数 <span class="math inline">\(S\)</span>，注意到一定存在这样的 <span class="math inline">\(S\)</span> 满足 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 分别有奇数位不同。</p>
<p>于是我们可以递归到两个 <span class="math inline">\(N-1\)</span> 位的子问题。</p>
<p>时间复杂度 <span class="math inline">\(O(2^NN)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc031/submissions/17408233">代码</a></p>
<h3 id="d---a-sequence-of-permutations">D - A Sequence of Permutations</h3>
<h4 id="题意-3">题意</h4>
<p>令 <span class="math inline">\(p,q\)</span> 为两个 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\)</span> 的排列，定义 <span class="math inline">\(f(p,q)\)</span> 为位置 <span class="math inline">\(p_i\)</span> 为 <span class="math inline">\(q_i\)</span> 的排列。</p>
<p>给定排列 <span class="math inline">\(p,q\)</span>，定义序列 <span class="math inline">\(\{a_n\}\)</span> 如下：</p>
<ul>
<li><span class="math inline">\(a_1=p,a_2=q\)</span></li>
<li><span class="math inline">\(a_{n+2}=f(a_n,a_{n+1})\)</span></li>
</ul>
<p>给定整数 <span class="math inline">\(K\)</span>，求 <span class="math inline">\(a_K\)</span>。</p>
<p><span class="math inline">\(N\le 10^5,K\le 10^9\)</span></p>
<h4 id="题解-3">题解</h4>
<p>根据题意，有 <span class="math display">\[
f(p,q)=
\begin{pmatrix}
p_1 &amp; p_2 &amp; \ldots &amp; p_N \\
q_1 &amp; q_2 &amp; \ldots &amp; q_N
\end{pmatrix}
\]</span></p>
<p>根据置换乘法的定义，有 <span class="math display">\[
\begin{pmatrix}
1 &amp; 2 &amp; \ldots &amp; N \\
p_1 &amp; p_2 &amp; \ldots &amp; p_N
\end{pmatrix}
\begin{pmatrix}
p_1 &amp; p_2 &amp; \ldots &amp; p_N \\
q_1 &amp; q_2 &amp; \ldots &amp; q_N
\end{pmatrix}
=
\begin{pmatrix}
1 &amp; 2 &amp; \ldots &amp; N \\
q_1 &amp; q_2 &amp; \ldots &amp; q_N
\end{pmatrix}
\]</span></p>
<p>即有 <span class="math display">\[p\cdot f(p,q)=q\]</span></p>
<p>即 <span class="math display">\[f(p,q)=p^{-1}q\]</span></p>
<p>另外，置换乘法有性质 <span class="math display">\[(ab)^{-1}=b^{-1}a^{-1}\]</span></p>
<p>于是可以得到 <span class="math display">\[
\begin{aligned}
a_1 &amp; = p \\
a_2 &amp; = q \\
a_3 &amp; = p^{-1}q \\
a_4 &amp; = q^{-1}p^{-1}q \\
a_5 &amp; = q^{-1}pq^{-1}p^{-1}q \\
a_6 &amp; = q^{-1}p^2q^{-1}p^{-1}q \\
a_7 &amp; = q^{-1}pqpq^{-1}p^{-1}q \\
a_8 &amp; = q^{-1}pqp^{-1}qpq^{-1}p^{-1}q
\end{aligned}
\]</span></p>
<p>令 <span class="math inline">\(r=q^{-1}pqp^{-1}\)</span>，可以归纳证明有 <span class="math display">\[a_n=ra_{n-6}r^{-1}\]</span></p>
<p>求一个置换的幂次可以通过求出该置换的每个循环 <span class="math inline">\(O(N)\)</span> 实现。</p>
<p>时间复杂度 <span class="math inline">\(O(N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc031/submissions/17409672">代码</a></p>
<h3 id="e---snuke-the-phantom-thief">E - Snuke the Phantom Thief</h3>
<h4 id="题意-4">题意</h4>
<p>平面上有 <span class="math inline">\(N\)</span> 个点，第 <span class="math inline">\(i\)</span> 个点在 <span class="math inline">\((x_i,y_i)\)</span>，价值为 <span class="math inline">\(v_i\)</span>。</p>
<p>你需要选择若干个点，有 <span class="math inline">\(M\)</span> 个限制，第 <span class="math inline">\(i\)</span> 个限制为横坐标/纵坐标小于等于/大于等于 <span class="math inline">\(a_i\)</span> 的点最多只能选 <span class="math inline">\(b_i\)</span> 个。</p>
<p>求选择的点的最大价值和。</p>
<p><span class="math inline">\(N\le 80,M\le 320,1\le x_i,y_i,a_i\le 100,1\le v_i\le 10^{15}\)</span></p>
<h4 id="题解-4">题解</h4>
<p>先考虑限制只有小于等于的情况。</p>
<p>考虑建立费用流模型，建立左右两排点。</p>
<p>对于左边第 <span class="math inline">\(i\)</span> 个点，该点只有唯一一条入边，该入边的流量为横坐标小于等于 <span class="math inline">\(i\)</span> 的点被选择的数量。</p>
<p>该点有若干出边，其中一条连向第 <span class="math inline">\(i-1\)</span> 个点，流量表示横坐标小于等于 <span class="math inline">\(i-1\)</span> 的点被选择的数量，其余边连向右边的点，流量表示是否选择一个横坐标为 <span class="math inline">\(i\)</span>，纵坐标为右边对应点的编号的点。</p>
<p>另外，源点连向左边最后一个点，流量表示总共被选择的点数。</p>
<p>右边的点同理。</p>
<p>这样子建图相当于原题每个限制会对左边或右边某条边的流量上界产生限制，而每个点对应左边到右边的一条边。</p>
<p>回到原题，考虑枚举总点数 <span class="math inline">\(s\)</span>，那么相当于每个坐标大于等于某个值的数量的上界限制可以转化为坐标小于等于某个值的数量的下界限制，也即会对左边或右边某条边的流量产生下界限制。</p>
<p>跑上下界费用流即可。</p>
<p><a href="https://atcoder.jp/contests/agc031/submissions/17417860">代码</a></p>
<h3 id="f---walk-on-graph">F - Walk on Graph</h3>
<h4 id="题意-5">题意</h4>
<p>给定一个 <span class="math inline">\(N\)</span> 个点 <span class="math inline">\(M\)</span> 条边的边带权无向连通图 <span class="math inline">\(G\)</span> 和一个奇数 <span class="math inline">\(P\)</span>，回答 <span class="math inline">\(Q\)</span> 次询问，第 <span class="math inline">\(i\)</span> 个询问为：</p>
<ul>
<li>判断 <span class="math inline">\(S_i\)</span> 到 <span class="math inline">\(T_i\)</span> 是否存在一条路径使得该路径的权值在模 <span class="math inline">\(P\)</span> 意义下与 <span class="math inline">\(R_i\)</span> 相等。</li>
</ul>
<p>路径可以经过重复点、重复边。</p>
<p>路径的权值定义为，若一条路径依次经过的边的边权为 <span class="math inline">\(L_0,L_1,L_2,\ldots,L_{k-1}\)</span>，那么该路径的权值为 <span class="math inline">\(\sum_{i=0}^{k-1} L_i\times 2^i\)</span>。</p>
<p><span class="math inline">\(N,M,Q\le 50000,P\le 10^6\)</span></p>
<h4 id="题解-5">题解</h4>
<p>若无注明，以下涉及权值有关运算均在模 <span class="math inline">\(P\)</span> 意义下进行。</p>
<p>将路径反过来，这样相当于每经过一条边权为 <span class="math inline">\(c\)</span> 的边，权值从 <span class="math inline">\(x\)</span> 变为 <span class="math inline">\(2x+c\)</span>。</p>
<p>记状态 <span class="math inline">\((u,x)\)</span> 为当前在节点 <span class="math inline">\(u\)</span>，权值为 <span class="math inline">\(x\)</span>。那么询问相当于判断 <span class="math inline">\((t,0)\)</span> 是否可以到达 <span class="math inline">\((s,r)\)</span>。</p>
<p>令 <span class="math inline">\(f(x)=2x+c\)</span>，由于 <span class="math inline">\(P\)</span> 是奇数，<span class="math inline">\(2\)</span> 有逆元，所以 <span class="math inline">\(f\)</span> 是一个双射，若 <span class="math inline">\(x\)</span> 向 <span class="math inline">\(f(x)\)</span> 连边，最终一定会形成若干个环。</p>
<p>考虑一条边 <span class="math inline">\((u,v,c)\)</span>，状态 <span class="math inline">\((u,x)\)</span> 一定可以来回通过这条边最终回到 <span class="math inline">\((u,x)\)</span>。这就意味着 <span class="math inline">\((u,x)\)</span> 可以到达 <span class="math inline">\((v,2x+c)\)</span>，<span class="math inline">\((v,2x+c)\)</span> 也可以到达 <span class="math inline">\((u,c)\)</span>，也即状态之间的边是双向的。接下来我们称两个状态等价当且仅当他们连通。</p>
<p>若同时存在边 <span class="math inline">\((u,v,a)\)</span> 和 <span class="math inline">\((u,w,b)\)</span>，那么有 <span class="math inline">\((u,x)\to (v,2x+a)\to (u,4x+3a)\)</span> 和 <span class="math inline">\((u,x)\to (w,2x+b)\to (u,4x+3b)\)</span>，即 <span class="math inline">\((u,4x+3a)\)</span> 和 <span class="math inline">\((u,4x+3b)\)</span> 是等价的。</p>
<p><span class="math inline">\(4\)</span> 也存在逆元，那么 <span class="math inline">\(4x+3a\)</span> 可以取到任何值，所以有 <span class="math inline">\((u,x)\)</span> 和 <span class="math inline">\((u,x+3(b-a))\)</span> 等价。</p>
<p>我们求出任意两条边边权之差的 <span class="math inline">\(\gcd\)</span>，记为 <span class="math inline">\(g\)</span>。由于图是连通的，我们可以从一个状态 <span class="math inline">\((u,x)\)</span> 出发，走到每个点对 <span class="math inline">\(x\)</span> 进行若干次变换，最终可以到达状态 <span class="math inline">\((u,x+3g)\)</span>。也就是说 <span class="math inline">\((u,x)\)</span> 与 <span class="math inline">\((u,x+3g)\)</span> 是等价的。</p>
<p>于是我们可以将 <span class="math inline">\(P\)</span> 置为 <span class="math inline">\(\gcd(P,3g)\)</span>。</p>
<p>注意到此时所有边边权模 <span class="math inline">\(g\)</span> 相等，置为 <span class="math inline">\(z\)</span>。我们可以把所有边边权减 <span class="math inline">\(z\)</span>，状态中的第二维（即路径权值）增加 <span class="math inline">\(z\)</span>。这样原来的状态 <span class="math inline">\((u,x)\)</span> 对应现在的状态 <span class="math inline">\((u,x+z)\)</span>。这样原来的转移 <span class="math inline">\((u,x)\to (v,2x+c)\)</span> 对应现在的转移 <span class="math inline">\((u,x+z)\to (v,2(x+z)+c-z)=(v,2x+c+z)\)</span>，仍然正确。</p>
<p>那么现在从状态 <span class="math inline">\((u,x)\)</span> 出发能到达的状态一定都能表示成 <span class="math inline">\((v,2^px+qg)\)</span> 的形式。由于 <span class="math inline">\((u,x)\)</span> 和 <span class="math inline">\((u,x+3g)\)</span> 等价，我们可以将 <span class="math inline">\(q\)</span> 的运算在模 <span class="math inline">\(3\)</span> 意义下进行而不影响答案。</p>
<p>另外，因为 <span class="math inline">\((u,x)\to (v,2x+c)\to (u,4x+3c)=(u,4x)\)</span>，我们可以将 <span class="math inline">\(p\)</span> 的运算在模 <span class="math inline">\(2\)</span> 意义下进行而不影响答案。</p>
<p>由于是询问 <span class="math inline">\((t,z)\)</span> 是否能到达 <span class="math inline">\((s,r+z)\)</span>，那么我们只需要保留能表示成 <span class="math inline">\((u,2^pz+qg)\)</span> 的状态，连边时将 <span class="math inline">\(p,q\)</span> 分别在模 <span class="math inline">\(2\)</span> 和模 <span class="math inline">\(3\)</span> 意义下进行即可。</p>
<p>对于每个询问，我们可以通过预处理快速得到 <span class="math inline">\(r+z\)</span> 对应的所有 <span class="math inline">\(p,q\)</span> 分别在模 <span class="math inline">\(2\)</span> 和模 <span class="math inline">\(3\)</span> 意义下两两不同的二元组 <span class="math inline">\((p,q)\)</span>，判断是否在同一连通块内即可。</p>
<p>连边和判断是否连通若用 DFS 和预处理的方法实现，时间复杂度 <span class="math inline">\(O(N+M+Q+P)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc031/submissions/17420246">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>分治</tag>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>网络流</tag>
        <tag>上下界费用流</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 030 题解</title>
    <url>/atcoder-agc030/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc030">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---poisonous-cookies">A - Poisonous Cookies</h3>
<h4 id="题意">题意</h4>
<p>有若干饼干，分别是 <span class="math inline">\(A\)</span> 块带有解毒剂的不好吃的饼干、<span class="math inline">\(B\)</span> 块带有解毒剂的好吃的饼干、<span class="math inline">\(C\)</span> 块带有毒药的好吃的饼干。</p>
<p>你可以按任意顺序吃任意数量的饼干，但是需要满足不能连续吃两块带有毒药的饼干。</p>
<p>求最多能吃多少块好吃的饼干。</p>
<p><span class="math inline">\(A,B,C\le 10^9\)</span></p>
<h4 id="题解">题解</h4>
<p>带有解毒剂的饼干一定全部都吃，这样带有毒药的饼干最多可以吃 <span class="math inline">\(A+B+1\)</span> 块。</p>
<p>所以答案即为 <span class="math inline">\(B+\min(C,A+B+1)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc030/submissions/17428216">代码</a></p>
<h3 id="b---tree-burning">B - Tree Burning</h3>
<h4 id="题意-1">题意</h4>
<p>有一个周长为 <span class="math inline">\(L\)</span> 的圆，你的起点在圆周上的某一位置，圆上的每个位置的坐标定义为从起点逆时针走到该点的距离，坐标范围为 <span class="math inline">\([0,L)\)</span>。</p>
<p>有 <span class="math inline">\(N\)</span> 棵树，第 <span class="math inline">\(i\)</span> 棵树在坐标 <span class="math inline">\(x_i\)</span>。你需要从起点出发，每次向左或向右走到第一棵树烧掉，直到树都被烧完。</p>
<p>求走的路程的最大值。</p>
<p><span class="math inline">\(N\le 2\times 10^5,L\le 10^9\)</span></p>
<h4 id="题解-1">题解</h4>
<p>我们把 <span class="math inline">\(N\)</span> 棵树的坐标放在数轴上，那么数轴上 <span class="math inline">\([0,L)\)</span> 的区间被分成了 <span class="math inline">\(N+1\)</span> 段。</p>
<p>考虑每一段的贡献，一定是存在一个分界点 <span class="math inline">\(p\)</span>，<span class="math inline">\(p\)</span> 前面部分是从前往后若干段连续递减到 <span class="math inline">\(0\)</span> 的偶数，后面部分是从后往前连续递减到 <span class="math inline">\(1\)</span> 的奇数，或者相反。同时需要保证第一段和最后一段的贡献差的绝对值为 <span class="math inline">\(1\)</span>。</p>
<p>若前面部分和后面部分同时存在贡献相同的长度超过 <span class="math inline">\(1\)</span> 的段，那么可以通过调整使得贡献更大，例如：</p>
<p><span class="math display">\[\{5,3,3,3,1,0,2,4,4\}\to\{7,5,3,3,1,0,2,4,6\}\]</span></p>
<p>并且如果存在这样的段，一定是贡献最大的段，否则也可以调整：</p>
<p><span class="math display">\[\{7,5,3,3,1,0,2,4,6\}\to\{7,7,5,3,1,0,2,4,6\}\]</span></p>
<p>于是枚举分界点后贡献就确定了，预处理 <span class="math inline">\((x_i-x_{i-1})\times i\)</span> 的前缀和即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc030/submissions/17850128">代码</a></p>
<h3 id="c---coloring-torus">C - Coloring Torus</h3>
<h4 id="题意-2">题意</h4>
<p>给定正整数 <span class="math inline">\(K\)</span>，你需要选择一个 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(500\)</span> 的整数 <span class="math inline">\(n\)</span>，并构造一个 <span class="math inline">\(n\times n\)</span> 的网格，记行列标号分别为 <span class="math inline">\(0,\ldots,n-1\)</span>，满足：</p>
<ul>
<li>每个格子为 <span class="math inline">\(K\)</span> 种颜色之一且每种颜色都至少出现一次。</li>
<li>对于两种颜色 <span class="math inline">\(i,j\)</span>，对于所有颜色为 <span class="math inline">\(i\)</span> 的格子，与该格子相邻的颜色为 <span class="math inline">\(j\)</span> 的格子数量相等。在这里，与 <span class="math inline">\((r,c)\)</span> 相邻的格子为 <span class="math inline">\(((r-1)\bmod n, c), ((r+1)\bmod n, c), (r, (c-1)\bmod n), (r, (c+1)\bmod n)\)</span>。</li>
</ul>
<p><span class="math inline">\(1\le K\le 1000\)</span></p>
<h4 id="题解-2">题解</h4>
<p>先考虑 <span class="math inline">\(n\)</span> 为偶数且 <span class="math inline">\(K=2n\)</span> 的情况。有一种方案是将每行交替填上两种颜色，但是这样填并不能扩展。</p>
<p>考虑斜着填，对于所有 <span class="math inline">\((i-j)\bmod n\)</span> 相同的位置，按 <span class="math inline">\(i\)</span> 从小到大的顺序交替填上两种颜色。</p>
<p>这样构造显然是正确的。</p>
<p>另外，若我们将某一斜线填上同种颜色，这样的方案仍然是正确的的，这样我们就可以将颜色数减小。</p>
<p>于是取 <span class="math inline">\(n=2\lceil\frac{K}{4}\rceil\)</span> 后按上述方法构造即可。</p>
<p><a href="https://atcoder.jp/contests/agc030/submissions/17867188">代码</a></p>
<h3 id="d---inversion-sum">D - Inversion Sum</h3>
<h4 id="题意-3">题意</h4>
<p>有一个序列 <span class="math inline">\(A_1,A_2,\ldots,A_N\)</span>，有 <span class="math inline">\(Q\)</span> 次操作，第 <span class="math inline">\(i\)</span> 次操作你可以交换 <span class="math inline">\(A_{X_i}\)</span> 和 <span class="math inline">\(A_{Y_i}\)</span> 或者什么都不干。</p>
<p>求所有 <span class="math inline">\(2^Q\)</span> 个最终序列的逆序对之和，对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(N,Q\le 3000\)</span></p>
<h4 id="题解-3">题解</h4>
<p>考虑对于每一对数计算贡献。</p>
<p>考虑 DP，令 <span class="math inline">\(f_{k,i,j}\)</span> 表示从第 <span class="math inline">\(k\)</span> 次操作开始，当前位置分别为 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 的两个数，在最终序列中第一个数在第二个数前面的方案数。</p>
<p>转移很简单，注意到除了第 <span class="math inline">\(X_k,Y_k\)</span> 行和第 <span class="math inline">\(X_k,Y_k\)</span> 列外，其他位置的 DP 值的操作只是乘了 <span class="math inline">\(2\)</span>。</p>
<p>于是我们只需要记录当前 DP 数组实际需要乘上的值，每次就可以 <span class="math inline">\(O(N)\)</span> 转移。</p>
<p>这本质上与方案数转概率相同。</p>
<p>时间复杂度 <span class="math inline">\(O(N(Q+N))\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc030/submissions/17851186">代码</a></p>
<h3 id="e---less-than-3">E - Less than 3</h3>
<h4 id="题意-4">题意</h4>
<p>若一个 <span class="math inline">\(01\)</span> 字符串中不存在连续 <span class="math inline">\(3\)</span> 个 <span class="math inline">\(0\)</span> 或连续 <span class="math inline">\(3\)</span> 个 <span class="math inline">\(1\)</span>，那么称之为好的。</p>
<p>有两个长度为 <span class="math inline">\(N\)</span> 的好的 01 字符串 <span class="math inline">\(s,t\)</span>。你可以对 <span class="math inline">\(s\)</span> 执行若干次以下操作：</p>
<ul>
<li>选择一个位置取反，需要保证操作后字符串仍然是好的。</li>
</ul>
<p>求使得 <span class="math inline">\(s\)</span> 变为 <span class="math inline">\(t\)</span> 的最少操作次数。</p>
<p><span class="math inline">\(N\le 5000\)</span></p>
<h4 id="题解-4">题解</h4>
<p>考虑在相邻的 <span class="math inline">\(01\)</span> 之间放一条红线，相邻的 <span class="math inline">\(10\)</span> 之间放一条蓝线，并且前后交替放置无限条红线和蓝线。</p>
<p>那么一次操作相当于把一条线向左或向右移动一格。除了首尾，需要保证每个位置最多只有一条线，且相邻的线距离最多为 <span class="math inline">\(2\)</span>。一个操作过程的例子如下图所示（来自官方题解）：</p>
<p><img src="https://i.loli.net/2020/11/06/ZBAuk5MPTUbhGI2.png" class="lazyload" data-srcset="https://i.loli.net/2020/11/06/ZBAuk5MPTUbhGI2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>若我们得到了 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 线与线的对应关系，可以证明一定有解，且答案即为每一个对应关系中两条线的距离之和。一个例子如下图所示（来自官方题解）：</p>
<p><img src="https://i.loli.net/2020/11/06/9QRNep2nW4O6I3S.png" class="lazyload" data-srcset="https://i.loli.net/2020/11/06/9QRNep2nW4O6I3S.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>该例子的答案为 <span class="math inline">\(\cdots+0+0+0+1+0+1+2+3+2+1+0+\cdots=10\)</span>。</p>
<p>对应关系只有 <span class="math inline">\(O(N)\)</span> 种，枚举即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc030/submissions/17903980">代码</a></p>
<h3 id="f---permutation-and-minimum">F - Permutation and Minimum</h3>
<h4 id="题意-5">题意</h4>
<p>给定一个未填完的 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(2N\)</span> 的排列 <span class="math inline">\(A_1,A_2,\ldots,A_{2N}\)</span>，你需要填完该排列，然后得到一个新的序列 <span class="math inline">\(B_1,B_2,\ldots,B_N\)</span>，其中 <span class="math inline">\(B_i=\min(A_{2i-1},A_{2i})\)</span>。</p>
<p>求可以得到多少不同的序列 <span class="math inline">\(B\)</span>。对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(N\le 300\)</span></p>
<h4 id="题解-5">题解</h4>
<p>咕咕咕</p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 034 题解</title>
    <url>/atcoder-agc034/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc034">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---kenken-race">A - Kenken Race</h3>
<h4 id="题意">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个方格从左到右排列，编号 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\)</span>。有些位置上有障碍。</p>
<p>有两个不同的棋子，分别在格子 <span class="math inline">\(A,B\)</span>。你可以执行以下操作若干次：</p>
<ul>
<li>选择其中一个棋子，向右跳一格或两格，要求目标位置不是障碍且没有其他棋子。</li>
</ul>
<p>判断是否可以使得最后两个棋子分别在 <span class="math inline">\(C,D\)</span>。</p>
<p><span class="math inline">\(N\le 2\times 10^5,A&lt;B\)</span></p>
<h4 id="题解">题解</h4>
<p>若 <span class="math inline">\(C&lt;D\)</span>，那么我们显然可以先跳第二个棋子使得两个棋子互不影响。</p>
<p>此时显然只需要 <span class="math inline">\(A\)</span> 到 <span class="math inline">\(B\)</span> 和 <span class="math inline">\(C\)</span> 到 <span class="math inline">\(D\)</span> 之间都没有连续两个障碍即可。</p>
<p>若 <span class="math inline">\(C&gt;D\)</span>，此时我们需要让第二个棋子在某个位置停留，将第一个棋子跳到终点，再将第二个棋子跳到终点。</p>
<p>为了使第一个棋子顺利跳到终点，我们需要让第二个棋子停留的位置满足把该位置当做障碍后 <span class="math inline">\(A\)</span> 到 <span class="math inline">\(C\)</span> 之间仍然不存在连续两个障碍。</p>
<p>那么只需要满足 <span class="math inline">\(B\)</span> 到 <span class="math inline">\(D\)</span> 之间（包含 <span class="math inline">\(B\)</span> 和 <span class="math inline">\(D\)</span>）存在左右两边都是非障碍格子即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc034/submissions/17207879">代码</a></p>
<h3 id="b---abc">B - ABC</h3>
<h4 id="题意-1">题意</h4>
<p>给定一个字符串 <span class="math inline">\(S\)</span>，只包含 <code>A</code>，<code>B</code> 和 <code>C</code>。</p>
<p>你可以执行若干次以下操作：</p>
<ul>
<li>选择一个 <span class="math inline">\(s\)</span> 的一个等于 <code>ABC</code> 的子串，替换为 <code>BCA</code>。</li>
</ul>
<p>求最多执行的操作次数。</p>
<p><span class="math inline">\(|S|\le 2\times 10^5\)</span></p>
<h4 id="题解-1">题解</h4>
<p>考虑对于一段 <code>AA..AABC</code>，假设 <code>A</code> 有 <span class="math inline">\(c\)</span> 个，那么可以操作 <span class="math inline">\(c\)</span> 次使得这一部分变为 <code>BCAA..AA</code>。</p>
<p>于是我们从前往后，有这样一段就操作。这样做一定是最优的，因为 <code>A</code> 仍然连续并且到了后面，可能会与后面的 <code>AA..AABC</code> 组成一个更长的段。</p>
<p>时间复杂度 <span class="math inline">\(O(N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc034/submissions/17208420">代码</a></p>
<h3 id="c---tests">C - Tests</h3>
<h4 id="题意-2">题意</h4>
<p>A 和 B 参加 <span class="math inline">\(N\)</span> 场考试。对于第 <span class="math inline">\(i\)</span> 场考试，A 可以规定一个 <span class="math inline">\(l_i\)</span> 到 <span class="math inline">\(u_i\)</span> 之间的整数 <span class="math inline">\(c_i\)</span> 作为该考试的价值。</p>
<p>已知 B 第 <span class="math inline">\(i\)</span> 场考试的分数为 <span class="math inline">\(b_i\)</span>。假设 A 第 <span class="math inline">\(i\)</span> 场考试的分数为 <span class="math inline">\(a_i\)</span>，A 的目标是使得 <span class="math inline">\(\sum_{i=1}^{N}a_ic_i\ge \sum_{i=1}^{N}b_ic_i\)</span>。</p>
<p>A 可以花费一单位的时间来使得自己某场考试的分数加 <span class="math inline">\(1\)</span>。已知考试的满分为 <span class="math inline">\(X\)</span>，A 不能将已经满分的考试分数加 <span class="math inline">\(1\)</span>。</p>
<p>求 A 达到目标最少花费的时间。</p>
<p><span class="math inline">\(N\le 10^5\)</span></p>
<h4 id="题解-2">题解</h4>
<p>假设 <span class="math inline">\(c_i\)</span> 已经确定，那么 A 一定是按 <span class="math inline">\(c_i\)</span> 从大到小依次加，直到比 B 的总分高。那么显然按 <span class="math inline">\(c_i\)</span> 从大到小排序后一定是一个前缀满分，一个后缀没分，只有中间一个有部分分。</p>
<p>注意到对于 <span class="math inline">\(a_i &gt; b_i\)</span> 的考试，我们可以把 <span class="math inline">\(c_i\)</span> 调整成 <span class="math inline">\(u_i\)</span> 使得自己比 B 的优势更大；对于 <span class="math inline">\(a_i &lt; b_i\)</span> 的考试，我们可以把 <span class="math inline">\(c_i\)</span> 调整成 <span class="math inline">\(l_i\)</span> 使得自己与 B 的差距更小。</p>
<p>于是我们可以强制对于第 <span class="math inline">\(i\)</span> 场考试，分数小于等于 <span class="math inline">\(b_i\)</span> 的部分按价值 <span class="math inline">\(l_i\)</span> 计算，大于 <span class="math inline">\(b_i\)</span> 的部分按价值 <span class="math inline">\(u_i\)</span> 计算，那么 B 的分数即为 <span class="math inline">\(S=\sum_{i=1}^{N}b_il_i\)</span>。</p>
<p>考虑二分答案 <span class="math inline">\(M\)</span>，枚举不是满分也不是零分的考试，该考试的分数是已知的；而满分的考试数量也唯一确定，所以只需要把剩余的考试按满分得到的价值 <span class="math inline">\(b_il_i+(X-b_i)u_i\)</span> 从大到小排序后选取即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N\log NX)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc034/submissions/17223364">代码</a></p>
<h3 id="d---manhattan-max-matching">D - Manhattan Max Matching</h3>
<h4 id="题意-3">题意</h4>
<p>在平面上有若干个红球和蓝球。有 <span class="math inline">\(N\)</span> 个位置有红球，第 <span class="math inline">\(i\)</span> 个位置为 <span class="math inline">\((RX_i,RY_i)\)</span>，有 <span class="math inline">\(RC_i\)</span> 个红球；有 <span class="math inline">\(N\)</span> 个位置有蓝球，第 <span class="math inline">\(i\)</span> 个位置为 <span class="math inline">\((BX_i,BY_i)\)</span>，有 <span class="math inline">\(BC_i\)</span> 个蓝球。保证 <span class="math inline">\(\sum RC_i=\sum BC_i\)</span>，令该值为 <span class="math inline">\(S\)</span>。</p>
<p>你需要将这 <span class="math inline">\(S\)</span> 个红球和 <span class="math inline">\(S\)</span> 个蓝球匹配，每个球最多被匹配一次。一对匹配的权值为这两个球的曼哈顿距离。</p>
<p>求每对匹配的权值之和的最大值。</p>
<p><span class="math inline">\(N\le 1000,RC_i,BC_i\le 10\)</span></p>
<h4 id="题解-3">题解</h4>
<p>考虑曼哈顿距离的式子，把两个绝对值分别拆开，共有 <span class="math inline">\(4\)</span> 种状态，然后两个球的贡献独立。</p>
<p>因为最后求的是最大值，所以最终一定会取到两个都为正的情况。</p>
<p>对于一个匹配，若我们确定了红球的两个坐标的正负性，我们就可以唯一确定蓝球坐标的正负性。</p>
<p>于是可以建立费用流模型，源点向红球连流量为 <span class="math inline">\(RC_i\)</span>，费用为 <span class="math inline">\(0\)</span> 的边，限制数量；在红球与蓝球中间建立四个点表示四种状态，每个红球向四种状态连对应流量为无穷大，费用为对应贡献的边。蓝球同理。</p>
<p>直接跑费用流即可。貌似可以用模拟费用流做到更优的复杂度。</p>
<p><a href="https://atcoder.jp/contests/agc034/submissions/17238025">代码</a></p>
<h3 id="e---complete-compress">E - Complete Compress</h3>
<h4 id="题意-4">题意</h4>
<p>给定一个 <span class="math inline">\(N\)</span> 个点的树，有些节点上有一个棋子。每次可以执行以下操作：</p>
<ul>
<li>选择两个有棋子且距离不小于 <span class="math inline">\(2\)</span> 的点 <span class="math inline">\(u,v\)</span>，在这两个点上各取一个棋子向靠近另一个点的方向移动一条边。</li>
</ul>
<p>求使得所有棋子到同一个点的最少操作次数。</p>
<p><span class="math inline">\(N\le 2000\)</span></p>
<h4 id="题解-4">题解</h4>
<p>枚举最后棋子到达的点 <span class="math inline">\(t\)</span>，将 <span class="math inline">\(t\)</span> 作为该树的根。</p>
<p>显然对于两个棋子，如果操作这两个棋子后其中一个深度变大了，那么一定不优。所以若合法，操作次数一定是所有棋子深度之和除以 <span class="math inline">\(2\)</span>。接下来考虑如何判断合法。</p>
<p>对于 <span class="math inline">\(i\)</span> 的子树，我们分别维护 <span class="math inline">\(L_i\)</span> 和 <span class="math inline">\(R_i\)</span> 表示对 <span class="math inline">\(i\)</span> 的子树内的棋子执行若干次操作后，这些棋子到 <span class="math inline">\(i\)</span> 的距离之和的最小值和最大值。那么可以取到的距离之和一定是在 <span class="math inline">\([L_i,R_i]\)</span> 之间与 <span class="math inline">\(L_i,R_i\)</span> 奇偶性相同的数。为方便描述，我们令 <span class="math inline">\(C_i\)</span> 为 <span class="math inline">\(i\)</span> 子树内棋子数量。</p>
<p>显然最大值为子树内的棋子到 <span class="math inline">\(i\)</span> 的距离之和。考虑如何求出最小值。</p>
<p>我们先把每个子树内部的操作处理完，然后考虑子树之间的操作。假设每个儿子子树内的棋子到 <span class="math inline">\(i\)</span> 的距离之和分别为 <span class="math inline">\(d_1,d_2,\ldots,d_k\)</span>。现在的操作相当于每次选两个 <span class="math inline">\(d_j\)</span> 减 <span class="math inline">\(1\)</span>。我们要使得最终的 <span class="math inline">\(\sum d_j\)</span> 最小。</p>
<p>令最大的 <span class="math inline">\(d_j\)</span> 为 <span class="math inline">\(d_{\max}\)</span>，<span class="math inline">\(S\)</span> 为所有 <span class="math inline">\(d_j\)</span> 之和减去 <span class="math inline">\(d_{\max}\)</span> 的值。那么可以证明最终 <span class="math inline">\(\sum d_i\)</span> 的最小值为 <span class="math inline">\(\max(d_{\max}-S,0)\)</span>。</p>
<p>令 <span class="math inline">\(i\)</span> 的儿子 <span class="math inline">\(v\)</span> 中 <span class="math inline">\(R_v+C_v\)</span> 最大的为 <span class="math inline">\(x\)</span>。若 <span class="math inline">\(L_x+C_x\)</span> 小于等于除 <span class="math inline">\(x\)</span> 以外儿子的 <span class="math inline">\(R_v+C_v\)</span> 最大值，那么我们可以将除 <span class="math inline">\(x\)</span> 以外的 <span class="math inline">\(d_j\)</span> 置为 <span class="math inline">\(R_v+C_v\)</span>，将 <span class="math inline">\(x\)</span> 对应的 <span class="math inline">\(d_j\)</span> 置为除 <span class="math inline">\(x\)</span> 以外的 <span class="math inline">\(R_v+C_v\)</span> 最大值，此时显然有 <span class="math inline">\(d_{\max}-S\le 0\)</span>，所以最小值就是 <span class="math inline">\(0\)</span>。</p>
<p>否则，无论 <span class="math inline">\(d\)</span> 取何值，<span class="math inline">\(x\)</span> 对应的 <span class="math inline">\(d_j\)</span> 一定是 <span class="math inline">\(d_{\max}\)</span>，那么我们一定会将 <span class="math inline">\(x\)</span> 取 <span class="math inline">\(L_x+C_x\)</span>，其他儿子 <span class="math inline">\(v\)</span> 取 <span class="math inline">\(R_v+C_v\)</span>，这样才能使 <span class="math inline">\(d_{\max}-S\)</span> 最小。</p>
<p>综上，最小值即为 <span class="math inline">\(\max(L_x+C_x-((\sum (R_v+C_v))-(R_x+C_x)),0)\)</span>。注意判断该值与最大值奇偶性不同的情况。</p>
<p>最后只需要判断根节点的最小值是否是 <span class="math inline">\(0\)</span> 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc034/submissions/17237509">代码</a></p>
<h3 id="f---rng-and-xor">F - RNG and XOR</h3>
<h4 id="题意-5">题意</h4>
<p>有一个随机数生成器，可以生成 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(2^N-1\)</span> 之间的整数，其中生成 <span class="math inline">\(i\)</span> 的概率为 <span class="math inline">\(\frac{A_i}{S}\)</span>，其中 <span class="math inline">\(S=\sum A_i\)</span>。</p>
<p>有一个变量 <span class="math inline">\(x\)</span>，初始为 <span class="math inline">\(0\)</span>，每次会异或一个用上述随机数生成器生成的整数。</p>
<p>对于每个 <span class="math inline">\(0\le i &lt; 2^N\)</span>，求 <span class="math inline">\(x\)</span> 第一次变成 <span class="math inline">\(i\)</span> 的期望次数。对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(N\le 18\)</span>。</p>
<h4 id="题解-5">题解</h4>
<p>考虑倒着做，求 <span class="math inline">\(i\)</span> 第一次得到 <span class="math inline">\(0\)</span> 的期望次数，显然与原答案相等。那么有 <span class="math display">\[
f_i=
\begin{cases}
1+\sum\limits_{j=0}^{2^N-1}f_jp_{i\oplus j} &amp; \text{ if }i&gt;0 \\
0 &amp; \text{ if }i=0
\end{cases}
\]</span></p>
<p>我们可以把上式写成卷积的形式： <span class="math display">\[(f_0,f_1,\ldots,f_{2^N-1})\oplus(p_0,p_1,\ldots,p_{2^N-1})=(c,f_1-1,f_2-1,\ldots,f_{2^N-1}-1)\]</span> 其中 <span class="math inline">\(c\)</span> 是一个未知的常数。</p>
<p>注意到上式要满足条件，必须有 <span class="math display">\[\left(\sum_{i=0}^{2^N-1} f_i\right)\left(\sum_{i=0}^{2^N-1} p_i\right)=c+\sum_{i=1}^{2^N-1}(f_i-1)\]</span></p>
<p>所以有 <span class="math inline">\(c=f_0+2^N-1\)</span>。那么上面的卷积式子可以写成 <span class="math display">\[(f_0,f_1,\ldots,f_{2^N-1})\oplus(p_0,p_1,\ldots,p_{2^N-1})=(f_0+2^N-1,f_1-1,f_2-1,\ldots,f_{2^N-1}-1)\]</span></p>
<p>可以把 <span class="math inline">\(p_0\)</span> 减 <span class="math inline">\(1\)</span> 去掉等式右边的 <span class="math inline">\(f_i\)</span>，即 <span class="math display">\[(f_0,f_1,\ldots,f_{2^N-1})\oplus(p_0-1,p_1,\ldots,p_{2^N-1})=(2^N-1,-1,-1,\ldots,-1)\]</span></p>
<p>那么只要将 <span class="math inline">\((2^N-1,-1,-1,\ldots,-1)\)</span> 和 <span class="math inline">\(p\)</span> 做 FWT 后对应位置做除法，再 IFWT 回去即可。</p>
<p>注意 <span class="math inline">\((2^N-1,-1,-1,\ldots,-1)\)</span> 和 <span class="math inline">\(p\)</span> 做 FWT 后有且只有 <span class="math inline">\(0\)</span> 位置的值为 <span class="math inline">\(0\)</span>，不能直接做除法。可以先取任意数，最后根据 <span class="math inline">\(f_0=0\)</span> 对所有数整体加即可。</p>
<p>时间复杂度 <span class="math inline">\(O(2^N(N+\log P))\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc034/submissions/17251759">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>网络流</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>费用流</tag>
        <tag>集合幂级数</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 032 题解</title>
    <url>/atcoder-agc032/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc032">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---limited-insertion">A - Limited Insertion</h3>
<h4 id="题意">题意</h4>
<p>有一个初始为空的序列 <span class="math inline">\(a\)</span>。</p>
<p>你需要执行 <span class="math inline">\(N\)</span> 次操作，第 <span class="math inline">\(i\)</span> 次操作需要选择一个 <span class="math inline">\(j\ (1\le j\le i)\)</span>，在 <span class="math inline">\(a\)</span> 中的位置 <span class="math inline">\(j\)</span> 插入 <span class="math inline">\(j\)</span>（序列最开始为位置 <span class="math inline">\(1\)</span>）。</p>
<p>给定一个长度为 <span class="math inline">\(N\)</span> 的序列 <span class="math inline">\(b\)</span>，构造一种操作序列使得最后 <span class="math inline">\(a=b\)</span>，或输出无解。</p>
<p><span class="math inline">\(N\le 100\)</span></p>
<h4 id="题解">题解</h4>
<p>显然若存在 <span class="math inline">\(a_i &gt; i\)</span> 一定无解，否则可以通过构造证明一定有解。</p>
<p>考虑倒着做，每次找到最后一个 <span class="math inline">\(a_i=i\)</span> 的位置删除，这样可以使得该序列仍然满足 <span class="math inline">\(a_i\le i\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(N^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc032/submissions/17391477">代码</a></p>
<h3 id="b---balanced-neighbors">B - Balanced Neighbors</h3>
<h4 id="题意-1">题意</h4>
<p>构造一个 <span class="math inline">\(N\)</span> 个点的简单无向连通图 <span class="math inline">\(G\)</span>，满足存在一个 <span class="math inline">\(S\)</span>，使得对于所有 <span class="math inline">\(1\le i\le N\)</span>，与 <span class="math inline">\(i\)</span> 相连的节点编号之和等于 <span class="math inline">\(S\)</span>。</p>
<p><span class="math inline">\(N\le 100\)</span></p>
<h4 id="题解-1">题解</h4>
<p>我们可以首先构造一个完全图，发现此时与 <span class="math inline">\(i\)</span> 相连的节点编号之和为 <span class="math inline">\(\frac{n(n+1)}{2}-i\)</span>。</p>
<p>考虑去掉所有形如 <span class="math inline">\((i,n-i)\)</span> 的边，那么与 <span class="math inline">\(i\)</span> 相连的节点编号之和为 <span class="math inline">\(\frac{n(n+1)}{2}-i-(n-i)=\frac{n(n+1)}{2}-n\)</span>，是一个定值。</p>
<p>但是这样构造在 <span class="math inline">\(n\)</span> 为偶数时会有问题，于是当 <span class="math inline">\(n\)</span> 是偶数时我们去掉所有形如 <span class="math inline">\((i,n+1-i)\)</span> 的边即可。</p>
<p><a href="https://atcoder.jp/contests/agc032/submissions/17391783">代码</a></p>
<h3 id="c---three-circuits">C - Three Circuits</h3>
<h4 id="题意-2">题意</h4>
<p>给定一个 <span class="math inline">\(N\)</span> 个点 <span class="math inline">\(M\)</span> 条边的简单无向连通图 <span class="math inline">\(G\)</span>，判断是否可以在 <span class="math inline">\(G\)</span> 中找出三个环使得每条边恰好被一个环覆盖。</p>
<p>这里的环是指每条边只能经过一次但点可以经过多次的环。</p>
<p><span class="math inline">\(N,M\le 10^5\)</span></p>
<h4 id="题解-2">题解</h4>
<p>显然若存在度数为奇数的点一定不合法。</p>
<p>当存在度数大于 <span class="math inline">\(4\)</span> 的点时，设该点为 <span class="math inline">\(x\)</span>，考虑从 <span class="math inline">\(x\)</span> 开始的一条欧拉回路，记录每次访问的节点编号，我们可以每次将两个 <span class="math inline">\(x\)</span> 之间的部分作为一个环删去，可以至少删三次，所以一定有解。</p>
<p>当度数等于 <span class="math inline">\(4\)</span> 的点数小于 <span class="math inline">\(2\)</span> 时，那么一定不合法。</p>
<p>当度数等于 <span class="math inline">\(4\)</span> 的点数等于 <span class="math inline">\(2\)</span> 时，设这两个点为 <span class="math inline">\(x,y\)</span>，若我们把度为 <span class="math inline">\(2\)</span> 的点组成的链缩成一条边，那么要有解必须是 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 有两条边且 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 各自有一个自环的形式。可以简单判断。</p>
<p>当度数等于 <span class="math inline">\(4\)</span> 的点数大于 <span class="math inline">\(2\)</span> 时，根据类似于存在度数大于 <span class="math inline">\(4\)</span> 点时的分析，我们可以从一个度数等于 <span class="math inline">\(4\)</span> 的点 <span class="math inline">\(A\)</span> 开始分成两个环。这两个环一定是以下两种情况之一（图来自官方题解）：</p>
<p><img src="/files/AGC032C.png" class="lazyload" data-srcset="/files/AGC032C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>可以发现这两种情况都可以构造出三个环。于是这种情况也一定有解。</p>
<p><a href="https://atcoder.jp/contests/agc032/submissions/17400933">代码</a></p>
<h3 id="d---rotation-sort">D - Rotation Sort</h3>
<h4 id="题意-3">题意</h4>
<p>给定一个 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\)</span> 排列 <span class="math inline">\(p\)</span>，你可以执行若干次以下操作：</p>
<ul>
<li>花费 <span class="math inline">\(A\)</span> 的代价，将一个区间循环左移一格；</li>
<li>花费 <span class="math inline">\(B\)</span> 的代价，将一个区间循环右移一格。</li>
</ul>
<p>求使得排列 <span class="math inline">\(p\)</span> 有序的最小代价。</p>
<p><span class="math inline">\(N\le 5000\)</span></p>
<h4 id="题解-3">题解</h4>
<p>可以发现循环左移相当于将一个数插入到后面，循环右移相当于将一个数插入到前面。</p>
<p>那么没有被操作的数一定是一个上升子序列 <span class="math inline">\(x_1 &lt; x_2 &lt; \ldots &lt; x_k\ (p_{x_1} &lt; p_{x_2} &lt; \ldots &lt; p_{x_k})\)</span>，而对于 <span class="math inline">\(x_{i-1}\)</span> 到 <span class="math inline">\(x_i\)</span> 之间被操作的位置 <span class="math inline">\(j\)</span>，若 <span class="math inline">\(p_j &gt; p_{x_i}\)</span>，则需要花费 <span class="math inline">\(A\)</span> 的代价，否则需要花费 <span class="math inline">\(B\)</span> 的代价。</p>
<p>于是直接 <span class="math inline">\(O(N^2)\)</span> DP 即可。可以用线段树优化到 <span class="math inline">\(O(N\log N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc032/submissions/17400966">代码</a></p>
<h3 id="e---modulo-pairing">E - Modulo Pairing</h3>
<h4 id="题意-4">题意</h4>
<p>给定 <span class="math inline">\(2N\)</span> 个整数 <span class="math inline">\(a_1,a_2,\ldots,a_{2N}\)</span>，以及一个整数 <span class="math inline">\(M\)</span>。</p>
<p>我们需要将这 <span class="math inline">\(2N\)</span> 个数划分成 <span class="math inline">\(N\)</span> 个二元组，使得每个数恰好在一个二元组中出现。</p>
<p>一个二元组 <span class="math inline">\((x,y)\)</span> 的权值为 <span class="math inline">\((x+y)\bmod M\)</span>，求 <span class="math inline">\(N\)</span> 个二元组权值最大值的最小值。</p>
<p><span class="math inline">\(N\le 10^5\)</span></p>
<h4 id="题解-4">题解</h4>
<p>考虑对于一个二元组 <span class="math inline">\((x,y)\)</span>，若 <span class="math inline">\(x+y &lt; M\)</span>，我们则将 <span class="math inline">\(x,y\)</span> 和这条匹配边染成蓝色，否则染成红色。</p>
<p>将 <span class="math inline">\(a\)</span> 从小到大排序，那么最后的匹配一定形如下图：</p>
<p><img src="/files/AGC032E1.png" class="lazyload" data-srcset="/files/AGC032E1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>否则可以通过以下方式进行调整：</p>
<p><img src="/files/AGC032E2.png" class="lazyload" data-srcset="/files/AGC032E2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>我们发现合法的分界点一定是一个区间，且越靠左越优。</p>
<p>于是二分答案即可。</p>
<p><a href="https://atcoder.jp/contests/agc032/submissions/17401208">代码</a></p>
<h3 id="f---one-third">F - One Third</h3>
<h4 id="题意-5">题意</h4>
<p>在一个圆上沿半径等概率随机切 <span class="math inline">\(N\)</span> 刀，选择连续若干块，假设占整个圆面积的 <span class="math inline">\(x\)</span> 倍，求 <span class="math inline">\(|x-\frac{1}{3}|\)</span> 的最小值的期望。</p>
<p><span class="math inline">\(N\le 10^6\)</span></p>
<h4 id="题解-5">题解</h4>
<p>考虑将每一刀切的半径标红，并对于每一条标红的半径，分别将该半径绕圆心逆时针 <span class="math inline">\(120^{\circ}\)</span> 和顺时针 <span class="math inline">\(120^{\circ}\)</span> 处的半径标成蓝色和绿色，那么 <span class="math inline">\(|x-\frac{1}{3}|\)</span> 的最小值等于两条不同颜色的半径形成的夹角与 <span class="math inline">\(360^{\circ}\)</span> 的比值的最小值。</p>
<p>注意到这个最小值一定会取在相邻的两条不同颜色半径上。</p>
<p>我们将第一刀对应的半径记为 <span class="math inline">\(0^{\circ}\)</span>，我们可以只保留 <span class="math inline">\(0^{\circ}\)</span> 到 <span class="math inline">\(120^{\circ}\)</span> 之间的半径，<span class="math inline">\(120^{\circ}\)</span> 到 <span class="math inline">\(240^{\circ}\)</span> 之间和 <span class="math inline">\(240^{\circ}\)</span> 到 <span class="math inline">\(360^{\circ}\)</span> 之间与这一部分等价，不需要考虑。</p>
<p>于是问题转化成：在一个数轴上，一开始在 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\frac{1}{3}\)</span> 处分别有一个红点和蓝点。然后在 <span class="math inline">\([0,\frac{1}{3}]\)</span> 中随机放置 <span class="math inline">\(N-1\)</span> 个随机颜色（红、蓝、绿）的点。求异色点距离最小值的期望。</p>
<p>我们可以求出 <span class="math inline">\(f(k)\)</span> 表示有恰好 <span class="math inline">\(k\)</span> 对相邻异色点的概率，<span class="math inline">\(g(k)\)</span> 表示有恰好 <span class="math inline">\(k\)</span> 对相邻异色点时异色点距离最小值的期望，那么最后答案为 <span class="math inline">\(f(k)g(k)\)</span> 之和。</p>
<p><span class="math inline">\(f(k)\)</span> 可以通过 DP 或组合数计算。<span class="math inline">\(g(k)\)</span> 可以考虑 <span class="math inline">\(k\)</span> 对相邻异或点距离的总和为 <span class="math inline">\(\frac{k}{3n}\)</span>，而将一条线段随机分成 <span class="math inline">\(k\)</span> 段，最小的一段的期望长度为总长的 <span class="math inline">\(\frac{1}{k^2}\)</span>，所以 <span class="math inline">\(g(k)=\frac{1}{3nk}\)</span>。 后面部分的具体计算过程可以参考<a href="https://www.zhihu.com/question/30359365/answer/47800953">曾加的回答 - 知乎</a>。</p>
<p><a href="https://atcoder.jp/contests/agc032/submissions/17402407">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>分类讨论</tag>
        <tag>概率</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 033 题解</title>
    <url>/atcoder-agc033/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc033">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---darker-and-darker">A - Darker and Darker</h3>
<h4 id="题意">题意</h4>
<p>有一个 <span class="math inline">\(H\times W\)</span> 的网格，每个格子有黑白两种颜色。初始颜色是给定的。</p>
<p>你需要不断执行以下操作，直到所有格子全黑（保证一开始有黑色格子）：</p>
<ul>
<li>对于每个和黑色格子有公共边的白色格子，变成黑色。</li>
</ul>
<p>求操作次数。</p>
<p><span class="math inline">\(H,W\le 1000\)</span></p>
<h4 id="题解">题解</h4>
<p>直接将所有黑色格子作为起点进行 BFS 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(NM)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc033/submissions/17252941">代码</a></p>
<h3 id="b---lrud-game">B - LRUD Game</h3>
<h4 id="题意-1">题意</h4>
<p>有一个 <span class="math inline">\(H\times W\)</span> 的网格，有一个棋子，一开始在 <span class="math inline">\((s_r,s_c)\)</span>。</p>
<p>A 和 B 玩游戏，执行 <span class="math inline">\(N\)</span> 次操作。A 和 B 每人有一个长度为 <span class="math inline">\(N\)</span> 的字符串，分别为 <span class="math inline">\(S,T\)</span>。第 <span class="math inline">\(i\)</span> 次操作如下：</p>
<ul>
<li>首先，A 进行游戏。A 可以选择将棋子按 <span class="math inline">\(S_i\)</span> 的方向移动一格，或不移动；</li>
<li>然后，B 进行游戏。B 可以选择将棋子按 <span class="math inline">\(T_i\)</span> 的方向移动一格，或不移动。</li>
</ul>
<p>A 的目标是在某一次操作将棋子走出棋盘，B 的目标则相反。</p>
<p>判断两个人采取最优策略时棋子是否会在某一次操作走出棋盘。</p>
<p><span class="math inline">\(H,W,N\le 2\times 10^5\)</span></p>
<h4 id="题解-1">题解</h4>
<p>倒着考虑，维护不能走出棋盘的所有起点，可以发现这些起点一定是棋盘的一个子矩形。</p>
<p>倒着考虑时，每次 B 进行游戏会使该矩形的某一边界向外移动，而 A 进行游戏会使该矩形的某一边界向内移动。</p>
<p>注意矩形边界不能移出棋盘，并且若中途矩形变空，那么就再也不能向外移动了。</p>
<p>时间复杂度 <span class="math inline">\(O(N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc033/submissions/17255543">代码</a></p>
<h3 id="c---removing-coins">C - Removing Coins</h3>
<h4 id="题意-2">题意</h4>
<p>给定一个 <span class="math inline">\(N\)</span> 个点的树，每个点上有一个棋子。</p>
<p>A 和 B 轮流进行以下操作，A 先手：</p>
<ul>
<li>选定一个有棋子的节点 <span class="math inline">\(v\)</span>，取走 <span class="math inline">\(v\)</span> 上的所有棋子；</li>
<li>将剩余的所有棋子向靠近 <span class="math inline">\(v\)</span> 的方向移动一条边。</li>
</ul>
<p>不能操作的人输。</p>
<p>求两人采取最优策略时的胜者。</p>
<p><span class="math inline">\(N\le 2\times 10^5\)</span></p>
<h4 id="题解-2">题解</h4>
<p>注意到操作相当于选择一个节点作为根，然后将叶子结点删去。</p>
<p>考虑对于一次操作，若选择的不是度为 <span class="math inline">\(1\)</span> 的点，那么直径会减小 <span class="math inline">\(2\)</span>；否则直径要么减 <span class="math inline">\(1\)</span>，要么减 <span class="math inline">\(2\)</span>。</p>
<p>于是我们只要在状态里记录直径上的点数即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc033/submissions/17263370">代码</a></p>
<h3 id="d---complexity">D - Complexity</h3>
<h4 id="题意-3">题意</h4>
<p>定义一个黑白网格的 complexity 为：</p>
<ul>
<li>若网格全黑或全白，则为 <span class="math inline">\(0\)</span>。</li>
<li>否则，我们用一条水平的直线或竖直的直线将网格分成两个子网格，令两个子网格的 complexity 分别为 <span class="math inline">\(c_1,c_2\)</span>，则原网格的 complexity 为 <span class="math inline">\(\max(c_1,c_2)+1\)</span> 的最小值。</li>
</ul>
<p>给定一个 <span class="math inline">\(H\times W\)</span> 的网格，求该网格的 complexity。</p>
<p><span class="math inline">\(H,W\le 185\)</span></p>
<h4 id="题解-3">题解</h4>
<p>考虑有两个简单的性质：</p>
<ul>
<li>一个 <span class="math inline">\(H\times W\)</span> 的网格的 complexity 不超过 <span class="math inline">\(\lceil\log_2 H\rceil+\lceil\log_2 W\rceil\)</span>。</li>
<li>一个网格在最后加入一行或最右边加入一列，complexity 不小于原网格的 complexity.</li>
</ul>
<p>于是我们设计状态 <span class="math inline">\(f_{c,i,j,k}\)</span> 表示操作次数为 <span class="math inline">\(c\)</span>，左上角为 <span class="math inline">\((i,j)\)</span>，下边界为 <span class="math inline">\(k\)</span> 时，右边界的最大值。<span class="math inline">\(g_{c,i,j,k}\)</span> 同理表示操作次数为 <span class="math inline">\(c\)</span>，左上角为 <span class="math inline">\((i,j)\)</span>，右边界为 <span class="math inline">\(k\)</span> 时，下边界的最大值。</p>
<p>根据第二个性质，我们可以直接用双指针优化转移。</p>
<p>时间复杂度 <span class="math inline">\(O(HW(H+W)\log HW)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc033/submissions/17266208">代码</a></p>
<h3 id="e---go-around-a-circle">E - Go around a Circle</h3>
<h4 id="题意-4">题意</h4>
<p>有一个 <span class="math inline">\(N\)</span> 个点的环，点编号 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\)</span>。给定一个长度为 <span class="math inline">\(M\)</span> 的只包含 <code>R</code> 和 <code>B</code> 的字符串 <span class="math inline">\(S\)</span>，你需要给环上每条边填上 <code>R</code> 或 <code>B</code>，使得对于任意 <span class="math inline">\(1\le i\le N\)</span>：</p>
<ul>
<li>假设初始有一个棋子在第 <span class="math inline">\(i\)</span> 个点。你可以执行 <span class="math inline">\(M\)</span> 次操作，每次沿一条边将棋子走到一个相邻的点。你需要满足存在一种操作方案使得第 <span class="math inline">\(j\)</span> 条经过的边上的字符等于 <span class="math inline">\(S_j\)</span>。</li>
</ul>
<p>求方案数。对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(N\le 2\times 10^5\)</span></p>
<h4 id="题解-4">题解</h4>
<p>不妨假设 <span class="math inline">\(S\)</span> 的第一个字符为 <code>R</code>。显然环上不能有连续两个 <code>B</code> 出现。</p>
<p>那么我们考虑根据 <code>B</code> 将环分成若干个 <code>R</code> 的连续段。若 <span class="math inline">\(S\)</span> 中的字符不全是 <code>R</code>，那么一定有每个 <code>R</code> 的极长连续段长度一定是奇数。这个可以用反证法证明。</p>
<p>另外，显然每段连续段还会有一个长度的限制。</p>
<p>这样我们就可以每次去掉开头的一段 <code>RR..RRBB..BB</code>，转化成一个类似的子问题。</p>
<p>注意「类似」是因为这个子问题的起点一定是每段 <code>R</code> 的两个端点，所以若该子问题开头的 <code>R</code> 的长度是偶数，该段 <code>R</code> 的长度并不会对环上每段 <code>R</code> 连续段的长度产生限制。</p>
<p>可以发现环上 <code>R</code> 的连续段只需要满足奇数和每个子问题产生的长度限制，就一定满足原问题中的限制。</p>
<p>于是直接 DP 即可。注意由于是环，可以把分界点取在最后一段的任意位置，所以最后统计答案时需要乘上最后一段的长度。显然这样做不会算重。</p>
<p><a href="https://atcoder.jp/contests/agc033/submissions/17268684">代码</a></p>
<h3 id="f---adding-edges">F - Adding Edges</h3>
<h4 id="题意-5">题意</h4>
<p>给定一个 <span class="math inline">\(N\)</span> 个点的树 <span class="math inline">\(T\)</span> 和 <span class="math inline">\(N\)</span> 个点 <span class="math inline">\(M\)</span> 条边的图 <span class="math inline">\(G\)</span>，你需要不断执行以下操作：</p>
<ul>
<li>选择三个点 <span class="math inline">\(a,b,c\)</span> 满足 <span class="math inline">\(G\)</span> 中存在边 <span class="math inline">\((a,b),(b,c)\)</span> 但不存在边 <span class="math inline">\((a,c)\)</span>，若 <span class="math inline">\(T\)</span> 中存在一条同时包含 <span class="math inline">\(a,b,c\)</span>（任意顺序）的简单路径，则在 <span class="math inline">\(G\)</span> 中加入边 <span class="math inline">\((a,c)\)</span>。</li>
</ul>
<p>求最终 <span class="math inline">\(G\)</span> 的边数。可以证明最终的 <span class="math inline">\(G\)</span> 唯一。</p>
<p><span class="math inline">\(N,M\le 2000\)</span></p>
<h4 id="题解-5">题解</h4>
<p>若题目中的条件为 <span class="math inline">\(a,b,c\)</span> 必须按该顺序排列，设原图为 <span class="math inline">\(G_0\)</span>，那么 <span class="math inline">\((x,y)\in G\)</span> 当且仅当存在序列 <span class="math inline">\(x=v_1,v_2,v_3,\ldots,v_k=y\)</span>，满足 <span class="math inline">\((v_i,v_{i+1})\in G_0\)</span> 且 <span class="math inline">\(v_1,v_2,\ldots,v_k\)</span> 按顺序被包含在树上的某条简单路径上。证明较为简单，不再展开。</p>
<p>现在的问题是原题目中 <span class="math inline">\(a,b,c\)</span> 可以按任意顺序排列。考虑对于三个点 <span class="math inline">\(a,b,c\)</span>，若这三个点在树上按该顺序被包含在同一条简单路径上，且 <span class="math inline">\((a,b),(a,c)\in G_0\)</span>，那么我们可以把 <span class="math inline">\((a,c)\)</span> 删去，加入 <span class="math inline">\((b,c)\)</span> 而不影响答案。我们把这样的操作称为压缩。</p>
<p>若我们不断对原图进行压缩，直到不能被压缩，那么可以证明最终的图一定满足以上 <span class="math inline">\(a,b,c\)</span> 必须按顺序排列时的性质。</p>
<p>那么问题是如何压缩。考虑依次加入边，我们记录 <span class="math inline">\(top(a,b)\)</span> 表示 <span class="math inline">\(T\)</span> 以 <span class="math inline">\(a\)</span> 为根时，<span class="math inline">\(b\)</span> 的祖先中离 <span class="math inline">\(b\)</span> 最近且在由当前 <span class="math inline">\(G_0\)</span> 生成的最终的 <span class="math inline">\(G\)</span> 中与 <span class="math inline">\(a\)</span> 有边的点。</p>
<p>假设当前加入边 <span class="math inline">\((a,b)\)</span>，若有 <span class="math inline">\(top(a,b)=b\)</span>，那么无需再加入。若 <span class="math inline">\(top(a,b)\)</span> 存在，则我们可以转化成加入边 <span class="math inline">\((top(a,b),b)\)</span>。</p>
<p>否则，我们加入边 <span class="math inline">\((a,b)\)</span>，更新 <span class="math inline">\(top(a,b)\)</span>。然后我们需要 DFS 更新以 <span class="math inline">\(a\)</span> 为根时 <span class="math inline">\(b\)</span> 子树内点 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(top(a,v)\)</span> 值。</p>
<p>假设当前更新到了点 <span class="math inline">\(v\)</span>，若 <span class="math inline">\(top(a,v)\)</span> 存在，由于是从上往下更新的，一定有 <span class="math inline">\(top(a,v)=v\)</span>。此时我们需要将 <span class="math inline">\((a,v)\)</span> 压缩，即我们需要再更新完后递归调用加边操作加入边 <span class="math inline">\((b,v)\)</span>。这种情况下我们不需要再更新子树的 <span class="math inline">\(top\)</span> 值，可以直接退出。</p>
<p>否则，我们将 <span class="math inline">\(top(a,v)\)</span> 更新为 <span class="math inline">\(b\)</span>，继续更新子树。</p>
<p>压缩完后，我们只要从每个点开始 DFS 统计以这个点为边的一个端点的边的数量即可。</p>
<p>我们每次更新时，若 <span class="math inline">\(top\)</span> 值不存在，我们会更新并继续递归；若存在则会压缩边。<span class="math inline">\(top\)</span> 值一共只有 <span class="math inline">\(N^2\)</span> 条，而边一共只有 <span class="math inline">\(M\)</span> 条，每条最多被缩 <span class="math inline">\(N\)</span> 次，所以时间复杂度为 <span class="math inline">\(O(N^2+NM)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc033/submissions/17280531">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>图论</tag>
        <tag>BFS</tag>
        <tag>博弈</tag>
        <tag>树的直径</tag>
        <tag>双指针</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 036 题解</title>
    <url>/atcoder-agc036/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc036">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---triangle">A - Triangle</h3>
<h4 id="题意">题意</h4>
<p>构造三角形满足：</p>
<ul>
<li>顶点坐标为整数，且在 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(10^9\)</span> 之间。</li>
<li>面积为 <span class="math inline">\(\frac{S}{2}\)</span>。</li>
</ul>
<p><span class="math inline">\(S\le 10^{18}\)</span></p>
<h4 id="题解">题解</h4>
<p>可以令其中一个点 <span class="math inline">\(A\)</span> 在原点，另外两点分别在 <span class="math inline">\(B(x_1,y_1)\)</span> 和 <span class="math inline">\(C(x_2,y_2)\)</span>，不妨令 <span class="math inline">\(C\)</span> 在 <span class="math inline">\(B\)</span> 的逆时针方向，那么有 <span class="math display">\[\overrightarrow{AB}\times \overrightarrow{AC}=S\]</span></p>
<p>其中 <span class="math inline">\(\times\)</span> 表示向量的叉积。代入 <span class="math inline">\(x_1,y_1,x_2,y_2\)</span> 得到 <span class="math display">\[x_1y_2-x_2y_1=S\]</span></p>
<p>我们可以将 <span class="math inline">\(S\)</span> 表示成 <span class="math inline">\(10^9a-b\)</span> 的形式，其中 <span class="math inline">\(0\le a,b\le 10^9\)</span>。于是令 <span class="math inline">\(x_1=10^9,y_2=a,x_2=1,y_1=b\)</span> 即可。</p>
<p><a href="https://atcoder.jp/contests/agc036/submissions/16980532">代码</a></p>
<h3 id="b---do-not-duplicate">B - Do Not Duplicate</h3>
<h4 id="题意-1">题意</h4>
<p>给定一个序列 <span class="math inline">\(A_0,A_1,\ldots,A_{N-1}\)</span>，将该序列复制 <span class="math inline">\(K\)</span> 份得到序列 <span class="math inline">\(X_0,X_1,\ldots,X_{NK-1}\)</span>。</p>
<p>有一个初始为空的序列 <span class="math inline">\(s\)</span>，按 <span class="math inline">\(i\)</span> 从 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(NK-1\)</span> 的顺序，依次执行以下操作：</p>
<ul>
<li>若 <span class="math inline">\(s\)</span> 中不包含 <span class="math inline">\(X_i\)</span>，则在 <span class="math inline">\(s\)</span> 的末尾加入 <span class="math inline">\(X_i\)</span>。</li>
<li>否则，则不断删去 <span class="math inline">\(s\)</span> 的末尾元素，直到 <span class="math inline">\(s\)</span> 中不包含 <span class="math inline">\(X_i\)</span>。此时不加入 <span class="math inline">\(X_i\)</span>。</li>
</ul>
<p>求最终得到的序列 <span class="math inline">\(s\)</span>。</p>
<p><span class="math inline">\(N\le 2\times 10^5,K\le 10^{12}\)</span></p>
<h4 id="题解-1">题解</h4>
<p>假设我们现在需要加入 <span class="math inline">\(X_p,\ldots,X_{NK-1}\)</span>，且 <span class="math inline">\(s\)</span> 序列当前为空。我们令 <span class="math inline">\(q\)</span> 为第一个满足 <span class="math inline">\(X_q=X_p\)</span> 且 <span class="math inline">\(q &gt; p\)</span> 的数。</p>
<p>若 <span class="math inline">\(q\)</span> 存在，那么在加入 <span class="math inline">\(X_q\)</span> 时一定会把 <span class="math inline">\(s\)</span> 序列清空，所以我们可以直接递归操作 <span class="math inline">\(X_{q+1},\ldots,X_{NK-1}\)</span>，即执行 <span class="math inline">\(p\gets q+1\)</span>。</p>
<p>否则若 <span class="math inline">\(p\)</span> 不存在，由于 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(N\)</span> 个数复制若干份得到的，那么剩余部分的长度一定不超过 <span class="math inline">\(N\)</span>，直接暴力模拟即可。</p>
<p>于是我们只要处理第一部分不断跳 <span class="math inline">\(p\)</span> 的过程。注意到 <span class="math inline">\(p\bmod N\)</span> 的值会形成一个环，每次跳一步 <span class="math inline">\(K\)</span> 可能会减少 <span class="math inline">\(0,1,2\)</span>，这只需要将 <span class="math inline">\(K\)</span> 对每次跳一个环会减少的值取模，最后再在环上跳若干步即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N+\max A_i)\)</span> 或 <span class="math inline">\(O(N\log N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc036/submissions/16980532">代码</a></p>
<h3 id="c---gp-2">C - GP 2</h3>
<h4 id="题意-2">题意</h4>
<p>有一个长度为 <span class="math inline">\(N\)</span> 个序列 <span class="math inline">\(x_0,x_1,\ldots,x_{N-1}\)</span>，初始都为 <span class="math inline">\(0\)</span>。你需要求执行恰好 <span class="math inline">\(M\)</span> 次以下操作后能得到多少不同的序列：</p>
<ul>
<li>选择两个整数 <span class="math inline">\(i,j\ (0\le i,j &lt; N,i\ne j)\)</span>，将 <span class="math inline">\(x_i\)</span> 加 <span class="math inline">\(2\)</span>，将 <span class="math inline">\(x_j\)</span> 加 <span class="math inline">\(1\)</span>。</li>
</ul>
<p>对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(N\le 10^6,M\le 5\times 10^5\)</span></p>
<h4 id="题解-2">题解</h4>
<p>一个序列合法的充要条件是：</p>
<ul>
<li><span class="math inline">\(\forall 0\le i &lt; N,0\le x_i\le 2M\)</span></li>
<li><span class="math inline">\(\sum\limits_{i=0}^{N-1}x_i=3M\)</span></li>
<li><span class="math inline">\(x_i\)</span> 是奇数的 <span class="math inline">\(i\)</span> 的数量不超过 <span class="math inline">\(M\)</span>。</li>
</ul>
<p>必要性显然，充分性可以考虑归纳证明，不再展开。</p>
<p>于是我们可以枚举奇数的数量 <span class="math inline">\(d\)</span>，将所有奇数都减 <span class="math inline">\(1\)</span>，再将所有数除以 <span class="math inline">\(2\)</span>，就变成了一个经典的求不定方程整数解数量的问题。即，<span class="math inline">\(N\)</span> 个整数变量，和为 <span class="math inline">\(\frac{3M-d}{2}\)</span>，其中 <span class="math inline">\(d\)</span> 个变量的范围为 <span class="math inline">\(0\le x_i &lt; M\)</span>，<span class="math inline">\(N-d\)</span> 个变量范围为 <span class="math inline">\(0\le x_i \le M\)</span>。可以套用经典的容斥和隔板法的解法，即枚举哪些变量不满足上界的限制，可以得到答案为 <span class="math display">\[
\sum_{i=0}^{d}\sum_{j=0}^{n-d}(-1)^{i+j}\binom{d}{i}\binom{n-d}{j}\binom{\frac{3M-d}{2}-iM-j(M+1)+N-1}{N-1}
\]</span></p>
<p>由于 <span class="math inline">\(i,j\)</span> 需要满足 <span class="math inline">\(iM+j(M+1)\le \frac{3M-d}{2}\)</span>，合法的 <span class="math inline">\(i,j\)</span> 只有常数个，所以总时间复杂度为 <span class="math inline">\(O(N+M)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc036/submissions/16980980">代码</a></p>
<h3 id="d---negative-cycle">D - Negative Cycle</h3>
<h4 id="题意-3">题意</h4>
<p>有一张 <span class="math inline">\(N\)</span> 个点的图，边的状态为：</p>
<ul>
<li>对于所有 <span class="math inline">\(0\le i &lt; N-1\)</span>，<span class="math inline">\(i\)</span> 向 <span class="math inline">\(i+1\)</span> 有一条边权为 <span class="math inline">\(0\)</span> 的不可被删除的有向边。</li>
<li>对于所有 <span class="math inline">\(0\le i &lt; j &lt; N\)</span>，<span class="math inline">\(i\)</span> 向 <span class="math inline">\(j\)</span> 有一条边权为 <span class="math inline">\(-1\)</span> 的可以用 <span class="math inline">\(A_{i,j}\)</span> 的代价删除的有向边。</li>
<li>对于所有 <span class="math inline">\(0\le j &lt; i &lt; N\)</span>，<span class="math inline">\(i\)</span> 向 <span class="math inline">\(j\)</span> 有一条边权为 <span class="math inline">\(1\)</span> 的可以用 <span class="math inline">\(A_{i,j}\)</span> 的代价删除的有向边。</li>
</ul>
<p>求使得图没有负环（即边权和为负数的环）的最小代价。</p>
<p><span class="math inline">\(N\le 500\)</span></p>
<h4 id="题解-3">题解</h4>
<p>首先我们可以把问题转化为一个差分约束的模型，即有 <span class="math inline">\(N\)</span> 个变量，需要满足以下限制：</p>
<ul>
<li><span class="math inline">\(\forall 0\le i &lt; N-1, x_i\ge x_{i+1}\)</span></li>
<li><span class="math inline">\(\forall 0\le i &lt; j &lt; N, x_j-x_i\le -1\)</span></li>
<li><span class="math inline">\(\forall 0\le j &lt; i &lt; N, x_j-x_i\le 1\)</span></li>
</ul>
<p>我们需要删除后面两种限制中的一些限制使得问题有解。</p>
<p>满足第一条限制的 <span class="math inline">\(x\)</span> 一定是 <span class="math inline">\(d,d,\ldots,d,d-1,\ldots,d-1,d-2,\ldots,d-2,\ldots\)</span> 的形式。<span class="math inline">\(x\)</span> 相同的连续段中两两之间的 <span class="math inline">\(-1\)</span> 的边需要删去，而 <span class="math inline">\(x\)</span> 相差超过 <span class="math inline">\(1\)</span> 的两个连续段之间的 <span class="math inline">\(+1\)</span> 边都需要删去。</p>
<p>考虑 DP，用 <span class="math inline">\(f_{i,j}\)</span> 表示最后一段相同的连续段为 <span class="math inline">\((j,i]\)</span> 时最少所需代价，转移时枚举下一段的结尾，用二维前缀和优化计算代价即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N^3)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc036/submissions/16981985">代码</a></p>
<h3 id="e---abc-string">E - ABC String</h3>
<h4 id="题意-4">题意</h4>
<p>有一个只包含 <code>A</code>、<code>B</code>、<code>C</code> 的字符串 <span class="math inline">\(S\)</span>，求出 <span class="math inline">\(S\)</span> 的一个最长的子序列 <span class="math inline">\(x\)</span> 满足：</p>
<ul>
<li>相邻两个字符不同；</li>
<li><code>A</code>、<code>B</code>、<code>C</code> 出现次数相同。</li>
</ul>
<p>构造一个方案。</p>
<p><span class="math inline">\(|S|\le 10^6\)</span></p>
<h4 id="题解-4">题解</h4>
<p>首先可以把极长的相同字符的连续段缩成一个字符。</p>
<p>设 A,B,C 数量为 <span class="math inline">\(cnt_A,cnt_B,cnt_C\)</span>，不妨假设 <span class="math inline">\(cnt_A\le cnt_B\le cnt_C\)</span>。</p>
<p>由于最后需要使得 <span class="math inline">\(cnt_A=cnt_B=cnt_C\)</span>，我们先尽量删 C 使得 <span class="math inline">\(cnt_C=cnt_B\)</span>。</p>
<p>考虑贪心地删，那么一定是优先删除两边字符不同的 C，这样一定对答案没有影响。</p>
<p>若删完这些 C 后，仍然 <span class="math inline">\(cnt_C &gt; cnt_B\)</span>，那么考虑两边字符相同的情况。若两边字符是 B，那么删除 C 会连带删除一个 B，不会对 <span class="math inline">\(cnt_C-cnt_B\)</span> 产生影响；若两边字符是 A，则删除 C 会连带删除一个 A。</p>
<p>若删完后仍然 <span class="math inline">\(cnt_C &gt; cnt_B\)</span>，那么一定无解。否则现在有 <span class="math inline">\(cnt_C=cnt_B\ge cnt_A\)</span>。我们需要同时删除 B 和 C 使得 <span class="math inline">\(cnt_A=cnt_B=cnt_C\)</span>。</p>
<p>注意到一个连续的 BC 或 CB 若两边不同时是 A，那么一定可以删除。发现将可以删除的 BC 或 CB 删除后一定会变成形如 ABCACBABCABCA 的形式，一定有 <span class="math inline">\(cnt_A &gt; cnt_B\)</span>，所以在中间删除的过程中一定会有一个时刻使得 <span class="math inline">\(cnt_A=cnt_B=cnt_C\)</span>。</p>
<p>可以用链表维护，也可以每次删除后重构，时间复杂度 <span class="math inline">\(O(|S|)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc036/submissions/16988647">代码</a></p>
<h3 id="f---square-constraints">F - Square Constraints</h3>
<h4 id="题意-5">题意</h4>
<p>求满足以下条件的 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(2N-1\)</span> 的排列 <span class="math inline">\(P_0,P_1,\ldots,P_{2N-1}\)</span> 的数量：</p>
<ul>
<li><span class="math inline">\(\forall 0\le i &lt; 2N,N^2\le i^2+P_i^2\le (2N)^2\)</span></li>
</ul>
<p>对给定的模数 <span class="math inline">\(M\)</span> 取模，不一定为质数。</p>
<p><span class="math inline">\(N\le 250,M\le 10^9\)</span></p>
<h4 id="题解-5">题解</h4>
<p>注意到题目相当于对排列的每个位置有一个 <span class="math inline">\((l_i,r_i]\)</span> 的限制。</p>
<p>没有 <span class="math inline">\(l_i\)</span> 的限制时，我们只需要按 <span class="math inline">\(r_i\)</span> 从小到大填数即可。</p>
<p>有 <span class="math inline">\(l_i\)</span> 的限制时，考虑容斥。注意到后 <span class="math inline">\(N\)</span> 个位置的 <span class="math inline">\(l_i=0\)</span>，可以不考虑。将前 <span class="math inline">\(N\)</span> 个数的 <span class="math inline">\(l_i,r_i\)</span> 和后 <span class="math inline">\(N\)</span> 个位置的 <span class="math inline">\(r_i\)</span> 共 <span class="math inline">\(3N\)</span> 个数从小到大排序，注意到最后 <span class="math inline">\(N\)</span> 个数一定是前 <span class="math inline">\(N\)</span> 个数的 <span class="math inline">\(r_i\)</span>，且一定是 <span class="math inline">\(r_{N-1},r_{N-2},\ldots,r_0\)</span>。</p>
<p>那么考虑枚举强制小于等于 <span class="math inline">\(l_i\)</span> 的数的数量 <span class="math inline">\(k\)</span>，那么前 <span class="math inline">\(2N\)</span> 个数共选择了 <span class="math inline">\(N+k\)</span> 个数。这个个数是确定的，于是可以 DP。</p>
<p>令 <span class="math inline">\(f_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 个数中，有 <span class="math inline">\(j\)</span> 个数强制不合法时的方案数。</p>
<p>若当前数是后 <span class="math inline">\(N\)</span> 个位置的上界，那么直接乘上贡献即可。</p>
<p>否则考虑该数是否强制不合法，两种情况都可以方便地计算贡献。</p>
<p>具体贡献式子可以参考代码。时间复杂度 <span class="math inline">\(O(N^3)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc036/submissions/16985540">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>图论</tag>
        <tag>贪心</tag>
        <tag>计算几何</tag>
        <tag>容斥</tag>
        <tag>差分约束</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 035 题解</title>
    <url>/atcoder-agc035/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc035">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---xor-circle">A - XOR Circle</h3>
<h4 id="题意">题意</h4>
<p>给定 <span class="math inline">\(N\)</span> 个非负整数 <span class="math inline">\(a_1,a_2,\ldots,a_N\)</span>，判断是否可以将这 <span class="math inline">\(N\)</span> 个数放入一个环中，使得每个数左右两边数的异或值等于该数。</p>
<p><span class="math inline">\(N\le 10^5,a_i\le 10^9\)</span></p>
<h4 id="题解">题解</h4>
<p>条件相当于连续三个数异或和等于 <span class="math inline">\(0\)</span>。假设最后环上的数按顺序为 <span class="math inline">\(b_0,b_1,\ldots,b_{n-1}\)</span>，那么一个必要条件是 <span class="math inline">\(b_i=b_{(i+3)\bmod n}\)</span>。</p>
<p>当 <span class="math inline">\(3\nmid n\)</span> 时，该条件相当于所有数相等。又因为需要连续三个数异或和为 <span class="math inline">\(0\)</span>，那么所有数必须都是 <span class="math inline">\(0\)</span>。</p>
<p>当 <span class="math inline">\(3\mid n\)</span> 时，我们需要将所有数分成 <span class="math inline">\(3\)</span> 组，每组有 <span class="math inline">\(\frac{n}{3}\)</span> 个数且都相等。同时为了满足连续三个数异或和为 <span class="math inline">\(0\)</span>，这三组中各取一个数的异或和需要等于 <span class="math inline">\(0\)</span>。直接判断即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span> 或 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc035/submissions/16995538">代码</a></p>
<h3 id="b---even-degrees">B - Even Degrees</h3>
<h4 id="题意-1">题意</h4>
<p>有一张 <span class="math inline">\(N\)</span> 个点 <span class="math inline">\(M\)</span> 条边的简单无向连通图，你需要给每条边定向，使得每个点的出度为偶数。构造一组方案，或输出无解。</p>
<p><span class="math inline">\(N,M\le 10^5\)</span></p>
<h4 id="题解-1">题解</h4>
<p>当 <span class="math inline">\(M\)</span> 是奇数时一定无解，<span class="math inline">\(M\)</span> 是偶数时可以通过构造证明一定有解。</p>
<p>当图是一棵树时，我们只需要从叶子向上依次确定边的方向即可。</p>
<p>对于原问题，我们只需要任意取出一棵生成树，任意确定非树边的方向，再用类似树的方法确定树边的方向即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N+M)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc035/submissions/16995732">代码</a></p>
<h3 id="c---skolem-xor-tree">C - Skolem XOR Tree</h3>
<h4 id="题意-2">题意</h4>
<p>有 <span class="math inline">\(2N\)</span> 个点，第 <span class="math inline">\(i\ (1\le i\le N)\)</span> 个点和第 <span class="math inline">\(N+i\)</span> 个点的点权为 <span class="math inline">\(i\)</span>。</p>
<p>将这 <span class="math inline">\(2N\)</span> 个点连成一棵树，使得：</p>
<ul>
<li>对于所有 <span class="math inline">\(1\le i\le N\)</span>，<span class="math inline">\(i\)</span> 和 <span class="math inline">\(i+N\)</span> 路径上点权的异或和为 <span class="math inline">\(i\)</span>（包括两个端点）。</li>
</ul>
<p><span class="math inline">\(N\le 10^5\)</span></p>
<h4 id="题解-2">题解</h4>
<p>当 <span class="math inline">\(N=2^k\)</span> 时一定无解，因为除去 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(2N\)</span> 两个点其他点权最高位都小于 <span class="math inline">\(k\)</span>，不可能使得异或和为 <span class="math inline">\(2^k\)</span>。</p>
<p>注意到 <span class="math inline">\(2i\)</span> 和 <span class="math inline">\(2i+1\)</span> 的异或值为 <span class="math inline">\(1\)</span>。当 <span class="math inline">\(N\)</span> 是奇数时，我们可以以节点 <span class="math inline">\(1\)</span> 为中心构造一条链，每次将点权为 <span class="math inline">\(2i\)</span> 和 <span class="math inline">\(2i+1\)</span> 的点对分别放在两边。例如 <span class="math inline">\(N=5\)</span> 时我们可以构造 <span class="math display">\[4-5-2-3-1-2-3-4-5\]</span></p>
<p>然后将另一个点权为 <span class="math inline">\(1\)</span> 的点连在第一对点对上即可，例如上面的例子中连在右边的 <span class="math inline">\(3\)</span> 上即可。</p>
<p>当 <span class="math inline">\(N\)</span> 是偶数时，我们一定可以找到一个 <span class="math inline">\(x,y\ (2\le x,y &lt; N)\)</span> 使得 <span class="math inline">\(N=x\oplus y\)</span>。那么我们只要强制链的一边 <span class="math inline">\(x,y\)</span> 有连边即可，例如 <span class="math inline">\(N=6,x=2,y=4\)</span> 时，可以构造 <span class="math display">\[4-5-3-2-1-3-2-4-5\]</span></p>
<p>然后将两个 <span class="math inline">\(6\)</span> 分别连在右边的 <span class="math inline">\(2\)</span> 和 <span class="math inline">\(4\)</span> 上即可。</p>
<p><a href="https://atcoder.jp/contests/agc035/submissions/16996178">代码</a></p>
<h3 id="d---add-and-remove">D - Add and Remove</h3>
<h4 id="题意-3">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 张卡片，从左到右分别写着数字 <span class="math inline">\(A_1,A_2,\ldots,A_N\)</span>。执行以下操作若干次直到卡片数量为 <span class="math inline">\(2\)</span>：</p>
<ul>
<li>选择连续三张卡片 <span class="math inline">\(x,y,z\)</span>；</li>
<li>将 <span class="math inline">\(A_x\)</span> 和 <span class="math inline">\(A_z\)</span> 各加上 <span class="math inline">\(A_y\)</span>，然后删去第 <span class="math inline">\(y\)</span> 张卡片。</li>
</ul>
<p>求最后两张卡片上的数字之和的最小值。</p>
<p><span class="math inline">\(N\le 18\)</span></p>
<h4 id="题解-3">题解</h4>
<p>考虑倒着做，令 <span class="math inline">\(f_{l,r,x,y}\)</span> 表示只考虑 <span class="math inline">\([l,r]\)</span> 中的卡片，其中 <span class="math inline">\(l\)</span> 最后会对答案产生 <span class="math inline">\(x\)</span> 倍的贡献，<span class="math inline">\(r\)</span> 最后会对答案产生 <span class="math inline">\(y\)</span> 倍的贡献时的最小值（不计入卡片 <span class="math inline">\(l,r\)</span> 上原来的数的贡献）。那么有 <span class="math display">\[
f_{l,r,x,y}=\min_{l &lt; k &lt; r} f_{l,k,x,x+y}+f_{k,r,x+y,y}+A_k(x+y)
\]</span></p>
<p>可以证明状态数为 <span class="math inline">\(O(2^n\operatorname{poly}(n))\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(2^n\operatorname{poly}(n))\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc035/submissions/16996639">代码</a></p>
<h3 id="e---develop">E - Develop</h3>
<h4 id="题意-4">题意</h4>
<p>有一个集合 <span class="math inline">\(S\)</span>，初始为所有整数。每次可以执行以下操作：</p>
<ul>
<li>选择一个 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\)</span> 且在 <span class="math inline">\(S\)</span> 中的整数 <span class="math inline">\(x\)</span>，在 <span class="math inline">\(S\)</span> 中删除 <span class="math inline">\(x\)</span>；</li>
<li>在 <span class="math inline">\(S\)</span> 中加入 <span class="math inline">\(x-2\)</span> 和 <span class="math inline">\(x+K\)</span>。已经存在则不加入。</li>
</ul>
<p>求通过若干次（可以是 <span class="math inline">\(0\)</span> 次）操作可以得到的不同的集合数量。对 <span class="math inline">\(M\)</span> 取模。</p>
<p><span class="math inline">\(N\le 150\)</span></p>
<h4 id="题解-4">题解</h4>
<p>考虑 <span class="math inline">\(x\)</span> 向 <span class="math inline">\(x-2\)</span> 和 <span class="math inline">\(x+K\)</span> 连有向边。我们可以将最终集合的数量转化为删去的数组成的集合的数量。显然一个环中的数不能都被删去，而删去的数构成的子图若不存在环那么一定合法。</p>
<p>当 <span class="math inline">\(K\)</span> 为偶数时，图的形态如下图所示（图中 <span class="math inline">\(N=11,K=6\)</span>）：</p>
<p><img src="/files/AGC035Eeven.png" class="lazyload" data-srcset="/files/AGC035Eeven.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>这相当于对于每一条链，不能连续选择超过 <span class="math inline">\(\frac{K}{2}\)</span> 个点，对每条链分别 DP 即可。</p>
<p>当 <span class="math inline">\(K\)</span> 为奇数时，图的形态如下图所示（图中 <span class="math inline">\(N=12,K=3\)</span>）：</p>
<p><img src="/files/AGC035Eodd.png" class="lazyload" data-srcset="/files/AGC035Eodd.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>图中的一个环一定是从左边的某个点向上，到某个点往右，然后再往上，最后回到原点。即在上图中形如一个三角形或一个八字形。</p>
<p>注意图中的每个简单环长度都为 <span class="math inline">\(K+2\)</span>，那么相当于不能存在一条向上、向右、再向上的，长度为 <span class="math inline">\(K+2\)</span> 的路径。</p>
<p>于是可以 DP，令 <span class="math inline">\(f_{i,j,k}\)</span> 表示到图中的第 <span class="math inline">\(i\)</span> 层，从第 <span class="math inline">\(i\)</span> 层左侧点开始的向上、向右、再向上的最长的路径长度为 <span class="math inline">\(j\)</span>，从右侧点向上的最长路径长度为 <span class="math inline">\(k\)</span> 时的方案数。</p>
<p>注意当上一层的 <span class="math inline">\(j\)</span> 为 <span class="math inline">\(0\)</span> 且这一层右侧点没有选择时，这一层的 <span class="math inline">\(j\)</span> 仍然是 <span class="math inline">\(0\)</span>，因为要形成环必须要有一条向右的边。</p>
<p>时间复杂度 <span class="math inline">\(O(N^3)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc035/submissions/17003956">代码</a></p>
<h3 id="f---two-histograms">F - Two Histograms</h3>
<h4 id="题意-5">题意</h4>
<p>有一个 <span class="math inline">\(N\times M\)</span> 的网格，初始都为 <span class="math inline">\(0\)</span>。你需要执行一次以下操作：</p>
<ul>
<li>对于每个 <span class="math inline">\(1\le i\le N\)</span>，选择一个 <span class="math inline">\(0\le k_i\le M\)</span>，将第 <span class="math inline">\(i\)</span> 行的前 <span class="math inline">\(k_i\)</span> 个格子中的数加 <span class="math inline">\(1\)</span>。</li>
<li>对于每个 <span class="math inline">\(1\le j\le M\)</span>，选择一个 <span class="math inline">\(0\le l_j\le N\)</span>，将第 <span class="math inline">\(i\)</span> 列的前 <span class="math inline">\(l_j\)</span> 个格子中的数加 <span class="math inline">\(1\)</span>。</li>
</ul>
<p>求最后能得到多少本质不同的网格。对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(N,M\le 5\times 10^5\)</span></p>
<h4 id="题解-5">题解</h4>
<p>注意到对于一个 <span class="math inline">\(\{k_i\},\{l_j\}\)</span>，若存在 <span class="math inline">\(i,j\)</span> 满足 <span class="math inline">\(k_i=j-1,l_j=i\)</span>，那么我们可以把 <span class="math inline">\(k_i\)</span> 加 <span class="math inline">\(1\)</span>，<span class="math inline">\(l_j\)</span> 减 <span class="math inline">\(1\)</span> 而不改变矩阵。由于每次改变会使 <span class="math inline">\(k\)</span> 的总和增加，所以改变次数一定是有限的。我们称不存在这样 <span class="math inline">\(i,j\)</span> 的 <span class="math inline">\(\{k_i\},\{l_j\}\)</span> 为标准形式。</p>
<p>接下来我们证明一个合法的网格一定对应唯一的一个标准形式。</p>
<p>假设一个网格对应两个不同的标准形式，分别为 <span class="math inline">\(\{k_i\},\{l_j\}\)</span> 和 <span class="math inline">\(\{k_i&#39;\},\{l_j&#39;\}\)</span>。令 <span class="math inline">\(j\)</span> 为第一个满足 <span class="math inline">\(l_j\ne l_j&#39;\)</span> 的位置。</p>
<p>不妨假设 <span class="math inline">\(l_j &lt; l_j&#39;\)</span>。若 <span class="math inline">\(j=1\)</span>，那么网格的第 <span class="math inline">\(l_1&#39;\)</span> 行第 <span class="math inline">\(1\)</span> 列一定为 <span class="math inline">\(1\)</span>，所以有 <span class="math inline">\(k_{l_1&#39;}&#39;=0\)</span>，与 <span class="math inline">\(\{k_i&#39;\},\{l_j&#39;\}\)</span> 是标准形式矛盾。</p>
<p>若 <span class="math inline">\(j&gt;1\)</span>，那么网格的第 <span class="math inline">\(l_j&#39;\)</span> 行第 <span class="math inline">\(j\)</span> 列一定为 <span class="math inline">\(1\)</span>，所以有 <span class="math inline">\(k_{l_j&#39;}\ge j,k_{l_j&#39;}&#39; &lt; j\)</span>。又因为 <span class="math inline">\(k_{l_j&#39;}&#39;\ne j-1\)</span>，所以 <span class="math inline">\(k_{l_j&#39;}&#39; &lt; j-1 &lt; k_{l_j&#39;}\)</span>，又因为 <span class="math inline">\(l_{j-1}=l_{j-1}&#39;\)</span>，网格的第 <span class="math inline">\(l_j&#39;\)</span> 行第 <span class="math inline">\(j-1\)</span> 列一定不同，矛盾。</p>
<p>于是接下来我们只要统计不存在 <span class="math inline">\(i,j\)</span> 满足 <span class="math inline">\(k_i=j-1,l_j=i\)</span> 的 <span class="math inline">\(\{k_i\},\{l_j\}\)</span> 的序列数量。考虑容斥，强制若干对 <span class="math inline">\(i,j\)</span> 满足该条件，容斥式子为 <span class="math display">\[
\sum_{i=0}^{\min(n,m)}(-1)^i\binom{n}{i}\binom{m}{i}i!(m+1)^{n-i}(n+1)^{m-i}
\]</span></p>
<p>直接计算即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc035/submissions/16997392">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 037 题解</title>
    <url>/atcoder-agc037/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc037">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---dividing-a-string">A - Dividing a String</h3>
<h4 id="题意">题意</h4>
<p>给定一个字符串 <span class="math inline">\(S\)</span>，求最多可以把该字符串分成多少份，使得相邻两份不相同。</p>
<p><span class="math inline">\(|S|\le 2\times 10^5\)</span></p>
<h4 id="题解">题解</h4>
<p>显然每一份的长度一定不超过 <span class="math inline">\(2\)</span>。直接 DP 即可。</p>
<p><a href="https://atcoder.jp/contests/agc037/submissions/16946000">代码</a></p>
<h3 id="b---rgb-balls">B - RGB Balls</h3>
<h4 id="题意-1">题意</h4>
<p>有 <span class="math inline">\(3N\)</span> 个球，编号 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(3N\)</span>。每个球有红（R）、绿（G）、蓝（B）三种颜色，每种颜色的球恰好有 <span class="math inline">\(N\)</span> 个。</p>
<p>你要将这些球分给 <span class="math inline">\(N\)</span> 个人，每个人得到恰好一个红球、一个绿球、一个蓝球。令第 <span class="math inline">\(i\)</span> 个人得到的球的编号按升序排列为 <span class="math inline">\(a_i,b_i,c_i\)</span>，则分配方案需要最小化 <span class="math display">\[\sum_{i=1}^{N} (c_i-a_i)\]</span></p>
<p>求使得上式最小的分配方案数，对 <span class="math inline">\(998244353\)</span> 取模。两种方案不同当且仅当存在某个人分到的球的集合不同。</p>
<h4 id="题解-1">题解</h4>
<p>有一种贪心是，从左往右依次扫描每个球，记录单个的，两个的，以及三个球都配好的数量。那么加入一个球时，优先与已经有两个球的对配成三个球；若不行，再尝试与单个的球配成两个球；若仍然不行，则单独成为一个球。</p>
<p>可以通过调整证明这样贪心得到的方案一定恰好能覆盖所有最小的方案。</p>
<p>于是直接用乘法原理计算答案即可。</p>
<p><a href="https://atcoder.jp/contests/agc037/submissions/16946846">代码</a></p>
<h3 id="c---numbers-on-a-circle">C - Numbers on a Circle</h3>
<h4 id="题意-2">题意</h4>
<p>环上有 <span class="math inline">\(N\)</span> 个正整数 <span class="math inline">\(A_i\)</span>，你可以执行若干次以下操作：</p>
<ul>
<li>选择环上的一个数，将该数加上与它相邻的两个数。</li>
</ul>
<p>你的目标是使得 <span class="math inline">\(A_i=B_i\)</span>。求最少操作次数，或输出无解。</p>
<p><span class="math inline">\(N\le 2\times 10^5\)</span></p>
<h4 id="题解-2">题解</h4>
<p>考虑倒着做，假设所有数中最大的为 <span class="math inline">\(x\)</span>。那么在操作 <span class="math inline">\(x\)</span> 之前不可能操作与 <span class="math inline">\(x\)</span> 相邻的两个数，所以我们一定会先操作 <span class="math inline">\(x\)</span>。</p>
<p>于是只要用堆模拟即可，因为每次相当于会对最大值取模，所以复杂度是 <span class="math inline">\(O(N\log N\log A_i)\)</span> 的。</p>
<p><a href="https://atcoder.jp/contests/agc037/submissions/16947071">代码</a></p>
<h3 id="d---sorting-a-grid">D - Sorting a Grid</h3>
<h4 id="题意-3">题意</h4>
<p>给定一个 <span class="math inline">\(N\times M\)</span> 的矩阵，第 <span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 列的数为 <span class="math inline">\(A_{i,j}\)</span>。矩阵满足 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(NM\)</span> 的每个数恰好出现一次。你需要按顺序执行以下操作：</p>
<ul>
<li>对于矩阵 <span class="math inline">\(A\)</span> 的每一行，重新排列该行的元素得到矩阵 <span class="math inline">\(B\)</span>；</li>
<li>对于矩阵 <span class="math inline">\(B\)</span> 的每一列，重新排列该列的元素得到矩阵 <span class="math inline">\(C\)</span>；</li>
<li>对于矩阵 <span class="math inline">\(C\)</span> 的每一行，重新排列该行的元素得到矩阵 <span class="math inline">\(D\)</span>。</li>
</ul>
<p>你的目标是使矩阵 <span class="math inline">\(D\)</span> 第 <span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 列的数为 <span class="math inline">\((i-1)M+j\)</span>。</p>
<p>构造一种方案。可以证明一定有解。</p>
<p><span class="math inline">\(N,M\le 100\)</span></p>
<h4 id="题解-3">题解</h4>
<p>对于矩阵 <span class="math inline">\(C\)</span>，我们可以将每个数替换成最终矩阵中的行号，<span class="math inline">\(C\)</span> 的每一列需要满足恰好是 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\)</span>。</p>
<p>那么对于矩阵 <span class="math inline">\(B\)</span>，每一列需要恰好是 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\)</span> 的一个排列。</p>
<p>于是我们考虑从左到右填 <span class="math inline">\(B\)</span> 的每一列。这可以直接跑二分图匹配。</p>
<p>我们可以用数学归纳法，根据霍尔定理证明一定有解。</p>
<p>时间复杂度 <span class="math inline">\(O(MN^3)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc037/submissions/16948114">代码</a></p>
<h3 id="e---reversing-and-concatenating">E - Reversing and Concatenating</h3>
<h4 id="题意-4">题意</h4>
<p>给定一个长度为 <span class="math inline">\(N\)</span> 的字符串 <span class="math inline">\(S\)</span>，你需要执行以下操作 <span class="math inline">\(K\)</span> 次：</p>
<ul>
<li>令 <span class="math inline">\(T\)</span> 为 <span class="math inline">\(S\)</span> 翻转后的串，令 <span class="math inline">\(U\)</span> 为 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(T\)</span> 按顺序拼接得到的串。</li>
<li>将 <span class="math inline">\(S\)</span> 替换为 <span class="math inline">\(U\)</span> 的一个长度为 <span class="math inline">\(N\)</span> 的子串。</li>
</ul>
<p>求最后得到的字典序最小的 <span class="math inline">\(S\)</span>。</p>
<p><span class="math inline">\(N\le 5000,K\le 10^9\)</span></p>
<h4 id="题解-4">题解</h4>
<p>因为需要字典序最小，所以我们会尽量使最小的字符在开头的出现次数最多。</p>
<p>假设最小的字符为 <span class="math inline">\(a\)</span>，假设初始字符串有一段长度为 <span class="math inline">\(l\)</span> 的字符 <span class="math inline">\(a\)</span>。那么我们可以执行以下若干次操作：</p>
<ul>
<li><span class="math inline">\(\ldots aaa\ldots\to \ldots aaa\boxed{\ldots\ldots aaa}\ldots\)</span></li>
<li><span class="math inline">\(\ldots\ldots aaa\to \ldots\boxed{\ldots aaaaaa}\ldots\ldots\)</span></li>
<li><span class="math inline">\(\ldots aaaaaa\to \ldots aaaaaaaaaaaa\ldots\)</span></li>
<li><span class="math inline">\(\ldots\)</span></li>
</ul>
<p>使得最后得到的字符串最前面有 <span class="math inline">\(l\times 2^{k-1}\)</span> 个 <span class="math inline">\(a\)</span>。</p>
<p>通过手动模拟可以得到后面部分一定是初始字符串中从这一段 <span class="math inline">\(a\)</span> 的下一个字符开始，到末尾，再从末尾返回得到的字符串。</p>
<p>于是我们枚举每一段最长的 <span class="math inline">\(a\)</span> 后暴力求出最后的字符串，暴力比较即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc037/submissions/16952413">代码</a></p>
<h3 id="f---counting-of-subarrays">F - Counting of Subarrays</h3>
<h4 id="题意-5">题意</h4>
<p>定义一个序列 <span class="math inline">\(S\)</span> 是属于 level <span class="math inline">\((k,l)\)</span> 的当且仅当满足以下条件之一：</p>
<ul>
<li><span class="math inline">\(S\)</span> 的长度为 <span class="math inline">\(1\)</span> 且元素为 <span class="math inline">\(k\)</span>；</li>
<li><span class="math inline">\(k&gt;1\)</span> 且存在属于 level <span class="math inline">\((k,l-1)\)</span> 的序列 <span class="math inline">\(T_1,T_2,\ldots,T_m\ (m\ge l)\)</span> 满足 <span class="math inline">\(T_1,T_2,\ldots,T_m\)</span> 按顺序拼接得到 <span class="math inline">\(S\)</span>。</li>
</ul>
<p>给定整数 <span class="math inline">\(L\)</span> 和一个序列 <span class="math inline">\(A_1,A_2,\ldots,A_N\)</span>，求 <span class="math inline">\(A\)</span> 有多少个连续子序列满足，存在一个 <span class="math inline">\(K\)</span> 使得该序列是属于 level <span class="math inline">\((K,L)\)</span> 的。</p>
<p><span class="math inline">\(N\le 2\times 10^5\)</span></p>
<h4 id="题解-5">题解</h4>
<p>一个序列 <span class="math inline">\(a_1,a_2,\ldots, a_n\)</span> 合法当且仅当满足以下条件之一：</p>
<ul>
<li><span class="math inline">\(n=1\)</span></li>
<li>令 <span class="math inline">\(x\)</span> 为该序列的最小值，对于所有 <span class="math inline">\(a_i=x\)</span> 的极长连续段，假设长度为 <span class="math inline">\(l_1,l_2,\ldots,l_m\)</span>，都有 <span class="math inline">\(l_i\ge L\)</span>，且将第 <span class="math inline">\(i\)</span> 段连续段替换成 <span class="math inline">\(\lfloor\frac{l_i}{L}\rfloor\)</span> 个 <span class="math inline">\(x+1\)</span>，得到一个新的序列 <span class="math inline">\(b_1,b_2,\ldots,b_k\)</span>，有 <span class="math inline">\(b\)</span> 序列合法。</li>
</ul>
<p>考虑将原序列不断地按上述过程进行变换，则原序列的一个区间对应新序列的一个区间，而新序列的一个区间对应原序列的若干个区间。</p>
<p>考虑在变换过程中维护 <span class="math inline">\(L_i\)</span>，表示原序列中有多少个左端点对应到新序列中为 <span class="math inline">\(i\)</span>，<span class="math inline">\(R_i\)</span> 同理。</p>
<p>我们只要在变换时维护答案即可，注意计入答案的区间必须满足区间中包含至少一个不是通过收缩得到的点。</p>
<p>用链表和堆模拟变换过程，时间复杂度 <span class="math inline">\(O(N\log N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc037/submissions/16957612">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>堆</tag>
        <tag>二分图匹配</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 038 题解</title>
    <url>/atcoder-agc038/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc038">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---01-matrix">A - 01 Matrix</h3>
<h4 id="题意">题意</h4>
<p>构造一个 <span class="math inline">\(H\times W\)</span> 的 01 矩阵，使得：</p>
<ul>
<li>对于每一行，1 的个数和 0 的个数的较小值为 <span class="math inline">\(A\)</span>；</li>
<li>对于每一列，1 的个数和 0 的个数的较小值为 <span class="math inline">\(B\)</span>。</li>
</ul>
<p>或输出无解。</p>
<p><span class="math inline">\(H,W\le 1000,0\le A\le \frac{W}{2},0\le B\le \frac{H}{2}\)</span></p>
<h4 id="题解">题解</h4>
<p>只要将左上角的 <span class="math inline">\(B\times A\)</span> 的矩阵和右下角的 <span class="math inline">\((H-B)\times (W-A)\)</span> 的矩阵置为全 1 矩阵即可。</p>
<p>时间复杂度 <span class="math inline">\(O(HW)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc038/submissions/16926652">代码</a></p>
<h3 id="b---sorting-a-segment">B - Sorting a Segment</h3>
<h4 id="题意-1">题意</h4>
<p>给定一个 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(N-1\)</span> 的排列 <span class="math inline">\(P_0,P_1,\ldots,P_{N-1}\)</span>。你需要求有多少本质不同的排列可以通过 <span class="math inline">\(P\)</span> 通过恰好一次以下操作得到：</p>
<ul>
<li>选择一个长度为 <span class="math inline">\(K\)</span> 的区间，将该区间中的元素从小到大排序。</li>
</ul>
<p><span class="math inline">\(N\le 2\times 10^5\)</span></p>
<h4 id="题解-1">题解</h4>
<p>考虑如何判断选择 <span class="math inline">\([i,i+k-1]\)</span> 和选择 <span class="math inline">\([j,j+k-1]\)</span> 得到的排列是否相同。</p>
<p>假设有 <span class="math inline">\(i&lt;j\)</span>。先考虑两个区间有交的情况。此时充要条件是 <span class="math inline">\([i,j-1]\)</span> 和 <span class="math inline">\([i+k,j+k-1]\)</span> 分别有序，且 <span class="math inline">\([i,j-1]\)</span> 中的元素小于相交部分的元素，<span class="math inline">\([i+k,j+k-1]\)</span> 中的元素大于相交部分。</p>
<p>而两个区间不交时，充要条件则为两个区间分别有序。</p>
<p>注意到对于区间相交的情况，当 <span class="math inline">\(j=k+1\ (k&gt;i)\)</span> 时若满足条件，则 <span class="math inline">\(j=k\)</span> 时一定满足条件。所以我们只需要判断 <span class="math inline">\(j=i+1\)</span> 的情况，这可以用滑动窗口的方法判断。</p>
<p>判断某个区间是否有序可以通过预处理 <span class="math inline">\([a_i&gt;a_{i-1}]\)</span> 的前缀和实现。</p>
<p>时间复杂度 <span class="math inline">\(O(N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc038/submissions/16927049">代码</a></p>
<h3 id="c---lcms">C - LCMs</h3>
<h4 id="题意-2">题意</h4>
<p>给定正整数序列 <span class="math inline">\(a_0,a_1,\ldots,a_{n-1}\)</span>，求 <span class="math display">\[\sum_{i=0}^{n-2}\sum_{j=i+1}^{n-1}\operatorname{lcm}(a_i,a_j)\]</span></p>
<p><span class="math inline">\(n\le 2\times 10^5,a_i\le 10^6\)</span></p>
<h4 id="题解-2">题解</h4>
<p>令 <span class="math inline">\(c_j\)</span> 表示 <span class="math inline">\(a_i=j\)</span> 的 <span class="math inline">\(i\)</span> 数量，<span class="math inline">\(m\)</span> 表示最大值，则有 <span class="math display">\[
\begin{aligned}
\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}\operatorname{lcm}(a_i,a_j)&amp;=\sum_{i=1}^{m}\sum_{j=1}^{m}c_ic_j\frac{ij}{\gcd(i,j)}\\
&amp;=\sum_{d=1}^{m}\frac{1}{d}\sum_{i=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}c_{id}c_{jd}\cdot id\cdot jd\cdot [\gcd(i,j)=1]\\
&amp;=\sum_{d=1}^{m}\frac{1}{d}\sum_{k=1}^{\lfloor\frac{m}{d}\rfloor}\mu(k)\left(\sum_{i=1}^{\lfloor\frac{m}{dk}\rfloor}c_{idk}\cdot idk\right)^2
\end{aligned}
\]</span></p>
<p>于是我们可以对于所有 <span class="math inline">\(1\le w\le m\)</span>，预处理出 <span class="math display">\[
\sum_{i=1}^{\lfloor\frac{m}{w}\rfloor} c_{iw}\cdot iw
\]</span></p>
<p>这一部分预处理和最后的计算都是调和级数的复杂度。最后只需要把答案减去 <span class="math inline">\(i=j\)</span> 的情况再除以 <span class="math inline">\(2\)</span> 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(m\log m)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc038/submissions/16927261">代码</a></p>
<h3 id="d---unique-path">D - Unique Path</h3>
<h4 id="题意-3">题意</h4>
<p>你需要判断是否存在 <span class="math inline">\(N\)</span> 个点 <span class="math inline">\(M\)</span> 条边的无向简单（无重边，无自环）连通图满足 <span class="math inline">\(Q\)</span> 个限制，其中第 <span class="math inline">\(i\)</span> 个限制为：</p>
<ul>
<li>若 <span class="math inline">\(C_i=0\)</span>，<span class="math inline">\(A_i\)</span> 到 <span class="math inline">\(B_i\)</span> 恰好有一条简单路径。</li>
<li>若 <span class="math inline">\(C_i=1\)</span>，<span class="math inline">\(A_i\)</span> 到 <span class="math inline">\(B_i\)</span> 有两条及以上不同的简单路径。</li>
</ul>
<p><span class="math inline">\(N\le 10^5,N-1\le M\le \frac{N(N-1)}{2},Q\le 10^5\)</span></p>
<h4 id="题解-3">题解</h4>
<p>假设已经有一张图，考虑如何判断。</p>
<p>考虑建出圆方树，特别地，对于点数为 <span class="math inline">\(2\)</span> 的点双，不建立方点，直接连边。于是限制条件想变成了：</p>
<ul>
<li>若 <span class="math inline">\(C_i=0\)</span>，圆方树上圆点 <span class="math inline">\(A_i\)</span> 到圆点 <span class="math inline">\(B_i\)</span> 的简单路径不经过方点。</li>
<li>若 <span class="math inline">\(C_i=1\)</span>，圆方树上圆点 <span class="math inline">\(A_i\)</span> 到圆点 <span class="math inline">\(B_i\)</span> 的简单路径经过至少一个方点。</li>
</ul>
<p>若我们只取出 <span class="math inline">\(C_i=0\)</span> 的限制，将 <span class="math inline">\(A_i\)</span> 与 <span class="math inline">\(B_i\)</span> 连边，则这个图的一个生成森林一定是圆方树的一个子图。</p>
<p>于是我们可以取出该图的任意一个生成森林。若此时存在一个 <span class="math inline">\(C_i=1\)</span> 的限制，有 <span class="math inline">\(A_i\)</span> 与 <span class="math inline">\(B_i\)</span> 连通，那一定无解。</p>
<p>假设当前连通块数为 <span class="math inline">\(K\)</span>。注意到合法的 <span class="math inline">\(M\)</span> 一定是一个区间。求上界时，我们一定会使方点尽量少，所以一定是只有一个方点与每个连通块中恰好一个点连边。所以上界为 <span class="math inline">\(\frac{K(K-1)}{2}+(N-K)\)</span>。</p>
<p>通过以上构造可以得到下界不超过 <span class="math inline">\(K+(N-K)=N\)</span>。显然，<span class="math inline">\(M=N-1\)</span> 可行当且仅当不存在 <span class="math inline">\(C_i=1\)</span> 的限制。</p>
<p>注意需要特判 <span class="math inline">\(K\le 2\)</span> 的情况。</p>
<p><a href="https://atcoder.jp/contests/agc038/submissions/16927937">代码</a></p>
<h3 id="e---gachapon">E - Gachapon</h3>
<h4 id="题意-4">题意</h4>
<p>有一个生成器，每次会以 <span class="math inline">\(\frac{A_i}{S}\)</span> 的概率生成 <span class="math inline">\(0\le i &lt; N\)</span> 的整数 <span class="math inline">\(i\)</span>，其中 <span class="math inline">\(S=\sum_{i=0}^{N-1} A_i\)</span>。</p>
<p>生成器会不断生成数直到满足以下条件：</p>
<ul>
<li>对于每个 <span class="math inline">\(0\le i &lt; N\)</span>，<span class="math inline">\(i\)</span> 被生成的次数大于等于 <span class="math inline">\(B_i\)</span>。</li>
</ul>
<p>求生成器生成的数的数量的期望，对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(N\le 400,S\le 400,\sum B_i\le 400\)</span></p>
<h4 id="题解-4">题解</h4>
<p>考虑 Min-Max 容斥，转化为确定一个集合 <span class="math inline">\(T\)</span> 后，第一次满足以下条件的期望次数：</p>
<ul>
<li>存在一个 <span class="math inline">\(i\in T\)</span>，满足 <span class="math inline">\(i\)</span> 被生成的次数大于等于 <span class="math inline">\(B_i\)</span>。</li>
</ul>
<p>根据期望的线性性，第一次满足该条件的期望次数等于所有不满足该条件的状态的概率之和。</p>
<p>一个不满足该条件的状态，将生成的数按生成的顺序排列，一定可以看成一段不在 <span class="math inline">\(T\)</span> 中的数（可能为空），加上一个在 <span class="math inline">\(T\)</span> 中的数，再一段不在 <span class="math inline">\(T\)</span> 中的数，加上一个在 <span class="math inline">\(T\)</span> 中的数，最后再有一段不在 <span class="math inline">\(T\)</span> 中的数。</p>
<p>那么所有这样的状态的概率之和就可以表示成每一段的概率之和的乘积。</p>
<p>对于一段不在 <span class="math inline">\(T\)</span> 中的数，我们不关心这些数具体是什么，我们只需要关心在 <span class="math inline">\(T\)</span> 中的数具体是什么。记 <span class="math inline">\(S_T=\sum_{i\in T} A_i\)</span>，那么形如「一段不在 <span class="math inline">\(T\)</span> 中的数，加上一个在 <span class="math inline">\(T\)</span> 中的数 <span class="math inline">\(x\)</span>」的所有状态的概率之和为 <span class="math display">\[\sum_{i=0}^{\infty}\left(\frac{S-S_T}{S}\right)^i\frac{A_x}{S}=\frac{S}{S_T}\cdot \frac{A_x}{S}=\frac{A_x}{S_T}\]</span></p>
<p>假设确定了所有 <span class="math inline">\(T\)</span> 中的数的出现次数 <span class="math inline">\(c_i\ (0\le c_i &lt; B_i)\)</span>，那么所有强制以 <span class="math inline">\(T\)</span> 中元素结尾的状态的概率之和，就是这些段的排列方案数乘上每一段的概率之和的乘积，即为 <span class="math display">\[\frac{(\sum c_i)!}{\prod c_i!}\cdot \prod_{i\in T}\left(\frac{A_i}{S_T}\right)^{c_i}\]</span></p>
<p>而不强制 <span class="math inline">\(T\)</span> 中元素结尾的状态的概率之和还要再乘上最后「一段不在 <span class="math inline">\(T\)</span> 中的数」的概率之和，即乘上 <span class="math display">\[\sum_{i=0}^{\infty}\left(\frac{S-S_T}{S}\right)^i=\frac{S}{S_T}\]</span></p>
<p>于是我们就可以 DP 了，只需要在 DP 状态中记录 <span class="math inline">\(S_T\)</span> 和 <span class="math inline">\(\sum c_i\)</span> 即可。注意要把容斥系数 <span class="math inline">\((-1)^{|T|-1}\)</span> 也 DP 进去。</p>
<p>时间复杂度 <span class="math inline">\(O(S(\sum B_i)^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc038/submissions/16936986">代码</a></p>
<h3 id="f---two-permutations">F - Two Permutations</h3>
<h4 id="题意-5">题意</h4>
<p>有两个 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(N-1\)</span> 的排列 <span class="math inline">\(P_0,P_1,\ldots,P_{N-1}\)</span>，<span class="math inline">\(Q_0,Q_1,\ldots,Q_{N-1}\)</span>。</p>
<p>求满足以下条件的两个排列 <span class="math inline">\(A,B\)</span> 的最大距离：</p>
<ul>
<li>对于所有 <span class="math inline">\(0\le i &lt; N\)</span>，<span class="math inline">\(A_i=i\)</span> 或 <span class="math inline">\(A_i=P_i\)</span>；</li>
<li>对于所有 <span class="math inline">\(0\le i &lt; N\)</span>，<span class="math inline">\(B_i=i\)</span> 或 <span class="math inline">\(B_i=Q_i\)</span>。</li>
</ul>
<p>两个排列 <span class="math inline">\(A,B\)</span> 的距离定义为 <span class="math inline">\(A_i\ne B_i\)</span> 的 <span class="math inline">\(i\)</span> 的数量。</p>
<p><span class="math inline">\(N\le 10^5\)</span></p>
<h4 id="题解-5">题解</h4>
<p>我们可以把问题转化为最小化 <span class="math inline">\(A_i=B_i\)</span> 的 <span class="math inline">\(i\)</span> 的数量。</p>
<p>我们先置 <span class="math inline">\(A_i=i,B_i=i\)</span>，然后相当于对于 <span class="math inline">\(P,Q\)</span> 的每个置换环，要么不变（即 <span class="math inline">\(A_i=i\)</span> 或 <span class="math inline">\(B_i=i\)</span>），要么在 <span class="math inline">\(A\)</span> 或 <span class="math inline">\(B\)</span> 的对应位置按环的顺序向前旋转一格（即 <span class="math inline">\(A_i=P_i\)</span> 或 <span class="math inline">\(B_i=Q_i\)</span>）。</p>
<p>分若干种情况讨论：</p>
<ul>
<li><span class="math inline">\(P_i=i,Q_i=i\)</span>，则一定有 <span class="math inline">\(1\)</span> 的贡献；</li>
<li><span class="math inline">\(P_i=i,Q_i\ne i\)</span>，则此时若 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(Q\)</span> 中所在的环没有旋转，即 <span class="math inline">\(B_i=i\)</span>，那么会产生 <span class="math inline">\(1\)</span> 的贡献；</li>
<li><span class="math inline">\(P_i\ne i,Q_i=i\)</span>，与上一种情况类似；</li>
<li><span class="math inline">\(P_i\ne i,Q_i\ne i\)</span> 且 <span class="math inline">\(P_i\ne Q_i\)</span>，此时若 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(Q\)</span> 中对应的环都没有旋转，则有 <span class="math inline">\(1\)</span> 的贡献；</li>
<li><span class="math inline">\(P_i\ne i,Q_i\ne i\)</span> 且 <span class="math inline">\(P_i=Q_i\)</span>，此时若 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(Q\)</span> 中对应的环都没有旋转或者都旋转了，则有 <span class="math inline">\(1\)</span> 的贡献。</li>
</ul>
<p>考虑建立一个最小割模型，将每个环看成一个点，对于排列 <span class="math inline">\(P\)</span> 的每个环，若在 <span class="math inline">\(S\)</span> 集合则旋转了，在 <span class="math inline">\(T\)</span> 集合则不旋转；对于排列 <span class="math inline">\(Q\)</span> 中的每个环，若在 <span class="math inline">\(T\)</span> 集合则旋转了，在 <span class="math inline">\(S\)</span> 集合则不旋转。对于上面的每种情况：</p>
<ul>
<li><span class="math inline">\(P_i=i,Q_i=i\)</span>，答案直接加 <span class="math inline">\(1\)</span> 即可；</li>
<li><span class="math inline">\(P_i=i,Q_i\ne i\)</span>，<span class="math inline">\(i\)</span> 在 <span class="math inline">\(Q\)</span> 中的环向 <span class="math inline">\(T\)</span> 连边权为 <span class="math inline">\(1\)</span> 的边；</li>
<li><span class="math inline">\(P_i\ne i,Q_i=i\)</span>，<span class="math inline">\(S\)</span> 向 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(P\)</span> 中的环连边权为 <span class="math inline">\(1\)</span> 的边；</li>
<li><span class="math inline">\(P_i\ne i,Q_i\ne i\)</span> 且 <span class="math inline">\(P_i\ne Q_i\)</span>，<span class="math inline">\(i\)</span> 在 <span class="math inline">\(Q\)</span> 中的环向 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(P\)</span> 中的环连边权为 <span class="math inline">\(1\)</span> 的边；</li>
<li><span class="math inline">\(P_i\ne i,Q_i\ne i\)</span> 且 <span class="math inline">\(P_i=Q_i\)</span>，<span class="math inline">\(i\)</span> 在 <span class="math inline">\(Q\)</span> 中的环与 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(P\)</span> 中的环双向连边权为 <span class="math inline">\(1\)</span> 的边。</li>
</ul>
<p>直接跑 Dinic 即可，由于图是二分图，复杂度可以证明是 <span class="math inline">\(O(M\sqrt{N})\)</span> 的。由于 <span class="math inline">\(M=O(N)\)</span>，所以总复杂度为 <span class="math inline">\(O(N\sqrt{N})\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc038/submissions/16932295">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>单调队列</tag>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
        <tag>Min-Max容斥</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 039 题解</title>
    <url>/atcoder-agc039/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc039">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---connection-and-disconnection">A - Connection and Disconnection</h3>
<h4 id="题意">题意</h4>
<p>给定字符串 <span class="math inline">\(S\)</span> 和一个整数 <span class="math inline">\(k\)</span>，令 <span class="math inline">\(T\)</span> 为将 <span class="math inline">\(S\)</span> 复制 <span class="math inline">\(k\)</span> 份依次拼接得到的字符串。</p>
<p>求最少需要改变 <span class="math inline">\(T\)</span> 中的几个字符使得 <span class="math inline">\(T\)</span> 中任意两个相邻的字符不同。</p>
<p><span class="math inline">\(|S|\le 100,k\le 10^9\)</span></p>
<h4 id="题解">题解</h4>
<p>考虑 <span class="math inline">\(k=1\)</span> 时如何求答案。设字符相同的连续段长度依次为 <span class="math inline">\(l_1,l_2,\ldots,l_m\)</span>，那么答案为 <span class="math inline">\(\sum\limits_{i=1}^{m} \lfloor\frac{l_i}{2}\rfloor\)</span>。</p>
<p><span class="math inline">\(k&gt;1\)</span> 时只要特殊处理一下首尾的两个连续段字符相同的情况。</p>
<p>时间复杂度 <span class="math inline">\(O(|S|)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc039/submissions/16792821">代码</a></p>
<h3 id="b---graph-partition">B - Graph Partition</h3>
<h4 id="题意-1">题意</h4>
<p>给定一个 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的简单无向连通图。</p>
<p>判断是否将图分成若干层，使得任意一条边连接的点在相邻两层（不能是同一层）。若可行，求最大层数。</p>
<p><span class="math inline">\(n\le 200\)</span></p>
<h4 id="题解-1">题解</h4>
<p>有解的充要条件是没有奇环。</p>
<p>我们钦定一个点 <span class="math inline">\(u\)</span> 在第一层，那么剩下点的分层方式一定是按 BFS 树分。具体证明可以根据 BFS 树的性质进行证明。</p>
<p>时间复杂度 <span class="math inline">\(O(N^3)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc039/submissions/16792993">代码</a></p>
<h3 id="c---division-by-two-with-something">C - Division by Two with Something</h3>
<h4 id="题意-2">题意</h4>
<p>给定一个整数 <span class="math inline">\(n\)</span> 以及一个 <span class="math inline">\(n\)</span> 位二进制数 <span class="math inline">\(X\)</span>，求对于 <span class="math inline">\(0\le k\le X\)</span>，执行若干次（不为 <span class="math inline">\(0\)</span> 次）以下操作第一次变回原来的 <span class="math inline">\(k\)</span> 的操作之和：</p>
<ul>
<li>若 <span class="math inline">\(k\)</span> 是奇数，则减 <span class="math inline">\(1\)</span> 后除以 <span class="math inline">\(2\)</span>；若 <span class="math inline">\(k\)</span> 是偶数，则除以 <span class="math inline">\(2\)</span> 后加 <span class="math inline">\(2^{n-1}\)</span>。</li>
</ul>
<p>对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(n\le 2\times 10^5\)</span></p>
<h4 id="题解-2">题解</h4>
<p>先不考虑 <span class="math inline">\(X\)</span> 的限制。</p>
<p>执行题目中的一次操作相当于把最后一位取反后放到最前面。而执行不超过 <span class="math inline">\(n\)</span> 次操作相当于把一段后缀取反后放到最前面。</p>
<p>即若把操作的数的二进制表示从高位到低位看成一个字符串 <span class="math inline">\(S\)</span>，我们要求最小的 <span class="math inline">\(p\)</span> 使得 <span class="math inline">\(\operatorname{not}(S[n-p+1,n])+S[1,n-p]=S\)</span>。注意到若操作次数大于 <span class="math inline">\(n\)</span>，条件与上述条件相同，所以若不存在这样的 <span class="math inline">\(p\)</span> 那么答案一定是 <span class="math inline">\(2n\)</span>。</p>
<p>发现满足上述条件的字符串一定是由一个长度为 <span class="math inline">\(d\ (d\mid n,d &lt; n)\)</span> 的字符串每次取反加入到 <span class="math inline">\(S\)</span> 中，执行 <span class="math inline">\(\frac{n}{d}\)</span> 次后得到的结果。如 <span class="math inline">\(n=9,d=3\)</span> 时，可以构造出形如 <span class="math inline">\(000111000,001110001\)</span> 的字符串。而这样构造得到的字符串一定有最小的 <span class="math inline">\(p=2d\)</span>。</p>
<p>于是考虑枚举 <span class="math inline">\(d\)</span>，那么方案数为 <span class="math inline">\(2^d\)</span>，操作次数为 <span class="math inline">\(2d\)</span>，对答案的贡献为 <span class="math inline">\(2^d\times 2d\)</span>。</p>
<p>可是这样做会有问题，例如 <span class="math inline">\(n=9,d=3\)</span> 时会构造出 <span class="math inline">\(010101010\)</span> 这样的字符串，但这样的字符串的 <span class="math inline">\(p\)</span> 应为 <span class="math inline">\(2\)</span>，应该在 <span class="math inline">\(d=1\)</span> 时被计算。所以容斥即可。</p>
<p>有 <span class="math inline">\(X\)</span> 的限制时同理，前 <span class="math inline">\(d\)</span> 位小于 <span class="math inline">\(X\)</span> 的前 <span class="math inline">\(d\)</span> 位时方案数就是 <span class="math inline">\(X\)</span> 的前 <span class="math inline">\(d\)</span> 位，等于时只有一种，直接构造出字符串判断是否小于等于 <span class="math inline">\(X\)</span> 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(d(n)n)\)</span>，其中 <span class="math inline">\(d(n)\)</span> 表示 <span class="math inline">\(n\)</span> 的因子数量。</p>
<p><a href="https://atcoder.jp/contests/agc039/submissions/16793650">代码</a></p>
<h3 id="d---incenters">D - Incenters</h3>
<h4 id="题意-3">题意</h4>
<p>给定单位圆上的 <span class="math inline">\(N\)</span> 个点，求随机选择三个不同的点形成的三角形的内心的坐标的期望。</p>
<p><span class="math inline">\(N\le 3000\)</span></p>
<h4 id="题解-3">题解</h4>
<p>假设三角形的三个顶点为 <span class="math inline">\(A,B,C\)</span>，我们可以得到 <span class="math inline">\(\angle A,\angle B,\angle C\)</span> 的角平分线与圆的交点，分别记做 <span class="math inline">\(A&#39;,B&#39;,C&#39;\)</span>。根据圆心角、圆周角的相关性质可以得到 <span class="math inline">\(A&#39;,B&#39;,C&#39;\)</span> 分别是弧 <span class="math inline">\(BC,CA,AB\)</span> 的中点。可以根据这一性质继而证明 <span class="math inline">\(\triangle ABC\)</span> 的内心与 <span class="math inline">\(\triangle A&#39;B&#39;C&#39;\)</span> 的垂心重合。</p>
<p>另外，根据欧拉线的相关性质，有三角形的重心 <span class="math inline">\(G\)</span> 在外心 <span class="math inline">\(O\)</span> 和垂心 <span class="math inline">\(H\)</span> 的连线段上，且 <span class="math inline">\(OH=3OG\)</span>，即 <span class="math inline">\(\overrightarrow{OH}=3\overrightarrow{OG}\)</span>。</p>
<p>于是我们把垂心的计算转化成了重心的计算。</p>
<p>三个点 <span class="math inline">\(A&#39;(x_1,y_1),B&#39;(x_2,y_2),C&#39;(x_3,y_3)\)</span> 形成的三角形的重心为 <span class="math inline">\((\frac{x_1+x_2+x_3}{3},\frac{y_1+y_2+y_3}{3})\)</span>。此题由于 <span class="math inline">\(A&#39;,B&#39;,C&#39;\)</span> 都在单位圆上，外心为原点，所以垂心即为 <span class="math inline">\((x_1+x_2+x_3,y_1+y_2+y_3)\)</span>。</p>
<p>于是我们可以枚举 <span class="math inline">\(N\)</span> 个点之间两两形成的弧，求出该弧的中点对答案的贡献即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc039/submissions/16794096">代码</a></p>
<h3 id="e---pairing-points">E - Pairing Points</h3>
<h4 id="题意-4">题意</h4>
<p>有 <span class="math inline">\(2N\)</span> 个点共圆，按逆时针编号 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(2N\)</span>。保证任意六个不同的点形成的三条线段不经过同一个点。</p>
<p>这些点之间有一些线段相连，你需要选出 <span class="math inline">\(N\)</span> 条线段，使得：</p>
<ul>
<li>每个点恰好属于一条选出线段。</li>
<li>若把选出的线段之间的交点看做顶点，把线段看做边，则形成一棵树。</li>
</ul>
<p>求方案数。</p>
<p><span class="math inline">\(N\le 20\)</span></p>
<h4 id="题解-4">题解</h4>
<p>首先可以枚举与 <span class="math inline">\(1\)</span> 相连的点，然后将环分成两部分。</p>
<p>令 <span class="math inline">\(f_{l_1,r_1,l_2,r_2}\)</span> 表示 <span class="math inline">\([l_1,r_1]\)</span> 与 <span class="math inline">\([l_2,r_2]\)</span> 配对（中间已经有一条线段）的方案数。跨越中间的匹配一定是在 <span class="math inline">\([l_1,r_1]\)</span> 中选一些点 <span class="math inline">\(x_1,x_2,\ldots,x_m\ (x_i &lt; x_{i+1})\)</span>，在 <span class="math inline">\([l_2,r_2]\)</span> 中选一些点 <span class="math inline">\(y_1,y_2,\ldots,y_m\ (y_i &gt; y_{i+1})\)</span>，然后 <span class="math inline">\(x_i\)</span> 与 <span class="math inline">\(y_i\)</span> 匹配，如下图所示：</p>
<p><img src="/files/agc039E.png" class="lazyload" data-srcset="/files/agc039E.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>为了防止算重和方便转移，我们再引入 <span class="math inline">\(g_{l_1,r_1,l_2,r_2}\)</span>，定义与 <span class="math inline">\(f\)</span> 类似，但是强制跨越中间的线段只能选一条。</p>
<p>那么 <span class="math inline">\(f\)</span> 的转移只需要枚举 <span class="math inline">\(x_m,y_m\)</span> 所在的区间即可：</p>
<p><span class="math display">\[f_{l_1,r_1,l_2,r_2}=\sum_{i,j} f_{l_1,i,j,r_1}\cdot g_{i+1,r_1,l_2,j-1}\]</span></p>
<p><span class="math inline">\(g\)</span> 的转移则只需要枚举匹配边即可：</p>
<p><span class="math display">\[g_{l_1,r_1,l_2,r_2}=\sum_{(i,j)\in E} f_{l_1,i-1,i+1,r_1}\cdot f_{l_2,j-1,j+1,r_2}\]</span></p>
<p>时间复杂度 <span class="math inline">\(O(N^6)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc039/submissions/16810909">代码</a></p>
<h3 id="f---min-product-sum">F - Min Product Sum</h3>
<h4 id="题意-5">题意</h4>
<p>你需要在一个 <span class="math inline">\(N\times M\)</span> 的网格的每个格子中填上 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(K\)</span> 的一个整数。</p>
<p>定义一个格子的权值为所在的行和所在的列中元素最小值。</p>
<p>定义一个方案的权值为所有格子的权值的乘积。</p>
<p>求所有填数方案的权值之和，对给定的大质数 <span class="math inline">\(P\)</span> 取模。</p>
<p><span class="math inline">\(N,M,K\le 100\)</span>。</p>
<h4 id="题解-5">题解</h4>
<p>假设我们知道了每行的最小值 <span class="math inline">\(r_i\)</span> 和每列的最小值 <span class="math inline">\(c_j\)</span>，则答案即为 <span class="math display">\[\prod_{i=1}^{N}\prod_{j=1}^{M}\min(r_i,c_j)\]</span></p>
<p>而对于方案数，假设我们只考虑 <span class="math inline">\(a_{i,j}\ge r_i\)</span> 和 <span class="math inline">\(a_{i,j}\ge c_j\)</span> 的限制，则方案数为 <span class="math display">\[\prod_{i=1}^{N}\prod_{j=1}^{M}(K-\max(r_i,c_j)+1)\]</span></p>
<p>为了强制取到最小值，只需要容斥即可，即强制一些行一些列大于钦定的最小值后计算即可。</p>
<p>于是我们可以 DP。令 <span class="math inline">\(f_{k,i,j}\)</span> 表示填了 <span class="math inline">\(r_i,c_j\)</span> 中小于等于 <span class="math inline">\(k\)</span> 的值，且已经填的行数为 <span class="math inline">\(i\)</span>，列数为 <span class="math inline">\(j\)</span> 时已填的位置对答案的贡献。</p>
<p>转移需要枚举加入的不被容斥的行数、不被容斥的列数、容斥的行数、容斥的列数，一起枚举复杂度过高，只要依次枚举，分四次转移即可。</p>
<p>时间复杂度 <span class="math inline">\(O(KNM(N+M))\)</span>，有点略微卡常。</p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>图论</tag>
        <tag>贪心</tag>
        <tag>BFS</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 040 题解</title>
    <url>/atcoder-agc040/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc040">比赛地址</a></p>
<span id="more"></span>
<h3 id="a--">A - &gt;&lt;</h3>
<h4 id="题意">题意</h4>
<p>给定一个长度为 <span class="math inline">\(N-1\)</span> 的只包含 <code>&lt;</code> 和 <code>&gt;</code> 的字符串 <span class="math inline">\(S\)</span>。</p>
<p>一个非负整数序列 <span class="math inline">\(a_1,a_2,\ldots,a_N\)</span> 被称为好的当且仅当满足以下条件：</p>
<ul>
<li>若 <span class="math inline">\(S_i\)</span> 是 <code>&lt;</code>，则有 <span class="math inline">\(a_i&lt;a_{i+1}\)</span>；</li>
<li>若 <span class="math inline">\(S_i\)</span> 是 <code>&gt;</code>，则有 <span class="math inline">\(a_i&gt;a_{i+1}\)</span>。</li>
</ul>
<p>求一个好的序列的元素之和的最小值。</p>
<p><span class="math inline">\(N\le 5\times 10^5\)</span></p>
<h4 id="题解">题解</h4>
<p>显然 <span class="math inline">\(a_i\)</span> 的下界为左边连续 <code>&lt;</code> 的数量与右边连续 <code>&gt;</code> 的数量的较大值。</p>
<p>当 <span class="math inline">\(a_i\)</span> 都取这个下界时显然满足条件。</p>
<p>所以直接求出 <span class="math inline">\(a_i\)</span> 后计算即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc040/submissions/16774949">代码</a></p>
<h3 id="b---two-contests">B - Two Contests</h3>
<h4 id="题意-1">题意</h4>
<p>给定 <span class="math inline">\(N\)</span> 个区间 <span class="math inline">\([l_i,r_i]\)</span>，将他们分成非空的两组。定义一个区间的权值为这个区间中包含的整点数量，定义一组区间的权值为这组区间的交的权值。</p>
<p>求两组区间的权值之和的最大值。</p>
<p><span class="math inline">\(N\le 10^5\)</span></p>
<h4 id="题解-1">题解</h4>
<p>不妨将所有区间右端点加 <span class="math inline">\(1\)</span>，将权值转化为区间长度。</p>
<p>首先考虑其中一组区间的交为空的情况。为了使得长度之和最大，另一组一定只有一个区间，并且是所有区间中最长的。</p>
<p>接下来考虑两组区间都非空的情况。假设第一组区间为 <span class="math inline">\(S\)</span>，那么答案式子为</p>
<p><span class="math display">\[\min_{i\in S}r_i-\max_{i\in S}l_i+\min_{i\not\in S}r_i-\max_{i\not\in S}l_i\]</span></p>
<p>令 <span class="math inline">\(R=\min r_i,L=\max l_i\)</span>，即全局右端点的最小值和全局左端点的最大值。</p>
<p>我们不妨强制 <span class="math inline">\(\min\limits_{i\in S} r_i=R\)</span>，此时又分两种情况。</p>
<p>当 <span class="math inline">\(\max\limits_{i\in S} l_i=L\)</span> 时，所有区间都可以被放入 <span class="math inline">\(S\)</span> 中。所以我们一定会尽可能地把区间放入第一组，将最长的区间放入第二组。</p>
<p>当 <span class="math inline">\(\max\limits_{i\in S} l_i\ne L\)</span> 时，考虑枚举 <span class="math inline">\(\max\limits_{i\in S} l_i=L&#39;\)</span>。由于 <span class="math inline">\(\min\limits_{i\in S}r_i=R\)</span>，是全局最小值，所以放入第一组的区间只需要满足 <span class="math inline">\(l_i\ge L&#39;\)</span> 即可。我们仍然会尽可能地把满足条件的区间都放入第一组，将其他区间放入第二组。</p>
<p>于是对于这种情况，我们只需要将区间按 <span class="math inline">\(l_i\)</span> 排序，预处理出 <span class="math inline">\(r_i\)</span> 的后缀 <span class="math inline">\(\min\)</span> 后枚举一个前缀放入第一组，可以 <span class="math inline">\(O(1)\)</span> 计算答案。</p>
<p>时间复杂度 <span class="math inline">\(O(N\log N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc040/submissions/16775135">代码</a></p>
<h3 id="c---neither-ab-nor-ba">C - Neither AB nor BA</h3>
<h4 id="题意-2">题意</h4>
<p>给定一个偶数 <span class="math inline">\(N\)</span>，求通过若干次以下操作可以将字符串 <span class="math inline">\(S\)</span> 变成空串的，长度为 <span class="math inline">\(N\)</span> 且只包含 <code>A</code>、<code>B</code> 和 <code>C</code> 的字符串 <span class="math inline">\(S\)</span> 的数量：</p>
<ul>
<li>选择 <span class="math inline">\(S\)</span> 中相邻两个字符，并将他们删去。但是不允许删除 <code>AB</code> 或 <code>BA</code>。</li>
</ul>
<p>对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(N\le 10^7\)</span></p>
<h4 id="题解-2">题解</h4>
<p>发现删除相邻两个字符有一些性质：</p>
<ul>
<li>删除的两个位置奇偶性不同；</li>
<li>删除后其余位置的奇偶性不变。</li>
</ul>
<p>于是我们可以考虑把所有奇数位的 <code>A</code> 变成 <code>B</code>，<code>B</code> 变成 <code>A</code>，这样我们的限制条件相当于变成了不能删除连续两个 <code>A</code> 或连续两个 <code>B</code>。</p>
<p>充要条件是 <code>A</code> 和 <code>B</code> 的数量都不超过 <span class="math inline">\(\frac{N}{2}\)</span>。必要性显然，充分性可以通过每次删除多的字符证明。</p>
<p>于是用容斥计算即可。时间复杂度 <span class="math inline">\(O(N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc040/submissions/16775651">代码</a></p>
<h3 id="d---balance-beam">D - Balance Beam</h3>
<h4 id="题意-3">题意</h4>
<p>有 <span class="math inline">\(n\)</span> 条线段，每条线段长度都为 <span class="math inline">\(1\)</span>。在第 <span class="math inline">\(i\)</span> 条线段上，A 的速度为 <span class="math inline">\(\frac{1}{a_i}\)</span>，B 的速度为 <span class="math inline">\(\frac{1}{b_i}\)</span>。</p>
<p>A 会将 <span class="math inline">\(n\)</span> 条线段按他想要的顺序排列形成一条长的线段，并以最左边的点作为起点。</p>
<p>然后 B 会在这条长度为 <span class="math inline">\(n\)</span> 的线段上等概率随机一个实数点作为起点。</p>
<p>A 获胜的条件是，A 和 B 同时出发后，按给定速度行走，A 能在 B 到达最右边之前的某个时刻追到 B。</p>
<p>求 A 的最大胜率。以最简分数形式给出。</p>
<p><span class="math inline">\(n\le 10^5\)</span></p>
<h4 id="题解-3">题解</h4>
<p>假设已经固定了线段的顺序，显然能使 A 获胜的点一定是一个前缀。</p>
<p>若我们以距最左边点的距离为 <span class="math inline">\(x\)</span> 坐标，时间为 <span class="math inline">\(y\)</span> 坐标，可以得到两条折线，其中 A 折线的终点为 <span class="math inline">\((n,S)\)</span>，其中 <span class="math inline">\(S=\sum a_i\)</span>。</p>
<p>为了求出最远的能使 A 获胜的点，我们将 B 折线从 <span class="math inline">\(x\)</span> 轴下方向上移，直到与 A 折线有交点。此时记 B 折线与 <span class="math inline">\(x\)</span> 轴的交点为 <span class="math inline">\((p,0)\)</span>，那么 <span class="math inline">\(p\)</span> 就是最远能使 A 获胜的点。</p>
<p>我们考虑一条新的折线 C，在 A 与 B 的交点左边取折线 B，右边取折线 A，那么 C 是一条从 <span class="math inline">\((p,0)\)</span> 开始到达 <span class="math inline">\((n,S)\)</span> 的折线。注意到每个方案都可以对应这样的一条折线，所以我们接下来考虑所有这样的折线。</p>
<p>为了使 <span class="math inline">\(p\)</span> 尽量大，我们一定会让折线 C 尽量“陡峭”。令 <span class="math inline">\(k\)</span> 为包含 <span class="math inline">\(p\)</span> 的线段，在 C 经过的线段中，除 <span class="math inline">\(k\)</span> 的斜率为 <span class="math inline">\(b_k\)</span> 以外，斜率上界为 <span class="math inline">\(\max(a_i,b_i)\)</span>。</p>
<p>事实上，我们可以达到这一上界。只要将 <span class="math inline">\(a_i &lt; b_i\)</span> 的线段放在折线 A 与 B 的交点前面，<span class="math inline">\(a_i \ge b_i\)</span> 的线段放在后面即可。</p>
<p>于是我们考虑枚举 <span class="math inline">\(k\)</span>，然后按 <span class="math inline">\(\max(a_i,b_i)\)</span> 从大到小依次加入线段，直到 <span class="math inline">\(b_k+\sum \max(a_i,b_i)\ge S\)</span>。这可以通过预处理前缀和实现。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc040/submissions/16778188">代码</a></p>
<h3 id="e---prefix-suffix-addition">E - Prefix Suffix Addition</h3>
<h4 id="题意-4">题意</h4>
<p>有一个初始为 <span class="math inline">\(0\)</span> 的序列 <span class="math inline">\(x_1,\ldots,x_n\)</span>。</p>
<p>你可以执行若干次以下操作：</p>
<ul>
<li>选择一个 <span class="math inline">\(k\ (1\le k\le n)\)</span> 和一个不降的非负整数序列 <span class="math inline">\(c_1,\ldots,c_k\)</span>，执行 <span class="math inline">\(x_i\gets x_i+c_i\)</span>。</li>
<li>选择一个 <span class="math inline">\(k\ (1\le k\le n)\)</span> 和一个不增的非负整数序列 <span class="math inline">\(c_1,\ldots,c_k\)</span>，执行 <span class="math inline">\(x_{n-k+i}\gets x_{n-k+i}+c_i\)</span>。</li>
</ul>
<p>求使得 <span class="math inline">\(x_i=a_i\)</span> 的最少操作次数。</p>
<p><span class="math inline">\(n\le 2\times 10^5\)</span></p>
<h4 id="题解-4">题解</h4>
<p>对于两次前缀加操作，若非零位置有交，一定可以通过调整仍然满足条件，并且不变劣。后缀加同理。</p>
<p>于是问题转化成了求两个序列 <span class="math inline">\(\{x_i\},\{y_i\}\)</span>，满足：</p>
<ul>
<li><span class="math inline">\(x_0=y_0=x_{n+1}=y_{n+1}=0\)</span></li>
<li><span class="math inline">\(x_i,y_i\ge 0\)</span></li>
<li><span class="math inline">\(x_i+y_i=a_i\)</span></li>
</ul>
<p>最小化 <span class="math inline">\(\sum [x_i&gt;x_{i+1}]+[y_i&lt;y_{i+1}]\)</span>。</p>
<p>令 <span class="math inline">\(f_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 个数，<span class="math inline">\(x_i=j\)</span> 时上式的最小值。对于每个 <span class="math inline">\(i\)</span>，有性质：</p>
<ul>
<li><span class="math inline">\(f_{i,j}\)</span> 单调不增；</li>
<li><span class="math inline">\(0\le f_{i,0}-f_{i,a_i}\le 2\)</span>。</li>
</ul>
<p>于是我们记录两个分界点，每次二分两个分界点进行转移即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc040/submissions/16781538">代码</a></p>
<h3 id="f---two-pieces">F - Two Pieces</h3>
<h4 id="题意-5">题意</h4>
<p>数轴上有两个点，一开始都在原点。每次你可以执行以下两种操作之一：</p>
<ul>
<li>选择一个点向右（正方向）移动一个单位；</li>
<li>将左边的点移动到右边的点的位置。</li>
</ul>
<p>你需要执行 <span class="math inline">\(N\)</span> 次操作。求最后左边的点在 <span class="math inline">\(A\)</span>，右边的点在 <span class="math inline">\(B\)</span> 的方案数。</p>
<p>两种方案被认为不同当且仅当某次操作之后两个点的坐标集合不同。</p>
<p><span class="math inline">\(N\le 10^7\)</span>。</p>
<h4 id="题解-5">题解</h4>
<p>考虑用 <span class="math inline">\((x,d)\)</span> 来表示一个状态，其中右边的点在 <span class="math inline">\(x\)</span>，两点距离为 <span class="math inline">\(d\)</span>。相当于有以下三种操作：</p>
<ul>
<li>将 <span class="math inline">\(x,d\)</span> 同时加 <span class="math inline">\(1\)</span>；</li>
<li>将 <span class="math inline">\(d\)</span> 减 <span class="math inline">\(1\)</span>，需要满足操作以后 <span class="math inline">\(d\ge 1\)</span>，即操作前 <span class="math inline">\(d\ge 2\)</span>；</li>
<li>将 <span class="math inline">\(d\)</span> 置 <span class="math inline">\(0\)</span>。</li>
</ul>
<p>此时由于第二种操作限制了 <span class="math inline">\(d\ge 2\)</span>，每种操作一定互不相同，所以问题转化为求操作序列数量。</p>
<p>考虑确定前两个操作序列，然后插入第三种操作。</p>
<p>注意到第一种操作恰好执行 <span class="math inline">\(B\)</span> 次，考虑枚举第二种操作的操作次数 <span class="math inline">\(k\)</span>。这个方案数可以用折线法进行计算。</p>
<p>然后考虑插入第三种操作。注意到插入后需要满足以下两个条件：</p>
<ul>
<li>最终 <span class="math inline">\(d\)</span> 到达 <span class="math inline">\(B-A\)</span>；</li>
<li>不会使第二种操作不合法。</li>
</ul>
<p>注意到将一个第三种操作插入到 <span class="math inline">\((x_i,d_i)\)</span> 后，会导致后面的 <span class="math inline">\(d_j\)</span> 都减 <span class="math inline">\(d_i\)</span>。</p>
<p>为了满足第一个条件，需要保证最后一个第三种操作满足 <span class="math inline">\(d_i=A-k\)</span>。</p>
<p>为了满足第二个条件，需要保证每个第三种操作都满足 <span class="math inline">\(d_i\)</span> 是后缀的严格最小值，即不存在 <span class="math inline">\(j\ge i\)</span> 满足 <span class="math inline">\(d_j \le d_i\)</span>。</p>
<p>也就是说，我们可以在最后一次 <span class="math inline">\(d_i=0,1,2,\ldots,A-k\)</span> 后面连续插入任意数量个第三种操作，并且需要保证 <span class="math inline">\(d_i=A-k\)</span> 后面一定有一个第三种操作。用隔板法计算即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc040/submissions/16783888">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>枚举</tag>
        <tag>二分</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 043 题解</title>
    <url>/atcoder-agc043/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc043">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---range-flip-find-route">A - Range Flip Find Route</h3>
<h4 id="题意">题意</h4>
<p>给定一个 <span class="math inline">\(H\times W\)</span> 的黑白矩阵 <span class="math inline">\(A\)</span>，你需要执行若干次以下操作使得 <span class="math inline">\((1,1)\)</span> 可以通过向下、向右且只走白色格子到达 <span class="math inline">\((H,W)\)</span>（起点、终点也必须是白色）：</p>
<ul>
<li>将一个连续子矩阵中每个格子反色。</li>
</ul>
<p>求最少操作次数。</p>
<p><span class="math inline">\(H,W\le 100\)</span></p>
<h4 id="题解">题解</h4>
<p>考虑一条 <span class="math inline">\((1,1)\)</span> 到 <span class="math inline">\((H,W)\)</span> 只向下、向右的路径。对于路径上一个黑色的连续段，由于路径是只向下、向右的，我们一定可以通过一次操作把改路径上的这个黑色连续段变成白色。</p>
<p>那么我们只需要选择黑色连续段数量最少的路径。DP 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(HW)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc043/submissions/11046672">代码</a></p>
<h3 id="b---123-triangle">B - 123 Triangle</h3>
<h4 id="题意-1">题意</h4>
<p>给定一个只有 <span class="math inline">\(1,2,3\)</span> 的序列 <span class="math inline">\(a_1,a_2,\ldots,a_n\)</span>。定义 <span class="math inline">\(x_{i,j}\)</span> 为</p>
<ul>
<li><span class="math inline">\(x_{1,j}=a_j\)</span></li>
<li><span class="math inline">\(x_{i,j}=|x_{i-1,j}-x_{i-1,j+1}|\ (i &gt; 1)\)</span></li>
</ul>
<p>求 <span class="math inline">\(x_{n,1}\)</span>。</p>
<p><span class="math inline">\(n\le 10^6\)</span></p>
<h4 id="题解-1">题解</h4>
<p>首先我们可以把 <span class="math inline">\(a_i\)</span> 都减 <span class="math inline">\(1\)</span> 变成 <span class="math inline">\(0,1,2\)</span>，显然对答案没有影响。</p>
<p>考虑只有 <span class="math inline">\(0,1\)</span> 时，显然中间过程也只有 <span class="math inline">\(0,1\)</span>。而对于两个 <span class="math inline">\(a,b\in \{0,1\}\)</span>，有 <span class="math inline">\(|a-b|=(a+b)\bmod 2\)</span>。于是 <span class="math inline">\(a_i\)</span> 对答案的贡献为 <span class="math inline">\(\begin{pmatrix}n-1\\i-1\end{pmatrix}\)</span>，在模 <span class="math inline">\(2\)</span> 意义下使用卢卡斯定理计算即可。</p>
<p>只有 <span class="math inline">\(0,2\)</span> 时，发现我们可以把 <span class="math inline">\(a_i\)</span> 都除以 <span class="math inline">\(2\)</span>，转化成只有 <span class="math inline">\(0,1\)</span> 的问题，最后乘 <span class="math inline">\(2\)</span> 即可。</p>
<p>包含 <span class="math inline">\(1\)</span> 时，在出现全 <span class="math inline">\(1\)</span> 之前，所有状态都一定包含至少一个 <span class="math inline">\(1\)</span>；而全 <span class="math inline">\(1\)</span> 之后的所有状态一定是全 <span class="math inline">\(0\)</span>。所以最终答案一定不可能是 <span class="math inline">\(2\)</span>。于是我们把 <span class="math inline">\(2\)</span> 变为 <span class="math inline">\(0\)</span> 后用只有 <span class="math inline">\(0,1\)</span> 的方法计算即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc043/submissions/11080568">代码</a></p>
<h3 id="c---giant-graph">C - Giant Graph</h3>
<h4 id="题意-2">题意</h4>
<p>给定三个 <span class="math inline">\(N\)</span> 个点分别为 <span class="math inline">\(M_1,M_2,M_3\)</span> 条边的简单无向图 <span class="math inline">\(X,Y,Z\)</span>，记每张图的点分别为 <span class="math inline">\(x_1,\ldots,x_n,y_1,\ldots,y_n,z_1,\ldots,z_n\)</span>。</p>
<p>定义 <span class="math inline">\(X\times Y\times Z\)</span> 为一个由所有 <span class="math inline">\(N^3\)</span> 个三元组 <span class="math inline">\((x_i,y_j,z_k)\)</span> 作为节点的无向图，边的生成方式如下：</p>
<ul>
<li>对于 <span class="math inline">\(X\)</span> 中的所有边 <span class="math inline">\((x_u,x_v)\)</span> 和所有 <span class="math inline">\(w,l\)</span>，<span class="math inline">\((x_u,y_w,z_l)\)</span> 和 <span class="math inline">\((x_v,y_w,z_l)\)</span> 连边；</li>
<li>对于 <span class="math inline">\(Y\)</span> 中的所有边 <span class="math inline">\((y_u,y_v)\)</span> 和所有 <span class="math inline">\(w,l\)</span>，<span class="math inline">\((x_w,y_u,z_l)\)</span> 和 <span class="math inline">\((x_w,y_v,z_l)\)</span> 连边；</li>
<li>对于 <span class="math inline">\(Z\)</span> 中的所有边 <span class="math inline">\((z_u,z_v)\)</span> 和所有 <span class="math inline">\(w,l\)</span>，<span class="math inline">\((x_w,y_l,z_u)\)</span> 和 <span class="math inline">\((x_w,y_l,z_v)\)</span> 连边。</li>
</ul>
<p>一个节点 <span class="math inline">\((x_i,y_j,z_k)\)</span> 的权值为 <span class="math inline">\((10^{18})^{i+j+k}\)</span>。</p>
<p>求 <span class="math inline">\(X\times Y\times Z\)</span> 的最大带权独立集。</p>
<p><span class="math inline">\(N\le 10^5,M_1+M_2+M_3\le 10^5\)</span>。</p>
<h4 id="题解-2">题解</h4>
<p>考虑一个 <span class="math inline">\(N^3\)</span> 的做法，我们将 <span class="math inline">\((x_i,y_j,z_k)\)</span> 按 <span class="math inline">\(i+j+k\)</span> 从大到小排序，依次加入最大独立集。这样贪心显然是对的。</p>
<p>我们可以把这个贪心写成一个类似于 DP 的形式，即 <span class="math inline">\(f_{i,j,k}\)</span> 表示 <span class="math inline">\((x_i,y_j,z_k)\)</span> 是否被选入最大独立集。<span class="math inline">\((x_i,y_j,z_k)\)</span> 被选入最大独立集当且仅当 <span class="math inline">\((x_i,y_j,z_k)\)</span> 的后继状态都没有被选入最大独立集，其中后继状态是指与 <span class="math inline">\((x_i,y_j,z_k)\)</span> 有边且权值大于该状态权值的状态。</p>
<p>观察 DP 的转移，发现这与博弈论的转移非常相似。于是我们可以把问题转化为一个游戏：</p>
<ul>
<li>有三张无向图 <span class="math inline">\(X,Y,Z\)</span>，初始时在 <span class="math inline">\(x_1,y_1,z_1\)</span> 有一颗棋子。两个人轮流操作，每次选择一张图上的棋子移动到相邻的且编号更大的节点，若无法移动则输。</li>
</ul>
<p>选入最大独立集的点恰好是所有后手必胜的状态。</p>
<p>注意到这一游戏是三个游戏的和，SG 函数值等于三个游戏的 SG 值异或的结果。而三个游戏各自的 SG 值可以 <span class="math inline">\(O(N+M)\)</span> 求出。</p>
<p>我们现在需要对所有满足 <span class="math inline">\(\operatorname{SG}(x_i)\oplus \operatorname{SG}(y_j)\oplus \operatorname{SG}(z_k)=0\)</span> 的 <span class="math inline">\(i,j,k\)</span>，对 <span class="math inline">\(10^{18(i+j+k)}\)</span> 求和。</p>
<p>注意到单个游戏的 SG 函数值在 <span class="math inline">\(O(\sqrt{M})\)</span> 级别，所以我们枚举其中两个 SG 值就可以唯一确定另一个。时间复杂度 <span class="math inline">\(O(N+M)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc043/submissions/16608405">代码</a></p>
<h3 id="d---merge-triplets">D - Merge Triplets</h3>
<h4 id="题意-3">题意</h4>
<p>求可以通过以下方式构造的本质不同的 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(3n\)</span> 的排列 <span class="math inline">\(P\)</span> 的数量：</p>
<ul>
<li>构造 <span class="math inline">\(N\)</span> 个长度为 <span class="math inline">\(3\)</span> 的序列 <span class="math inline">\(A_1,A_2,\ldots,A_n\)</span>，满足 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(3n\)</span> 的每个数恰好出现一次。</li>
<li>求出所有非空序列第一个元素的最小值 <span class="math inline">\(x\)</span>，将 <span class="math inline">\(x\)</span> 从序列中删去，加入 <span class="math inline">\(P\)</span> 的末尾。</li>
</ul>
<p><span class="math inline">\(n\le 2000\)</span></p>
<h4 id="题解-3">题解</h4>
<p>考虑对于一个序列 <span class="math inline">\(x_1,x_2,x_3\)</span>，若 <span class="math inline">\(x_1 &gt; x_2\)</span>，则选了 <span class="math inline">\(x_1\)</span> 以后一定会立刻选 <span class="math inline">\(x_2\)</span>；其他两对类似。</p>
<p>于是我们可以将这样的一个序列分成若干小块，每个小块满足块首元素是块内最大值，并且满足块首元素递增。</p>
<p>由于我们保证了单个序列中块首元素递增，那么最终排列一定是所有小块按块首元素递增排列的结果。</p>
<p>这就意味着，对于一个合法排列，我们一定可以把该排列分成若干块，满足：</p>
<ul>
<li>每块元素数量不超过 <span class="math inline">\(3\)</span>；</li>
<li>块首元素是块内最大值；</li>
<li>块首元素递增排列。</li>
</ul>
<p>但是满足以上条件的排列不一定合法，因为不一定能还原出原来的 <span class="math inline">\(n\)</span> 个序列。</p>
<p>但是我们发现，单个序列的分块方式一定只有 <span class="math inline">\(3;1,2;2,1;1,1,1\)</span> 四种，可以发现 <span class="math inline">\(2\)</span> 的数量一定不超过 <span class="math inline">\(1\)</span> 的数量。同时我们发现，在满足以上三个条件的情况下，只要满足该条件，一定可以构造出原来的 <span class="math inline">\(n\)</span> 个序列。</p>
<p>所以我们只要在上述三个条件的基础上加上这个条件就构成了一个排列合法的充要条件。</p>
<p>假设块大小依次为 <span class="math inline">\(a_1,a_2,\ldots,a_k\)</span>，我们考虑计算排列合法的概率。我们发现我们需要保证第 <span class="math inline">\(k\)</span> 块的块首元素是整个排列的最大值，而每个位置成为排列最大值的概率是相同的，所以概率为 <span class="math inline">\(\frac{1}{n}\)</span>。然后我们发现剩下的位置形成的排列仍然是等概率的，所以我们可以把它变成一个 <span class="math inline">\(n-a_k\)</span> 的子问题。于是，合法的概率为 <span class="math display">\[\prod_{i=1}^{k}\frac{1}{\sum\limits_{j=1}^{i}a_j}\]</span></p>
<p>排列数量只要再乘上 <span class="math inline">\(n!\)</span> 即可。</p>
<p>于是我们就可以 DP 了。用 <span class="math inline">\(f_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 个位置，<span class="math inline">\(1\)</span> 的数量与 <span class="math inline">\(2\)</span> 的数量的差为 <span class="math inline">\(j\)</span>。转移只要考虑下一块长度即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc043/submissions/16613074">代码</a></p>
<h3 id="e---topology">E - Topology</h3>
<h4 id="题意-4">题意</h4>
<p>平面上有 <span class="math inline">\(n\)</span> 个点，第 <span class="math inline">\(i\ (0\le i &lt; n)\)</span> 个点在 <span class="math inline">\((i+0.5,0.5)\)</span>。对于这 <span class="math inline">\(n\)</span> 个点的每一个子集 <span class="math inline">\(S\)</span> 都给出了 <span class="math inline">\(A_S\in \{0,1\}\)</span>。</p>
<p>你需要构造一个闭合曲线 <span class="math inline">\(C\)</span> 满足对于所有 <span class="math inline">\(n\)</span> 个点的子集 <span class="math inline">\(S\)</span>，都有：</p>
<ul>
<li><span class="math inline">\(C\)</span> 能在不经过点集 <span class="math inline">\(S\)</span> 的情况下连续移动到 <span class="math inline">\(x\)</span> 轴下方当且仅当 <span class="math inline">\(A_S=1\)</span>。</li>
</ul>
<p>对「闭合曲线」、「不经过点集 <span class="math inline">\(S\)</span> 的连续移动」的形式化定义以及输出方式参见原题。</p>
<p><span class="math inline">\(n\le 8\)</span></p>
<h4 id="题解-4">题解</h4>
<p>如果存在一个集合 <span class="math inline">\(S\)</span> 满足 <span class="math inline">\(A_S=1\)</span> 但存在它的一个子集 <span class="math inline">\(S&#39;\)</span> 满足 <span class="math inline">\(A_{S&#39;}=0\)</span>，那么一定不合法。我们可以通过构造证明其余情况一定合法。</p>
<p>考虑从第 <span class="math inline">\(i\)</span> 个点向上射出一条射线 <span class="math inline">\(u_i\)</span>，向下射出一条射线 <span class="math inline">\(d_i\)</span>。</p>
<p>于是我们可以把一条曲线依次经过的射线编号顺次连接生成一个字符串，同样我们也可以根据这样的字符串生成一条曲线。</p>
<p>如样例 2 中的曲线在 <span class="math inline">\(S=\{0,1\}\)</span> 时可以记为 <span class="math inline">\(d_1u_1u_0d_0\)</span>。</p>
<p>我们可以发现曲线能移动到 <span class="math inline">\(x\)</span> 轴下方当且仅当生成的字符串满足：</p>
<ul>
<li>你可以通过不断删除连续两个相同的字符使得字符串成为空串。</li>
</ul>
<p>接下来我们考虑 <span class="math inline">\(A=11\ldots 110\)</span> 的情况，即只有 <span class="math inline">\(S\)</span> 为全集时不能移动到 <span class="math inline">\(x\)</span> 轴下方。我们可以递归地构造这样的字符串，记为 <span class="math inline">\(a_n\)</span>：</p>
<ul>
<li>当 <span class="math inline">\(n=1\)</span> 时，<span class="math inline">\(a_n=u_0d_0\)</span>。</li>
<li>当 <span class="math inline">\(n\ge 2\)</span> 时，令 <span class="math inline">\(s\)</span> 为 <span class="math inline">\(a_{n-1}\)</span> 中所有字符的下标加 <span class="math inline">\(1\)</span> 得到的字符串，构造 <span class="math inline">\(a_n=u_0su_0d_0s^{-1}d_0\)</span>，其中 <span class="math inline">\(s^{-1}\)</span> 表示 <span class="math inline">\(s\)</span> 翻转后得到的字符串。</li>
</ul>
<p>例如：</p>
<ul>
<li><span class="math inline">\(a_1=u_0d_0\)</span></li>
<li><span class="math inline">\(a_2=u_0(u_1d_1)u_0d_0(d_1u_1)d_0\)</span></li>
<li><span class="math inline">\(a_3=u_0(u_1(u_2d_2)u_1d_1(d_2u_2)d_1)u_0d_0(d_1(u_2d_2)d_1u_1(d_2u_2)u_1)d_0\)</span></li>
</ul>
<p>证明可以通过归纳证明，分别考虑 <span class="math inline">\(0\not\in S\)</span> 和 <span class="math inline">\(0\in S,\exists 1\le i &lt; n,i\not\in S\)</span> 两种情况进行证明即可。</p>
<p>对于一般情况，我们只要对于所有满足 <span class="math inline">\(A_S=0\)</span> 且对于所有 <span class="math inline">\(S&#39;\in S\)</span> 都有 <span class="math inline">\(A_{S&#39;}=1\)</span> 的集合 <span class="math inline">\(S\)</span> 进行类似构造得到的字符串拼接起来即可。</p>
<p>一个非常宽的上界是 <span class="math inline">\(4n\cdot 3^n\)</span>，可以通过。</p>
<p><a href="https://atcoder.jp/contests/agc043/submissions/16615826">代码</a></p>
<h3 id="f---jewelry-box">F - Jewelry Box</h3>
<h4 id="题意-5">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个商店，第 <span class="math inline">\(i\)</span> 个商店卖 <span class="math inline">\(K_i\)</span> 种珠宝，第 <span class="math inline">\(i\)</span> 个商店的第 <span class="math inline">\(j\)</span> 个珠宝重量为 <span class="math inline">\(S_{i,j}\)</span>，价格为 <span class="math inline">\(P_{i,j}\)</span>，数量为 <span class="math inline">\(C_{i,j}\)</span>。</p>
<p>一个珠宝盒被称为好的当且仅当满足以下条件：</p>
<ul>
<li>对于每个商店，珠宝盒中都恰好包含一颗该商店的珠宝。</li>
<li>对于所有 <span class="math inline">\(1\le i\le M\)</span>，满足珠宝盒中商店 <span class="math inline">\(V_i\)</span> 的珠宝重量小于等于商店 <span class="math inline">\(U_i\)</span> 的珠宝重量加 <span class="math inline">\(W_i\)</span>。</li>
</ul>
<p><span class="math inline">\(Q\)</span> 次询问，每次询问 <span class="math inline">\(A_i\)</span>，表示制作 <span class="math inline">\(A_i\)</span> 个好的珠宝盒的最小总价格。</p>
<p><span class="math inline">\(N,K_i\le 30,S_{i,j},M\le 50,Q\le 10^5,W_i\le 10^9,P_{i,j}\le 30,C_{i,j}\le 10^{12},A_i\le 3\times 10^{13}\)</span></p>
<h4 id="题解-5">题解</h4>
<p>首先考虑只有一组询问的情况，即询问制作 <span class="math inline">\(A\)</span> 个好的珠宝盒的最小价格。</p>
<p>假设对于每个商店我们已经选出了 <span class="math inline">\(A\)</span> 个珠宝。那么我们贪心地考虑，一定是最小的放在第一个珠宝盒内，第二小的放在第二个珠宝盒内，以此类推。</p>
<p>于是我们可以对每个商店的珠宝按重量从小到大排序，然后记 <span class="math inline">\(x_{i,j}\)</span> 为第 <span class="math inline">\(i\)</span> 个商店中前 <span class="math inline">\(j\)</span> 个物品选了几个。</p>
<p>对于一个限制 <span class="math inline">\((u,v,w)\)</span>，对于 <span class="math inline">\(1\le j\le K_v\)</span>，令 <span class="math inline">\(k\)</span> 为 <span class="math inline">\(S_{u,k}+W_i\ge S_{v,j}\)</span> 的最小的 <span class="math inline">\(k\)</span>，不存在则令 <span class="math inline">\(k=K_u+1\)</span>。那么这一限制等价于对于所有 <span class="math inline">\(j\)</span> 都满足 <span class="math inline">\(x_{v,j-1}\ge x_{u,k-1}\)</span>。</p>
<p>于是我们把问题转化成了一个线性规划问题：</p>
<ul>
<li>minimize <span class="math inline">\(\sum P_{i,j}(x_{i,j}-x_{i,j-1})\)</span></li>
<li>subject to <span class="math display">\[
\begin{cases}
x_{i,j}\ge x_{i,j-1}\\
x_{i,j}\le x_{i,j-1}+C_{i,j}\\
x_{i,0}=0\\
x_{i,K_i}=A\\
x_{u,k}\le x_{v,j}\\
x_{i,j}\ge 0
\end{cases}
\]</span></li>
</ul>
<p>注意到求价格时是相邻两项作差，那么我们无需保证 <span class="math inline">\(x_{i,0}=0,x_{i,K_i}=A\)</span>，只需要保证 <span class="math inline">\(x_{i,K_i}-x_{i,0}=A\)</span> 即可，于是可以拆成 <span class="math inline">\(x_{i,K_i}-x_{i,0}\le A\)</span> 和 <span class="math inline">\(x_{i,K_i}-x_{i,0}\ge A\)</span> 两个限制。注意到 <span class="math inline">\(x_{i,K_i}-x_{i,0} &gt; A\)</span> 时一定不优，所以我们可以前一个限制。</p>
<p>于是我们可以把问题转化成标准型：</p>
<ul>
<li>minimize <span class="math inline">\(\sum x_{i,j}(P_{i,j}-P_{i,j+1})\)</span></li>
<li>subject to <span class="math display">\[
\begin{cases}
x_{i,j}-x_{i,j-1}\ge 0\\
x_{i,j-1}-x_{i,j}\ge -C_{i,j}\\
x_{i,K_i}-x_{i,0}\ge A\\
x_{v,j}-x_{u,k}\ge 0\\
x_{i,j}\ge 0
\end{cases}
\]</span></li>
</ul>
<p>注意到系数矩阵的每行都有恰好一个 <span class="math inline">\(+1\)</span> 和一个 <span class="math inline">\(-1\)</span>，于是我们可以把问题对偶，系数矩阵的每一列都有恰好一个 <span class="math inline">\(+1\)</span> 和一个 <span class="math inline">\(-1\)</span>。</p>
<p>由于左边的和为 <span class="math inline">\(0\)</span>，右边的和也为 <span class="math inline">\(0\)</span>，而每个限制都是小于等于，那么所有限制一定都是取到等于。</p>
<p>于是我们可以根据网络流的流量守恒建立费用流模型。</p>
<p>图中的一个点对应对偶后的一个方程，也就是原问题的一个变量；图中的一条边对应对偶后的一个变量，也就是原问题的一个限制。对于原问题中 <span class="math inline">\(x-y\ge w\)</span> 的限制，则从 <span class="math inline">\(x\)</span> 向 <span class="math inline">\(y\)</span> 连一条流量为 <span class="math inline">\(\infty\)</span>，费用为 <span class="math inline">\(w\)</span> 的边；对于原问题最小化的式子中变量 <span class="math inline">\(x\)</span> 的系数 <span class="math inline">\(c\)</span>，若 <span class="math inline">\(c&gt;0\)</span>，则从源点向 <span class="math inline">\(x\)</span> 连一条流量为 <span class="math inline">\(c\)</span>，费用为 <span class="math inline">\(0\)</span> 的边，否则从 <span class="math inline">\(x\)</span> 向汇点连一条流量为 <span class="math inline">\(c\)</span>，费用为 <span class="math inline">\(0\)</span> 的边，特别地，这些边必须满流。</p>
<p>我们可以首先利用所有 <span class="math inline">\(x_{i,j}\)</span> 向 <span class="math inline">\(x_{i,j-1}\)</span> 连的 <span class="math inline">\((\infty,0)\)</span> 的边，将所有需要满流的边满流。可以发现这一定可以做到，并且流完以后得到的反向边为 <span class="math inline">\(x_{i,j-1}\)</span> 向 <span class="math inline">\(x_{i,j}\)</span> 的流量为 <span class="math inline">\(P_{i,j}\)</span>，费用为 <span class="math inline">\(0\)</span> 的边。</p>
<p>于是我们可以把源汇点去掉，只保留这些反向边，变成一个无源汇最大费用可行流的问题。</p>
<p>注意到边权与 <span class="math inline">\(A\)</span> 有关的只有 <span class="math inline">\(x_{i,K_i}\)</span> 向 <span class="math inline">\(x_{i,0}\)</span> 连的流量为 <span class="math inline">\(\infty\)</span>，费用为 <span class="math inline">\(A\)</span> 的边。考虑将所有 <span class="math inline">\(x_{i,0}\)</span> 缩成一个点 <span class="math inline">\(S\)</span>，<span class="math inline">\(x_{i,K_i}\)</span> 缩成一个点 <span class="math inline">\(T\)</span>，就只有一条 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span> 的 <span class="math inline">\((\infty,A)\)</span> 的边了。</p>
<p>为了使费用最大，每一次增广一定是从 <span class="math inline">\(S\)</span> 流到 <span class="math inline">\(T\)</span> 再经过这条费用为 <span class="math inline">\(A\)</span> 的边流回 <span class="math inline">\(S\)</span>。条件是 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 的这条增广路的费用 <span class="math inline">\(\ge -A\)</span>。</p>
<p>根据费用流每次增广的凸性，我们可以直接二分得到增广次数。</p>
<p>时间复杂度 <span class="math inline">\(O(\operatorname{MCMF}(\sum K_i,\sum K_i+\sum K_{V_i})+Q\log \sum P_{i,j})\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc043/submissions/16630601">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>网络流</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>费用流</tag>
        <tag>博弈</tag>
        <tag>Lucas定理</tag>
        <tag>SG函数</tag>
        <tag>线性规划</tag>
        <tag>对偶</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 041 题解</title>
    <url>/atcoder-agc041/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc041">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---table-tennis-training">A - Table Tennis Training</h3>
<h4 id="题意">题意</h4>
<p>有 <span class="math inline">\(n\)</span> 张桌子，编号 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span>，有两个人，一个在桌子 <span class="math inline">\(A\)</span>，另一个在桌子 <span class="math inline">\(B\)</span>。</p>
<p>每一个人每次可以向左或向右移动，但不能不动。特别地，如果在桌子 <span class="math inline">\(1\)</span>，向左移动则仍留在桌子 <span class="math inline">\(1\)</span>；如果在桌子 <span class="math inline">\(n\)</span>，向右移动则仍留在桌子 <span class="math inline">\(n\)</span>。</p>
<p>问最少多少次两个人可以移动到同一张桌子。</p>
<p><span class="math inline">\(n\le 10^{18}\)</span></p>
<h4 id="题解">题解</h4>
<p>分两种情况：</p>
<ul>
<li><span class="math inline">\(A\)</span> 与 <span class="math inline">\(B\)</span> 奇偶性相同。此时每个人往另一个人的方向移动即可。</li>
<li><span class="math inline">\(A\)</span> 与 <span class="math inline">\(B\)</span> 奇偶性不同。又分两种情况：
<ul>
<li>两个人同时向 <span class="math inline">\(1\)</span> 移动，当左边的人移动到 <span class="math inline">\(1\)</span> 时，在 <span class="math inline">\(1\)</span> 停留一次，然后向右移动；右边的人则保持向左移动。</li>
<li>两个人同时向 <span class="math inline">\(n\)</span> 移动，情况同理。</li>
</ul></li>
</ul>
<p><a href="https://atcoder.jp/contests/agc041/submissions/16659671">代码</a></p>
<h3 id="b---voting-judges">B - Voting Judges</h3>
<h4 id="题意-1">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个数 <span class="math inline">\(A_i\)</span>，执行恰好 <span class="math inline">\(M\)</span> 次操作，每次操作选择恰好 <span class="math inline">\(V\)</span> 个数加 <span class="math inline">\(1\)</span>。然后降序排列，有相同时顺序任意。</p>
<p>求有多少个数有可能能进入最终的前 <span class="math inline">\(P\)</span> 个。</p>
<p><span class="math inline">\(N\le 10^5,M\le 10^9\)</span></p>
<h4 id="题解-1">题解</h4>
<p>将 <span class="math inline">\(A_i\)</span> 从大到小排序。前 <span class="math inline">\(P\)</span> 个显然可以，考虑对于 <span class="math inline">\(P &lt; i \le N\)</span> 判断是否可以进入前 <span class="math inline">\(P\)</span> 个。</p>
<p>首先每次加 <span class="math inline">\(1\)</span> 的数中，前 <span class="math inline">\(P-1\)</span> 个一定选，<span class="math inline">\(i\)</span> 和 <span class="math inline">\(i\)</span> 之后的数也一定选，但是此时可能仍然不足 <span class="math inline">\(V\)</span> 个数。</p>
<p>此时我们每次需要选择一些中间的数补足 <span class="math inline">\(V\)</span> 个。假设还需要 <span class="math inline">\(R\)</span> 个数，则充要条件是 <span class="math display">\[\sum_{j=P}^{i-1}(A_i+M-A_j)\le MR\]</span></p>
<p>必要性显然，充分性可以通过每次选最小的 <span class="math inline">\(R\)</span> 个数证明。</p>
<p>时间复杂度瓶颈在于排序。</p>
<p><a href="https://atcoder.jp/contests/agc041/submissions/16659574">代码</a></p>
<h3 id="c---domino-quality">C - Domino Quality</h3>
<h4 id="题意-2">题意</h4>
<p>在 <span class="math inline">\(N\times N\)</span> 的网格中放一些多米诺骨牌。至少放一个骨牌，每个格子最多只能被一个骨牌覆盖，可以不被覆盖。对于网格的每一行，定义质量为覆盖该行中至少一个格子的骨牌数量。列同理。</p>
<p>构造一组方案使得所有行、列的质量相等。</p>
<p><span class="math inline">\(N\le 1000\)</span></p>
<h4 id="题解-2">题解</h4>
<p>发现 <span class="math inline">\(N=4,5,6,7\)</span> 时都可以构造出行列质量为 <span class="math inline">\(3\)</span> 的方案。于是我们在对角线上铺上这些方案即可。</p>
<p><span class="math inline">\(N=3\)</span> 的时候可以构造出质量为 <span class="math inline">\(1\)</span> 的方案，需要特判。</p>
<p><a href="https://atcoder.jp/contests/agc041/submissions/16733952">代码</a></p>
<h3 id="d---problem-scores">D - Problem Scores</h3>
<h4 id="题意-3">题意</h4>
<p>求满足以下条件的长度为 <span class="math inline">\(N\)</span> 的序列 <span class="math inline">\(A\)</span> 的数量：</p>
<ul>
<li><span class="math inline">\(1\le A_1\le A_2\le A_3\le \ldots \le A_N\le N\)</span></li>
<li>对于所有 <span class="math inline">\(1\le k &lt; N\)</span>，都满足序列 <span class="math inline">\(A\)</span> 的任意一个大小为 <span class="math inline">\(k\)</span> 的子集和严格小于任意一个大小为 <span class="math inline">\(k+1\)</span> 的子集和。</li>
</ul>
<p>对 <span class="math inline">\(M\)</span> 取模。</p>
<p><span class="math inline">\(N\le 5000,9\times 10^8 &lt; M &lt; 10^9\)</span>，<span class="math inline">\(M\)</span> 是质数。</p>
<h4 id="题解-3">题解</h4>
<p>显然只要 <span class="math inline">\(k=\lfloor\frac{n-1}{2}\rfloor\)</span> 时满足条件即可。</p>
<p>令 <span class="math inline">\(t=\sum\limits_{i=1}^{k+1} A_i-\sum\limits_{i=n-k+1}^{n}A_i\)</span>，即我们需要满足 <span class="math inline">\(t&gt;0\)</span>。</p>
<p>于是考虑将原序列差分，设为 <span class="math inline">\(x_1,x_2,\ldots,x_n\)</span>，那么对 <span class="math inline">\(t\)</span> 的贡献分别为 <span class="math display">\[w=\{1,0,-1,-2,-3,\ldots,-3,-2,-1\}\]</span></p>
<p>令 <span class="math inline">\(A=\sum\limits_{i=2}^{n}x_i,B=-\sum\limits_{i=2}^{n}w_ix_i\)</span>，则 <span class="math inline">\(B+1\le x_1\le n-A\)</span>，即贡献为 <span class="math inline">\(n-A-B\)</span>。</p>
<p>于是我们只要考虑 DP <span class="math inline">\(A+B=d\)</span> 的方案数。完全背包即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="e---balancing-network">E - Balancing Network</h3>
<h4 id="题意-4">题意</h4>
<p>一个网络中有水平的 <span class="math inline">\(n\)</span> 根导线，以及 <span class="math inline">\(m\)</span> 个竖直的平衡器。平衡器从左往右依次编号 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(m\)</span>。第 <span class="math inline">\(i\)</span> 个平衡器连接导线 <span class="math inline">\(x_i\)</span> 和 <span class="math inline">\(y_i\)</span>，其中 <span class="math inline">\(x_i &lt; y_i\)</span>。</p>
<p>你可以为每个平衡器确定一个方向，向上或向下。</p>
<p>有一个点从某根导线，所有平衡器左边的某一位置开始，向右运动，当经过第 <span class="math inline">\(i\)</span> 个平衡器时：</p>
<ul>
<li>若该点在导线 <span class="math inline">\(x_i\)</span> 且平衡器向下，则移动到导线 <span class="math inline">\(y_i\)</span> 的对应位置，继续向右运动。</li>
<li>若该点在导线 <span class="math inline">\(y_i\)</span> 且平衡器向上，则移动到导线 <span class="math inline">\(x_i\)</span> 的对应位置，继续向右运动。</li>
<li>否则保持向右运动。</li>
</ul>
<p>若从任意导线出发，最终都能到达同一根导线的无穷远处，则称该网络是均衡的，否则是不均衡的。</p>
<p>给定参数 <span class="math inline">\(T\)</span>，若 <span class="math inline">\(T=1\)</span> 你需要构造一个均衡的网络，<span class="math inline">\(T=2\)</span> 你需要构造一个不均衡的网络。</p>
<p><span class="math inline">\(n\le 5\times 10^4,m\le 10^5,T\in \{1,2\}\)</span></p>
<h4 id="题解-4">题解</h4>
<p>对于 <span class="math inline">\(T=1\)</span> 的情况，假设我们已经确定终点 <span class="math inline">\(w\)</span>，我们从后往前依次加入平衡器，同时维护 <span class="math inline">\(A_i\)</span> 表示第 <span class="math inline">\(i\)</span> 个点是否可以到达终点 <span class="math inline">\(w\)</span>。初始时 <span class="math inline">\(A_w=1\)</span>。</p>
<p>对于当前的平衡器 <span class="math inline">\((x,y)\)</span>，分四种情况：</p>
<ul>
<li><span class="math inline">\(A_x=1,A_y=1\)</span>，此时平衡器如何定向都不会改变状态。</li>
<li><span class="math inline">\(A_x=0,A_y=0\)</span>，同理不会改变状态。</li>
<li><span class="math inline">\(A_x=0,A_y=1\)</span>，此时将平衡器方向定为 <span class="math inline">\(x\to y\)</span> 可以使得 <span class="math inline">\(A_x=1\)</span>。</li>
<li><span class="math inline">\(A_x=1,A_y=0\)</span>，同理将平衡器方向定为 <span class="math inline">\(y\to x\)</span> 可以使得 <span class="math inline">\(A_y=1\)</span>。</li>
</ul>
<p>发现这是一个将 <span class="math inline">\(A_x,A_y\)</span> 都置为原来 <span class="math inline">\(A_x,A_y\)</span> 的二进制或值的过程。</p>
<p>于是我们可以用 bitset 优化。时间复杂度 <span class="math inline">\(O(\frac{nm}{w})\)</span>。</p>
<hr />
<p>对于 <span class="math inline">\(T=2\)</span> 的情况，显然 <span class="math inline">\(n\le 2\)</span> 一定无解，否则可以通过构造证明一定有解。</p>
<p>仍然考虑从后往前考虑每个平衡器的方向。</p>
<p>记录 <span class="math inline">\(P_x\)</span> 表示起点为 <span class="math inline">\(x\)</span> 时的终点，<span class="math inline">\(S_x\)</span> 表示终点为 <span class="math inline">\(x\)</span> 的起点数量。我们可以保证任意时刻 <span class="math inline">\(S_x &lt; n\)</span>。</p>
<p>对于当前平衡器 <span class="math inline">\((x,y)\)</span>，若 <span class="math inline">\(S_{P_x}=n-1\)</span>，那么如果此时将平衡器定向为 <span class="math inline">\(y\to x\)</span>，会导致 <span class="math inline">\(S_{P_x}=n\)</span>。但是因为有 <span class="math inline">\(\sum S_i=n\)</span>，所以此时有 <span class="math inline">\(S_{P_y}\le 1 &lt; n-1\)</span>，于是定向为 <span class="math inline">\(x\to y\)</span> 即可。<span class="math inline">\(S_{P_y}=n-1\)</span> 同理。</p>
<p>时间复杂度 <span class="math inline">\(O(n+m)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc041/submissions/16737690">代码</a></p>
<h3 id="f---histogram-rooks">F - Histogram Rooks</h3>
<h4 id="题意-5">题意</h4>
<p>有一个 <span class="math inline">\(n\)</span> 列的棋盘，第 <span class="math inline">\(i\)</span> 列从底向上有 <span class="math inline">\(h_i\)</span> 个格子。</p>
<p>你可以在棋盘上放一些车，使得对于棋盘上每个格子都能被某个车覆盖到。</p>
<p>一个车可以覆盖某个格子当且仅当它们在同一行或同一列，且中间的格子都存在。</p>
<p>求放置车的方案数。对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(1\le h_i\le N\le 400\)</span></p>
<h4 id="题解-5">题解</h4>
<p>一个朴素的容斥是，我们可以求出钦定 <span class="math inline">\(k\)</span> 个位置不被车覆盖，其他位置没有限制的方案数，乘上容斥系数 <span class="math inline">\((-1)^k\)</span> 即为对答案的贡献。</p>
<p>考虑建出笛卡尔树后 DP。用 <span class="math inline">\(f_{u,i}\)</span> 表示 <span class="math inline">\(u\)</span> 表示的列区间中，有 <span class="math inline">\(i\)</span> 列中有钦定不覆盖的位置时，对答案的贡献（即容斥系数乘方案数之和）。</p>
<p>转移时，先可以考虑第 <span class="math inline">\(u\)</span> 列是否有钦定不覆盖的位置将左右子树合并，然后我们在底部加入若干行。当加入一行时，假设 <span class="math inline">\(u\)</span> 表示的列区间长度为 <span class="math inline">\(L\)</span>，则转移分两种情况：</p>
<ul>
<li>当前行中没有格子被钦定。此时该行中可以任意放车而不会有影响，方案数为 <span class="math inline">\(2^{L-i}\)</span>，容斥系数为 <span class="math inline">\(1\)</span>。</li>
<li>当前行中有格子被钦定。此时该行中一定不能放车，且被钦定的格子一定是那 <span class="math inline">\(i\)</span> 列的一个子集，所以方案数为 <span class="math inline">\(1\)</span>，容斥系数为 <span class="math inline">\(\sum\limits_{k=1}^{i} (-1)^k\begin{pmatrix}i\\k\end{pmatrix}=-[i\ne 0]\)</span>。</li>
</ul>
<p>然而，这样的 DP 状态设计和转移有一个问题，我们并不能保证这 <span class="math inline">\(i\)</span> 列每一列都有被钦定的位置。</p>
<p>这仍然可以通过容斥解决。考虑加入一维 <span class="math inline">\(j\)</span> 表示 <span class="math inline">\(i\)</span> 列中有 <span class="math inline">\(j\)</span> 列不存在被钦定的位置。DP 的转移第一种不变，第二种变为选择其余 <span class="math inline">\(i-j\)</span> 列的一个子集，容斥系数变为 <span class="math inline">\(-[i\ne j]\)</span>。</p>
<p>注意到其实我们只需要在 DP 状态中记录 <span class="math inline">\(j\)</span> 是否等于 <span class="math inline">\(i\)</span>，并将容斥系数 <span class="math inline">\((-1)^j\)</span> 压入 DP 值中，而不需要记录 <span class="math inline">\(j\)</span> 的具体数值。</p>
<p>时间复杂度 <span class="math inline">\(O(N^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc041/submissions/16742677">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>容斥</tag>
        <tag>搜索</tag>
        <tag>背包</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 044 题解</title>
    <url>/atcoder-agc044/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc044">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---pay-to-win">A - Pay to Win</h3>
<h4 id="题意">题意</h4>
<p>你要通过以下操作将 <span class="math inline">\(0\)</span> 变成 <span class="math inline">\(N\)</span>：</p>
<ul>
<li>乘 <span class="math inline">\(2\)</span>，花费 <span class="math inline">\(A\)</span>；</li>
<li>乘 <span class="math inline">\(3\)</span>，花费 <span class="math inline">\(B\)</span>；</li>
<li>乘 <span class="math inline">\(5\)</span>，花费 <span class="math inline">\(C\)</span>；</li>
<li>加 <span class="math inline">\(1\)</span> 或减 <span class="math inline">\(1\)</span>，花费 <span class="math inline">\(D\)</span>。</li>
</ul>
<p>求最少操作次数。</p>
<p><span class="math inline">\(N\le 10^{18},A,B,C,D\le 10^9\)</span></p>
<h4 id="题解">题解</h4>
<p>考虑倒着做。假设当前的 <span class="math inline">\(N\)</span> 要除以 <span class="math inline">\(v\)</span>，那么一定是转移到 <span class="math inline">\(\lfloor\frac{N}{v}\rfloor\)</span> 或 <span class="math inline">\(\lceil\frac{N}{v}\rceil\)</span>。</p>
<p>注意到这样子转移遇到的状态一定是 <span class="math inline">\(\lfloor\frac{N}{2^a3^b5^c}\rfloor\)</span> 或 <span class="math inline">\(\lceil\frac{N}{2^a3^b5^c}\rceil\)</span>，所以状态数是 <span class="math inline">\(O(\log^3 N)\)</span> 的。</p>
<p>注意转移时需要考虑 <span class="math inline">\(N\to N/v\)</span> 时可能直接减的花费更小，需要与直接减的花费取 <span class="math inline">\(\min\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(\log^3 N)\)</span>，如果使用 map 则复杂度为 <span class="math inline">\(O(\log^3 N\log \log N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc044/submissions/16560685">代码</a></p>
<h3 id="b---joker">B - Joker</h3>
<h4 id="题意-1">题意</h4>
<p>有一个 <span class="math inline">\(N\times N\)</span> 的矩阵，每个位置上有一个人，编号从上到下从左到右依次是 <span class="math inline">\(1,\ldots,N^2\)</span>。</p>
<p>人会一个一个地离开（即从所在位置每次向上下左右移动直到走出矩阵），第 <span class="math inline">\(i\)</span> 个离开的人编号为 <span class="math inline">\(P_i\)</span>。</p>
<p>当一个人离开时，一条路径的权值为路径上还没有离开的人的数量。每个人会选择权值最小的路径离开。</p>
<p>求最小权值之和。</p>
<p><span class="math inline">\(N\le 500\)</span></p>
<h4 id="题解-1">题解</h4>
<p>考虑模拟这个过程，并同时维护 <span class="math inline">\(f(i,j)\)</span> 表示 <span class="math inline">\((i,j)\)</span> 走到矩阵外的最小路径权值。</p>
<p>每次当 <span class="math inline">\((x,y)\)</span> 位置的人离开后，<span class="math inline">\(f(x,y)\)</span> 减 <span class="math inline">\(1\)</span>，会连带其他位置的 <span class="math inline">\(f\)</span> 值改变。</p>
<p>但是注意到开始时 <span class="math inline">\(\sum f(i,j)\le N^3\)</span>，所以我们只要每次暴力把需要更新的 <span class="math inline">\(f\)</span> 修改即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N^3)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc044/submissions/16568410">代码</a></p>
<h3 id="c---strange-dance">C - Strange Dance</h3>
<h4 id="题意-2">题意</h4>
<p>有一个长度为 <span class="math inline">\(3^N\)</span> 的序列 <span class="math inline">\(P_0,\ldots,P_{3^N-1}\)</span>。有 <span class="math inline">\(|T|\)</span> 次操作，操作有两种：</p>
<ul>
<li><span class="math inline">\(T_i=\mathtt{R}\)</span>，对于所有 <span class="math inline">\(0\le i &lt; 3^N\)</span>，执行 <span class="math inline">\(P_i\gets (P_i+1)\bmod 3^N\)</span>。</li>
<li><span class="math inline">\(T_i=\mathtt{S}\)</span>，对于所有 <span class="math inline">\(0\le i &lt; 3^N\)</span>，将 <span class="math inline">\(P_i\)</span> 的三进制表示下的 <span class="math inline">\(1\)</span> 改成 <span class="math inline">\(2\)</span>，<span class="math inline">\(2\)</span> 改成 <span class="math inline">\(1\)</span>。</li>
</ul>
<p>求最后的序列 <span class="math inline">\(P\)</span>。</p>
<p><span class="math inline">\(N\le 12,|T|\le 2\times 10^5\)</span></p>
<h4 id="题解-2">题解</h4>
<p>考虑从低位到高位建立 Trie。</p>
<p>对于 <span class="math inline">\(\mathtt{R}\)</span> 操作，可以从 Trie 的根节点开始，将 <span class="math inline">\(0\)</span> 改成 <span class="math inline">\(1\)</span>，将 <span class="math inline">\(1\)</span> 改成 <span class="math inline">\(2\)</span>，将 <span class="math inline">\(2\)</span> 改成 <span class="math inline">\(0\)</span>，然后递归原来 <span class="math inline">\(2\)</span> 的子树即可。</p>
<p>对于 <span class="math inline">\(\mathtt{S}\)</span> 操作，可以直接在根节点打上标记，在需要递归时下传即可。</p>
<p>时间复杂度 <span class="math inline">\(O(3^N+|T|N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc044/submissions/16569045">代码</a></p>
<h3 id="d---guess-the-password">D - Guess the Password</h3>
<h4 id="题意-3">题意</h4>
<p>这是一个交互题。交互库有一个长度不超过 <span class="math inline">\(L=128\)</span> 的字符串 <span class="math inline">\(S\)</span>。你可以每次询问交互库不超过 <span class="math inline">\(Q=850\)</span> 次以下询问来得到 <span class="math inline">\(S\)</span>：</p>
<ul>
<li>给出一个长度不超过 <span class="math inline">\(L\)</span> 的字符串 <span class="math inline">\(T\)</span>，交互库会返回支持插入字符、删除字符、修改字符时 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 的最少操作次数（即编辑距离）。</li>
</ul>
<p>字符集为所有大写字母、小写字母和 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(9\)</span> 的数字。</p>
<h4 id="题解-3">题解</h4>
<p>首先我们可以通过询问形如 <span class="math inline">\(\underbrace{aa\ldots a}_{L}\)</span> 的字符串求出字符 <span class="math inline">\(a\)</span> 的出现次数，即设返回值为 <span class="math inline">\(x\)</span>，则 <span class="math inline">\(a\)</span> 的出现次数为 <span class="math inline">\(L-x\)</span>。</p>
<p>然后我们假设 <span class="math inline">\(S_1,S_2\)</span> 是 <span class="math inline">\(S\)</span> 的两个不相交的子序列，考虑如何合并成一个长度为 <span class="math inline">\(|S_1|+|S_2|\)</span> 的子序列。</p>
<p>我们可以将 <span class="math inline">\(S_2\)</span> 中的字符依次插入 <span class="math inline">\(S_1\)</span> 中，询问次数约为 <span class="math inline">\(|S_1|+|S_2|\)</span>。</p>
<p>于是我们可以对字符集分治，然后每次合并，询问次数约为 <span class="math inline">\(L\log_2 |\Sigma|\)</span>，可以通过。</p>
<p><a href="https://atcoder.jp/contests/agc044/submissions/16569827">代码</a></p>
<h3 id="e---random-pawn">E - Random Pawn</h3>
<h4 id="题意-4">题意</h4>
<p>有一个长度为 <span class="math inline">\(N\)</span> 的环，环上的点顺时针编号为 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\)</span>。</p>
<p>初始时会在所有点中等概率随机一个位置放一个棋子。</p>
<p>假设当前棋子在 <span class="math inline">\(p\)</span>，可以执行两种操作：</p>
<ul>
<li>获得 <span class="math inline">\(A_p\)</span> 的收益，结束游戏。</li>
<li>花费 <span class="math inline">\(B_p\)</span>，将棋子等概率移动到相邻两个位置之一（即各 <span class="math inline">\(\frac{1}{2}\)</span>）。</li>
</ul>
<p>求最大的期望收益，精度要求 <span class="math inline">\(10^{-10}\)</span>。</p>
<p><span class="math inline">\(N\le 2\times 10^5\)</span></p>
<h4 id="题解-4">题解</h4>
<p>如果我们到达 <span class="math inline">\(A_i\)</span> 最大的位置，那么可以直接结束游戏，所以我们可以断环成链。</p>
<p>考虑 <span class="math inline">\(B_i=0\)</span> 的情况，令 <span class="math inline">\(f_i\)</span> 为从 <span class="math inline">\(i\)</span> 出发的最大期望收益。</p>
<p>假设我们钦定到达 <span class="math inline">\(S=\{x_1,x_2,\ldots,x_k\}\ (x_i &lt; x_{i+1})\)</span> 集合中的点时结束游戏，到达其他点则继续移动，那么对于 <span class="math inline">\(i\not\in S\)</span> 的情况，有 <span class="math display">\[
f_i=\frac{f_{i-1}+f_{i+1}}{2}
\]</span> 移项后得 <span class="math display">\[f_{i+1}-f_i=f_i-f_{i-1}\]</span></p>
<p>也就是说，对于 <span class="math inline">\(u=x_j\le i\le x_{j+1}=v\)</span>，这些 <span class="math inline">\(f_i\)</span> 组成了一个等差数列。那么我们有 <span class="math display">\[\sum_{i=u}^{v} f_i=\frac{(A_u+A_v)(v-u+1)}{2}\]</span></p>
<p>那么所有 <span class="math inline">\(f_i\)</span> 之和可以看做是 <span class="math inline">\((x_i,A_{x_i})\)</span> 这些点顺次相连的折线下方的若干梯形面积之和加上一个定值。</p>
<p>为了使这个和最大，这些点一定是 <span class="math inline">\((i,A_i)\)</span> 的上凸壳上的顶点。</p>
<p>接下来我们一般情况。</p>
<p>考虑令 <span class="math inline">\(f_i&#39;=f_i-C_i\)</span>，那么有 <span class="math display">\[
f_i&#39;=
\begin{cases}
A_i-C_i &amp; \text{if } i\in S\\
\frac{f_{i-1}+f_{i+1}}{2}-B_i-C_i=\frac{f_{i-1}&#39;+f_{i+1}&#39;}{2}-B_i-C_i+\frac{C_{i-1}+C_{i+1}}{2} &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>我们只要使得 <span class="math inline">\(C_i\)</span> 满足 <span class="math inline">\(\frac{C_{i-1}+C_{i+1}}{2}-C_i=B_i\)</span> 即可转化为 <span class="math inline">\(B_i=0\)</span> 的情况。</p>
<p>这样的 <span class="math inline">\(C_i\)</span> 可以很简单的递推构造。</p>
<p>时间复杂度 <span class="math inline">\(O(N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc044/submissions/16571039">代码</a></p>
<h3 id="f---name-preserving-clubs">F - Name-Preserving Clubs</h3>
<p>题意描述较为复杂，请直接查看<a href="https://atcoder.jp/contests/agc044/tasks/agc044_f">原题面</a> <strong>Formal Statement</strong> 部分。</p>
<h4 id="题解-5">题解</h4>
<p>首先我们强制 <span class="math inline">\(L\)</span> 中的集合互不相同。</p>
<p>考虑建立一个 <span class="math inline">\(k\times n\)</span> 的矩阵，每一位填 <span class="math inline">\(0\)</span> 或者 <span class="math inline">\(1\)</span>。称一个矩阵是好的当且仅当行与行之间互不相同，并且任意打乱列后得到的矩阵都不能通过原矩阵打乱行得到。</p>
<p>显然好的矩阵和题目中的 name-preserving configuration 一一对应。</p>
<p>假设一个矩阵 <span class="math inline">\(A\)</span> 是好的，我们可以观察到下面两个性质：</p>
<ul>
<li><span class="math inline">\(A\)</span> 的转置是好的。</li>
<li>考虑 <span class="math inline">\(2^k\)</span> 种不同的列，由其中所有不在 <span class="math inline">\(A\)</span> 中的列任意排列构成的矩阵也是好的。</li>
</ul>
<p>那么如果我们设 <span class="math inline">\(c(k,n)\)</span> 表示本质不同的 <span class="math inline">\(k\times n\)</span> 的好的矩阵数量，那么有 <span class="math inline">\(c(k,n)=c(n,k)=c(k,2^k-n)\)</span>。</p>
<p>令 <span class="math inline">\(g(n)\)</span> 表示最小的 <span class="math inline">\(k\)</span> 满足 <span class="math inline">\(c(k,n)&gt;0\)</span>。</p>
<p>令 <span class="math inline">\(G(n)\)</span> 满足 <span class="math inline">\(G(1)=0\)</span>，<span class="math inline">\(G(n)\)</span> 表示最小的正整数 <span class="math inline">\(k\)</span> 满足 <span class="math inline">\(2^k-n\ge G(k)\)</span>。</p>
<p>我们可以用 <span class="math inline">\(G(n)\)</span> 的若干性质，通过归纳和构造证明 <span class="math inline">\(G(n)=g(n)\)</span>。</p>
<p>另外，我们还可以用构造证明对于 <span class="math inline">\(6\le k\le n\)</span> 时有 <span class="math inline">\(c(k,n)&gt;1000\)</span>。</p>
<p>于是我们只需要考虑 <span class="math inline">\(k\le 5,n\le 2^{k-1}\)</span> 的情况。暴搜后打表即可。</p>
<p>对于原题 <span class="math inline">\(L\)</span> 中的集合可以互不相同的情况，可以证明只有当 <span class="math inline">\(N=4\)</span> 和 <span class="math inline">\(N=7\)</span> 时分别会额外增加 <span class="math inline">\(1\)</span> 种方案和 <span class="math inline">\(2\)</span> 种方案，特判即可。</p>
<p>上述结论的证明可以参考<a href="https://img.atcoder.jp/agc044/editorial.pdf">官方题解</a>。</p>
<p><a href="https://atcoder.jp/contests/agc044/submissions/16574625">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>凸包</tag>
        <tag>搜索</tag>
        <tag>记忆化搜索</tag>
        <tag>trie</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 045 题解</title>
    <url>/atcoder-agc045/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc045">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---xor-battle">A - Xor Battle</h3>
<h4 id="题意">题意</h4>
<p>有 Person 0 和 Person 1 两个人玩游戏，有一个长度为 <span class="math inline">\(n\)</span> 的 01 字符串 <span class="math inline">\(S\)</span>、一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A_1,A_2,\ldots,A_n\)</span> 和一个初始为 <span class="math inline">\(0\)</span> 的变量 <span class="math inline">\(x\)</span>。</p>
<p>游戏有 <span class="math inline">\(n\)</span> 轮。第 <span class="math inline">\(i\)</span> 轮 Person <span class="math inline">\(S_i\)</span> 会执行以下两种操作之一：</p>
<ul>
<li><span class="math inline">\(x\gets x\oplus A_i\)</span>，其中 <span class="math inline">\(\oplus\)</span> 表示异或运算。</li>
<li>不做任何修改。</li>
</ul>
<p>游戏结束时，若 <span class="math inline">\(x=0\)</span>，则 Person 0 获胜，否则 Person 1 获胜。</p>
<p>判断两个人都采用最优策略时的胜者。</p>
<p><span class="math inline">\(T\)</span> 组数据，<span class="math inline">\(T\le 200,n\le 200,A_i\le 10^{18}\)</span>。</p>
<h4 id="题解">题解</h4>
<p>我们说一个数能被一个集合表示当且仅当这个数可以通过选择这个集合内的若干个数异或得到。</p>
<p>考虑从后往前依次考虑。</p>
<p>若 <span class="math inline">\(S_i=0\)</span>，则我们将 <span class="math inline">\(A_i\)</span> 加入到一个初始为空的集合 <span class="math inline">\(B\)</span> 中。</p>
<p>若 <span class="math inline">\(S_i=1\)</span>，则又分为两种情况：</p>
<ul>
<li><span class="math inline">\(A_i\)</span> 能被 <span class="math inline">\(B\)</span> 表示。此时无论 Person 1 是否选择将 <span class="math inline">\(x\)</span> 异或上 <span class="math inline">\(A_i\)</span>，Person 0 都可以通过选择 <span class="math inline">\(B\)</span> 中的数将这次选择抵消。所以我们直接忽略这一轮即可。</li>
<li><span class="math inline">\(A_i\)</span> 不能被 <span class="math inline">\(B\)</span> 表示。此时 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(x\oplus A_i\)</span> 中一定有一个不能被 <span class="math inline">\(B\)</span> 表示。那么 Person 1 只要选择那个不能被表示的数，最终 <span class="math inline">\(x\)</span> 就一定不可能是 <span class="math inline">\(0\)</span>，所以此时 Person 1 一定获胜。</li>
</ul>
<p>现在我们只需要能够快速判断一个数能否被一个集合表示即可。使用线性基即可。</p>
<p>时间复杂度 <span class="math inline">\(O(Tn\log A_i)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc045/submissions/16509525">代码</a></p>
<h3 id="b---01-unbalanced">B - 01 Unbalanced</h3>
<h4 id="题意-1">题意</h4>
<p>给定一个含有 <code>?</code> 的 01 串 <span class="math inline">\(S\)</span>。</p>
<p>定义一个 01 串 <span class="math inline">\(S\)</span> 的不平衡度为所有区间中，0 和 1 数量的差的绝对值的最大值。</p>
<p>求将 <span class="math inline">\(S\)</span> 中的 <code>?</code> 替换成 0 或 1（每个 <code>?</code> 独立选择）的最小不平衡度。</p>
<p><span class="math inline">\(|S|\le 10^6\)</span></p>
<h4 id="题解-1">题解</h4>
<p>对于一个 01 串 <span class="math inline">\(S\)</span>，如果把 0 看成 <span class="math inline">\(-1\)</span>，1 看成 <span class="math inline">\(+1\)</span>，我们可以求出前缀和 <span class="math inline">\(a_i\)</span>，那么不平衡度即为 <span class="math inline">\(\max a_i-\min a_i\)</span>。</p>
<p>考虑枚举 <span class="math inline">\(\min a_i=x\)</span>，那么我们要在满足 <span class="math inline">\(a_i\ge x\)</span> 的前提下最小化 <span class="math inline">\(a_i\)</span> 的最大值。</p>
<p>一个做法是，先将所有 <code>?</code> 替换成 <code>1</code>，这样可以求出 <span class="math inline">\(\min a_i\)</span> 的最大值 <span class="math inline">\(M\)</span>。</p>
<p>如果 <span class="math inline">\(x&gt;M\)</span>，则显然无解。否则我们从前往后依次考虑每一个可以被替换的位置，如果替换 <code>0</code> 后仍然能满足 <span class="math inline">\(\min a_i\ge x\)</span>，则替换。这样贪心显然是最优的，因为在后面替换一定不如前面替换更优。</p>
<p>根据该贪心算法，可以发现 <span class="math inline">\(x=k\)</span> 时的答案一定不劣于 <span class="math inline">\(x=k-2\)</span> 的答案，因为 <span class="math inline">\(x=k-2\)</span> 时相比于 <span class="math inline">\(x=k\)</span> 时最多多替换一个 <code>?</code>，最大值最多减小 <span class="math inline">\(2\)</span>，所以一定不会更优。</p>
<p>于是只要分别求出 <span class="math inline">\(x=M\)</span> 和 <span class="math inline">\(x=M-1\)</span> 时的答案即可。</p>
<p>时间复杂度 <span class="math inline">\(O(|S|)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc045/submissions/16530092">代码</a></p>
<h3 id="c---range-set">C - Range Set</h3>
<h4 id="题意-2">题意</h4>
<p>求有多少个不同的 01 串可以通过对长度为 <span class="math inline">\(N\)</span> 的全 <span class="math inline">\(0\)</span> 字符串按任意顺序执行任意次以下两种操作得到：</p>
<ul>
<li>选择一个长度为 <span class="math inline">\(A\)</span> 的子段，将该子段的所有字符替换成 <span class="math inline">\(0\)</span>。</li>
<li>选择一个长度为 <span class="math inline">\(B\)</span> 的子段，将该子段的所有字符替换成 <span class="math inline">\(1\)</span>。</li>
</ul>
<p>答案对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(N\le 5000\)</span></p>
<h4 id="题解-2">题解</h4>
<p>显然我们交换 <span class="math inline">\(A,B\)</span> 答案不会变化。所以我们接下来假设有 <span class="math inline">\(A\le B\)</span>。</p>
<p>一个字符串 <span class="math inline">\(S\)</span> 可以得到的充要条件是，如果将 <span class="math inline">\(S\)</span> 中所有长度不小于 <span class="math inline">\(A\)</span> 的全 <span class="math inline">\(0\)</span> 极长子段中的所有字符替换为 <span class="math inline">\(1\)</span>，那么 <span class="math inline">\(S\)</span> 中需要存在一个长度不小于 <span class="math inline">\(B\)</span> 的全 <span class="math inline">\(1\)</span> 子段。</p>
<p><strong>充分性</strong>：将所有长度不小于 <span class="math inline">\(A\)</span> 的全 <span class="math inline">\(0\)</span> 极长子段中的所有字符替换为 <span class="math inline">\(1\)</span> 后，把那段长度不小于 <span class="math inline">\(B\)</span> 的全 <span class="math inline">\(1\)</span> 子段左右两边的部分全部替换成正确的字符（分别从左往右和从右往左），然后把这个子段替换为 <span class="math inline">\(1\)</span>，再把开始替换的 <span class="math inline">\(0\)</span> 重新替换回去。</p>
<p><strong>必要性</strong>：考虑倒着还原，把所有长度不小于 <span class="math inline">\(A\)</span> 的全 <span class="math inline">\(0\)</span> 极长子段中的所有字符替换为 <span class="math inline">\(1\)</span> 可以使得 <span class="math inline">\(1\)</span> 的连续段尽量长。此时如果还是不存在长度不小于 <span class="math inline">\(B\)</span> 的全 <span class="math inline">\(1\)</span> 子段，那么我们无论如何都无法将原来的 <span class="math inline">\(1\)</span> 变成 <span class="math inline">\(0\)</span>。</p>
<p>接下来我们用总方案数减去不合法的方案数。</p>
<p>下面为了方便，我们将一个只包含长度不小于 <span class="math inline">\(A\)</span> 的极长全 <span class="math inline">\(0\)</span> 子段的串称为广义全 <span class="math inline">\(1\)</span> 串。</p>
<p>首先我们考虑求出 <span class="math inline">\(f_{i,0/1}\)</span> 表示长度为 <span class="math inline">\(i\)</span>，以 <span class="math inline">\(0/1\)</span> 结尾的广义全 <span class="math inline">\(1\)</span> 串数量。这可以简单地转移。</p>
<p>可以发现不合法的串一定是由长度小于 <span class="math inline">\(A\)</span> 的全 <span class="math inline">\(0\)</span> 串和长度小于 <span class="math inline">\(B\)</span> 且首尾都是 <span class="math inline">\(1\)</span> 的广义全 <span class="math inline">\(1\)</span> 串交替拼接而成。但是开头的如果是广义全 <span class="math inline">\(1\)</span> 串，则开头可以是 <span class="math inline">\(0\)</span>，结尾同理。</p>
<p>接下来我们考虑求出 <span class="math inline">\(g_{i,0/1}\)</span> 表示长度为 <span class="math inline">\(i\)</span>，以长度小于 <span class="math inline">\(A\)</span> 的全 <span class="math inline">\(0\)</span> 串结尾或是以长度小于 <span class="math inline">\(B\)</span> 且首尾都是 <span class="math inline">\(1\)</span> 的广义全 <span class="math inline">\(1\)</span> 串结尾的不合法串数量。转移也较为简单，注意开头和结尾需要特殊处理。</p>
<p>时间复杂度 <span class="math inline">\(O(NB)\)</span>。</p>
<h3 id="d---lamps-and-buttons">D - Lamps and Buttons</h3>
<h4 id="题意-3">题意</h4>
<p>A 和 B 玩游戏。有 <span class="math inline">\(N\)</span> 盏灯，其中 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(A\)</span> 是亮的，其他是暗的。灯的状态在游戏过程中对两个人都是公开的。</p>
<p>A 会首先等概率选择一个排列 <span class="math inline">\(p_1,p_2,\ldots,p_N\)</span>，B 不知道这个排列。这个排列在游戏过程中不会改变。</p>
<p>然后 B 会执行若干次操作，每次操作 B 会选定一盏亮着的灯 <span class="math inline">\(i\)</span>，如果没有则 A 获胜。接着 A 会把灯 <span class="math inline">\(p_i\)</span> 的状态改变，注意灯 <span class="math inline">\(i\)</span> 的状态不会改变。</p>
<p>如果某一时刻灯全部亮着，则 B 获胜。另外，如果过程中某一时刻灯的状态不可能通过有限次操作变成全部亮着，那么 A 获胜。</p>
<p>B 会有一个最优的策略使得自己胜率最大。求在最优策略下可以使 B 获胜的排列数量。</p>
<p><span class="math inline">\(N\le 10^7,A\le 5000\)</span></p>
<h4 id="题解-3">题解</h4>
<p>对于一个大小不小于 <span class="math inline">\(2\)</span> 的置换环，如果 B 某次选到了该置换环上一个亮着的灯，那么 B 就可以将整个环都点亮。</p>
<p>对于一个大小为 <span class="math inline">\(1\)</span> 的置换环，如果 B 某次选到了该置换环上的那个点，那么 B 就不可能再点亮该点，就会输掉游戏。</p>
<p>那么 B 的最优策略是每次随机选择一个点，然后将这个点所在的置换环点亮。</p>
<p>令 <span class="math inline">\(t\)</span> 为满足 <span class="math inline">\(1\le t\le A\)</span> 且 <span class="math inline">\(p_t=t\)</span> 的最小值。若不存在则 <span class="math inline">\(t=A+1\)</span>。我们可以根据上面的分析得到，排列 <span class="math inline">\(p\)</span> 合法的充要条件为，对于所有 <span class="math inline">\(A &lt; i\le n\)</span>，<span class="math inline">\(i\)</span> 所在的置换环存在一个小于 <span class="math inline">\(t\)</span> 的元素。</p>
<p>考虑枚举 <span class="math inline">\(t\)</span>，我们需要额外保证对于所有 <span class="math inline">\(1\le i &lt; t\)</span> 都有 <span class="math inline">\(p_i\ne i\)</span>，这个条件可以通过容斥解决，即枚举 <span class="math inline">\(p_i=i\)</span> 位置数量 <span class="math inline">\(j\)</span>，那么我们现在可以把所有 <span class="math inline">\(n\)</span> 个点分成若干类点：</p>
<ul>
<li>限制 <span class="math inline">\(p_i=i\)</span> 的点。这类点可以直接忽略。下面的几类点都默认去掉这类点。</li>
<li><span class="math inline">\(1\le i &lt; t\)</span> 的点。记为 A 类点，假设有 <span class="math inline">\(a\)</span> 个。</li>
<li><span class="math inline">\(A &lt; i\le n\)</span> 的点。记为 B 类点，假设有 <span class="math inline">\(b\)</span> 个。这类点有一个额外的限制为，每个点所在的置换环中都要存在一个 <span class="math inline">\(1\le i &lt; t\)</span> 的点（即 A 类点）。</li>
<li><span class="math inline">\(t &lt; i\le A\)</span> 的点。记为 C 类点，假设有 <span class="math inline">\(c\)</span> 个。</li>
</ul>
<p>考虑依次插入 A 类点、B 类点、C 类点。在插入时既可以在之前某个置换环上的两个相邻点之间插入，也可以单独成点（B 类点除外）。所以方案数为 <span class="math display">\[
\begin{aligned}
1^{\overline{a}}\times a^{\overline{b}}\times (a+b+1)^{\overline{c}}&amp;=a!\times \frac{(a+b-1)!}{(a-1)!}\times \frac{(a+b+c)!}{(a+b)!}\\
&amp;=\frac{(a+b+c)!\times a}{a+b}
\end{aligned}
\]</span></p>
<p>再乘上选出 <span class="math inline">\(j\)</span> 个数的方案数 <span class="math inline">\(\begin{pmatrix}t-1\\j\end{pmatrix}\)</span> 和容斥系数 <span class="math inline">\((-1)^j\)</span> 加入答案即可。</p>
<p>时间复杂度 <span class="math inline">\(O(A^2+N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc045/submissions/16537665">代码</a></p>
<h3 id="e---fragile-balls">E - Fragile Balls</h3>
<h4 id="题意-4">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个盒子和 <span class="math inline">\(M\)</span> 个球，一开始第 <span class="math inline">\(i\)</span> 个球在第 <span class="math inline">\(A_i\)</span> 个盒子。</p>
<p>每次操作可以选择一个至少有两个球的盒子，取出其中一个球放入另一个盒子。</p>
<p>第 <span class="math inline">\(i\)</span> 个球最多只能被操作 <span class="math inline">\(C_i\)</span> 次，目标是最终到第 <span class="math inline">\(B_i\)</span> 个盒子。</p>
<p>求最少需要操作多少次，或输出无解。</p>
<p><span class="math inline">\(N,M\le 10^5\)</span>，保证对于每个 <span class="math inline">\(1\le i\le N\)</span>，都存在 <span class="math inline">\(1\le j\le M\)</span> 满足 <span class="math inline">\(B_j=i\)</span>。</p>
<h4 id="题解-4">题解</h4>
<p>考虑建立一个 <span class="math inline">\(N\)</span> 个点的有向图。对于第 <span class="math inline">\(i\)</span> 个球，我们连一条 <span class="math inline">\(A_i\)</span> 到 <span class="math inline">\(B_i\)</span> 的权值为 <span class="math inline">\(C_i\)</span> 的边。一次操作相当于改变一条边的起点并将这条边的权值减 <span class="math inline">\(1\)</span>，需要保证操作前起点的出度大于 <span class="math inline">\(1\)</span> 且边权大于 <span class="math inline">\(0\)</span>。</p>
<p>首先我们不考虑边权，假设 <span class="math inline">\(C_i=1\)</span>。对于图中的一个弱连通分量（即把边看成无向边后的一个连通块），如果是一个环，那么一定无解；否则因为每个点入度大于 <span class="math inline">\(0\)</span>，那么一定存在一个点出度不小于 <span class="math inline">\(2\)</span>，一定有解。</p>
<p>注意到我们可以操作一个不是环的弱连通分量中的一条权值不小于 <span class="math inline">\(2\)</span> 的边（若起点出度不满足限制我们可以先操作若干次使得出度满足限制），将一个环与该弱连通分量合并成一个更大的弱连通分量。</p>
<p>这就意味着，我们只需要不断地选择不是环的弱连通分量中的权值不小于 <span class="math inline">\(2\)</span> 的边减 <span class="math inline">\(1\)</span>，就可以将环不断地合并进不是环的弱连通分量。</p>
<p>假若我们忽略 <span class="math inline">\(A_i=B_i\)</span> 的情况，那么我们只需要把每个弱连通分量的 <span class="math inline">\(C_i-1\)</span> 求和，将环按 <span class="math inline">\(C_i-1\)</span> 的和从大到小排序后依次合并进不是环的弱连通分量。</p>
<p>如果存在 <span class="math inline">\(A_i=B_i\)</span>，这样的边原来没有贡献，所以如果用来合并环则会导致贡献相比于其他边有额外的增加。额外的增加分两种情况：</p>
<ul>
<li>这个自环在一个不是环的弱连通分量里。此时额外的贡献是 <span class="math inline">\(1\)</span>。</li>
<li>这个自环单独成为一个弱连通分量。此时额外的贡献是 <span class="math inline">\(2\)</span>。</li>
</ul>
<p>这相当于一个背包，我们可以枚举额外贡献是 <span class="math inline">\(1\)</span> 的自环数量，用双指针维护额外贡献是 <span class="math inline">\(2\)</span> 的自环数量即可。</p>
<p>一种合并方案合法的条件是：</p>
<ul>
<li>所有可以用来合并的边 <span class="math inline">\(C_i-1\)</span> 之和不小于需要合并的环数。</li>
<li>初始时不是环的弱连通分量中可用来合并的边 <span class="math inline">\(C_i-1\)</span> 之和大于 <span class="math inline">\(0\)</span>。</li>
</ul>
<p>注意细节较多。</p>
<p>时间复杂度瓶颈在于排序，使用桶排可以做到时间复杂度 <span class="math inline">\(O(N+M)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc045/submissions/16559101">代码</a></p>
<h3 id="f---division-into-multiples">F - Division into Multiples</h3>
<h4 id="题意-5">题意</h4>
<p>你有 <span class="math inline">\(X+Y\)</span> 个数字，其中 <span class="math inline">\(X\)</span> 个数字是 <span class="math inline">\(A\)</span>，<span class="math inline">\(Y\)</span> 个数字是 <span class="math inline">\(B\)</span>，<span class="math inline">\(A\ne B\)</span>。</p>
<p>你需要将这些数字分成若干组，如果一组中数字的和为 <span class="math inline">\(C\)</span> 的倍数，则这一组是好的组。</p>
<p>求最多有多少好的组。</p>
<p><span class="math inline">\(T\)</span> 组数据，<span class="math inline">\(T\le 20000,A,B,X,Y,C\le 10^9\)</span>。</p>
<h4 id="题解-5">题解</h4>
<p>首先我们可以通过顺序执行以下几个操作使得 <span class="math inline">\(A,B,C\)</span> 两两互质：</p>
<ul>
<li>若 <span class="math inline">\(\gcd(A,B)&gt;1\)</span>，则可以将 <span class="math inline">\(A,B\)</span> 同时除以 <span class="math inline">\(\gcd(A,B)\)</span>，并且将 <span class="math inline">\(C\)</span> 除以 <span class="math inline">\(\gcd(A,B,C)\)</span>。</li>
<li>若 <span class="math inline">\(\gcd(A,C)&gt;1\)</span>，则可以将 <span class="math inline">\(A,C\)</span> 同时除以 <span class="math inline">\(\gcd(A,C)\)</span>，并且将 <span class="math inline">\(Y\)</span> 除以 <span class="math inline">\(\gcd(A,C)\)</span> 并下取整。</li>
<li>若 <span class="math inline">\(\gcd(B,C)&gt;1\)</span>，则可以将 <span class="math inline">\(B,C\)</span> 同时除以 <span class="math inline">\(\gcd(B,C)\)</span>，并且将 <span class="math inline">\(X\)</span> 除以 <span class="math inline">\(\gcd(B,C)\)</span> 并下取整。</li>
</ul>
<p>考虑求出同余方程 <span class="math inline">\(Ax+By\equiv 0\pmod{C}\)</span> 的所有最小解 <span class="math inline">\((x_i,y_i)\)</span>，最小指的是不存在 <span class="math inline">\(i\ne j\)</span> 使得 <span class="math inline">\(x_i\le x_j,y_i\le y_j\)</span>。注意不能包含 <span class="math inline">\(x=y=0\)</span> 这组解。</p>
<p>由于 <span class="math inline">\(\gcd(B,C)=1\)</span>，我们可以令 <span class="math inline">\(D=\frac{A}{B}\bmod C\)</span>，那么有 <span class="math inline">\(y\equiv -xD\pmod{C}\)</span>。</p>
<p>于是我们可以从 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(C\)</span> 枚举 <span class="math inline">\(x\)</span>，若求出的 <span class="math inline">\(y\)</span> 比之前的都要小，那么加入最小解。考虑如何加速。</p>
<p>考虑这么一个过程，假设有一个 <span class="math inline">\((0,0)\)</span> 到 <span class="math inline">\((C,D)\)</span> 的矩形，一个点 <span class="math inline">\((p,q)\)</span> 从原点出发，沿向量 <span class="math inline">\((1,1)\)</span> 方向前进，若 <span class="math inline">\(q=D\)</span> 则将 <span class="math inline">\(q\)</span> 置为 <span class="math inline">\(0\)</span>，若 <span class="math inline">\(p=C\)</span> 则将 <span class="math inline">\(p\)</span> 置为 <span class="math inline">\(0\)</span>。<span class="math inline">\(q=0\)</span> 时，若当前的 <span class="math inline">\(p\)</span> 比之前的都大，则将 <span class="math inline">\(x\equiv \frac{p}{D},y\equiv -p\)</span> 加入最小解。</p>
<p>于是我们可以递归，假设当前矩形的宽度为 <span class="math inline">\(W\)</span>，长度为 <span class="math inline">\(H\)</span>。当 <span class="math inline">\(W\ge H\)</span> 时，我们可以去掉 <span class="math inline">\((0,0)\)</span> 到 <span class="math inline">\((W,W)\)</span> 这个正方形，可以发现对之后的过程不会有太大影响。<span class="math inline">\(W&lt;H\)</span> 的情况类似，也可以去掉一个正方形。</p>
<p>可以发现这是一个类似于辗转相减的过程，每次最多会加入一个最小解。辗转相减的复杂度会有问题，我们可以变成辗转相除，将一段等差数列（即 <span class="math inline">\(x\)</span> 等差，<span class="math inline">\(y\)</span> 等差）加入最小解。</p>
<p>注意到 <span class="math inline">\(y\)</span> 之差会随着矩形减小不断减小，<span class="math inline">\(x\)</span> 之差会随着删除的正方形的增多不断增大，所以我们有 <span class="math inline">\(x_{i+1}-x_i\ge x_i-x_{i-1},y_{i+1}-y_i\ge y_i-y_{i-1}\)</span>。所以最优解的点组成了一个下凸壳。</p>
<p>接下来我们的问题是我们需要选择一个最大的可重集 <span class="math inline">\(S\)</span> 使得 <span class="math inline">\(\sum\limits_{i\in S}x_i\le X,\sum\limits_{i\in S}y_i\le Y\)</span>。</p>
<p>我们只要考虑 <span class="math inline">\(\max S-\min S\le 1\)</span> 的 <span class="math inline">\(S\)</span> 即可。证明考虑假设存在 <span class="math inline">\(i,j\in S,j-i\ge 2\)</span>，那么因为有 <span class="math inline">\(x_{i+1}-x_i\le x_j-x_{j-1}, y_{i+1}-y_i\le y_j-y_{j-1}\)</span>，我们可以将 <span class="math inline">\(i,j\)</span> 从 <span class="math inline">\(S\)</span> 中删去，插入 <span class="math inline">\(i+1,j-1\)</span>，一定仍然满足条件。</p>
<p>假设一个等差数列为 <span class="math inline">\((x_l,y_l),(x_l+\Delta x,y_l-\Delta y),(x_l+2\Delta x,y_l-2\Delta y),\ldots,(x_r=x_l+n\Delta x,y_r=y_l-n\Delta y)\)</span>。</p>
<p>考虑如何计算这个等差数列的答案。考虑二分答案 <span class="math inline">\(m\)</span>，由于等差数列上的一个点可以表示成 <span class="math inline">\((x_l+k\Delta x,y_r+(n-k)\Delta y)\)</span>，于是我们只需要满足 <span class="math inline">\(\lfloor\frac{X-m\cdot x_l}{\Delta x}\rfloor+\lfloor\frac{Y-m\cdot y_l}{\Delta y}\rfloor\ge m\cdot n\)</span> 就一定可以构造出合法的可重集合 <span class="math inline">\(S\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(T\log^2 V)\)</span>，其中 <span class="math inline">\(V\)</span> 是输入中数字的最大值。</p>
<p><a href="https://atcoder.jp/contests/agc045/submissions/16551226">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>图论</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>博弈</tag>
        <tag>容斥</tag>
        <tag>凸包</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 047 题解</title>
    <url>/atcoder-agc047/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc047">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---integer-product">A - Integer Product</h3>
<h4 id="题意">题意</h4>
<p>给定 <span class="math inline">\(n\)</span> 个小数点后最多 <span class="math inline">\(9\)</span> 位的实数 <span class="math inline">\(A_1,A_2,A_3,\ldots,A_n\)</span>，求有多少对 <span class="math inline">\((i,j)\ (1\le i &lt; j\le n)\)</span> 满足 <span class="math inline">\(A_i\cdot A_j\)</span> 为整数。</p>
<p><span class="math inline">\(n\le 2\times 10^5,0&lt;A_i&lt;10^4\)</span></p>
<h4 id="题解">题解</h4>
<p>令 <span class="math inline">\(a_i=10^9A_i=2^{x_i}5^{y_i}r_i\)</span>，将小数转化为整数。</p>
<p>则合法的 <span class="math inline">\((i,j)\)</span> 需要满足 <span class="math inline">\(10^{18}|a_ia_j\)</span>，也就是满足 <span class="math inline">\(x_i+x_j\ge 18,y_i+y_j\ge 18\)</span>。</p>
<p>直接枚举 <span class="math inline">\(x_i,x_j,y_i,y_j\)</span> 即可。注意去掉 <span class="math inline">\(i\ge j\)</span> 的情况。</p>
<p>记 <span class="math inline">\(m=\max\{a_i\}\)</span>，时间复杂度 <span class="math inline">\(O(n\log m+\log^4 m)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc047/submissions/16454160">代码</a></p>
<h3 id="b---first-second">B - First Second</h3>
<h4 id="题意-1">题意</h4>
<p>对于一个字符串，有一种操作是删除这个字符串的第一个字符或第二个字符。</p>
<p>有 <span class="math inline">\(n\)</span> 个字符串 <span class="math inline">\(S_1,S_2,S_3,\ldots,S_n\)</span>，求有多少对 <span class="math inline">\((i,j)\ (1\le i &lt; j\le n)\)</span> 满足 <span class="math inline">\(S_i\)</span> 和 <span class="math inline">\(S_j\)</span> 中的其中一个字符串可以通过若干次上述操作得到另一个字符串。</p>
<p><span class="math inline">\(n\le 2\times 10^5,\sum |S_i|\le 10^6,|\Sigma|\le 26,S_i\ne S_j\)</span>。</p>
<h4 id="题解-1">题解</h4>
<p>考虑两个字符串 <span class="math inline">\(A,B\ (|A|\le |B|)\)</span> 可以从 <span class="math inline">\(B\)</span> 变成 <span class="math inline">\(A\)</span> 当且仅当 <span class="math inline">\(A[2..|A|]\)</span> 是 <span class="math inline">\(B\)</span> 的一个后缀，且 <span class="math inline">\(A[1]\)</span> 在 <span class="math inline">\(B[1..|B|-|A|+1]\)</span> 中出现。</p>
<p>将字符串翻转后，条件变为 <span class="math inline">\(A\)</span> 可以拆成 <span class="math inline">\(B\)</span> 中一个前缀加一个字符的形式。</p>
<p>考虑将所有 <span class="math inline">\(S_i\)</span> 翻转后建 Trie，枚举每个字符串以及另一个字符串在该字符串中对应的前缀和后面加的字符即可。</p>
<p>时间复杂度 <span class="math inline">\(O(|\Sigma|\sum |S_i|)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc047/submissions/16454426">代码</a></p>
<h3 id="c---product-modulo">C - Product Modulo</h3>
<h4 id="题意-2">题意</h4>
<p>令质数 <span class="math inline">\(P=200003\)</span>。给定 <span class="math inline">\(n\)</span> 个整数 <span class="math inline">\(A_1,A_2,A_3,\ldots,A_n\)</span>，求 <span class="math display">\[\sum_{i=1}^{n}\sum_{j=i+1}^{n} (A_iA_j\bmod P)\]</span> 的值。</p>
<p><span class="math inline">\(n\le 2\times 10^5\)</span></p>
<h4 id="题解-2">题解</h4>
<p>求出 <span class="math inline">\(P\)</span> 的一个原根 <span class="math inline">\(g=2\)</span>。</p>
<p>于是我们可以将 <span class="math inline">\(A_i\)</span> 表示成 <span class="math inline">\(g^{B_i}\bmod P\)</span>。</p>
<p>于是 <span class="math inline">\(A_iA_j\bmod P=g^{B_i+B_j}\bmod P\)</span>。</p>
<p>用 FFT 求出对于每个 <span class="math inline">\(k\)</span> 求出 <span class="math inline">\(B_i+B_j=k\)</span> 的 <span class="math inline">\((i,j)\)</span> 数量即可。</p>
<p>时间复杂度 <span class="math inline">\(O(P\log P)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc047/submissions/16454723">代码</a></p>
<h3 id="d---twin-binary-trees">D - Twin Binary Trees</h3>
<h4 id="题意-3">题意</h4>
<p>有两棵高度为 <span class="math inline">\(H\)</span> 的满二叉树 <span class="math inline">\(T_1,T_2\)</span>，节点编号为从根开始逐层标号 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(2^H-1\)</span>。</p>
<p>有一个 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(2^{H-1}\)</span> 的排列 <span class="math inline">\(P\)</span>，表示 <span class="math inline">\(T_1\)</span> 中编号为 <span class="math inline">\(2^{H-1}+i-1\)</span> 的叶子与 <span class="math inline">\(T_2\)</span> 中编号为 <span class="math inline">\(2^{H-1}+P_i-1\)</span> 的叶子有一条特殊边。</p>
<p>定义一个环的权值为环上所有节点编号的乘积。</p>
<p>求所有恰好包含两条特殊边的简单环的权值之和。对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(H\le 18\)</span></p>
<h4 id="题解-3">题解</h4>
<p>一个暴力的想法是枚举 <span class="math inline">\(T_1\)</span> 中的两个叶子 <span class="math inline">\(x,y\)</span>，然后能唯一确定一个简单环 <span class="math inline">\(x\to \operatorname{LCA}(T_1,x,y)\to y\to P_y\to \operatorname{LCA}(T_2,P_x,P_y)\to P_x\to x\)</span>。</p>
<p>考虑枚举 <span class="math inline">\(x,y\)</span> 在 <span class="math inline">\(T_1\)</span> 上的 LCA <span class="math inline">\(u\)</span>，然后枚举 <span class="math inline">\(u\)</span> 左子树中每个叶子 <span class="math inline">\(x\)</span>，在 <span class="math inline">\(T_2\)</span> 中 <span class="math inline">\(P_x\)</span> 到根路径上的每个点上加上对应的路径权值。</p>
<p>接下来枚举右子树中每个点 <span class="math inline">\(y\)</span>，枚举 <span class="math inline">\(T_2\)</span> 中 <span class="math inline">\(P_y\)</span> 到根路径上的每个点作为 <span class="math inline">\(P_x,P_y\)</span> 的 LCA 计算贡献。</p>
<p>时间复杂度 <span class="math inline">\(O(2^H\times H^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc047/submissions/16455686">代码</a></p>
<h3 id="e---product-simulation">E - Product Simulation</h3>
<h4 id="题意-4">题意</h4>
<p><strong>本题没有输入。</strong></p>
<p>你可以在长度为 <span class="math inline">\(N=200000\)</span> 的数组 <span class="math inline">\(a_0,a_1,a_2,\ldots,a_{N-1}\)</span> 上执行以下两种操作：</p>
<ul>
<li>`+ i j k`，表示执行 <span class="math inline">\(a_k\gets a_i+a_j\)</span>。<span class="math inline">\(i,j,k\)</span> 不需要互不相同。</li>
<li><code>&lt; i j k</code>，表示执行 <span class="math inline">\(a_k\gets [a_i&lt;a_j]\)</span>。<span class="math inline">\(i,j,k\)</span> 不需要互不相同。</li>
</ul>
<p>初始时，<span class="math inline">\(a_0=A,a_1=B,a_2=a_3=\ldots=a_{N-1}=0\)</span>。</p>
<p>你可以执行最多 <span class="math inline">\(Q=200000\)</span> 次操作来实现 <span class="math inline">\(a_2\gets a_0\times a_1\)</span>。</p>
<p><span class="math inline">\(0\le A,B\le 10^9\)</span>。<strong>注意你不知道 <span class="math inline">\(A,B\)</span> 具体的值。</strong></p>
<h4 id="题解-4">题解</h4>
<p>首先考虑一个最简单的问题，实现 <span class="math inline">\(a_k\gets a_i\times a_j\)</span>，其中 <span class="math inline">\(a_i,a_j\in \{0,1\}\)</span>。</p>
<p>在这种情况下，有一个简单的式子 <span class="math inline">\(a_i\times a_j=[1&lt;a_i+a_j]\)</span>。</p>
<p>假设我们已经在第 <span class="math inline">\(3\)</span> 个位置构造出了 <span class="math inline">\(1\)</span>，则我们只要依次执行 <code>+ i j k</code> 和 <code>&lt; 3 k k</code> 即可。</p>
<p>注意到 <span class="math inline">\(A=B=0\)</span> 时无论如何执行操作数组中都不可能出现除 <span class="math inline">\(0\)</span> 以外的数，所以我们可以忽略这种情况。</p>
<p>在其他情况下，<span class="math inline">\(A&lt;2(A+B)\)</span> 恒成立，所以我们用该式子可以构造出 <span class="math inline">\(1\)</span>。</p>
<p>构造出 <span class="math inline">\(1\)</span> 以后，我们可以依次构造出 <span class="math inline">\(2^1,2^2,\ldots,2^{29}\)</span>。</p>
<p>类似地，我们可以实现 <span class="math inline">\(a_x\gets a_x\times 2^k\)</span> 的操作，只要执行 <span class="math inline">\(k\)</span> 次 <code>+ x x x</code> 即可。</p>
<p>接下来我们可以实现对非负整数 <span class="math inline">\(x\)</span> 二进制分解。从高到低依次枚举 <span class="math inline">\(2^k\)</span>，用临时变量 <span class="math inline">\(S\)</span> 存储已经确定的位，每次将 <span class="math inline">\(S+2^k&lt;x+1\)</span> 的值存在临时变量 <span class="math inline">\(t\)</span> 中，将 <span class="math inline">\(t\)</span> 的值赋值到存储分解结果的位置，然后将 <span class="math inline">\(t\)</span> 乘上 <span class="math inline">\(2^k\)</span> 后加到 <span class="math inline">\(S\)</span> 中。可以发现这些操作都可以用上面讨论过的操作实现。</p>
<p>我们用上述操作将 <span class="math inline">\(A,B\)</span> 分解后，枚举每一对二进制位 <span class="math inline">\((i,j)\)</span>，用之前提到过的 01 乘法和自乘 <span class="math inline">\(2\)</span> 的幂次的操作即可实现乘法。</p>
<p>数组使用约 <span class="math inline">\(100\)</span> 个，操作次数约为 <span class="math inline">\(30000\)</span> 次。</p>
<p><a href="https://atcoder.jp/contests/agc047/submissions/16458767">代码</a></p>
<h3 id="f---rooks">F - Rooks</h3>
<h4 id="题意-5">题意</h4>
<p>有一个无限大的棋盘上有 <span class="math inline">\(n\)</span> 个互不攻击的车 <span class="math inline">\((X_i,Y_i)\)</span>。车的攻击范围为所在的行和所在的列。</p>
<p>你可以用一个国王替换某一个车。<strong>国王的移动方式为每次向上下左右其中一个方向移动一格。特别地，在攻击车时，移动方式为每次向左上、左下、右上、右下四个方向其中一个方向移动一格。</strong></p>
<p>国王不能进入存在的车的攻击范围内。</p>
<p>对于每个 <span class="math inline">\(i\)</span>，求用国王替换第 <span class="math inline">\(i\)</span> 个车时，在攻击最多的车的前提下，最少需要的移动步数。</p>
<p><span class="math inline">\(n\le 2\times 10^5\)</span></p>
<h4 id="题解-5">题解</h4>
<p>考虑一个简单的 DP。将车按 <span class="math inline">\(x\)</span> 坐标排序，国王在攻击的过程中，被攻击的车一定是一个区间。用 <span class="math inline">\(f[L][R][0/1]\)</span> 表示当前已经攻击掉 <span class="math inline">\([L,R]\)</span> 这些车，国王在车 <span class="math inline">\(L\)</span>/车 <span class="math inline">\(R\)</span> 的位置时，攻击最多的车还需要的最少步数。</p>
<p>转移比较简单，不再展开。</p>
<p>注意到若要攻击的区间 <span class="math inline">\([l,r]\)</span> 满足，横坐标相邻的车纵坐标也相邻，那么假设起点为 <span class="math inline">\(s\)</span>，攻击的路线一定是 <span class="math inline">\(s\to l\to r\)</span> 或 <span class="math inline">\(s\to r\to l\)</span>。可以 <span class="math inline">\(O(1)\)</span> 计算。</p>
<p>然后我们发现，如果我们将这样的极大区间看成一个整体，我们可以将这个区间继续往左右两边扩张，扩张后的区间仍然存在类似的性质。可以结合下图理解：</p>
<p><img src="/files/agc047F1.png" class="lazyload" data-srcset="/files/agc047F1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>于是我们只要将每次扩张的区间作为 DP 的状态进行 DP 即可。</p>
<p>注意到最开始的区间中的每个点作为起点时，都可以快速计算，于是我们可以通过这样的一次扩张和 DP 将初始的区间中每个车作为起点的答案都计算出来。</p>
<p>结合上图可以发现，只有在扩张白色点时才会将白色、蓝色、绿色的点都访问一遍，而扩张蓝色点、绿色点时都只会扩张出本身的一个区间，所以每个点最多被访问 <span class="math inline">\(2\)</span> 次。</p>
<p>还有一个小情况如下：</p>
<p><img src="/files/agc047F2.png" class="lazyload" data-srcset="/files/agc047F2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>中间的相交部分最多只会被两个大矩形包含，所以最多被访问 <span class="math inline">\(3\)</span> 次。</p>
<p>最终复杂度瓶颈在于排序和离散的复杂度，扩张和 DP 部分复杂度为线性。</p>
<p>图片来自于官方<a href="https://www.youtube.com/watch?v=SN0dyP2kJgo&amp;t=22m">视频题解</a>。</p>
<p><a href="https://atcoder.jp/contests/agc047/submissions/16465339">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>枚举</tag>
        <tag>数论</tag>
        <tag>trie</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT1724」「CODE FESTIVAL 2015 OKINAWA OPEN」Beware of the Sogginess!</title>
    <url>/atcoder-cfoo15B-sol/</url>
    <content><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_b">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定 <span class="math inline">\(n\)</span> 个二元组 <span class="math inline">\((a_i,b_i)\)</span>。一个二元组 <span class="math inline">\((a,b)\)</span> 可以变为 <span class="math inline">\((a+t,b-t)\ (0\le t\le b)\)</span>。你现在可以选择一些二元组并将它们<strong>分别</strong>进行（即互相独立）一次变换，使得变换后你选择的所有二元组 <span class="math inline">\((a_j,b_j)\)</span>，<span class="math inline">\(\sum a_j\ge A,\sum b_j\ge B\)</span>。求最少需要选择并变换的二元组数量。</p>
<p><span class="math inline">\(1\le n\le 50,1\le A,B,a_i,b_i\le 10^4\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>转化题意：给定 <span class="math inline">\(n\)</span> 个二元组 <span class="math inline">\((b_i,a_i+b_i)\)</span>，选择最少的二元组使得所有选择的二元组 <span class="math inline">\(\sum b_j\ge B,\sum (a_j+b_j)\ge A+B\)</span>。</p>
<p>于是就可以 DP 了。<span class="math inline">\(dp_{i,j}\)</span> 表示选择 <span class="math inline">\(i\)</span> 个二元组，<span class="math inline">\(\sum b_i=j\)</span> 时，<span class="math inline">\(\sum (a_i+b_i)\)</span> 的最大值。</p>
<p>考虑把 <span class="math inline">\(n\)</span> 个二元组依次加入，DP 方程很容易写出。</p>
<p>发现直接写，第二维有百万级别，怎么办？<span class="math inline">\(j&gt;B\)</span> 的状态都合并到 <span class="math inline">\(j=B\)</span> 处即可。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, A, B, a[<span class="number">55</span>], b[<span class="number">55</span>], dp[<span class="number">55</span>][<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmx</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123; x = std :: <span class="built_in">max</span>(x, y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;B, &amp;A), B += A; <span class="comment">// 与上面的 A,B 有区别，注意区分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, b + i, a + i), b[i] += a[i]; <span class="comment">// 与上面的 ai,bi 有区别，注意区分</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp), dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">// 依次加入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i - <span class="number">1</span>; ~j; --j) <span class="comment">// 倒着做，与 01 背包同理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= A; ++k)</span><br><span class="line">                <span class="keyword">if</span> (~dp[j][k]) <span class="built_in">cmx</span>(dp[j + <span class="number">1</span>][k + a[i] &gt; A ? A : k + a[i]], dp[j][k] + b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (dp[i][A] &gt;= B) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 046 题解</title>
    <url>/atcoder-agc046/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc046">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---takahashikun-the-strider">A - Takahashikun, The Strider</h3>
<h4 id="题意">题意</h4>
<p>有一个人，初始时在 <span class="math inline">\((0,0)\)</span>，面向 <span class="math inline">\(y\)</span> 轴正方向。每一步会向前走一个单位，然后逆时针旋转 <span class="math inline">\(X^{\circ}\)</span>。</p>
<p>求第一次回到 <span class="math inline">\((0,0)\)</span> 时用的步数。</p>
<h4 id="题解">题解</h4>
<p>可以证明答案为 <span class="math inline">\(\frac{360}{\gcd(X,360)}\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc046/submissions/16473692">代码</a></p>
<h3 id="b---extension">B - Extension</h3>
<h4 id="题意-1">题意</h4>
<p>有一个 <span class="math inline">\(A\times B\)</span> 的全白网格。每次可以在上面加上一行，并且将这一行的恰好一个格子染成黑色；或者在右边加上一列，并且将这一列的恰好一个格子染成黑色。</p>
<p>求通过若干次操作后 <span class="math inline">\(C\times D\)</span> 的本质不同的网格数量。对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(C,D\le 3000\)</span></p>
<h4 id="题解-1">题解</h4>
<p>直接 DP，记 <span class="math inline">\(f_{i,j}\)</span> 为 <span class="math inline">\(i\times j\)</span> 的本质不同网格数量。转移考虑最后一次操作是扩充行还是扩充列，但是注意右上角为白色的方案会被算两次，要减去。转移方程为</p>
<p><span class="math display">\[f_{i,j}=f_{i-1,j}\times j+f_{i,j-1}\times i-f_{i-1,j-1}\times (i-1)\times (j-1)\]</span></p>
<p>时间复杂度 <span class="math inline">\(O(CD)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc046/submissions/16473735">代码</a></p>
<h3 id="c---shift">C - Shift</h3>
<h4 id="题意-2">题意</h4>
<p>给定 01 字符串 <span class="math inline">\(S\)</span>，求有多少本质不同的字符串可以通过 <span class="math inline">\(S\)</span> 执行 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(K\)</span> 次以下操作得到：</p>
<ul>
<li>选择 <span class="math inline">\(i,j\ (i&lt;j)\)</span> 满足 <span class="math inline">\(S_i=0,S_j=1\)</span>，将 <span class="math inline">\(S_j\)</span> 移动到 <span class="math inline">\(S_i\)</span> 的左边。</li>
</ul>
<p><span class="math inline">\(|S|\le 300,K\le 10^9\)</span></p>
<h4 id="题解-2">题解</h4>
<p>考虑将相邻的 <span class="math inline">\(0\)</span> 之间（包括首尾）<span class="math inline">\(1\)</span> 的数量依次记为 <span class="math inline">\(a_1,a_2,\ldots,a_m\)</span>。</p>
<p>则一次操作相当于 <span class="math inline">\(a_i\gets a_i+1,a_j\gets a_j-1\)</span>，其中 <span class="math inline">\(i&lt;j\)</span>。</p>
<p>考虑最终得到的序列 <span class="math inline">\(b_1,b_2,\ldots,b_m\)</span>，需要满足：</p>
<ul>
<li>对于所有 <span class="math inline">\(1\le i\le m\)</span>，满足 <span class="math inline">\(\sum\limits_{j=1}^{i} b_j\ge \sum\limits_{j=1}^{i} a_j\)</span>；</li>
<li><span class="math inline">\(\sum\limits_{i=1}^{m}b_i=\sum\limits_{i=1}^{m}a_i\)</span>；</li>
<li><span class="math inline">\(\sum\limits_{i=1}^{m}\max(b_i-a_i,0)\le k\)</span></li>
</ul>
<p>于是在 DP 状态中记录当前 <span class="math inline">\(b_i\)</span> 之和以及 <span class="math inline">\(\max(b_i-a_i,0)\)</span> 之和，直接转移是 <span class="math inline">\(O(|S|^4)\)</span> 的，可以用前缀和优化到 <span class="math inline">\(O(|S|^3)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc046/submissions/16474016">代码</a></p>
<h3 id="d---secret-passage">D - Secret Passage</h3>
<h4 id="题意-3">题意</h4>
<p>给定 01 字符串 <span class="math inline">\(S\)</span>，求有多少本质不同的字符串可以通过 <span class="math inline">\(S\)</span> 执行若干次（包括 <span class="math inline">\(0\)</span> 次）以下操作得到：</p>
<ul>
<li>删除前两个字符中的一个，将另一个插入到字符串中的任意位置。</li>
</ul>
<p><span class="math inline">\(|S|\le 300\)</span></p>
<h4 id="题解-3">题解</h4>
<p>考虑将 <span class="math inline">\(T\)</span> 表示成 <span class="math inline">\(S\)</span> 的一个后缀中插入若干个 <span class="math inline">\(0,1\)</span>。</p>
<p>为了判断 <span class="math inline">\(T\)</span> 能否通过 <span class="math inline">\(S\)</span> 得到，我们一定会使这个表示中 <span class="math inline">\(0,1\)</span> 数量尽量，也就是 <span class="math inline">\(S\)</span> 的后缀尽量长。</p>
<p>那么我们用 <span class="math inline">\(f[i][j][k]\)</span> 表示后缀为 <span class="math inline">\(S[i+1,n]\)</span>，需要插入 <span class="math inline">\(j\)</span> 个 <span class="math inline">\(0\)</span>、<span class="math inline">\(k\)</span> 个 <span class="math inline">\(1\)</span> 的字符串 <span class="math inline">\(T\)</span> 的数量。因为我们保证后缀尽量长，所以不会算重。</p>
<p>接下来我们需要考虑的问题是通过删除前缀 <span class="math inline">\(S[1..i]\)</span>，能否向后缀中插入 <span class="math inline">\(j\)</span> 个 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(k\)</span> 个 <span class="math inline">\(1\)</span>。</p>
<p>令 <span class="math inline">\(g[i][j][k]\)</span> 表示已经删除前缀 <span class="math inline">\(S[1..i]\)</span>，向后缀中插入 <span class="math inline">\(j\)</span> 个 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(k\)</span> 个 <span class="math inline">\(1\)</span> 时，最多有多少个字符可以被再次删除。</p>
<p>转移考虑直接删除 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(i+1\)</span> 还是删除 <span class="math inline">\(i\)</span> 和之前一个删除后插入到该位置的字符。</p>
<p>最后对于 <span class="math inline">\(i,j,k\)</span>，若存在一个 <span class="math inline">\(i&#39;\le i,j&#39;\ge j,k&#39;\ge k\)</span> 满足 <span class="math inline">\(g[i&#39;][j&#39;][k&#39;]\ge 0\)</span>，则答案加上 <span class="math inline">\(f[i][j][k]\)</span> 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(|S|^3)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc046/submissions/16475134">代码</a></p>
<h3 id="e---permutation-cover">E - Permutation Cover</h3>
<h4 id="题意-4">题意</h4>
<p>你需要构造一个满足以下条件的序列 <span class="math inline">\(P\)</span>，无解输出 <span class="math inline">\(-1\)</span>：</p>
<ul>
<li>序列中每个元素为 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(K\)</span> 的整数，且整数 <span class="math inline">\(i\)</span> 恰好出现 <span class="math inline">\(a_i\)</span> 次。</li>
<li>对于序列中每个元素，都存在至少一个连续子序列包含该元素并且是一个 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(K\)</span> 的排列。</li>
</ul>
<p>在满足以上条件的前提下要求字典序最小。</p>
<p><span class="math inline">\(K\le 100,\sum a_i\le 1000\)</span></p>
<h4 id="题解-4">题解</h4>
<p>令 <span class="math inline">\(x=\max a_i,y=\min a_i\)</span>，则有解的充要条件为 <span class="math inline">\(x\le 2y\)</span>，证明如下：</p>
<p><strong>必要性</strong>：假设不满足该条件。取满足 <span class="math inline">\(a_i=x\)</span> 的任意一个 <span class="math inline">\(i\)</span> 和满足 <span class="math inline">\(a_i=y\)</span> 的任意一个 <span class="math inline">\(j\)</span>，只考虑序列 <span class="math inline">\(P\)</span> 中值为 <span class="math inline">\(i\)</span> 或 <span class="math inline">\(j\)</span> 的位置按相对顺序拿出来组成一个新的序列，则必定存在一个值为 <span class="math inline">\(i\)</span> 的位置只与 <span class="math inline">\(i\)</span> 相邻，那么就一定不存在一个排列覆盖到这个位置。假设不成立，必要性得证。</p>
<p><strong>充分性</strong>：考虑从空序列开始依次加入若干个序列得到最终的序列。记 <span class="math inline">\(B_i\)</span> 为当前元素 <span class="math inline">\(i\)</span> 还需要放多少个。将所有满足 <span class="math inline">\(B_i=y\)</span> 的元素 <span class="math inline">\(i\)</span> 取出，按任意顺序排列得到序列 <span class="math inline">\(S\)</span>，其他元素按任意顺序排列得到序列 <span class="math inline">\(T\)</span>。我们在 <span class="math inline">\(P\)</span> 中依次加入序列 <span class="math inline">\(T,S,T\)</span> 即可。这样的构造可以始终满足 <span class="math inline">\(x\le 2y\)</span> 的条件，充分性得证。</p>
<hr />
<p>接下来我们仍然考虑用依次加入若干序列的方式构造最终的序列。</p>
<p>假设当前序列为 <span class="math inline">\(P\)</span>，最后 <span class="math inline">\(k\)</span> 个元素按顺序组成的序列为 <span class="math inline">\(Q\)</span>，第 <span class="math inline">\(i\)</span> 个元素还需要 <span class="math inline">\(B_i\)</span> 个。</p>
<p>显然 <span class="math inline">\(Q\)</span> 一定是一个排列。</p>
<p>令 <span class="math inline">\(x=\max B_i,y=\min B_i\)</span>，则有解的充要条件为：</p>
<ul>
<li><span class="math inline">\(x\le 2y+1\)</span>；</li>
<li>若 <span class="math inline">\(x=2y+1\)</span>，则还需要满足 <span class="math inline">\(Q\)</span> 中所有 <span class="math inline">\(B_i=x\)</span> 的元素 <span class="math inline">\(i\)</span> 在所有 <span class="math inline">\(B_j=x\)</span> 的元素 <span class="math inline">\(j\)</span> 的前面。</li>
</ul>
<p><strong>第一个条件的必要性</strong>：类似于之前有解条件的必要性证明，需要注意第一个 <span class="math inline">\(B_i=x\)</span> 的元素 <span class="math inline">\(i\)</span> 可以和前面部分组成一个排列，所以需要删去。</p>
<p><strong>第二个条件的必要性</strong>：可以假设存在一个 <span class="math inline">\(B_j=y\)</span> 的元素 <span class="math inline">\(j\)</span> 和 <span class="math inline">\(B_i=x\)</span> 的元素 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(j\)</span> 的位置在 <span class="math inline">\(i\)</span> 前面，观察 <span class="math inline">\(x\le 2y+1\)</span> 的必要性证明，可以发现此时第一个元素不能与前面组成排列，不能删去，那么此时必须满足 <span class="math inline">\(x\le 2y\)</span>，与 <span class="math inline">\(x=2y+1\)</span> 矛盾，假设不成立，得证。</p>
<p><strong>充分性</strong>：假设最后一个满足 <span class="math inline">\(B_i=x\)</span> 的元素 <span class="math inline">\(i\)</span> 为 <span class="math inline">\(Q\)</span> 中第 <span class="math inline">\(s\)</span> 个。考虑在 <span class="math inline">\(P\)</span> 的末尾加入 <span class="math inline">\(Q_1,Q_2,\ldots,Q_s\)</span>，此时 <span class="math inline">\(y\)</span> 不变，<span class="math inline">\(x\)</span> 一定减 <span class="math inline">\(1\)</span>，所以此时满足 <span class="math inline">\(x=2y\)</span>，一定有解。充分性得证。</p>
<p>有了以上两个结论后，我们就可以构造字典最小的解了。</p>
<p>考虑每次枚举加入的元素个数 <span class="math inline">\(s\)</span>，则此时加入的一定是 <span class="math inline">\(Q_1,Q_2,\ldots,Q_s\)</span> 的一个排列，那么我们就可以确定加入以后的 <span class="math inline">\(B_i\)</span>，于是可以求出新的 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>。分三种情况：</p>
<ul>
<li>若 <span class="math inline">\(x\le 2y\)</span>，则直接从小到大排序后加入即可；</li>
<li>若 <span class="math inline">\(x=2y+1\)</span>，我们将 <span class="math inline">\(B_{Q_i}\in \{x,y\}\)</span> 的元素 <span class="math inline">\(Q_i\)</span> 放在序列 <span class="math inline">\(f_1\)</span> 中，其余元素放在 <span class="math inline">\(f_2\)</span> 中。<span class="math inline">\(f_1\)</span> 优先按是否为 <span class="math inline">\(y\)</span> 进行排序，都是 <span class="math inline">\(y\)</span> 或都是 <span class="math inline">\(x\)</span> 则按大小排序；<span class="math inline">\(f_2\)</span> 直接按大小排序。然后将 <span class="math inline">\(f_1\)</span> 和 <span class="math inline">\(f_2\)</span> 归并即可。注意需要判断最终的序列是否合法。</li>
<li>若 <span class="math inline">\(x&gt;2y+1\)</span>，则直接无解。</li>
</ul>
<p>时间复杂度 <span class="math inline">\(O(K^2\sum a_i)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/agc046/submissions/16477878">代码</a></p>
<h3 id="f---forbidden-tournament">F - Forbidden Tournament</h3>
<h4 id="题意-5">题意</h4>
<p>求满足以下条件的 <span class="math inline">\(N\)</span> 个点有标号竞赛图数量：</p>
<ul>
<li>每个节点入度不超过 <span class="math inline">\(K\)</span>；</li>
<li><strong>不存在</strong>四个互不相同的节点 <span class="math inline">\(a,b,c,d\)</span> 满足，同时存在 <span class="math inline">\(a\to b,b\to c,c\to a,a\to d,b\to d,c\to d\)</span> 这六条边。</li>
</ul>
<p><span class="math inline">\(N\le 200\)</span></p>
<h4 id="题解-5">题解</h4>
<p>令图 <span class="math inline">\(H=(\{a,b,c,d\},\{(a,b),(b,c),(c,a),(a,d),(b,d),(c,d)\})\)</span>，即不能出现的子图。下文中，在不会引起歧义的前提下，会使用一个点集来表示一个诱导子图。</p>
<p>接下来我们考虑一个合法的竞赛图 <span class="math inline">\(G\)</span> 的结构。</p>
<p>首先我们不断将入度为 <span class="math inline">\(0\)</span> 的节点删去，假设删去了 <span class="math inline">\(s\)</span> 个节点，则现在 <span class="math inline">\(G\)</span> 变为了一个 <span class="math inline">\(N-s\)</span> 个点，入度不超过 <span class="math inline">\(K-s\)</span> 的强连通竞赛图。</p>
<p>接下来我们任选 <span class="math inline">\(G\)</span> 中的一个节点 <span class="math inline">\(v\)</span>，将所有存在边 <span class="math inline">\(v\to w\)</span> 的节点 <span class="math inline">\(w\)</span> 组成的集合记为 <span class="math inline">\(Y\)</span>，其余节点记为 <span class="math inline">\(X\)</span>，注意 <span class="math inline">\(v\in X\)</span>。</p>
<hr />
<p>竞赛图有性质：若一个竞赛图中存在环，则该图中一定存在三元环。</p>
<p>那么假设 <span class="math inline">\(X\)</span> 中存在环，那么一定存在不包含 <span class="math inline">\(v\)</span> 的三元环，那么这个三元环与 <span class="math inline">\(v\)</span> 一起会组成 <span class="math inline">\(H\)</span>，不合法，所以 <span class="math inline">\(X\)</span> 一定是一个 DAG。我们将这些节点按拓扑序记为 <span class="math inline">\(x_1,x_2,\ldots,x_k\)</span>，那么有 <span class="math inline">\(x_i\to x_j\)</span> 当且仅当 <span class="math inline">\(i &lt; j\)</span>。</p>
<p>因为不存在入度为 <span class="math inline">\(0\)</span> 的点，那么一定存在 <span class="math inline">\(w\in Y,u\in X\)</span> 满足存在边 <span class="math inline">\(w\to u\)</span>。假设存在一个点 <span class="math inline">\(w&#39;\in Y\)</span> 满足存在边 <span class="math inline">\(w\to w&#39;\)</span>，那么一定存在边 <span class="math inline">\(w&#39;\to u\)</span>。这是因为如果存在边 <span class="math inline">\(u\to w&#39;\)</span>，则 <span class="math inline">\(u,v,w,w&#39;\)</span> 会构成 <span class="math inline">\(H\)</span>，不合法。</p>
<p>然后我们可以推导出对于 <span class="math inline">\(w\)</span> 能到的所有在 <span class="math inline">\(Y\)</span> 中的点 <span class="math inline">\(w&#39;&#39;\)</span>，都存在边 <span class="math inline">\(w&#39;&#39;\to u\)</span>。那么 <span class="math inline">\(w\)</span> 能到的在 <span class="math inline">\(Y\)</span> 中的点一定不会有环，因为如果有环，就会有三元环，就会与 <span class="math inline">\(u\)</span> 组成 <span class="math inline">\(H\)</span>，不合法。</p>
<p>对于 <span class="math inline">\(w\)</span> 不能到的所有在 <span class="math inline">\(Y\)</span> 中的点 <span class="math inline">\(z\)</span>，一定存在边 <span class="math inline">\(z\to w\)</span>，那么如果这些点中存在环，又会与 <span class="math inline">\(w\)</span> 组成 <span class="math inline">\(H\)</span>，不合法。</p>
<p>综合以上两部分，我们证明了 <span class="math inline">\(Y\)</span> 也是一个 DAG，我们可以将 <span class="math inline">\(Y\)</span> 中的节点按拓扑序记为 <span class="math inline">\(y_1,y_2,\ldots,y_l\)</span>。</p>
<hr />
<p>接下来我们只要考虑 <span class="math inline">\(X,Y\)</span> 之间边的方向。</p>
<p>根据上面的讨论，我们得到了一个引理：如果存在边 <span class="math inline">\(y_j\to x_i\)</span>，那么对于所有 <span class="math inline">\(j\le j&#39;\le l\)</span>，都存在边 <span class="math inline">\(y_{j&#39;}\to x_i\)</span>。</p>
<p>根据这个引理，假设存在边 <span class="math inline">\(x_1\to y_l\)</span>，那么对于所有 <span class="math inline">\(1\le j\le l\)</span>，都存在边 <span class="math inline">\(x_1\to y_j\)</span>，这与 <span class="math inline">\(x_1\)</span> 入度大于 <span class="math inline">\(0\)</span> 矛盾，所以一定存在边 <span class="math inline">\(y_l\to x_1\)</span>。</p>
<p>接下来我们证明，对于所有 <span class="math inline">\(2\le i\le k\)</span>，假设存在边 <span class="math inline">\(x_i\to y_l\)</span>，那么对于所有 <span class="math inline">\(i &lt; i&#39; \le k\)</span>，一定存在边 <span class="math inline">\(x_{i&#39;}\to y_l\)</span>。假设存在边 <span class="math inline">\(y_l\to x_{i&#39;}\)</span>，那么 <span class="math inline">\(x_i,y_l,x_1,x_{i&#39;}\)</span> 构成了 <span class="math inline">\(H\)</span>，不合法。也就是说，存在边 <span class="math inline">\(y_l\to x_i\)</span> 的 <span class="math inline">\(i\)</span> 一定是一个前缀 <span class="math inline">\(\{1,\ldots,t\}\)</span>。</p>
<p>我们还可以证明，对于所有 <span class="math inline">\(1\le i\le t,1\le j\le l-1\)</span>，若存在边 <span class="math inline">\(x_i\to y_j\)</span>，那么对于所有 <span class="math inline">\(i &lt; i&#39; \le k\)</span>，都存在边 <span class="math inline">\(x_{i&#39;}\to y_j\)</span>。假设存在边 <span class="math inline">\(y_j\to x_{i&#39;}\)</span>，根据引理一定存在 <span class="math inline">\(y_l\to x_{i&#39;}\)</span>，那么 <span class="math inline">\(x_i,y_j,y_l,x_{i&#39;}\)</span> 构成了 <span class="math inline">\(H\)</span>，不合法。</p>
<p>我们可以将上面的结论推广到 <span class="math inline">\(1\le i\le k\)</span> 的情况，此时我们需要证明当所有 <span class="math inline">\(1\le i&#39;&#39;\le t\)</span> 都存在边 <span class="math inline">\(y_j\to x_{i&#39;&#39;}\)</span> 时，对于 <span class="math inline">\(t &lt; i &lt; i&#39; \le k\)</span>，若存在边 <span class="math inline">\(x_i\to y_j\)</span>，则一定存在边 <span class="math inline">\(x_{i&#39;}\to y_j\)</span>。假设存在边 <span class="math inline">\(y_j\to x_{i&#39;}\)</span>，则 <span class="math inline">\(x_{i&#39;&#39;},x_i,y_j,x_{i&#39;}\)</span> 会构成 <span class="math inline">\(H\)</span>，不合法。</p>
<hr />
<p>根据上面的结论，我们可以发现对于所有 <span class="math inline">\(1\le j\le l\)</span>，都存在一个 <span class="math inline">\(p_j\)</span> 满足，对于所有 <span class="math inline">\(1\le i\le p_j\)</span>，存在边 <span class="math inline">\(y_j\to x_i\)</span>；对于所有 <span class="math inline">\(p_j &lt; i\le k\)</span>，存在边 <span class="math inline">\(x_i\to y_j\)</span>。</p>
<p>根据引理，我们可以得到 <span class="math inline">\(p_j \le p_{j+1}\)</span>。</p>
<p>另外我们还需要满足 <span class="math inline">\(0\le p_j &lt; k, p_l\ge 1\)</span>。</p>
<p>可以发现只需要满足这三个条件就可以唯一构造出一个不存在 <span class="math inline">\(H\)</span> 的强连通竞赛图 <span class="math inline">\(G\)</span>。</p>
<p>那么我们只需要计算 <span class="math inline">\(p\)</span> 的方案数，DP 即可，注意判断当前的状态是否满足度数限制。</p>
<p>一次 DP 复杂度 <span class="math inline">\(O(kl)\)</span>，总复杂度 <span class="math inline">\(O(N^4)\)</span>。</p>
<p>值得一提的是，序列 <span class="math inline">\(p\)</span> 的方案数等价于不能经过两条直线的路径方案数，可以用容斥与组合数学优化到更低的复杂度。</p>
<p><a href="https://atcoder.jp/contests/agc046/submissions/16484580">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>竞赛图</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT1723」「CODE FESTIVAL 2015 OKINAWA OPEN」Automatic Map Generator</title>
    <url>/atcoder-cfoo15A-sol/</url>
    <content><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_a">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>构造一张 <span class="math inline">\(H\times W\)</span> 的由岛屿<code>#</code>、海洋<code>.</code>组成的地图，岛屿为八连通，满足恰好包含 <span class="math inline">\(K\)</span> 个联通块。</p>
<p><span class="math inline">\(1\le H,W\le 100,1\le K\le 10000\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>为了放置更多的联通块，每个联通块恰好为一个单位时显然最优。</p>
<p>所以放一张类似于下图所示的地图即可（即在奇数行奇数列放置<code>#</code>，直到放满 <span class="math inline">\(K\)</span> 个）。</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">#.#.#.#.</span><br><span class="line">........</span><br><span class="line">#.#.#.#.</span><br></pre></td></tr></table></figure>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m, t;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (t &amp;&amp; (i &amp; <span class="number">1</span>) &amp;&amp; (j &amp; <span class="number">1</span>)) a[i][j] = <span class="string">&#x27;#&#x27;</span>, --t; <span class="keyword">else</span> a[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (t) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;IMPOSSIBLE\n&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="built_in">putchar</span>(a[i][j]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT1725」「CODE FESTIVAL 2015 OKINAWA OPEN」Cat versus Wolf</title>
    <url>/atcoder-cfoo15C-sol/</url>
    <content><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_c">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定一个初始状态如图所示的建筑，共 <span class="math inline">\(n\)</span> 层（不包括 Daruma），自底向上编号 <span class="math inline">\(1\sim n\)</span>。</p>
<p>下图分别表示建筑的初始状态、奇数层的放置和偶数层的放置。</p>
<p><img src="https://code-festival-2015-okinawa.contest.atcoder.jp/img/other/code_festival_2015_okinawa/vfgagrt/C1.png" class="lazyload" data-srcset="https://code-festival-2015-okinawa.contest.atcoder.jp/img/other/code_festival_2015_okinawa/vfgagrt/C1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>Snuke 和 Sothe 轮流进行游戏，Snuke 先手，每次游戏可以拿走建筑中的任意一块砖头，但不允许拿走砖头后建筑变得<strong>不平衡</strong>。如果不存在砖头可以被拿走，那么该玩家输。</p>
<p>给定一个未结束的游戏，判断两人在绝对聪明的情况下，谁是必胜者（需要根据以拿走的砖块数量确定先手）。</p>
<p><strong>不平衡</strong>的定义是，<span class="math inline">\(n\)</span>层中，存在某层没有砖块，或只有一块砖且这块砖在两侧。</p>
<p><span class="math inline">\(n\le 50000\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>显然是个博弈问题。且层与层之间独立，所以可以看作是 <span class="math inline">\(n\)</span> 个单独的游戏的和。那么我们只要求出每一层的 SG 函数值，然后 xor 起来即可。</p>
<p>每一层只有 <span class="math inline">\(2^3-3=5\)</span> 种可能的情况，分类讨论每种情况的 SG 函数值即可。</p>
<p>游戏图如下（0 表示没有砖块，1 表示有砖块，括号内的数表示该状态的 SG 函数值）：</p>
<p><img src="/files/AT-CFOO15C-pic.png" class="lazyload" data-srcset="/files/AT-CFOO15C-pic.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, S, ans;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[j]);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; s[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; s[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span>) ans ^= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; s[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; s[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span>) ans ^= <span class="number">1</span>, ++S;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; s[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; s[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) ans ^= <span class="number">1</span>, ++S;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; s[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; s[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) S += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; s[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; s[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span>) ++S;</span><br><span class="line">        <span class="comment">// 五种情况分类讨论</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>((!ans) == (S &amp; <span class="number">1</span>) ? <span class="string">&quot;Snuke\n&quot;</span> : <span class="string">&quot;Sothe\n&quot;</span>); <span class="comment">// 注意判断先后手</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>SG函数</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Regular Contest 105 题解</title>
    <url>/atcoder-arc105/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/arc105">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---fourtune-cookies">A - Fourtune Cookies</h3>
<h4 id="题意">题意</h4>
<p>给定四个整数 <span class="math inline">\(A,B,C,D\)</span>，判断是否可以选择一个或更多个数使得这些数之和等于剩下的数之和。</p>
<h4 id="题解">题解</h4>
<p>排序，只有 <span class="math inline">\(A+D=B+C\)</span> 和 <span class="math inline">\(A+B+C=D\)</span> 两种情况。</p>
<p><a href="https://atcoder.jp/contests/arc105/submissions/17358055">代码</a></p>
<h3 id="b---max-min">B - MAX-=min</h3>
<h4 id="题意-1">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个数 <span class="math inline">\(a_i\)</span>，不断执行以下操作，直到所有数相等：</p>
<ul>
<li>将所有等于最大值的数减去最小值。</li>
</ul>
<p>求最后每个数的值。</p>
<p><span class="math inline">\(N\le 10^5,a_i\le 10^9\)</span></p>
<h4 id="题解-1">题解</h4>
<p>显然执行题目中的操作不会改变所有数的 gcd。</p>
<p>于是求出所有数的 gcd 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N+\log a_i)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/arc105/submissions/17358112">代码</a></p>
<h3 id="c---camels-and-bridge">C - Camels and Bridge</h3>
<h4 id="题意-2">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个球，第 <span class="math inline">\(i\)</span> 个球的重量为 <span class="math inline">\(w_i\)</span>。你可以将这些球按任意顺序在数轴上排列，相邻两个球的距离为任意非负实数。</p>
<p>你需要满足 <span class="math inline">\(M\)</span> 个限制，第 <span class="math inline">\(i\)</span> 个限制为数轴上任意长度为 <span class="math inline">\(l_i\)</span> 的开区间（即不包含左右端点）中的球重量之和不超过 <span class="math inline">\(k_i\)</span>。</p>
<p>求最右边的球与最左边的球的距离的最小值，或输出无解。</p>
<p><span class="math inline">\(N\le 8,M\le 10^5\)</span></p>
<h4 id="题解-2">题解</h4>
<p>枚举球的顺序，令 <span class="math inline">\(x_i\)</span> 为确定顺序后从左到右第 <span class="math inline">\(i\)</span> 个球的坐标，那么可以根据限制得到 <span class="math inline">\(x_i\)</span> 之间的若干限制。</p>
<p>根据这些限制跑差分约束即可。注意到每条边只会从前往后连，所以可以直接从前往后 DP。</p>
<p>时间复杂度 <span class="math inline">\(O(M\log M+N!\cdot N^2\log M)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/arc105/submissions/17358714">代码</a></p>
<h3 id="d---lets-play-nim">D - Let's Play Nim</h3>
<h4 id="题意-3">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个包，第 <span class="math inline">\(i\)</span> 个包有 <span class="math inline">\(a_i\)</span> 个金币。另外还有无限个空盘子。</p>
<p>A 和 B 玩游戏，A 先手，两人轮流操作，每次操作如下：</p>
<ul>
<li>若存在一个包有金币，那么选择一个有金币的包，将这个包的所有金币放到任意一个盘子上；</li>
<li>若不存在包有金币，那么选择一个有金币的盘子，取走一个或更多个金币。</li>
</ul>
<p>不能操作的人输。判断先手是否有必胜策略。</p>
<p><span class="math inline">\(N\le 10^5,a_i\le 10^9\)</span></p>
<h4 id="题解-3">题解</h4>
<p>发现包为空以后是一个 Nim 游戏。Nim 游戏先手必胜的条件是异或和大于 <span class="math inline">\(0\)</span>。</p>
<p>若干个数的最大值若超过这些数总和的一半，那么异或和一定大于 <span class="math inline">\(0\)</span>。这是因为异或的本质是不进位加法，由于最大值大于其他数的和，那么最大值一定大于其他数的异或和，所以总异或和一定不为 <span class="math inline">\(0\)</span>。</p>
<p>当 <span class="math inline">\(N\)</span> 为奇数时，最后的 Nim 游戏 B 是先手，而 B 需要使得最大值超过总和的一半很简单，只需要不断将金币最多的包放到金币最多的盘子上即可，可以证明一定满足条件。所以 <span class="math inline">\(N\)</span> 为奇数时一定是 B 获胜。</p>
<p>当 <span class="math inline">\(N\)</span> 为偶数时，最后的 Nim 游戏 A 是先手。A 为了使得最大值最大，一定是每次选最大值放到一个固定的盘子上。而 B 为了使得 A 选的数之和尽量小，每次也会选择最大值放到其他盘子中。</p>
<p>在这样的策略下，假设 <span class="math inline">\(a\)</span> 从大到小排序，若存在 <span class="math inline">\(a_{2i-1}&gt;a_{2i}\)</span>，那么 A 一定可以达到目标；否则 B 只要每次做与 A 类似的操作可以保证异或和一直为 <span class="math inline">\(0\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(N\log N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/arc105/submissions/17359783">代码</a></p>
<h3 id="e---keep-graph-disconnected">E - Keep Graph Disconnected</h3>
<h4 id="题意-4">题意</h4>
<p>有一个 <span class="math inline">\(N\)</span> 个点 <span class="math inline">\(M\)</span> 条边的无向图 <span class="math inline">\(G\)</span>。定义一个图是好的当且仅当 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(N\)</span> 不连通且没有自环和重边。保证一开始的 <span class="math inline">\(G\)</span> 是好的。</p>
<p>A 和 B 玩游戏，A 先手，两人轮流操作，每次操作为在保证 <span class="math inline">\(G\)</span> 是好的前提下加入一条边。</p>
<p>不能操作的人输。判断先手是否有必胜策略。</p>
<p><span class="math inline">\(N,M\le 10^5\)</span></p>
<h4 id="题解-4">题解</h4>
<p>显然最后两个图一定是两个分别包含 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(N\)</span> 的完全图组成的。令两个完全图的大小分别为 <span class="math inline">\(A,B\)</span>，那么新加的边数为 <span class="math inline">\(\frac{N(N-1)}{2}-M-AB\)</span>。也就是说，最后获胜的人与 <span class="math inline">\(AB\)</span> 的奇偶性有关。</p>
<p>当 <span class="math inline">\(N\)</span> 为奇数时，<span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 必有一个是偶数，那么 <span class="math inline">\(AB\)</span> 一定为偶数，只需要判断 <span class="math inline">\(\frac{N(N-1)}{2}-M\)</span> 的奇偶性即可确定胜者。</p>
<p>当 <span class="math inline">\(N\)</span> 为偶数时，记 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 为一开始 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(N\)</span> 所在连通块的大小。</p>
<p>若 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 奇偶性不同，那么其他连通块中大小为奇数的一定有奇数个，先手可以先将 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 操作成同奇或同偶，然后跟着后手操作即可。</p>
<p>否则，若先手需要的 <span class="math inline">\(AB\)</span> 奇偶性与 <span class="math inline">\(xy\)</span> 奇偶性不同，那么后手一定必胜，否则先手必胜。</p>
<p>时间复杂度 <span class="math inline">\(O(N+M)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/arc105/submissions/17366198">代码</a></p>
<h3 id="f---lights-out-on-connected-graph">F - Lights Out on Connected Graph</h3>
<h4 id="题意-5">题意</h4>
<p><strong>注意以下题意相较于原题意有一步简单的转化。</strong></p>
<p>给定一个 <span class="math inline">\(N\)</span> 个点 <span class="math inline">\(M\)</span> 条边的无向图 <span class="math inline">\(G=(V,E)\)</span>。你可以选择 <span class="math inline">\(E\)</span> 的一个子集 <span class="math inline">\(E&#39;\)</span> 得到无向图 <span class="math inline">\(G&#39;=(V,E&#39;)\)</span>。</p>
<p>求有多少 <span class="math inline">\(G&#39;\)</span> 是连通二分图。对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(N\le 17\)</span></p>
<h4 id="题解-5">题解</h4>
<p>不妨令一个二分图的权值为黑白染色方案数，即 <span class="math inline">\(2^c\)</span>，其中 <span class="math inline">\(c\)</span> 是连通块数。</p>
<p>于是我们可以求出 <span class="math inline">\(g(S)\)</span> 表示点集为 <span class="math inline">\(S\)</span> 时所有二分图的权值之和。</p>
<p>接下来我们考虑求出 <span class="math inline">\(f(S)\)</span> 表示点集为 <span class="math inline">\(S\)</span> 时所有连通二分图的权值之和。</p>
<p>考虑用所有二分图的权值之和减去不连通的二分图权值之和。令 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(S\)</span> 中任意一个点。考虑枚举 <span class="math inline">\(x\)</span> 所在的连通块 <span class="math inline">\(T\)</span>，那么权值之和即为 <span class="math inline">\(f(T)g(S-T)\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(2^NM+3^N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/arc105/submissions/17373771">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>枚举</tag>
        <tag>博弈</tag>
        <tag>容斥</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT1729」「CODE FESTIVAL 2015 OKINAWA OPEN」Gorgeous Vases</title>
    <url>/atcoder-cfoo15G-sol/</url>
    <content><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_g">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>有两个有序二元组 <span class="math inline">\((A,B),(C,D)\)</span>，<span class="math inline">\(A,B\)</span> 给定且保证 <span class="math inline">\(A\ge B\)</span>，<span class="math inline">\(C,D\)</span> 一开始为 <span class="math inline">\(0\)</span>。另外给定 <span class="math inline">\(n\)</span> 个有序二元组 <span class="math inline">\((p_i,q_i)\)</span>，有两种操作：</p>
<ol type="1">
<li><span class="math inline">\(A\gets A-1,C\gets C+1\)</span></li>
<li><span class="math inline">\(B\gets B-1,D\gets D+1\)</span></li>
</ol>
<p>不断执行这两种操作，直到二元组变为 <span class="math inline">\((0,0),(A&#39;,B&#39;)\)</span>，其中 <span class="math inline">\(A&#39;,B&#39;\)</span> 表示最初的 <span class="math inline">\(A,B\)</span>。但<strong>任意时刻</strong>都需要满足：</p>
<ol type="1">
<li><span class="math inline">\(A\ge B,C\ge D\)</span></li>
<li><span class="math inline">\(\forall i\in [1,n],(A,B)\ne (p_i,q_i),(C,D)\ne (p_i,q_i)\)</span>。</li>
</ol>
<p>求方案数 <span class="math inline">\(\bmod (10^9+7)\)</span> 的值。</p>
<p>记操作序列为由每次的操作编号组成的长度为 <span class="math inline">\(A&#39;+B&#39;\)</span> 的序列，则两个方案不同当且仅当两个方案的操作序列不同。</p>
<p><span class="math inline">\(1\le B\le A\le 10^5,0\le n\le 20\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>可以发现，题目可以转化为：</p>
<blockquote>
<p>从 <span class="math inline">\((0,0)\)</span> 走到 <span class="math inline">\((A,B)\)</span>，每次只能走 <span class="math inline">\((+1,0)\)</span> 或 <span class="math inline">\((0,+1)\)</span>（即只能向上、向右走），求满足以下条件的方案数： 1. 对于所有经过的点 <span class="math inline">\((x,y)\)</span>，<span class="math inline">\(x\ge y,A-x\ge B-y\)</span> 2. 不能经过点 <span class="math inline">\((p_i,q_i),(A-p_i,B-q_i)\)</span>。</p>
</blockquote>
<p>把 <span class="math inline">\((A,B)\)</span> 和所有不能经过的点称为障碍点，把障碍点按一定顺序排序后，可以很轻松地写出一个 DP：</p>
<p><span class="math inline">\(dp_i\)</span> 表示到达障碍点 <span class="math inline">\(i\)</span> 的方案数，则 <span class="math inline">\(dp_i=solve(0,i)-\sum dp_j+solve(j,i)\)</span>，其中 <span class="math inline">\(j\)</span> 在 <span class="math inline">\(i\)</span> 的左下方，<span class="math inline">\(solve(j,i)\)</span> 表示 <span class="math inline">\(j\)</span> 到 <span class="math inline">\(i\)</span> 的方案数，<span class="math inline">\(solve(0,i)\)</span> 表示 <span class="math inline">\((0,0)\)</span> 到 <span class="math inline">\(i\)</span> 的方案数。</p>
<p>发现关键在于如何求 <span class="math inline">\(solve(i,j)\)</span> 的值。那么问题又转化为：</p>
<blockquote>
<p>从 <span class="math inline">\((x_1,y_1)\)</span> 走到 <span class="math inline">\((x_2,y_2)\)</span>，只能向上、向右走，满足所有经过的点 <span class="math inline">\((x,y)\)</span> 在直线 <span class="math inline">\(y=x\)</span> 和 <span class="math inline">\(y=x-(A-B)\)</span> 之间（包括这两条直线上的点），求方案数。</p>
</blockquote>
<figure>
<img src="/files/at-cfoo15g-pic1.png" class="lazyload" data-srcset="/files/at-cfoo15g-pic1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /><figcaption>图 1</figcaption>
</figure>
<p>类似上图中的情况，求 <span class="math inline">\((x_1,y_2)\)</span> 到 <span class="math inline">\((x_2,y_2)\)</span> 的方案数。</p>
<p>首先，为方便起见，把两条直线分别向上、向下移动一个单位，这样我们就不能碰到这两条直线，碰到即算不符合。</p>
<p>考虑所有情况减去不符合要求的情况，所有情况可以用组合数直接计算，那么我们要计算下图中的两种情况的方案数。</p>
<figure>
<img src="/files/at-cfoo15g-pic2.png" class="lazyload" data-srcset="/files/at-cfoo15g-pic2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /><figcaption>图 2</figcaption>
</figure>
<p>我们先考虑左图的情况，可以发现，左图的情况可以把剩余部分按直线 <span class="math inline">\(y=x+1\)</span> 对称，如下图所示：</p>
<figure>
<img src="/files/at-cfoo15g-pic3.png" class="lazyload" data-srcset="/files/at-cfoo15g-pic3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /><figcaption>图 3</figcaption>
</figure>
<p>此时 <span class="math inline">\((x_1,y_1)\)</span> 到 <span class="math inline">\((x_2,y_2)\)</span> 一定会碰到 <span class="math inline">\(y=x+1\)</span>，即图 2 中左图的情况。</p>
<p>可是会发现，如果一个方案穿过了 <span class="math inline">\(y=x+1\)</span>，然后又穿过了 <span class="math inline">\(y=x-(A-B)-1\)</span>，则这个方案会被重复计算，需要减去。</p>
<p>可以发现，对称后，<span class="math inline">\(y=x-(A-B)-1\)</span> 这条直线到了最上面，即此时的情况为（下图中的左图）：</p>
<figure>
<img src="/files/at-cfoo15g-pic4.png" class="lazyload" data-srcset="/files/at-cfoo15g-pic4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /><figcaption>图 4</figcaption>
</figure>
<p>那么同样，对称后计算（如上图右图所示）。</p>
<p>如果还有重复情况（即上下上、上下上下等情况），则继续对称即可。</p>
<p>具体实现及细节见代码。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<p>注意，代码并不是每次作对称然后判断正负的，而是把所有负的都减掉，再把所有正的加上，所以与上面的分析有所出入，请仔细理解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> A, B, n, m, fac[<span class="number">200005</span>], inv[<span class="number">200005</span>], dp[<span class="number">50</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; res.x || x == res.x &amp;&amp; y &lt; res.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == res.x &amp;&amp; y == res.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[m].y &lt;= p[m].x &amp;&amp; p[m].y &gt;= p[m].x - A + B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1ll</span> * a * a % P) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1ll</span> * s * a % P;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    inv[n] = <span class="built_in">qpow</span>(fac[n], P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i) inv[i - <span class="number">1</span>] = <span class="number">1ll</span> * inv[i] * i % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x &gt; b.x || a.y &gt; b.y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[b.x - a.x + b.y - a.y] * inv[b.x - a.x] % P * inv[b.y - a.y] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123; (x += y) &gt;= P ? x -= P : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123; (x -= y) &lt; <span class="number">0</span> ? x += P : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(node a, node b)</span></span>&#123; <span class="comment">// 计算 a 到 b 的方案数，主要难在这个函数</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">F</span>(a, b), w = A - B + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> node c = (node)&#123;b.y - <span class="number">1</span>, b.x + <span class="number">1</span>&#125;; c.x &gt;= a.x; c.x -= w, c.y += w) <span class="built_in">del</span>(res, <span class="built_in">F</span>(a, c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> node c = (node)&#123;b.x - w, b.y + w&#125;; c.x &gt;= a.x; c.x -= w, c.y += w) <span class="built_in">add</span>(res, <span class="built_in">F</span>(a, c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> node c = (node)&#123;b.y + w - <span class="number">1</span>, b.x - w + <span class="number">1</span>&#125;; c.y &gt;= a.y; c.x += w, c.y -= w) <span class="built_in">del</span>(res, <span class="built_in">F</span>(a, c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> node c = (node)&#123;b.x + w, b.y - w&#125;; c.y &gt;= a.y; c.x += w, c.y -= w) <span class="built_in">add</span>(res, <span class="built_in">F</span>(a, c));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;A, &amp;B, &amp;n), <span class="built_in">pre</span>(A + B);</span><br><span class="line">    <span class="keyword">if</span> (A == B) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (!x &amp;&amp; !y) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>), <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == A &amp;&amp; x == B) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>), <span class="number">0</span>;</span><br><span class="line">        p[++m] = (node)&#123;x, y&#125;, !<span class="built_in">check</span>(m) ? --m : <span class="number">0</span>;</span><br><span class="line">        p[++m] = (node)&#123;A - x, B - y&#125;, !<span class="built_in">check</span>(m) ? --m : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>] = (node)&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, p[++m] = (node)&#123;A, B&#125;;</span><br><span class="line">    std :: <span class="built_in">sort</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + m);</span><br><span class="line">    m = std :: <span class="built_in">unique</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + m) - p - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        dp[i] = <span class="built_in">calc</span>(p[<span class="number">0</span>], p[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            (dp[i] -= <span class="number">1ll</span> * dp[j] * <span class="built_in">calc</span>(p[j], p[i]) % P) &lt; <span class="number">0</span> ? dp[i] += P : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT1726」「CODE FESTIVAL 2015 OKINAWA OPEN」Dictionary for Shiritori Game</title>
    <url>/atcoder-cfoo15D-sol/</url>
    <content><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_d">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定大小为 <span class="math inline">\(n\)</span> 的字符集和 <span class="math inline">\(m\)</span> 个单词，第 <span class="math inline">\(i\)</span> 个单词以字符 <span class="math inline">\(a_i\)</span> 开头，以字符 <span class="math inline">\(b_i\)</span> 结尾。</p>
<p>Snuke 和 Sothe 轮流玩单词接龙游戏（Snuke 先手）。每次游戏那个人必须说出一个以上个单词的末尾字符开头的单词，第一个人必须说出一个以字符 1 开头的单词。若轮到该人进行游戏时，说不出符合条件的单词，则该人失败。</p>
<p>假设两人绝对聪明，判断谁是胜者或者游戏会永远进行下去。</p>
<p><span class="math inline">\(n\le 10^5,m\le 2\times 10^5\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>每个字符当作一个状态，建出游戏图（<span class="math inline">\(a_i\to b_i\)</span>）。若游戏图中某个点的所有儿子都是必胜态，则当前点必败；若当前点的所有儿子中有一个状态是必败，则当前点必胜；否则为平局。</p>
<p>直接用 dfs 会因为有环而变得很难搞（求助路过的 dalao 帮蒟蒻看一下 <a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/submissions/3917268">代码</a>，WA 3个点 QAQ），所以考虑建反图，倒着推。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) ;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 200005</span></span><br><span class="line"><span class="keyword">int</span> n, m, f[N], h, t, Q[N], d[N];</span><br><span class="line"><span class="keyword">int</span> edge, to[M], pr[M], hd[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;  <span class="comment">// 连边</span></span><br><span class="line">    to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i)</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), <span class="built_in">addedge</span>(y, x), ++d[x]; <span class="comment">// 倒推，反向连边</span></span><br><span class="line">    h = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!d[i]) Q[++t] = i, f[i] = <span class="number">2</span>; <span class="comment">// 边界状态</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt; t)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q[++h];</span><br><span class="line">        <span class="keyword">if</span> (f[u] == <span class="number">2</span>)  <span class="comment">// 当前状态必败</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u]; i; i = pr[i])</span><br><span class="line">                !f[to[i]] ? Q[++t] = to[i] : <span class="number">0</span>, f[to[i]] = <span class="number">1</span>; <span class="comment">// 则父状态必胜</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 当前状态必胜</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u]; i; i = pr[i])</span><br><span class="line">                <span class="keyword">if</span> (!(--d[to[i]])) Q[++t] = to[i], f[to[i]] = <span class="number">2</span>; <span class="comment">// 所有后继状态都是必胜，则必败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f[<span class="number">1</span>] == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Draw\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (f[<span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;Snuke\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (f[<span class="number">1</span>] == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;Sothe\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>建图</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT1727」「CODE FESTIVAL 2015 OKINAWA OPEN」Enormous XOR Rectangle</title>
    <url>/atcoder-cfoo15E-sol/</url>
    <content><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_e">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p><span class="math inline">\(H\times W\)</span> 的矩阵，第 <span class="math inline">\(i(0\le i&lt; H)\)</span> 行第 <span class="math inline">\(j(0\le j&lt; W)\)</span> 列的数为 <span class="math inline">\(iW+j\)</span>。</p>
<p>选一个子矩阵，使得该子矩阵中所有元素 <code>xor</code> 的值最大。输出这个值。</p>
<p><span class="math inline">\(H,W\le 10^9\)</span></p>
<span id="more"></span>
</div><h2 id="分析">分析</h2><div class="story post-story">
<p>记 <span class="math inline">\(n\)</span> 为满足 <span class="math inline">\(2^{n-1} \le H\times W-1 &lt; 2^n\)</span> 的值。所以答案一定 <span class="math inline">\(&lt; 2^n\)</span>。</p>
<p>当 <span class="math inline">\(2^{n-1}-1\)</span> 与 <span class="math inline">\(2^{n-1}\)</span> 左右相邻时，由于 <span class="math inline">\((2^{n-1}-1)\text{ xor }(2^{n-1})=2^n-1\)</span>，所以答案显然为 <span class="math inline">\(2^n-1\)</span>。</p>
<p>否则，此时的情况一定是 <span class="math inline">\(2^{n-1}-1\)</span> 在某行的最后一列，<span class="math inline">\(2^{n-1}\)</span> 在这一行下面一行的第一列，所以 <span class="math inline">\(W\)</span> 此时一定能表示为 <span class="math inline">\(2^m(0\le m\le n-1)\)</span>。例如：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code"> 0  1  2  3</span></span><br><span class="line"><span class="code"> 4  5  6  7</span></span><br><span class="line"><span class="code"> 8  9 10 11</span></span><br><span class="line"><span class="section">12 13 14 15</span></span><br><span class="line"><span class="section">-----------</span></span><br><span class="line">16 17 18 19</span><br><span class="line">20 21 22 23</span><br><span class="line">24 25 26 27</span><br></pre></td></tr></table></figure>
<p>图中 <span class="math inline">\(n=5,2^{n-1}-1=15,2^{n-1}=16\)</span>。</p>
<p>这种情况下，下界显然是 <span class="math inline">\(2^n-2^m=2^n-W\)</span>，即 <span class="math inline">\((2^{n-1}-1)\text{ xor }(2^{n-1}-1+2^m)\)</span>。记这个下界为 <span class="math inline">\(d\)</span>，考虑是否有答案超过 <span class="math inline">\(d\)</span> 的情况。</p>
<p>通过观察可以发现：</p>
<ol type="1">
<li>一行中所有数的最高 <span class="math inline">\(n-m\)</span> 位都相同。</li>
<li>一列中所有数的最后 <span class="math inline">\(m\)</span> 位都相同。</li>
</ol>
<p>继续分析可以得到：</p>
<ol type="1">
<li>若选偶数行，<code>xor</code> 值的最后 <span class="math inline">\(m\)</span> 位都是 <span class="math inline">\(0\)</span>，答案 <span class="math inline">\(\le d\)</span>。</li>
<li>若选偶数列，<code>xor</code> 值的最高 <span class="math inline">\(n-m\)</span> 位都是 <span class="math inline">\(0\)</span>，答案 <span class="math inline">\(\le d\)</span>。</li>
<li>若选奇数列，考虑每一行，一定在该行中存在一个数与该行的 <code>xor</code> 值相等，且每一行的这个数一定在同一列，所以选奇数列的所有情况相当于选 <span class="math inline">\(1\)</span> 列的所有情况。那么，为了得到最优的答案，一定选择最后一列。</li>
</ol>
<p>综上，我们选择的范围变成了最后一列，选奇数行。并且，若存在这样的答案，答案最后的 <span class="math inline">\(m\)</span> 位一定都为 <span class="math inline">\(1\)</span>。那么超过 <span class="math inline">\(d\)</span> 的答案只可能是 <span class="math inline">\(2^n-1\)</span>。</p>
<p>所以，问题变成了以一个序列上的问题：</p>
<blockquote>
<p><span class="math inline">\(H\)</span> 个数，第 <span class="math inline">\(i(0\le i&lt; H)\)</span> 个数为 <span class="math inline">\(i\)</span>，问是否存在一个区间，使得这个区间的 <code>xor</code> 值为 <span class="math inline">\(2^{n-m}-1\)</span>。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> | <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>分界线左边最高位为 <span class="math inline">\(0\)</span>，右边最高位为 <span class="math inline">\(1\)</span>。由于要达到 <span class="math inline">\(2^{n-m}-1\)</span>，分界线右边必须选奇数个，才能保证最高位为 <span class="math inline">\(1\)</span>。</p>
<p>根据 <span class="math inline">\((2n)\text{ xor }(2n+1)=1\ (n\ge 0)\)</span>，可以证明分界线左边的数不需要选择。</p>
<p>根据 <span class="math inline">\(0\text{ xor }1\text{ xor }2\text{ xor }\cdots\text{ xor }(2^n-1)=0 \ (n\ge 2)\)</span>，可以证明右边若要选出 <span class="math inline">\(2^{n-m}-1\)</span>，必须选择 <span class="math inline">\(2^{n-m-1}\sim 2^{n-m}-2\)</span> 的所有数。</p>
<p>注意上述结论是一般情况，<span class="math inline">\(n-m\)</span> 特别小时可以特殊处理，不过仍然可以证明下面总结中的结论是正确的。</p>
</div><h2 id="结论">结论</h2><div class="story post-story">
<p>根据上面的分析、推导和转化，可以得到如下结论：</p>
<p>若 <span class="math inline">\(W\)</span> 不是 <span class="math inline">\(2\)</span> 的幂次，或者 <span class="math inline">\(H\)</span> 是 <span class="math inline">\(2\)</span> 的幂次，或者 <span class="math inline">\(H+1\)</span> 是 <span class="math inline">\(2\)</span> 的幂次，则答案为 <span class="math inline">\(2^n-W\)</span>，否则答案为 <span class="math inline">\(2^n-1\)</span>。</p>
<h3 id="技巧">技巧</h3>
<p>判断一个数是否是 <span class="math inline">\(2\)</span> 的幂次，可以根据 <span class="math inline">\(lowbit\)</span> 与该数本身是否相等来判断。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x &amp; -x) == x; &#125; <span class="comment">// 技巧</span></span><br><span class="line"><span class="keyword">int</span> H, W, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;H, &amp;W);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">1ll</span> * H * W - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp) ++n, tmp &gt;&gt;= <span class="number">1</span>; <span class="comment">// 求 n</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">check</span>(W) || <span class="built_in">check</span>(H) || <span class="built_in">check</span>(H + <span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="number">1ll</span> &lt;&lt; n) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="number">1ll</span> &lt;&lt; n) - W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT1728」「CODE FESTIVAL 2015 OKINAWA OPEN」Falconry</title>
    <url>/atcoder-cfoo15F-sol/</url>
    <content><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_f">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定平面上 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\((x_i,y_i)\)</span>，以及三只鸟的初始坐标 <span class="math inline">\((x_a,y_a),(x_b,y_b),(x_c,y_c)\)</span>。现在三只鸟要从初始点开始，依次飞到一些点（不需要回到起点），要求每个点至少被一只鸟飞到。求三只鸟总飞行距离之和的最小值。</p>
<p>从一个点 <span class="math inline">\((x_s,y_s)\)</span> 飞到另一个点 <span class="math inline">\((x_t,y_t)\)</span> 的飞行距离为这两个点的欧几里得距离，即 <span class="math display">\[\sqrt{(x_s - x_t)^2 + (y_s - y_t)^2}\]</span></p>
<p><span class="math inline">\(n\le 18\)</span>，所有横纵坐标的绝对值 <span class="math inline">\(\le 10^4\)</span>，时限 <span class="math inline">\(8s\)</span>。</p>
<span id="more"></span>
</div><h2 id="方法一">方法一</h2><div class="story post-story">
<p>三只鸟很难考虑，考虑一只鸟飞遍某个点集所需的最少时间。</p>
<p>记 <span class="math inline">\(dp_{t,i,j}\)</span> 表示第 <span class="math inline">\(t\)</span> 只鸟，飞遍点集 <span class="math inline">\(i\)</span>，最后停留在点 <span class="math inline">\(j\)</span> 的最小距离和。</p>
<p>转移很显然，只要在点集 <span class="math inline">\(i\)</span> 中枚举上一个点 <span class="math inline">\(k\)</span>，然后直接转移即可。</p>
<p>最后枚举每只鸟飞到的点集即可，因为两只鸟飞到的点集不会有交，所以复杂度为 <span class="math inline">\(O(3^n)\)</span>。具体实现时，可以枚举一个集合 <span class="math inline">\(A\)</span>，再枚举这个集合的子集 <span class="math inline">\(B\)</span>，假设全集为 <span class="math inline">\(C\)</span>，则三个集合分别为 <span class="math inline">\(B,A-B,C-A\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(3n^22^n+3^n)\)</span>，常数不大，最大点 <span class="math inline">\(2898ms\)</span>（<a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/submissions/3961803">评测记录</a>）。</p>
</div><h2 id="方法二">方法二</h2><div class="story post-story">
<p>发现上面的方法比较慢，且主要在于 <span class="math inline">\(3^n\)</span> 的统计答案。考虑直接在第二只鸟、第三只鸟 DP 时，直接合并答案。</p>
<p>记 <span class="math inline">\(dp_{t,i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 只鸟，飞遍点集 <span class="math inline">\(i\)</span>，第 <span class="math inline">\(i\)</span> 只鸟停留在点 <span class="math inline">\(j\)</span> 时的最小距离和。</p>
<p>主要转移方程与方法一差不多，但是有一些细节需要注意，例如飞到第一个点时需要特殊转移，具体参见代码。也许有更好的、细节更少的写法，欢迎分享。</p>
<p>时间复杂度 <span class="math inline">\(O(3n^22^n)\)</span>，最大点 <span class="math inline">\(535ms\)</span>（<a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/submissions/4218967">评测记录</a>）。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<h3 id="方法一-1">方法一</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;a[<span class="number">20</span>], b[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">double</span> Dp[<span class="number">3</span>][<span class="number">300000</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(point a, point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;b[i].x, &amp;b[i].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">3</span>; ++t)&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">double</span></span> (*dp)[<span class="number">20</span>] = Dp[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">                dp[i][j] = <span class="number">1e100</span>;</span><br><span class="line">        dp[<span class="number">0</span>][n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) dp[<span class="number">1</span> &lt;&lt; i][i] = <span class="built_in">dis</span>(b[t], a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">                        <span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span> &amp;&amp; k != j)</span><br><span class="line">                            dp[i][j] = std :: <span class="built_in">min</span>(dp[i][j], dp[<span class="number">1</span> &lt;&lt; j ^ i][k] + <span class="built_in">dis</span>(a[k], a[j]));</span><br><span class="line">                    dp[i][n] = std :: <span class="built_in">min</span>(dp[i][n], dp[i][j]); <span class="comment">// 这个状态记录0~n-1的最小值</span></span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1e100</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j = (j - <span class="number">1</span>) &amp; i)&#123;</span><br><span class="line">            <span class="keyword">int</span> A = j, B = i ^ j, C = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) ^ i;</span><br><span class="line">            ans = std :: <span class="built_in">min</span>(ans, Dp[<span class="number">0</span>][A][n] + Dp[<span class="number">1</span>][B][n] + Dp[<span class="number">2</span>][C][n]);</span><br><span class="line">            <span class="keyword">if</span> (!j) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.12lf\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二-1">方法二</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;a[<span class="number">20</span>], b;</span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">3</span>][<span class="number">300000</span>][<span class="number">20</span>], d[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(point a, point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">3</span>; ++t)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;b.x, &amp;b.y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">                dp[t][i][j] = <span class="number">1e100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                d[i][j] = <span class="built_in">dis</span>(a[i], a[j]);</span><br><span class="line">        dp[t][<span class="number">0</span>][n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) dp[t][<span class="number">1</span> &lt;&lt; i][i] = <span class="built_in">dis</span>(b, a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[t][i][n] = std :: <span class="built_in">min</span>(t ? dp[t - <span class="number">1</span>][i][n] : <span class="number">1e100</span>, dp[t][i][n]); <span class="comment">// 特殊转移 1</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">                        <span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span> &amp;&amp; k != j)</span><br><span class="line">                            dp[t][i][j] = std :: <span class="built_in">min</span>(dp[t][i][j], dp[t][<span class="number">1</span> &lt;&lt; j ^ i][k] + d[k][j]);</span><br><span class="line">                    dp[t][i][j] = std :: <span class="built_in">min</span>(dp[t][i][j], t ? dp[t - <span class="number">1</span>][<span class="number">1</span> &lt;&lt; j ^ i][n] + <span class="built_in">dis</span>(b, a[j]) : <span class="number">1e100</span>); <span class="comment">// 特殊转移 2</span></span><br><span class="line">                    dp[t][i][n] = std :: <span class="built_in">min</span>(dp[t][i][n], dp[t][i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.12lf\n&quot;</span>, dp[<span class="number">2</span>][(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有更好的写法或复杂度更优的做法请在评论中分享！</p>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT1730」「CODE FESTIVAL 2015 OKINAWA OPEN」Happy 2015</title>
    <url>/atcoder-cfoo15H-sol/</url>
    <content><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_h">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定 <span class="math inline">\(n\)</span> 个区间 <span class="math inline">\((l_r,r_i]\)</span>（注意原题中虽然写着 <span class="math inline">\([l_i,r_i]\)</span>，但通过转化后相当于 <span class="math inline">\((l_i,r_i]\)</span>），每个区间有存在和不存在两种状态。求所有 <span class="math inline">\(2^n\)</span> 种方案中，<strong>本质不同</strong>的方案的数量 <span class="math inline">\(\bmod (10^9+7)\)</span> 的值。</p>
<p>记一个方案的<strong>点集合</strong>为数轴上至少被一个区间覆盖的整数组成的集合，则两个方案<strong>本质不同</strong>当且仅当这两个方案的<strong>点集合</strong>不同。</p>
<p><span class="math inline">\(n\le 2000,0\le l_i&lt; r_i\le 10^9\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>为方便处理，我们把 <span class="math inline">\(l_i\)</span> 加 <span class="math inline">\(1\)</span> 使得区间变为闭区间。</p>
<p>显然，<span class="math inline">\(l_i,r_i\)</span> 可以离散，所以坐标变为 <span class="math inline">\(O(n)\)</span> 级别。</p>
<p>然后考虑一个 DP，<span class="math inline">\(dp_{i,0/1}\)</span> 表示覆盖前 <span class="math inline">\(i\)</span> 个点，且第 <span class="math inline">\(i\)</span> 个点必须覆盖/不覆盖的本质不同的方案数。</p>
<p>那么可以写出一个 <span class="math inline">\(O(n^2)\)</span> 的 DP，方程如下：<span class="math display">\[dp_{i,j}=\begin{cases} dp_{i-1,0}+dp_{i-1,1} &amp; \text{ if } j=0 \\ \sum\limits_{cov(k,i)=1} dp_{k-1,0} &amp; \text{ if } j=1 \end{cases}\]</span></p>
<p>其中 <span class="math inline">\(cov(k,i)=0/1\)</span> 表示是否存在一种区间覆盖方案使得刚好覆盖 <span class="math inline">\([k,i]\)</span>。</p>
<p><span class="math inline">\(cov(i,j)\)</span> 可以用如下方式处理：</p>
<p>记 <span class="math inline">\(p_i\)</span>（一个 vector） 表示所有右端点为 <span class="math inline">\(i\)</span> 的区间的左端点。</p>
<p>枚举 <span class="math inline">\(i\)</span>（被覆盖部分的左端点），首先枚举所有左端点为 <span class="math inline">\(i\)</span> 的区间 <span class="math inline">\([i,r_j]\)</span>，使得 <span class="math inline">\(cov(i,r_j)=1\)</span>。</p>
<p>然后枚举所有右端点 <span class="math inline">\(j\)</span>，再枚举所有右端点为 <span class="math inline">\(j\)</span> 的区间（即 <span class="math inline">\([p_{j,k},j]\)</span> ），若 <span class="math inline">\(p_{j,k}&gt; i\)</span> 且存在一个 <span class="math inline">\(x\in [p_{j,k},j]\)</span> 满足 <span class="math inline">\(cov(i,x)=1\)</span>，则 <span class="math inline">\(cov(i,j)=1\)</span>。</p>
<p>至于如何判断“存在一个 <span class="math inline">\(x\in [p_{j,k},j]\)</span> 满足 <span class="math inline">\(cov(i,x)=1\)</span>”，可以在枚举右端点求 <span class="math inline">\(cov(i,j)\)</span> 的同时用前缀和进行判断，具体实现见代码。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n, m, pos[<span class="number">4005</span>], sum[<span class="number">4005</span>], dp0[<span class="number">4005</span>], dp1[<span class="number">4005</span>];</span><br><span class="line"><span class="keyword">bool</span> cov[<span class="number">4005</span>][<span class="number">4005</span>];</span><br><span class="line">std :: vector&lt;<span class="keyword">int</span>&gt; p[<span class="number">4005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;a[<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    (x += y) &gt;= P ? x -= P : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a[i].l, &amp;a[i].r), pos[++m] = a[i].l, pos[++m] = a[i].r;</span><br><span class="line">    std :: <span class="built_in">sort</span>(pos + <span class="number">1</span>, pos + <span class="number">1</span> + m);</span><br><span class="line">    m = std :: <span class="built_in">unique</span>(pos + <span class="number">1</span>, pos + <span class="number">1</span> + m) - pos - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        a[i].l = std :: <span class="built_in">lower_bound</span>(pos + <span class="number">1</span>, pos + <span class="number">1</span> + m, a[i].l) - pos + <span class="number">1</span>;</span><br><span class="line">        a[i].r = std :: <span class="built_in">lower_bound</span>(pos + <span class="number">1</span>, pos + <span class="number">1</span> + m, a[i].r) - pos;</span><br><span class="line">        p[a[i].r].<span class="built_in">push_back</span>(a[i].l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以上分别为：转为闭区间、离散、处理 p</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        sum[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[j].l == i) cov[i][a[j].r] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt;= m; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p[j].<span class="built_in">size</span>(); ++k)</span><br><span class="line">                <span class="keyword">if</span> (p[j][k] &gt; i &amp;&amp; sum[j] &gt; sum[p[j][k] - <span class="number">1</span>])&#123; cov[i][j] = <span class="number">1</span>; <span class="keyword">break</span>; &#125; <span class="comment">// 根据前缀和判断</span></span><br><span class="line">            sum[j + <span class="number">1</span>] = sum[j] + cov[i][j]; <span class="comment">// 同时处理前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以上为处理 cov</span></span><br><span class="line">    dp0[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="built_in">add</span>(dp0[i], dp0[i - <span class="number">1</span>]), <span class="built_in">add</span>(dp0[i], dp1[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (cov[j][i]) <span class="built_in">add</span>(dp1[i], dp0[j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以上为 dp</span></span><br><span class="line">    <span class="built_in">add</span>(dp0[m], dp1[m]), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp0[m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>离散</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT1731」「CODE FESTIVAL 2015 OKINAWA OPEN」Implementation Addict</title>
    <url>/atcoder-cfoo15I-sol/</url>
    <content><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_i">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>有 <span class="math inline">\(n\)</span> 天，每天有一个值 <span class="math inline">\(a_i\)</span>（未确定的值），其中 <span class="math inline">\(a_i=0\)</span> 的天数称为“休息”，其他的称为“工作”。</p>
<p>若第 <span class="math inline">\(i\)</span> 天为“工作”，设第 <span class="math inline">\(i\)</span> 天之前（不包含第 <span class="math inline">\(i\)</span> 天）连续“工作”的天数为 <span class="math inline">\(k\)</span>，则 <span class="math inline">\(a_i=\max(0,A-kB)\)</span>（<span class="math inline">\(A,B\)</span> 给定）；若第 <span class="math inline">\(i\)</span> 天为“休息”，则 <span class="math inline">\(a_i=0\)</span>。</p>
<p>现已经确定 <span class="math inline">\(m\)</span> 天为“休息”，求 <span class="math inline">\(\sum_{i=1}^{n} a_i\)</span> 的最大值。</p>
<p><span class="math inline">\(n,A,B\le 10^9,m\le 10^5\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p><span class="math inline">\(m\)</span> 天“休息”，相当于把 <span class="math inline">\(n\)</span> 分成了 <span class="math inline">\(m+1\)</span> 份，每份是独立的，所以可以分别进行计算。所以，现在不再需要考虑 <span class="math inline">\(m\)</span> 天“休息”。假设当前子问题的天数为 <span class="math inline">\(n\)</span>。</p>
<p>为了使得和最大，一定是等分更优。例如 <span class="math inline">\(n=7\)</span>，分成 <span class="math inline">\(3\)</span> 块（即“休息” <span class="math inline">\(2\)</span> 天），则一定是分别工作 <span class="math inline">\(1,2,2\)</span> 天。为方便处理，可以将 <span class="math inline">\(n\)</span> 加 <span class="math inline">\(1\)</span>，钦定最后一天为“休息”。</p>
<p>假设分成 <span class="math inline">\(x\)</span> 块，设 <span class="math inline">\(t=\left\lfloor \frac{n}{x}\right\rfloor-1\)</span>，则一定是 <span class="math inline">\(n\bmod x\)</span> 块工作 <span class="math inline">\(t+1\)</span> 天，<span class="math inline">\(x-n\bmod x\)</span> 块工作 <span class="math inline">\(t\)</span> 天。这个可以直接用等差数列求和公式进行计算。</p>
<p>至于如何确定 <span class="math inline">\(x\)</span>，可以发现，答案是一个单峰函数，所以直接三分 <span class="math inline">\(x\)</span> 即可。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m, x[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A, B, ans;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 计算 n 天分成 x 块的答案</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = n / x - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((A + A - (m - <span class="number">1</span>) * B) * m &gt;&gt; <span class="number">1</span>) * x + (A - m * B) * (n % x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 三分求 n 天的答案</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> md = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">// 写的有点像二分，其实是三分</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(n, md) &gt;= <span class="built_in">get</span>(n, md + <span class="number">1</span>)) ans = md, r = md - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = md + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(n, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld%d&quot;</span>, &amp;n, &amp;A, &amp;B, &amp;m), x[m + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, x + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) ans += <span class="built_in">solve</span>(x[i + <span class="number">1</span>] - x[i]); <span class="comment">// n 在这里已经加 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT1732」「CODE FESTIVAL 2015 OKINAWA OPEN」Jungle</title>
    <url>/atcoder-cfoo15J-sol/</url>
    <content><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_j">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>有 <span class="math inline">\(n\)</span> 棵树，第 <span class="math inline">\(i\)</span> 棵树高度为 <span class="math inline">\(a_i\)</span>。你需要砍掉一些树，砍树规则如下：</p>
<ol type="1">
<li>只能砍最多 <span class="math inline">\(m\)</span> 棵树。</li>
<li>对于每个 <span class="math inline">\(i\ (1\le i\le n-k+1)\)</span>，满足 <span class="math inline">\([i,i+k-1]\)</span> 中被砍掉的树的数量不超过 <span class="math inline">\(1\)</span>。</li>
</ol>
<p>被砍掉的树的位置的高度都变为 <span class="math inline">\(0\)</span>。</p>
<p>求砍树后 <span class="math inline">\(\max\limits_{1\le i\le n-k+1}\sum\limits_{j=i}^{i+k-1} a_j\)</span> 的最小值，即最小化所有长度为 <span class="math inline">\(k\)</span> 的区间的树的高度之和的最大值。</p>
<p><span class="math inline">\(n\le 10^5,a_i\le 10^9\)</span></p>
<span id="more"></span>
</div><h2 id="一个错误但可以-ac-的贪心解法">一个错误但可以 AC 的贪心解法</h2><div class="story post-story">
<p>求出 <span class="math inline">\(sum_i\)</span> 表示以 <span class="math inline">\(i\)</span> 结尾的长度为 <span class="math inline">\(k\)</span> 的区间的 <span class="math inline">\(a_i\)</span> 之和。然后求出 <span class="math inline">\(mx_i\)</span> 表示所有包含 <span class="math inline">\(i\)</span> 的长度为 <span class="math inline">\(k\)</span> 的区间中，最大的 <span class="math inline">\(sum_j\)</span> 减去 <span class="math inline">\(a_i\)</span> 的值，即 <span class="math inline">\(mx_i=\max\limits_{i\le j&lt; i+k}sum_j-a_i\)</span>。</p>
<p>显然可以二分。二分答案 <span class="math inline">\(x\)</span> 后，问题变成了一个判定性问题。</p>
<blockquote>
<p>是否存在一种砍树的方法，使得所有长度为 <span class="math inline">\(k\)</span> 的区间的树的高度之和都不超过 <span class="math inline">\(x\)</span>。</p>
</blockquote>
<p>可以发现，若一棵树 <span class="math inline">\(i\)</span> 能砍，必须满足 <span class="math inline">\(mx_i\le x\)</span>。对于每个不符合要求的区间，选择该区间中最后一棵能砍的树砍掉。可以发现，优先选最后一棵有时候是不优的，例如</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">[O <span class="meta">X</span> <span class="meta">X</span> O] <span class="meta">X</span> [O <span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span>]</span><br></pre></td></tr></table></figure>
<p>这种情况（<code>O</code> 表示可以砍的树，<code>X</code> 表示不能砍的树，<code>[...]</code> 表示不符合条件的区间），显然方案是选两个区间的第一棵树。若优先选最后一棵，如果不考虑前后两个区间选择的树的距离，虽然也能得到“能”的答案，但方案是不满足要求的，可以用 <code>[X X X O] X [O X X X]</code> 的数据卡掉；如果考虑前后两个区间选择的树的距离，则会得到“不能”的答案，也是错误的。</p>
<p>我没有考虑前后两个区间选择的树的距离，所以 <code>[X X X O] X [O X X X]</code> 这种数据会得到一个偏小的答案，然而可以 AC。</p>
<p>附 hack 数据：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">10 </span><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span> <span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">5</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>答案是 <span class="math inline">\(9\)</span>，我的代码会输出 <span class="math inline">\(8\)</span>。</p>
</div><h2 id="贪心算法代码">贪心算法代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n, m, k, a[N], h, t, Q[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N], id[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> *cp)</span></span>&#123; <span class="comment">// 单调队列</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt;= t &amp;&amp; cp[Q[t]] &lt;= cp[x]) --t;</span><br><span class="line">    Q[++t] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    h = <span class="number">1</span>, t = <span class="number">1</span>, Q[t] = k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i + k &lt;= n ? <span class="built_in">push</span>(i + k, sum) : <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>), ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[h] &lt; i) ++h;</span><br><span class="line">        <span class="keyword">if</span> (sum[Q[h]] - a[i] &lt;= x) id[i] = i; <span class="keyword">else</span> id[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    h = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="built_in">push</span>(i, id);</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>; i &lt;= n - k + <span class="number">1</span>; <span class="built_in">push</span>(i + k, id), ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[h] &lt; i) ++h;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum[i + k - <span class="number">1</span>] &lt;= x) <span class="keyword">continue</span>;</span><br><span class="line">        p = <span class="built_in"><span class="keyword">int</span></span>(id[Q[h]]), ++s;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i] - (i &gt; k ? a[i - k] : <span class="number">0</span>); <span class="comment">// 求 sum</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>, r = <span class="number">100000000000000ll</span>, md, ans;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) <span class="keyword">if</span> (<span class="built_in">check</span>(md = (l + r) &gt;&gt; <span class="number">1</span>)) ans = md, r = md - <span class="number">1</span>; <span class="keyword">else</span> l = md + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="正确的解法">正确的解法</h2><div class="story post-story">
<h3 id="一个正确但效率较低的二分-dp-解法">一个正确但效率较低的二分 +DP 解法</h3>
<p>仍然求出 <span class="math inline">\(sum_i,mx_i\)</span>，考虑二分。</p>
<p>考虑用 <span class="math inline">\(O(nk)\)</span> 的时间进行一个 DP 来判断。</p>
<p>首先考虑这样一个 DP 状态：<span class="math inline">\(dp_i\)</span> 表示前 <span class="math inline">\(i\)</span> 棵树（不包括 <span class="math inline">\(i\)</span>），满足所有长度为 <span class="math inline">\(k\)</span> 的区间的和都不超过 <span class="math inline">\(x\)</span>，且第 <span class="math inline">\(i-k\)</span> 棵树<strong>必砍</strong>时，最少需要砍多少棵树。</p>
<p>考虑主动转移，枚举下一棵砍的树 <span class="math inline">\(i+j\ (j\ge 0)\)</span>，若可以砍 <span class="math inline">\(i+j\)</span>（即满足 <span class="math inline">\(mx_{i+j}\le x\)</span> 且 <span class="math inline">\(\max\limits_{i\le p&lt; i+j} sum_p\le x\)</span>），则 <span class="math inline">\(dp_{i+j+k}\gets \min(dp_{i+j+k},dp_{i}+1)\)</span>。</p>
<p>然而直接这样做是 <span class="math inline">\(O(n^2)\)</span> 的。通过观察发现，若 <span class="math inline">\(j\ge k\)</span>，则可以把 <span class="math inline">\(dp_i\)</span> 先转移到 <span class="math inline">\(dp_{i+k}\)</span>，再把 <span class="math inline">\(dp_{i+k}\)</span> 向前转移。于是，我们只需要考虑 <span class="math inline">\(0\le j&lt; k\)</span> 即可。时间复杂度优化为 <span class="math inline">\(O(nk)\)</span>。</p>
<p>总的时间复杂度为 <span class="math inline">\(O(nk\log ans)\)</span>。</p>
<h3 id="另一个正确但效率较低的-dp-解法">另一个正确但效率较低的 DP 解法</h3>
<p>仍然求出 <span class="math inline">\(sum_i,mx_i\)</span>，但不二分，直接进行 DP。</p>
<p><span class="math inline">\(dp_{i,j}\)</span> 表示前 <span class="math inline">\(j\)</span> 棵树，砍了 <span class="math inline">\(i\)</span> 棵，<span class="math inline">\(j\)</span> 必须砍时 <span class="math inline">\(\max\limits_{k\le p&lt; j+k}sum_p\)</span> 的最小值。</p>
<p>当 <span class="math inline">\(i\)</span> 确定时，记 <span class="math inline">\(Mx_j\)</span> 表示前 <span class="math inline">\(j\)</span> 棵树（不包括 <span class="math inline">\(j\)</span>），砍了 <span class="math inline">\(i-1\)</span> 棵树且最后一棵砍的树 <span class="math inline">\(t\)</span> 满足 <span class="math inline">\(j-t\ge k\)</span> 的 <span class="math inline">\(\max\limits_{k\le p&lt; j} sum_p\)</span> 的最小值。</p>
<p>其实求 <span class="math inline">\(Mx_j\)</span> 的过程相当于一个 DP 的过程，显然有两种决策：当 <span class="math inline">\(t&lt; j-k\)</span> 时，<span class="math inline">\(Mx_j=\max(Mx_{j-1},sum_{j-1})\)</span>；当 <span class="math inline">\(t=j-k\)</span> 时，<span class="math inline">\(Mx_j=dp_{i-1,j-k}\)</span>。所以有 <span class="math inline">\(Mx_j=\min(\max(Mx_{j-1},sum_{j-1}),dp_{i-1,j-k})\)</span>。</p>
<p>求出 <span class="math inline">\(Mx_j\)</span> 后，求 <span class="math inline">\(dp_{i,j}\)</span> 就变得很显然：<span class="math inline">\(dp_{i,j}=\max(Mx_j,mx_j)\)</span>，分别表示 <span class="math inline">\(\max\limits_{k\le p&lt; j}sum_p\)</span> 的最小值，以及 <span class="math inline">\(\max\limits_{j\le p&lt; j+k}sum_p\)</span> 的最小值，这两部分互不影响，所以可以独立计算。</p>
<p>求出 <span class="math inline">\(dp_{i,j}\)</span> 后，求答案也变得很显然：由于 <span class="math inline">\(dp_{m,j}\)</span> 并没有包括 <span class="math inline">\(\max\limits_{j+k\le p\le n}sum_p\)</span>，把这部分与 <span class="math inline">\(dp_{m,j}\)</span> 取 <span class="math inline">\(\max\)</span> 即可。</p>
<p>可以使用滚动数组优化内存。时间复杂度为 <span class="math inline">\(O(nm)\)</span>。</p>
<h3 id="正解两者之并">正解——两者之并</h3>
<p>可以发现，<span class="math inline">\(m&gt; \lceil \frac{n}{k}\rceil\)</span> 与 <span class="math inline">\(m= \lceil \frac{n}{k}\rceil\)</span> 的情况答案是相同的。所以 <span class="math inline">\(m\)</span> 最大为 <span class="math inline">\(\lceil \frac{n}{k}\rceil\)</span>。</p>
<p>上面的两个 DP，可以发现当 <span class="math inline">\(k\le 50\)</span> 时第一个 DP 是可以过的。而 <span class="math inline">\(k&gt;50\)</span> 时，由于 <span class="math inline">\(m\)</span> 的级别是 <span class="math inline">\(\frac{n}{k}\)</span>，第二个 DP 可以过。</p>
<p>那么把两者合并一下就可以通过此题。</p>
</div><h2 id="正解代码">正解代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n, m, k, a[N], h, t, Q[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N], mx[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 单调队列维护</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt;= t &amp;&amp; sum[Q[t]] &lt;= sum[x]) --t;</span><br><span class="line">    Q[++t] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Subtask1&#123; <span class="comment">// 二分+DP O(nk log ans)</span></span><br><span class="line">    <span class="keyword">int</span> dp[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n + <span class="number">1</span>) i = n + <span class="number">1</span>;</span><br><span class="line">        dp[i] = std :: <span class="built_in">min</span>(dp[i], j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) dp[i] = <span class="number">1e9</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> Mx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; i + j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Mx &lt;= x &amp;&amp; mx[i + j] &lt;= x) <span class="built_in">upd</span>(i + j + k, dp[i] + <span class="number">1</span>);</span><br><span class="line">                Mx = std :: <span class="built_in">max</span>(Mx, sum[i + j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if (x == 0) printf(&quot;%d %lld\n&quot;, i, Mx);</span></span><br><span class="line">            <span class="keyword">if</span> (Mx &lt;= x) <span class="built_in">upd</span>(i + k, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n + <span class="number">1</span>] &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>, r = <span class="number">1e14</span>, md, ans;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) <span class="keyword">if</span> (<span class="built_in">check</span>(md = (l + r) &gt;&gt; <span class="number">1</span>)) ans = md, r = md - <span class="number">1</span>; <span class="keyword">else</span> l = md + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Subtask2&#123; <span class="comment">// DP O(nm)=O(n^2/k)</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">2</span>][N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> Mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; k) Mx = std :: <span class="built_in">max</span>(Mx, sum[i - <span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][i] = std :: <span class="built_in">max</span>(Mx, mx[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = i &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> Mx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; k) Mx = std :: <span class="built_in">max</span>(Mx, sum[j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; k) Mx = std :: <span class="built_in">min</span>(Mx, dp[!t][j - k]);</span><br><span class="line">                dp[t][j] = std :: <span class="built_in">max</span>(Mx, mx[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0x3f3f3f3f3f3f3f3f</span>ll;</span><br><span class="line">        Mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= n) Mx = std :: <span class="built_in">max</span>(Mx, sum[i + k]);</span><br><span class="line">            ans = std :: <span class="built_in">min</span>(ans, std :: <span class="built_in">max</span>(dp[m &amp; <span class="number">1</span>][i], Mx));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    m = std :: <span class="built_in">min</span>(m, n / k + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i] - (i &gt; k ? a[i - k] : <span class="number">0</span>);</span><br><span class="line">    h = <span class="number">1</span>, t = <span class="number">1</span>, Q[t] = k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i + k &lt;= n ? <span class="built_in">push</span>(i + k) : <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>), ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[h] &lt; i) ++h;</span><br><span class="line">        mx[i] = sum[Q[h]] - a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">2005</span>) <span class="keyword">return</span> Subtask2 :: <span class="built_in">Main</span>(), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">55</span>) <span class="keyword">return</span> Subtask1 :: <span class="built_in">Main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>二分</tag>
        <tag>单调队列</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>DISCO Presents Discovery Channel Code Contest 2020 Qual 题解</title>
    <url>/atcoder-ddcc2020-qual/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/ddcc2020-qual">比赛地址</a></p>
<span id="more"></span>
<p>A 就不写了。</p>
<h3 id="b---iron-bar-cutting">B - Iron Bar Cutting</h3>
<h4 id="题意">题意</h4>
<p>有一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A_1,A_2,\ldots,A_n\)</span>，每次操作你可以将某个数加 <span class="math inline">\(1\)</span> 或减 <span class="math inline">\(1\)</span>，求使得序列满足以下条件的最小操作次数：</p>
<ul>
<li>存在一个 <span class="math inline">\(1\le i &lt; n\)</span>，满足 <span class="math inline">\(\sum\limits_{j=1}^{i}A_j=\sum\limits_{j=i+1}^{n}A_j\)</span>。</li>
</ul>
<p><span class="math inline">\(n\le 2\times 10^5\)</span></p>
<h4 id="题解">题解</h4>
<p>当固定 <span class="math inline">\(i\)</span> 时，由于可以任意加减，最小操作次数显然是前面部分的和与后面部分的和的差的绝对值。对所有 <span class="math inline">\(i\)</span> 取 <span class="math inline">\(\min\)</span> 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/ddcc2020-qual/submissions/16760029">代码</a></p>
<h3 id="c---strawberry-cakes">C - Strawberry Cakes</h3>
<h4 id="题意-1">题意</h4>
<p>在 <span class="math inline">\(H\times W\)</span> 的网格中有 <span class="math inline">\(K\)</span> 个黑色格子，你需要构造一组将网格划分成 <span class="math inline">\(K\)</span> 个矩形的方案，使得每个矩形内有恰好一个黑色格子。</p>
<p><span class="math inline">\(H,W\le 300\)</span></p>
<h4 id="题解-1">题解</h4>
<p>只有一行时构造非常简单。</p>
<p>当每行都有至少一个黑色格子时，每行独立按只有一行的方式构造即可。</p>
<p>当存在一些行没有黑色格子时，只要将上一行或下一行的构造延伸到这一行即可，显然仍然是矩形。</p>
<p>时间复杂度 <span class="math inline">\(O(HW)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/ddcc2020-qual/submissions/16760238">代码</a></p>
<h3 id="d---digit-sum-replace">D - Digit Sum Replace</h3>
<h4 id="题意-2">题意</h4>
<p>有一个正整数 <span class="math inline">\(N\)</span>，每次可以执行如下操作，直到 <span class="math inline">\(N\le 9\)</span>：</p>
<ul>
<li>在 <span class="math inline">\(N\)</span> 的十进制表示中，选择相邻的两位，并将这两位替换成他们的和。</li>
</ul>
<p>如 <span class="math inline">\(N=2378\)</span>，则可以执行一次操作变成 <span class="math inline">\(578\)</span>，<span class="math inline">\(2108\)</span> 或 <span class="math inline">\(2315\)</span>。</p>
<p>求最多可以执行多少次操作。</p>
<p><span class="math inline">\(N\)</span> 的给定方式为，给定两个序列 <span class="math inline">\(d_1,\ldots,d_M\)</span> 和 <span class="math inline">\(c_1,\ldots,c_M\)</span>，<span class="math inline">\(N\)</span> 的十进制表示为 <span class="math inline">\(c_1\)</span> 个 <span class="math inline">\(d_1\)</span>，紧接着 <span class="math inline">\(c_2\)</span> 个 <span class="math inline">\(d_2\)</span>，以此类推，最后有 <span class="math inline">\(c_M\)</span> 个 <span class="math inline">\(d_M\)</span>。</p>
<p><span class="math inline">\(M\le 2\times 10^5,\sum c_i\le 10^{15}\)</span></p>
<h4 id="题解-2">题解</h4>
<p>注意到一次操作会导致 <span class="math inline">\(N\)</span> 的位数 <span class="math inline">\(C\)</span> 和每位上的和 <span class="math inline">\(S\)</span> 有以下两种变化：</p>
<ul>
<li><span class="math inline">\(C\)</span> 减 <span class="math inline">\(1\)</span>，<span class="math inline">\(S\)</span> 不变；</li>
<li><span class="math inline">\(C\)</span> 不变，<span class="math inline">\(S\)</span> 减 <span class="math inline">\(9\)</span>。</li>
</ul>
<p>由于最终一定有 <span class="math inline">\(C=1,S\le 9\)</span>，所以两种变化的数量是确定的，也即总操作次数是固定的，即 <span class="math inline">\(C-1+\lceil\frac{S}{9}\rceil-1\)</span>。</p>
<p><a href="https://atcoder.jp/contests/ddcc2020-qual/submissions/16760883">代码</a></p>
<h3 id="e---majority-of-balls">E - Majority of Balls</h3>
<h4 id="题意-3">题意</h4>
<p><strong>这是一个交互题。</strong></p>
<p>有 <span class="math inline">\(2N\)</span> 个球，编号 <span class="math inline">\(1,\ldots,2N\)</span>，其中 <span class="math inline">\(N\)</span> 是奇数。每个球的颜色为红色或蓝色，红球和蓝球各有 <span class="math inline">\(N\)</span> 个。</p>
<p>你可以询问不超过 <span class="math inline">\(210\)</span> 次确定每个球的颜色。每次可以询问一个大小为 <span class="math inline">\(N\)</span> 的球的子集中，红球数量是否比蓝球数量更多。</p>
<p><span class="math inline">\(N\le 99\)</span></p>
<h4 id="题解-3">题解</h4>
<p>如果我们把红球看成 <span class="math inline">\(+1\)</span>，蓝球看成 <span class="math inline">\(-1\)</span>，每次相当于询问一个集合的和是否大于 <span class="math inline">\(0\)</span>。</p>
<p>若 <span class="math inline">\(1,\ldots,N\)</span> 的和大于 <span class="math inline">\(0\)</span>，那么 <span class="math inline">\(N+1,\ldots,2N\)</span> 的和一定小于 <span class="math inline">\(0\)</span>。同理，若 <span class="math inline">\(1,\ldots,N\)</span> 的和小于 <span class="math inline">\(0\)</span>，那么 <span class="math inline">\(N+1,\ldots,2N\)</span> 的和一定大于 <span class="math inline">\(0\)</span>。</p>
<p>注意到从左往右扫描每个长度为 <span class="math inline">\(N\)</span> 的区间时，和每次的变化只有 <span class="math inline">\(+2,0,-2\)</span> 三种情况。那么中途一定会出现和从 <span class="math inline">\(+1\)</span> 到 <span class="math inline">\(-1\)</span> 的变化或从 <span class="math inline">\(-1\)</span> 到 <span class="math inline">\(+1\)</span> 的变化。此时我们就可以找到一个长度为 <span class="math inline">\(N-1\)</span> 的，红蓝球数量相等的区间。</p>
<p>找到这样一个区间后，我们可以轻松地判断出每个不在该区间内球的颜色。而求出其余球的颜色后，我们又可以找到另一个大小为 <span class="math inline">\(N-1\)</span> 的，不包含原区间内任意一个球的，红蓝球数量相等的集合，我们可以利用该集合确定原区间内每个球的颜色。</p>
<p>这样我们总共需要 <span class="math inline">\(3N\)</span> 次询问，不能满足要求。</p>
<p>注意到对于第一部分，记 <span class="math inline">\(S_i\)</span> 为 <span class="math inline">\([i,i+N)\)</span> 这些球进行查询的结果，我们需要求出一个 <span class="math inline">\(0\le i &lt; N\)</span> 满足 <span class="math inline">\(S_i\ne S_{i+1}\)</span>。</p>
<p>假设当前我们要在 <span class="math inline">\([L,R)\)</span> 中找出一个 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(S_i\ne S_{i+1}\)</span>。考虑区间中点 <span class="math inline">\(M=\lfloor\frac{L+R+1}{2}\rfloor\)</span>。若 <span class="math inline">\(S_M\ne S_L\)</span>，那么我们可以将区间缩小到 <span class="math inline">\([L,M)\)</span>；否则我们可以将区间缩小到 <span class="math inline">\([M,R)\)</span>。</p>
<p>于是第一部分的查询数量就可以缩小到 <span class="math inline">\(\log_2 N\)</span>，可以通过本题。</p>
<p><a href="https://atcoder.jp/contests/ddcc2020-qual/submissions/16762066">代码</a></p>
<h3 id="f---discosmos">F - DISCOSMOS</h3>
<h4 id="题意-4">题意</h4>
<p>有一个 <span class="math inline">\(H\times W\)</span> 的网格。在第 <span class="math inline">\(0\)</span> 秒，你需要在每个格子上放一个机器人。机器人有三种：</p>
<ul>
<li>Type-H，始终不移动。</li>
<li>Type-R，每一秒会向右移动，即从 <span class="math inline">\((x,y)\)</span> 到 <span class="math inline">\((x,y+1)\)</span>。特别地，若 <span class="math inline">\(y=W\)</span>，则下一步到 <span class="math inline">\((x,1)\)</span>。</li>
<li>Type-D，每一秒会向左移动，即从 <span class="math inline">\((x,y)\)</span> 到 <span class="math inline">\((x+1,y)\)</span>。特别地，若 <span class="math inline">\(x=H\)</span>，则下一步到 <span class="math inline">\((1,y)\)</span>。</li>
</ul>
<p>同一时刻某个格子上可以有多个机器人。</p>
<p>求有多少种放置机器人的方案，使得在时刻 <span class="math inline">\(0,T,2T,3T,\ldots\)</span>（即所有 <span class="math inline">\(T\)</span> 的倍数的时刻），每个格子上恰好有一个机器人。</p>
<p><span class="math inline">\(H,W,T\le 10^9\)</span>。</p>
<h4 id="题解-4">题解</h4>
<p>首先我们可以令 <span class="math inline">\(n=\frac{H}{\gcd(H,T)},m=\frac{W}{\gcd(W,T)}\)</span>，转化成 <span class="math inline">\(T=1\)</span> 的情况，只要最后将答案 <span class="math inline">\(s\)</span> 变为 <span class="math inline">\(s^{\frac{H}{n}\cdot\frac{W}{m}}\)</span> 即可。</p>
<p>注意到有一些显然合法的情况：</p>
<ul>
<li>选择若干行，这些行的每个格子都放 Type-R 的机器人。其余位置放 Type-H 的机器人。</li>
<li>选择若干列，这些列的每个格子都放 Type-D 的机器人。其余位置放 Type-H 的机器人。</li>
</ul>
<p>这些情况有 <span class="math inline">\(2^n+2^m-1\)</span> 种。接下来我们考虑同时有 Type-R 和 Type-D 的情况。</p>
<p>假设 <span class="math inline">\(n=m\)</span>，下面的同余符号默认都在模 <span class="math inline">\(n\)</span> 意义下同余。</p>
<p>对于所有 <span class="math inline">\(i+j\equiv k\)</span> 的位置 <span class="math inline">\((i,j)\)</span> 的机器人，移动一步后，一定只有这些机器人可以移动到 <span class="math inline">\(i+j\equiv k+1\)</span> 的位置 <span class="math inline">\((i,j)\)</span>。而这些位置上都只能有恰好一个机器人，所以 <span class="math inline">\(i+j\equiv k\)</span> 的位置 <span class="math inline">\((i,j)\)</span> 上的机器人必须都是 Type-R 或都是 Type-D 的。</p>
<p>所以除去全部相等的两种情况，共 <span class="math inline">\(2^n-2\)</span> 种情况。</p>
<p>对于 <span class="math inline">\(n\ne m\)</span> 的情况，可以类似说明所有 <span class="math inline">\(i+j\equiv k\pmod{\gcd(n,m)}\)</span> 的位置必须都是同一类型且会移动的机器人。</p>
<p>综上，总方案数为 <span class="math inline">\(2^n+2^m+2^{\gcd(n,m)}-3\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(\log H+\log W+\log T)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/ddcc2020-qual/submissions/16765822">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>贪心</tag>
        <tag>数论</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>diverta 2019 Programming Contest 题解</title>
    <url>/atcoder-diverta2019/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/diverta2019">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---consecutive-integers">A - Consecutive Integers</h3>
<h4 id="题意">题意</h4>
<p>求在 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\)</span> 的整数中选择连续的 <span class="math inline">\(K\)</span> 个整数的方案数。</p>
<p><span class="math inline">\(N\le 50\)</span></p>
<h4 id="题解">题解</h4>
<p>显然答案为 <span class="math inline">\(N-K+1\)</span>。</p>
<p><a href="https://atcoder.jp/contests/diverta2019/submissions/17010505">代码</a></p>
<h3 id="b---rgb-boxes">B - RGB Boxes</h3>
<h4 id="题意-1">题意</h4>
<p>求有多少非负整数三元组 <span class="math inline">\((r,g,b)\)</span> 满足 <span class="math display">\[Rr+Gg+Bb=N\]</span></p>
<p><span class="math inline">\(N\le 3000\)</span></p>
<h4 id="题解-1">题解</h4>
<p>枚举其中两个即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/diverta2019/submissions/17010528">代码</a></p>
<h3 id="c---ab-substrings">C - AB Substrings</h3>
<h4 id="题意-2">题意</h4>
<p>给定 <span class="math inline">\(N\)</span> 个字符串 <span class="math inline">\(s_i\)</span>，将这些字符串按任意顺序拼接，求 <code>AB</code> 作为子串的出现次数的最大值。</p>
<p><span class="math inline">\(N\le 10^4,|s_i|\le 10\)</span></p>
<h4 id="题解-2">题解</h4>
<p>先将每个字符串中间的 <code>AB</code> 计入贡献，那么剩余的字符串可以分为 <code>xxx</code>、<code>xxA</code>、<code>Bxx</code>、<code>BxA</code> 四种。</p>
<p>那么一定是用所有 <code>BxA</code> 和至多一个 <code>xxA</code> 和 <code>Bxx</code> 拼出 <code>xxABxABxA...BxABxx</code> 这样的字符串，再用剩下的 <code>xxA</code> 和 <code>Bxx</code> 拼 <code>xxABxx</code> 这样的字符串。</p>
<p>注意细节。</p>
<p><a href="https://atcoder.jp/contests/diverta2019/submissions/17010631">代码</a></p>
<h3 id="d---divrem-number">D - DivRem Number</h3>
<h4 id="题意-3">题意</h4>
<p>给定正整数 <span class="math inline">\(N\)</span>，求有多少正整数 <span class="math inline">\(m\)</span> 满足 <span class="math inline">\(\lfloor\frac{N}{m}\rfloor=N\bmod m\)</span>。</p>
<p><span class="math inline">\(N\le 10^{12}\)</span></p>
<h4 id="题解-3">题解</h4>
<p>化一下式子，得到 <span class="math inline">\(\lfloor\frac{N}{m}\rfloor(m+1)=N\)</span>。那么 <span class="math inline">\(m+1\)</span> 一定是 <span class="math inline">\(N\)</span> 的因数，枚举即可。</p>
<p>时间复杂度 <span class="math inline">\(O(\sqrt{N})\)</span>。</p>
<p><a href="https://atcoder.jp/contests/diverta2019/submissions/17010669">代码</a></p>
<h3 id="e---xor-partitioning">E - XOR Partitioning</h3>
<h4 id="题意-4">题意</h4>
<p>给定序列 <span class="math inline">\(A_1,A_2,\ldots,A_N\)</span>，将该序列划分成若干段，使得每段的异或和相等，求方案数。对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(N\le 5\times 10^5\)</span></p>
<h4 id="题解-4">题解</h4>
<p>对原序列作前缀和 <span class="math inline">\(S_i\)</span>，假设每段的异或和为 <span class="math inline">\(x\)</span>，那么一个合法的划分方案一定是选择 <span class="math inline">\(S\)</span> 中一个 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(0\)</span> 交替的子序列。</p>
<p>考虑枚举 <span class="math inline">\(x\)</span>，然后 DP。令 <span class="math inline">\(f_i\)</span> 表示前 <span class="math inline">\(i\)</span> 个数，强制 <span class="math inline">\(i\)</span> 选择且 <span class="math inline">\(S_i=x\)</span> 时合法方案数。那么有 <span class="math display">\[f_i=1+\sum_{j=0}^{i-1} f_j(c_i-c_j)\]</span></p>
<p>其中 <span class="math inline">\(c_i\)</span> 表示 <span class="math inline">\(S_1,S_2,\ldots,S_i\)</span> 中 <span class="math inline">\(0\)</span> 的数量。</p>
<p>最终答案与段数的奇偶性有关，段数为奇数时为 <span class="math inline">\(f_N\)</span>，段数为偶数时为所有 <span class="math inline">\(f_i\)</span> 的和。段数的奇偶性可以通过 <span class="math inline">\(S_N\)</span> 是否等于 <span class="math inline">\(0\)</span> 确定。</p>
<p>用前缀和优化 DP 转移，时间复杂度 <span class="math inline">\(O(N)\)</span>。注意特判 <span class="math inline">\(x=0\)</span> 的情况。</p>
<p><a href="https://atcoder.jp/contests/diverta2019/submissions/17010841">代码</a></p>
<h3 id="f---edge-ordering">F - Edge Ordering</h3>
<h4 id="题意-5">题意</h4>
<p>给定一个 <span class="math inline">\(N\)</span> 个点 <span class="math inline">\(M\)</span> 条边的简单无向连通图 <span class="math inline">\(G\)</span>，保证前 <span class="math inline">\(N-1\)</span> 条边构成了 <span class="math inline">\(G\)</span> 的一个生成树。</p>
<p>你需要给每条边确定一个 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(M\)</span> 的整数边权，需要保证边权互不相同。</p>
<p>对于一个确定边权的方案，我们称该方案是好的当且仅当前 <span class="math inline">\(N-1\)</span> 条边构成的生成树是最小生成树。</p>
<p>求所有好的方案的最小生成树边权和之和。对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(N\le 20\)</span></p>
<h4 id="题解-5">题解</h4>
<p>假设原图如下图（重绘自官方题解）：</p>
<p><img src="/files/atcoder-diverta2019-F1.png" class="lazyload" data-srcset="/files/atcoder-diverta2019-F1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>其中边上的数字为边的编号，黑边为树边，红边为非树边。</p>
<p>我们假设前 <span class="math inline">\(N-1\)</span> 条边的边权按 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N-1\)</span> 的顺序递增，例如上图中有 <span class="math inline">\(cost(1) &lt; cost(2) &lt; \ldots &lt; cost(5)\)</span>。为了使这五条边成为最小生成树，我们需要保证其余非树边 <span class="math inline">\((u,v)\)</span> 的边权需要大于树上 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 路径上最大的边权。例如图中 <span class="math inline">\(cost(7) &gt; cost(3),cost(9) &gt; cost(4)\)</span>。</p>
<p>我们可以根据边权的大小关系建出一个拓扑关系图，例如上图对应的拓扑图如下图所示（来自官方题解）：</p>
<p><img src="/files/atcoder-diverta2019-F2.png" class="lazyload" data-srcset="/files/atcoder-diverta2019-F2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>令 <span class="math inline">\(a_i\ (1\le i\le N-1)\)</span> 表示上图中 <span class="math inline">\(i\)</span> 向下的连边数量，即点 <span class="math inline">\(i\)</span> 向编号大于 <span class="math inline">\(N-1\)</span> 的点的连边数量。</p>
<p>那么我们可以把问题转化为，有 <span class="math inline">\(M\)</span> 个有标号的球，你有一个空的序列 <span class="math inline">\(S\)</span>，球会按 <span class="math inline">\(a_{N-1}\)</span> 个白球，一个黑球，<span class="math inline">\(a_{N-2}\)</span> 个白球，一个黑球……这样的顺序给你，例如上图对应的球的序列为 <span class="math inline">\(8,5,9,6,4,7,3,2,1\)</span>。每收到一个球，你可以执行以下操作：</p>
<ul>
<li>若收到的球是黑球，则在 <span class="math inline">\(S\)</span> 的最前面插入该球。</li>
<li>若收到的球是白球，则插入到 <span class="math inline">\(S\)</span> 的任意位置。</li>
</ul>
<p>求最终得到的所有 <span class="math inline">\(S\)</span> 序列中黑球的位置编号和之和。</p>
<p>考虑在依次收到球的过程中，维护 <span class="math inline">\(n\)</span> 表示当前序列 <span class="math inline">\(S\)</span> 的长度，<span class="math inline">\(b\)</span> 表示 <span class="math inline">\(S\)</span> 中黑球的数量，<span class="math inline">\(c\)</span> 表示不同的序列 <span class="math inline">\(S\)</span> 的数量，<span class="math inline">\(s\)</span> 表示所有序列 <span class="math inline">\(S\)</span> 中黑球的位置编号之和的和。用 <span class="math inline">\((n,b,c,s)\)</span> 表示当前的状态。</p>
<p>若收到一个黑球，那么新的状态为 <span class="math inline">\((n+1,b+1,c,s+(b+1)c)\)</span>。</p>
<p>若收到一个白球，假设原来的序列中黑球的位置为 <span class="math inline">\(p_1,p_2,\ldots,p_b\)</span>，不妨假设 <span class="math inline">\(p_0=0,p_{b+1}=n+1\)</span>，那么插入该白球时的总变化量（即每个位置的贡献之和）为 <span class="math display">\[
\sum_{i=1}^{b+1}(p_i-p_{i-1})(b-i+1)=\sum_{i=1}^{b}p_i
\]</span></p>
<p>所以新的状态为 <span class="math inline">\((n+1,b,(n+1)c,(n+1)s+s)\)</span>，即 <span class="math inline">\((n+1,b,(n+1)c,(n+2)s)\)</span>。</p>
<p>那么加入 <span class="math inline">\(k\)</span> 个白球后新的状态为 <span class="math inline">\((n+k,b,\frac{(n+k)!}{n!}c,\frac{(n+k+1)!}{(n+1)!}s)\)</span>。</p>
<p>对于原来的问题，我们并没有固定前 <span class="math inline">\(N-1\)</span> 条边边权的大小关系，所以需要 DP。考虑到上面的问题是按边权从大到小进行转移的，那么这里的 DP 也从大到小确定边权的大小关系。</p>
<p>令 <span class="math inline">\(f_S=(n,b,c,s)\)</span>，<span class="math inline">\(S\)</span> 表示该集合中边权的大小关系仍未确定，不在该集合中的边的边权都大于在该集合中的边的边权。<span class="math inline">\(n,b,c,s\)</span> 的定义与之前类似。转移只需要枚举下一条边，<span class="math inline">\(c,s\)</span> 的转移与上面问题类似。</p>
<p>实现精细可以做到 <span class="math inline">\(O(2^NN)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/diverta2019/submissions/17012385">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>图论</tag>
        <tag>贪心</tag>
        <tag>枚举</tag>
        <tag>数论</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>diverta 2019 Programming Contest 2 题解</title>
    <url>/atcoder-diverta2019-2/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/diverta2019-2">比赛地址</a></p>
<span id="more"></span>
<p>AB 就不写了。</p>
<h3 id="c---successive-subtraction">C - Successive Subtraction</h3>
<h4 id="题意">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个数，执行 <span class="math inline">\(N-1\)</span> 次操作，每次选择两个数 <span class="math inline">\(x,y\)</span>，删去这两个数，替换成 <span class="math inline">\(x-y\)</span>。求最后结果的最大值并构造方案。</p>
<p><span class="math inline">\(N\le 10^5\)</span></p>
<h4 id="题解">题解</h4>
<p>最后一定是给每个数一个正负号后加起来的结果。</p>
<p>显然，全部填正号或全部填负号一定不可行。而同时有正负时，记其中一个填正号的数是 <span class="math inline">\(a\)</span>，填负号的数是 <span class="math inline">\(b\)</span>，那么我们可以用 <span class="math inline">\(b\)</span> 减去其他填正号的数，再用 <span class="math inline">\(a\)</span> 减去该数，最后再减去其他填负号的数。</p>
<p>所以我们只要将所有正数填上正号，所有负数填上负号即可，需要注意全正和全负的情况。</p>
<p><a href="https://atcoder.jp/contests/diverta2019-2/submissions/16964439">代码</a></p>
<h3 id="d---squirrel-merchant">D - Squirrel Merchant</h3>
<h4 id="题意-1">题意</h4>
<p>一开始有 <span class="math inline">\(N\)</span> 个球，有两个商店 A、B。在商店 <span class="math inline">\(X\)</span> 交易时，可以按任意顺序执行任意次以下交换（交换是双向的）：</p>
<ul>
<li>交换 <span class="math inline">\(g_X\)</span> 个球与 <span class="math inline">\(1\)</span> 单位的金。</li>
<li>交换 <span class="math inline">\(s_X\)</span> 个球与 <span class="math inline">\(1\)</span> 单位的银。</li>
<li>交换 <span class="math inline">\(b_X\)</span> 个球与 <span class="math inline">\(1\)</span> 单位的铜。</li>
</ul>
<p>你可以按顺序在商店 A，商店 B，商店 A 进行交易。</p>
<p>求最后最多有多少球。</p>
<p><span class="math inline">\(N,g_A,s_A,b_A,g_B,s_B,b_B\le 5000\)</span></p>
<h4 id="题解-1">题解</h4>
<p>我们可以把问题看成先用 <span class="math inline">\(N\)</span> 个球依次在 A 和 B 交易，全部换成球，得到 <span class="math inline">\(M\)</span> 个球，然后再用这 <span class="math inline">\(M\)</span> 个球依次在 B 和 A 交易，再全部换成球，就是答案。</p>
<p>这两步的问题是一样且独立的，而每一步的问题相当于一个完全背包问题。直接 DP 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/diverta2019-2/submissions/16964967">代码</a></p>
<h3 id="e---balanced-piles">E - Balanced Piles</h3>
<h4 id="题意-2">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个初始为 <span class="math inline">\(0\)</span> 的整数，每次可以执行以下操作：</p>
<ul>
<li>记 <span class="math inline">\(N\)</span> 个数中的最小值为 <span class="math inline">\(m\)</span>，最大值为 <span class="math inline">\(M\)</span>。选择任意一个等于 <span class="math inline">\(m\)</span> 的数，加上一个正整数，使得该数在 <span class="math inline">\([M,M+D]\)</span> 中。</li>
</ul>
<p>你的目标是使所有数都变成 <span class="math inline">\(H\)</span>。求操作方案数，对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(N,D,H\le 10^6\)</span></p>
<h4 id="题解-2">题解</h4>
<p>令 <span class="math inline">\(f_{i,j}\)</span> 表示当前最大值为 <span class="math inline">\(i\)</span>，有 <span class="math inline">\(j\)</span> 个时的操作方案数。</p>
<p>注意到此时转移与最小值有关，貌似并不能转移。</p>
<p>但是考虑到这 <span class="math inline">\(j\)</span> 个最大值在接下来的某段操作中会变成最小值，而在这一段操作中，因为我们确定了每一次操作后的最大值，所以这 <span class="math inline">\(j\)</span> 个最大值的贡献是 <span class="math inline">\(j!\)</span>。</p>
<p>于是我们有 <span class="math display">\[
f_{i,j}=
\begin{cases}
\sum\limits_{k=1}^d\sum\limits_{l=1}^{n} f_{i-k,l} &amp; \text{ if }j=1\\
f_{i,j-1}\cdot j &amp; \text{ if }j&gt;1
\end{cases}
\]</span></p>
<p>也就是说我们有 <span class="math inline">\(f_{i,j}=f_{i,1}\cdot j!,f_{i,1}=\sum\limits_{k=1}^{d}f_{i-k,1}\sum\limits_{l=1}^{n}l!\)</span>。</p>
<p>所以只记录 <span class="math inline">\(f_{i,1}\)</span>，用前缀和优化转移即可。</p>
<p>注意 <span class="math inline">\(i=0\)</span> 时，只有 <span class="math inline">\(f_{i,n}=n!\)</span>，其他位置都是 <span class="math inline">\(0\)</span>，所以最后答案需要乘上 <span class="math inline">\(\frac{n!}{\sum\limits_{i=1}^{n}i!}\)</span> 去掉其他位置的贡献。</p>
<p><a href="https://atcoder.jp/contests/diverta2019-2/submissions/16964967">代码</a></p>
<h3 id="f---diverta-city">F - Diverta City</h3>
<h4 id="题意-3">题意</h4>
<p>给一个 <span class="math inline">\(n\)</span> 个点的无向完全图的每条边确定一个权值，使得所有 <span class="math inline">\(\frac{n!}{2}\)</span> 条本质不同的哈密顿路权值不同。</p>
<p><span class="math inline">\(n\le 10\)</span></p>
<h4 id="题解-3">题解</h4>
<p>构造一个序列 <span class="math inline">\(f=\{1, 2, 4, 7, 12, 20, 29, 38, 52\}\)</span>，这个序列满足所有元素以及所有元素两两的和都互不相等。</p>
<p>考虑每次加入一个点 <span class="math inline">\(i\)</span>，对于所有 <span class="math inline">\(j &lt; i\)</span>，将 <span class="math inline">\((i,j)\)</span> 这条边的边权置为 <span class="math inline">\((M+1)f_j\)</span>，其中 <span class="math inline">\(M\)</span> 表示前 <span class="math inline">\(i-1\)</span> 个点的所有哈密顿路权值的最大值。</p>
<p>这样构造显然是正确的。证明可以考虑在任意两条哈密顿路中的任意位置插入 <span class="math inline">\(i\)</span>，因为乘了 <span class="math inline">\((M+1)\)</span>，原来哈密顿路的权值以及减去的边的权值都不需要考虑，而只需要考虑加入的两条边。因为乘了 <span class="math inline">\(f_i\)</span>，这些边具有了 <span class="math inline">\(f\)</span> 的性质，即所有元素以及所有元素两两的和都互不相等，所以这些新的哈密顿路权值一定都互不相等。</p>
<p><a href="https://atcoder.jp/contests/diverta2019-2/submissions/16965955">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Social Infrastructure Information Systems Division, Hitachi Programming Contest 2020 题解</title>
    <url>/atcoder-hitachi2020/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/hitachi2020">比赛地址</a></p>
<span id="more"></span>
<h3 id="a---hitachi-string">A - Hitachi String</h3>
<h4 id="题意">题意</h4>
<p>判断一个字符串 <span class="math inline">\(S\)</span> 是否由若干个 <code>hi</code> 拼接而成。</p>
<p><span class="math inline">\(|S|\le 10\)</span></p>
<h4 id="题解">题解</h4>
<p>条件为：</p>
<ul>
<li><span class="math inline">\(n\)</span> 是偶数；</li>
<li>奇数位为 <code>h</code>；</li>
<li>偶数位为 <code>i</code>。</li>
</ul>
<p>时间复杂度 <span class="math inline">\(O(|S|)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/hitachi2020/submissions/16587225">代码</a></p>
<h3 id="b---nice-shopping">B - Nice Shopping</h3>
<h4 id="题意-1">题意</h4>
<p>有 <span class="math inline">\(A\)</span> 种 A 商品，第 <span class="math inline">\(i\)</span> 种价格为 <span class="math inline">\(a_i\)</span>；有 <span class="math inline">\(B\)</span> 种 B 商品，第 <span class="math inline">\(i\)</span> 种价格为 <span class="math inline">\(b_i\)</span>。</p>
<p>有 <span class="math inline">\(M\)</span> 张优惠券，第 <span class="math inline">\(i\)</span> 张优惠券是同时买 A 商品的第 <span class="math inline">\(x_i\)</span> 种和 B 商品的第 <span class="math inline">\(y_i\)</span> 种时可以优惠 <span class="math inline">\(c_i\)</span> 元。</p>
<p>你需要买恰好一种 A 商品和恰好一种 B 商品，求在最多只能用一张优惠券时的最小花费。</p>
<p><span class="math inline">\(A,B,C\le 10^5\)</span></p>
<h4 id="题解-1">题解</h4>
<p>有两种情况：</p>
<ul>
<li>不使用优惠券，则花费为 <span class="math inline">\(\min\{a_i\}+\min\{b_i\}\)</span>；</li>
<li>使用优惠券，则花费为 <span class="math inline">\(\min \{a_{x_i}+b_{y_i}-c_i\}\)</span>。</li>
</ul>
<p>两种情况取 <span class="math inline">\(\min\)</span> 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(A+B+M)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/hitachi2020/submissions/16587256">代码</a></p>
<h3 id="c---three">C - ThREE</h3>
<h4 id="题意-2">题意</h4>
<p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，构造一个排列 <span class="math inline">\(p\)</span> 满足：</p>
<ul>
<li>对于所有 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(j\)</span> 的简单路径边数为 <span class="math inline">\(3\)</span> 的 <span class="math inline">\((i,j)\)</span>，满足 <span class="math inline">\(p_ip_j\)</span> 和 <span class="math inline">\(p_i+p_j\)</span> 中至少有一个是 <span class="math inline">\(3\)</span> 的倍数。</li>
</ul>
<p><span class="math inline">\(n\le 2\times 10^5\)</span></p>
<h4 id="题解-2">题解</h4>
<p>假设 <span class="math inline">\(n\)</span> 为 <span class="math inline">\(3\)</span> 的倍数。其他情况类似。</p>
<p>相当于我们要给每个点赋 <span class="math inline">\(0,1,2\)</span> 中的一个数，每个数都恰好出现 <span class="math inline">\(\frac{n}{3}\)</span> 次。</p>
<p>首先我们可以从任意点开始 DFS，将深度为奇数的点填 <span class="math inline">\(1\)</span>，深度为偶数的点填 <span class="math inline">\(2\)</span>。显然这样已经能满足题目中的条件。</p>
<p>考虑如何满足出现次数的条件。记填 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(2\)</span> 的数量分别为 <span class="math inline">\(c_1,c_2\)</span>，那么分两种情况：</p>
<ul>
<li><span class="math inline">\(c_1,c_2\ge \frac{n}{3}\)</span>。此时只要将多余的 <span class="math inline">\(1,2\)</span> 填成 <span class="math inline">\(0\)</span> 即可。</li>
<li><span class="math inline">\(\exists i\in \{1,2\},c_i &lt; \frac{n}{3}\)</span>。此时将 <span class="math inline">\(i\)</span> 全部替换成 <span class="math inline">\(3\)</span>，剩下的节点任意填即可。</li>
</ul>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/hitachi2020/submissions/16587424">代码</a></p>
<h3 id="d---manga-market">D - Manga Market</h3>
<h4 id="题意-3">题意</h4>
<p>有 <span class="math inline">\(n\)</span> 个商店，从时刻 <span class="math inline">\(0\)</span> 开始，每次你可以花费 <span class="math inline">\(1\)</span> 个单位的时间走到任意一个商店。</p>
<p>若你在时刻 <span class="math inline">\(t\)</span> 到达商店 <span class="math inline">\(i\)</span> 并在商店 <span class="math inline">\(i\)</span> 购物，那么你需要花费 <span class="math inline">\(a_i\times t+b_i\)</span> 单位的时间。</p>
<p>所有商店会在时刻 <span class="math inline">\(T+0.5\)</span> 关门，也就是说，如果你走到某个商店时的时刻加上需要花费的时间大于 <span class="math inline">\(T\)</span>，那么你就无法在该商店购物。</p>
<p>每个商店只能购物一次。</p>
<p>求最多可以在多少商店购物。</p>
<p><span class="math inline">\(n\le 2\times 10^5,T\le 10^9\)</span></p>
<h4 id="题解-3">题解</h4>
<p>首先我们可以把 <span class="math inline">\(b_i\)</span> 加上 <span class="math inline">\(a_i+1\)</span>，这样就可以认为走路不需要时间。</p>
<p>然后我们可以把 <span class="math inline">\(a_i\)</span> 加上 <span class="math inline">\(1\)</span>，这样 <span class="math inline">\(a_it+b_i\)</span> 就是购物结束的时刻。</p>
<p>假若我们依次在 <span class="math inline">\(i_1,i_2,\ldots,i_k\)</span> 这些商店购物，这是在这些商店购物的最优顺序当且仅当对于所有 <span class="math inline">\(1\le j &lt; k\)</span> 都满足 <span class="math display">\[b_{i_j}a_{i_{j+1}}\prod_{l=j+2}^{k}a_{i_l}+b_{i_{j+1}}\prod_{l=j+2}^{k}a_{i_l}\le b_{i_{j+1}}a_{i_j}\prod_{l=j+2}^{k}a_{i_l}+b_{i_j}\prod_{l=j+2}^{k}a_{i_l}\]</span> 化简得到 <span class="math display">\[\frac{b_{i_j}}{a_{i_j}-1}\le \frac{b_{i_{j+1}}}{a_{i_{j+1}}-1}\]</span></p>
<p>所以我们可以首先把原序列按这个式子排序。</p>
<p>然后我们可以 DP。用 <span class="math inline">\(f_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 个商店，去了 <span class="math inline">\(j\)</span> 个的最小时间。</p>
<p>注意到若忽略 <span class="math inline">\(a_i=1\)</span> 的商店，那么 <span class="math inline">\(j\)</span> 只有 <span class="math inline">\(O(\log T)\)</span> 个。</p>
<p>而 <span class="math inline">\(a_i=1\)</span> 的商店一定排在最后，可以最后贪心按 <span class="math inline">\(b_i\)</span> 从小到大依次购物。</p>
<p>所以时间复杂度 <span class="math inline">\(O(n\log T)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/hitachi2020/submissions/16587863">代码</a></p>
<h3 id="e---odd-sum-rectangles">E - Odd Sum Rectangles</h3>
<h4 id="题意-4">题意</h4>
<p>构造一个 <span class="math inline">\((2^n-1)\times (2^m-1)\)</span> 的 01 矩阵，使得和为奇数的连续子矩阵数量最多。</p>
<p><span class="math inline">\(n,m\le 10\)</span></p>
<h4 id="题解-4">题解</h4>
<p>假设 <span class="math inline">\(n\ge m\)</span>。令 <span class="math inline">\(H=2^n,W=2^m\)</span>。考虑枚举 <span class="math inline">\(1\le j_1\le j_2&lt; W\)</span>，令 <span class="math inline">\(f(i)=S(1,i,j_1,j_2)\ (0\le i&lt; H)\)</span>。那么和为奇数的子矩阵数量为 <span class="math inline">\(f(i)\)</span> 中 <span class="math inline">\(0\)</span> 的数量乘 <span class="math inline">\(1\)</span> 的数量。于是我们可以得到数量的上界为 <span class="math inline">\(\frac{H^2}{4}\times \frac{W(W-1)}{2}\)</span>。</p>
<p>接下来我们证明这个上界是可以达到的。</p>
<p>假设 <span class="math inline">\(n=m\)</span>。我们考虑用归纳证明。</p>
<p>当 <span class="math inline">\(n=1\)</span> 时，我们只需要构造一个元素为 <span class="math inline">\(1\)</span> 的 <span class="math inline">\(1\times 1\)</span> 矩阵即可。</p>
<p>假设我们已经构造出了 <span class="math inline">\(n=k\)</span> 的矩阵，我们可以按如下方式构造一个 <span class="math inline">\((2^{k+1}-1)\times (2^{k+1}-1)\)</span> 的矩阵：</p>
<ul>
<li>左上角、左下角、右上角、右下角分别用 <span class="math inline">\(n=k\)</span> 的矩阵填充。</li>
<li>第 <span class="math inline">\(2^k\)</span> 行 <span class="math inline">\(2^k\)</span> 列填 <span class="math inline">\(1\)</span>。</li>
<li>其他位置填 <span class="math inline">\(0\)</span>。</li>
</ul>
<p>以没有跨过第 <span class="math inline">\(2^k\)</span> 列的两列作为 <span class="math inline">\(j_1,j_2\)</span> 时证明比较容易。而对于跨过第 <span class="math inline">\(2^k\)</span> 列的两列，由于构造的矩阵具有对称性，我们可以转化成第 <span class="math inline">\(2^k\)</span> 列加上没有跨过第 <span class="math inline">\(2^k\)</span> 列的两列之间的部分。这一部分证明也比较容易。</p>
<p><span class="math inline">\(n&gt;m\)</span> 的情况先构造 <span class="math inline">\((2^n-1)\times (2^n-1)\)</span> 再取前 <span class="math inline">\(2^m-1\)</span> 列即可。因为我们证明了任意两列之间都能卡到上界，所以这样构造一定仍然能够卡到上界。</p>
<p>时间复杂度 <span class="math inline">\(O(2^{2\max(n,m)})\)</span>。</p>
<p><a href="https://atcoder.jp/contests/hitachi2020/submissions/16588883">代码</a></p>
<h3 id="f---preserve-diameter">F - Preserve Diameter</h3>
<h4 id="题意-5">题意</h4>
<p>给定一棵 <span class="math inline">\(n\)</span> 个点的树 <span class="math inline">\(G\)</span>。求在树 <span class="math inline">\(G\)</span> 中加入若干条边得到的满足以下条件的图 <span class="math inline">\(H\)</span> 的数量：</p>
<ul>
<li>不存在重边和自环。</li>
<li><span class="math inline">\(H\)</span> 的直径与 <span class="math inline">\(G\)</span> 相等。</li>
<li>对于所有在 <span class="math inline">\(H\)</span> 中没有直接的边相连的点对 <span class="math inline">\((u,v)\ (u\ne v)\)</span>，满足加入边 <span class="math inline">\((u,v)\)</span> 后会使直径长度减小。</li>
</ul>
<p>对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(n\le 2\times 10^5\)</span></p>
<h4 id="题解-5">题解</h4>
<p>首先不难发现 <span class="math inline">\(H\)</span> 的直径是唯一的，否则一定可以继续加入边。假设这条唯一的直径两个端点为 <span class="math inline">\(x,y\)</span>。</p>
<p>我们考虑以 <span class="math inline">\(x\)</span> 为根建立 BFS 树，令 <span class="math inline">\(dis_i\)</span> 为 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(i\)</span> 的最短路长度，那么两个点 <span class="math inline">\(u,v\)</span> 在 <span class="math inline">\(H\)</span> 中有边当且仅当 <span class="math inline">\(|dis_u-dis_v|\le 1\)</span>。</p>
<p>直接对 <span class="math inline">\(dis_i\)</span> 计数由于需要确定 <span class="math inline">\(x\)</span> 而不好计数。考虑继续转化。</p>
<p>假设 <span class="math inline">\(G\)</span> 的直径长度为 <span class="math inline">\(L\)</span>。我们首先考虑 <span class="math inline">\(L\)</span> 是偶数的情况，此时我们可以得到直径的中点 <span class="math inline">\(c\)</span>。</p>
<p>可以发现 <span class="math inline">\(x,y\)</span> 在 <span class="math inline">\(G\)</span> 上的路径一定经过 <span class="math inline">\(c\)</span>，这是因为 <span class="math inline">\(x,y\)</span> 一定也是 <span class="math inline">\(G\)</span> 的直径端点，而树上任意一条直径一定都经过直径中点。</p>
<p>于是我们考虑以 <span class="math inline">\(c\)</span> 为根，给每个点赋一个标号 <span class="math inline">\(d_i\)</span>，满足：</p>
<ul>
<li><span class="math inline">\(d_c=0\)</span>。</li>
<li>恰好存在一个点 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(d_x=-\frac{L}{2}\)</span>。</li>
<li>恰好存在一个点 <span class="math inline">\(y\)</span> 满足 <span class="math inline">\(d_y=\frac{L}{2}\)</span>。</li>
<li>对于在 <span class="math inline">\(G\)</span> 中有边的点对 <span class="math inline">\((u,v)\)</span>，满足 <span class="math inline">\(|d_u-d_v|\le 1\)</span>。</li>
</ul>
<p>可以发现一个合法的 <span class="math inline">\(H\)</span> 一定恰好对应两种满足以上条件的标号方案。</p>
<p>于是我们可以 DP，记以 <span class="math inline">\(c\)</span> 到 <span class="math inline">\(u\)</span> 的距离为 <span class="math inline">\(dep_u\)</span>，则我们用 <span class="math inline">\(f_{u,i,j}\)</span> 表示对 <span class="math inline">\(u\)</span> 的子树进行标号，<span class="math inline">\(d_v-d_u=\frac{L}{2}-dep_u\)</span> 的点 <span class="math inline">\(v\)</span> 数量为 <span class="math inline">\(i\)</span>，<span class="math inline">\(d_u-d_v=\frac{L}{2}-dep_u\)</span> 的点 <span class="math inline">\(v\)</span> 数量为 <span class="math inline">\(j\)</span> 时的方案数。</p>
<p>注意 <span class="math inline">\(i,j\)</span> 可以与 <span class="math inline">\(2\)</span> 取 <span class="math inline">\(\min\)</span>。</p>
<p><span class="math inline">\(L\)</span> 为奇数时类似，只需要将直径中间的边断开后对两边分别 DP 后合并即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/hitachi2020/submissions/16592027">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>「AtCoder」「JSC 2019 Qual E」Card Collector</title>
    <url>/atcoder-jsc19qualE-sol/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_e">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>一个 <span class="math inline">\(H\times W\)</span> 的矩阵，有 <span class="math inline">\(n\)</span> 个位置有卡片，每张卡片上有个数字 <span class="math inline">\(a_i\)</span>。你可以在每行拿走一张卡片，然后在每列拿走一张卡片，求拿走的卡片的 <span class="math inline">\(a_i\)</span> 之和的最大值。</p>
<p><span class="math inline">\(1\le H,W,n,a_i\le 10^5\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>假设有 <span class="math inline">\(H+W\)</span> 个点，第 <span class="math inline">\(1\sim H\)</span> 个点表示行，第 <span class="math inline">\(H+1\sim H+W\)</span> 个点表示列。第 <span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 列的卡片对应一条 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(H+j\)</span> 的边，边权为卡片上的数字。我们把所有拿走的卡片对应的边拿出来，显然会形成一个环套树森林。简单证明一下：</p>
<blockquote>
<p>假设边是有向的，在第 <span class="math inline">\(i\)</span> 行选了第 <span class="math inline">\(j\)</span> 列的卡片，则选择 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(H+j\)</span> 的有向边；在第 <span class="math inline">\(i\)</span> 列选了第 <span class="math inline">\(j\)</span> 行的卡片，则选择 <span class="math inline">\(H+i\)</span> 到 <span class="math inline">\(j\)</span> 的有向边。那么每个点有且仅有一条出边，所以这是一个环套内向树森林。忽略边的方向，则是环套树森林。</p>
</blockquote>
<p>相当于我们要求出一个原图的边权之和最大的“生成环套树森林”。用类似于求最大生成树的 Kruskal 算法贪心选边即可。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, h, w, fa[<span class="number">200005</span>], g[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> r, c, v;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v &gt; rhs.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : (fa[x] = <span class="built_in">find</span>(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">if</span> (g[x]) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">return</span> g[x] = <span class="number">1</span>, <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (g[x] &amp;&amp; g[y]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fa[y] = x, g[x] |= g[y], <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), h = <span class="built_in">read</span>(), w = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i].r = <span class="built_in">read</span>(), a[i].c = <span class="built_in">read</span>(), a[i].v = <span class="built_in">read</span>();</span><br><span class="line">    std :: <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h + w; ++i) fa[i] = i, g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">merge</span>(a[i].r, a[i].c + h)) ans += a[i].v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>JSC 2019 Qual</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>ExaWizards 2019 题解</title>
    <url>/atcoder-exawizards2019/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/exawizards2019">比赛地址</a></p>
<span id="more"></span>
<p>AB 就不写了。</p>
<h3 id="c---snuke-the-wizard">C - Snuke the Wizard</h3>
<h4 id="题意">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个格子从左到右排列，第 <span class="math inline">\(i\)</span> 个格子上有一个字符 <span class="math inline">\(s_i\)</span>。</p>
<p>初始时，每个格子上有一个棋子。接下来进行 <span class="math inline">\(Q\)</span> 次操作，第 <span class="math inline">\(i\)</span> 次操作为：</p>
<ul>
<li>将所有字符为 <span class="math inline">\(t_i\)</span> 的格子上的棋子向 <span class="math inline">\(d_i\)</span> 方向移动，<span class="math inline">\(d_i\)</span> 为 <code>L</code> 或 <code>R</code>，分别表示向左和向右。</li>
</ul>
<p>若一个棋子被移出格子，该棋子消失。求最后存在的棋子数量。</p>
<p><span class="math inline">\(N,Q\le 2\times 10^5\)</span></p>
<h4 id="题解">题解</h4>
<p>注意到棋子间的相对顺序不会改变。所以最后存在的棋子一定是原来的一个区间。</p>
<p>可以通过二分求出该区间的左右端点。</p>
<p>时间复杂度 <span class="math inline">\(O(N+Q\log N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/exawizards2019/submissions/17375390">代码</a></p>
<h3 id="d---modulo-operations">D - Modulo Operations</h3>
<h4 id="题意-1">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个互不相同的数 <span class="math inline">\(S_i\)</span>，以及一个数 <span class="math inline">\(X\)</span>。你需要求出对于所有 <span class="math inline">\(S_i\)</span> 的排列，<span class="math inline">\(X\)</span> 依次对所有 <span class="math inline">\(S_i\)</span> 取模后的值之和。对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(N\le 200,S_i,X\le 10^5\)</span></p>
<h4 id="题解-1">题解</h4>
<p>显然对最后结果有影响的是所有等于前缀最小值的位置。</p>
<p>将 <span class="math inline">\(S_i\)</span> 从大到小排序，考虑钦定若干数作为前缀最小值，那么其他数就必须插入到后面，也就是说，第 <span class="math inline">\(i\)</span> 个数若没有被钦定为前缀最小值，则方案数需要乘上 <span class="math inline">\(N-i\)</span>。</p>
<p>于是就可以简单 DP 了。时间复杂度 <span class="math inline">\(O(NX)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/exawizards2019/submissions/17377927">代码</a></p>
<h3 id="e---black-or-white">E - Black or White</h3>
<h4 id="题意-2">题意</h4>
<p>有 <span class="math inline">\(B\)</span> 个黑球和 <span class="math inline">\(W\)</span> 个白球，不断执行以下操作：</p>
<ul>
<li>等概率选择黑白两种颜色之一，若存在该颜色的球，则取走一个。</li>
</ul>
<p>对于每个 <span class="math inline">\(i=1,\ldots,B+W\)</span>，求第 <span class="math inline">\(i\)</span> 个取走的球是黑色的概率。</p>
<p><span class="math inline">\(B,W\le 10^5\)</span></p>
<h4 id="题解-2">题解</h4>
<p>题目中的操作相当于两种颜色同时存在时黑白颜色各有 <span class="math inline">\(\frac{1}{2}\)</span> 的概率，只有一种颜色时只能取走该颜色的球。</p>
<p>求出 <span class="math inline">\(f_i,g_i\)</span> 分别表示前 <span class="math inline">\(i\)</span> 个球把所有白球或所有黑球取完的概率，那么第 <span class="math inline">\(i\)</span> 个球是黑球的概率即为 <span class="math inline">\(f_{i-1}+\frac{1}{2}(1-f_{i-1}-g_{i-1})\)</span>。</p>
<p>考虑如何求 <span class="math inline">\(f_i,g_i\)</span>。显然有递推式 <span class="math display">\[f_i=f_{i-1}+\binom{i-1}{W-1}\frac{1}{2^i}\]</span></p>
<p><span class="math inline">\(g_i\)</span> 类似。</p>
<p>时间复杂度 <span class="math inline">\(O(N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/exawizards2019/submissions/17378378">代码</a></p>
<h3 id="f---more-realistic-manhattan-distance">F - More Realistic Manhattan Distance</h3>
<h4 id="题意-3">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 条水平单向道路和 <span class="math inline">\(M\)</span> 条竖直单向道路，相邻两条道路距离为 <span class="math inline">\(1\)</span>。道路与道路之间有 <span class="math inline">\(NM\)</span> 个交点。每条道路的方向是给定的。</p>
<p><span class="math inline">\(Q\)</span> 次询问，每次给定两个点 <span class="math inline">\((a,b),(c,d)\)</span>，求最短路。</p>
<p><span class="math inline">\(N,M\le 10^5,Q\le 2\times 10^5\)</span></p>
<h4 id="题解-3">题解</h4>
<p>注意到 <span class="math inline">\((a,b)\)</span> 右边第二条向下的路是没有用的，其他方向同理。</p>
<p>于是我们只需要保留 <span class="math inline">\((a,b)\)</span> 上下左右各方向的第一条道路即可，<span class="math inline">\((c,d)\)</span> 同理。</p>
<p>这样最多只有 <span class="math inline">\(6\)</span> 条水平道路和 <span class="math inline">\(6\)</span> 条竖直道路，最多有 <span class="math inline">\(36\)</span> 个交点，<span class="math inline">\(72\)</span> 条边。</p>
<p>直接跑堆优化 Dijkstra 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N+M+Q)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/exawizards2019/submissions/17387368">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>图论</tag>
        <tag>二分</tag>
        <tag>概率</tag>
        <tag>模拟</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>「AtCoder」「JSC 2019 Qual C」Cell Inversion</title>
    <url>/atcoder-jsc19qualC-sol/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_c">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>有 <span class="math inline">\(2n\)</span> 个格子，每个格子初始为黑色或白色。你需要执行恰好 <span class="math inline">\(n\)</span> 次操作，使得最后所有格子变成白色。每次操作你可以选择两个从未选择过的格子 <span class="math inline">\(l,r (l &lt; r)\)</span>，然后将区间 <span class="math inline">\([l,r]\)</span> 的所有格子的颜色取反，即黑色的格子变成白色，白色的格子变成黑色。求方案数 <span class="math inline">\(\bmod 10^9+7\)</span> 的值。</p>
<p>两个方案不同当且仅当存在一个 <span class="math inline">\(i\in [1,n]\)</span>，满足第 <span class="math inline">\(i\)</span> 次操作选择的两个格子至少有一个不同。</p>
<p><span class="math inline">\(n\le 10^5\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>我们发现，操作的顺序与最后结果无关，于是我们强制 <span class="math inline">\(l\)</span> 从小到大，最后乘上 <span class="math inline">\(m!\)</span> 即可。</p>
<p>从左往右对于每个格子 <span class="math inline">\(i\)</span>，设 <span class="math inline">\(m\)</span> 次操作中有 <span class="math inline">\(x\)</span> 个操作 <span class="math inline">\(l &lt; r &lt; i\)</span>，有 <span class="math inline">\(y\)</span> 个操作 <span class="math inline">\(l &lt; i\le r\)</span>，那么有 <span class="math inline">\(y=i-1-2x\)</span>，所以 <span class="math inline">\(y\)</span> 与 <span class="math inline">\(i-1\)</span> 的奇偶性相同，于是可以直接判断 <span class="math inline">\(y\)</span> 的奇偶性。若 <span class="math inline">\(y\)</span> 是偶数，那么执行完所有 <span class="math inline">\(l &lt; i\)</span> 的操作后，<span class="math inline">\(i\)</span> 的颜色不会变化，此时若 <span class="math inline">\(i\)</span> 是黑色，那么一定存在一个操作 <span class="math inline">\(l = i &lt; r\)</span>，否则一定不存在，即一定存在一个操作 <span class="math inline">\(l &lt; i = r\)</span>。<span class="math inline">\(y\)</span> 为偶数同理。</p>
<p>经过上述处理，我们已经知道了每个格子是作为 <span class="math inline">\(l\)</span> 被选择还是作为 <span class="math inline">\(r\)</span> 被选择。</p>
<p>我们又发现，两个操作 <span class="math inline">\(l_1,r_1\)</span> 和 <span class="math inline">\(l_2,r_2\)</span>（<span class="math inline">\(l_1 &lt; r_2,l_2 &lt; r_1\)</span>），变成 <span class="math inline">\(l_1,r_2\)</span> 和 <span class="math inline">\(l_2,r_1\)</span> 结果也是不变的。</p>
<p>那么我们只要把所有左端点和右端点任意匹配即可。对于每个作为右端点的 <span class="math inline">\(i\)</span>，记 <span class="math inline">\([1,i-1]\)</span> 中作为左端点的点的数量减去作为右端点的点的数量为 <span class="math inline">\(d\)</span>，即多余的左端点个数，那么 <span class="math inline">\(i\)</span> 可以与这 <span class="math inline">\(d\)</span> 个左端点中的任意一个进行匹配，答案乘上 <span class="math inline">\(d\)</span>。最后再乘上 <span class="math inline">\(m!\)</span> 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n, d, ans;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); ++i)</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) ^ (s[i] == <span class="string">&#x27;B&#x27;</span>)) s[i] = <span class="string">&#x27;R&#x27;</span>; <span class="keyword">else</span> s[i] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">    ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); ++i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;L&#x27;</span>) ++d;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!d) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>), <span class="number">0</span>;</span><br><span class="line">            ans = <span class="number">1ll</span> * ans * d % P, --d;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (d) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = <span class="number">1ll</span> * ans * i % P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>JSC 2019 Qual</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Dwango Programming Contest 6th 题解</title>
    <url>/atcoder-dwacon6th-prelims/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/dwacon6th-prelims">比赛地址</a></p>
<span id="more"></span>
<p>A 就不写了。</p>
<h3 id="b---fusing-slimes">B - Fusing Slimes</h3>
<h4 id="题意">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个史莱姆，从左到右第 <span class="math inline">\(i\)</span> 个在 <span class="math inline">\(x_i\)</span>。执行 <span class="math inline">\(N-1\)</span> 次操作，对于第 <span class="math inline">\(i\)</span> 次操作：</p>
<ul>
<li>在 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N-i\)</span> 中等概率选择一个整数 <span class="math inline">\(k\)</span>；</li>
<li>将从左到右第 <span class="math inline">\(k\)</span> 个史莱姆向右移动到第 <span class="math inline">\(k+1\)</span> 个史莱姆处，合并成一个新的史莱姆。</li>
</ul>
<p>求期望移动距离乘 <span class="math inline">\((N-1)!\)</span> 的值，对 <span class="math inline">\(10^9+7\)</span> 取模。合并后的史莱姆只算一个。</p>
<p><span class="math inline">\(N\le 10^5\)</span></p>
<h4 id="题解">题解</h4>
<p>令 <span class="math inline">\(f_i\)</span> 表示初始有 <span class="math inline">\(i+1\)</span> 个史莱姆时，执行 <span class="math inline">\(i\)</span> 次操作后，最后一段的期望贡献。分两种情况：</p>
<ul>
<li>第一次选择的是 <span class="math inline">\(i\)</span>。此时最后一段被多贡献了一次，转化成 <span class="math inline">\(i\)</span> 个史莱姆的子问题，所以贡献为 <span class="math inline">\(\frac{1}{i}(f_{i-1}+1)\)</span>。</li>
<li>第一次选择的不是 <span class="math inline">\(i\)</span>。此时最后一段没有贡献，仍然转化成了 <span class="math inline">\(i\)</span> 个史莱姆的子问题，所以贡献为 <span class="math inline">\(\frac{i-1}{i}f_{i-1}\)</span>。</li>
</ul>
<p>将两种情况的贡献相加，得到 <span class="math inline">\(f_i=f_{i-1}+\frac{1}{i}\)</span>。</p>
<p>考虑如何计算 <span class="math inline">\(x_i\)</span> 到 <span class="math inline">\(x_{i+1}\)</span> 这一段的贡献。此时我们只需要考虑前 <span class="math inline">\(i\)</span> 个史莱姆的相对操作顺序，而不需要考虑 <span class="math inline">\(i+1\)</span> 到 <span class="math inline">\(n\)</span> 这些史莱姆的操作顺序，所以期望贡献次数就是 <span class="math inline">\(f_i\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/dwacon6th-prelims/submissions/16746557">代码</a></p>
<h3 id="c---cookie-distribution">C - Cookie Distribution</h3>
<h4 id="题意-1">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个数 <span class="math inline">\(c_1,c_2,\ldots,c_N\)</span>，初始为 <span class="math inline">\(0\)</span>。有 <span class="math inline">\(K\)</span> 次操作，第 <span class="math inline">\(i\)</span> 次操作会选择 <span class="math inline">\(N\)</span> 个数中的恰好 <span class="math inline">\(a_i\)</span> 个加 <span class="math inline">\(1\)</span>。求 <span class="math inline">\(\prod\limits_{i=1}^{N} c_i\)</span> 的期望乘 <span class="math inline">\(\prod\limits_{i=1}^{K}\begin{pmatrix}N\\a_i\end{pmatrix}\)</span> 的值。</p>
<p><span class="math inline">\(N\le 1000,K\le 20\)</span></p>
<h4 id="题解-1">题解</h4>
<p>考虑 <span class="math inline">\(\prod\limits_{i=1}^{N} c_i\)</span> 的组合意义，即为对于每个 <span class="math inline">\(i\)</span>，在所有选择到 <span class="math inline">\(i\)</span> 的操作中选择一个的方案数。</p>
<p>那么我们可以考虑先对于每个 <span class="math inline">\(i\)</span>，固定最终方案中选择的操作，记第 <span class="math inline">\(j\)</span> 个操作被选择了 <span class="math inline">\(x_j\)</span> 次。</p>
<p>此时方案数很好算，即 <span class="math display">\[\prod\limits_{i=1}^{K}\begin{pmatrix}N-x_i\\a_i-x_i\end{pmatrix}\]</span> 假设只固定 <span class="math inline">\(x_i\)</span>，而没有固定选择的方案，那么需要乘上选择的方案数 <span class="math display">\[\frac{N!}{\prod\limits_{i=1}^{K} x_i!}\]</span></p>
<p>直接对 <span class="math inline">\(x_i\)</span> 进行 DP 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N^2K)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/dwacon6th-prelims/submissions/16747853">代码</a></p>
<h3 id="d---arrangement">D - Arrangement</h3>
<h4 id="题意-2">题意</h4>
<p>给定 <span class="math inline">\(a_1,a_2,\ldots,a_N\)</span>，求一个字典序最小的 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\)</span> 的排列 <span class="math inline">\(b_i\)</span>，满足以下条件：</p>
<ul>
<li>对于所有 <span class="math inline">\(1\le i\le N-1\)</span>，<span class="math inline">\(a_{b_i}\ne b_{i+1}\)</span>。</li>
</ul>
<p><span class="math inline">\(N\le 10^5,a_i\ne i\)</span></p>
<h4 id="题解-2">题解</h4>
<p><span class="math inline">\(N=3\)</span> 时可以通过讨论各种可能情况证明一定有解，而 <span class="math inline">\(N&gt;3\)</span> 时可以通过构造归纳证明。下面我们直接构造一组字典序最小的解。</p>
<p>考虑逐位确定，在逐位确定的过程中，若我们将 <span class="math inline">\(i\)</span> 向 <span class="math inline">\(a_i\)</span> 连边，当前还未填的数形成的图一定是一个包含基环内向树和树的森林。</p>
<p>若存在一个点的入度等于当前总点数减 <span class="math inline">\(1\)</span>，即其他所有点都连向该点，那么此时必须选择这个点，否则我们选择能填的编号最小的点。</p>
<p>注意到这样填唯一会出问题的情况是剩下两个数没有填而这两个数形成了一个大小为 <span class="math inline">\(2\)</span> 的环。但是因为我们证明了 <span class="math inline">\(N=3\)</span> 时一定可行，此时限制比一般的 <span class="math inline">\(N=3\)</span> 的情况更少，所以在剩下 <span class="math inline">\(3\)</span> 个数时一定有合法解。</p>
<p>所以我们在剩下 <span class="math inline">\(3\)</span> 个数时按字典序枚举所有 <span class="math inline">\(3!\)</span> 种排列判断是否合法即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N)\)</span> 或 <span class="math inline">\(O(N\log N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/dwacon6th-prelims/submissions/16754810">代码</a></p>
<h3 id="e---span-covering">E - Span Covering</h3>
<h4 id="题意-3">题意</h4>
<p>你需要在数轴上 <span class="math inline">\([0,X)\)</span> 这段区间中放 <span class="math inline">\(N\)</span> 个有标号的区间。</p>
<p>放第 <span class="math inline">\(i\)</span> 个区间时，你需要选择一个 <span class="math inline">\(0\le j\le X-L_i\)</span> 的整数 <span class="math inline">\(j\)</span>，然后第 <span class="math inline">\(i\)</span> 个区间为 <span class="math inline">\([j,j+L_i)\)</span>。</p>
<p>求覆盖 <span class="math inline">\([0,X)\)</span> 中每个点的方案数。</p>
<p><span class="math inline">\(N\le 100,X\le 500\)</span></p>
<h4 id="题解-3">题解</h4>
<p>有一个简单的容斥想法是，钦定 <span class="math inline">\(k\)</span> 个位置 <span class="math inline">\(x_1,x_2,\ldots,x_k\)</span> 不被覆盖，假设 <span class="math inline">\(x_0=-1,x_{k+1}=X\)</span>，那么贡献是 <span class="math display">\[(-1)^k\prod_{j=1}^{N}\left(\sum_{i=1}^{k+1}\max(0,x_i-x_{i-1}-L_j)\right)\]</span></p>
<p>假设 <span class="math inline">\(L_j=i\)</span> 的 <span class="math inline">\(j\ (1\le j\le N)\)</span> 的数量为 <span class="math inline">\(c_i\)</span>。记上述容斥中 <span class="math inline">\(x_j-x_{j-1}-1=i\)</span> 的 <span class="math inline">\(j\ (1\le j\le k+1)\)</span> 的数量为 <span class="math inline">\(a_i\)</span>，那么上面的贡献式子也可以写成 <span class="math display">\[(-1)^{X-\sum a_i}\prod_{i=1}^{X}\left(\sum_{j=i}^{X}a_j(j+1-i)\right)^{c_i}\]</span></p>
<p>我们考虑钦定 <span class="math inline">\(a_1,a_2,\ldots,a_X\)</span>，只需要在上述式子中再乘上 <span class="math inline">\(x_1,x_2,\ldots,x_k\)</span> 的方案数，即 <span class="math display">\[
\left(\sum_{i=1}^{X} a_i\right)!\prod_{i=1}^{X}\frac{1}{a_i!}\begin{pmatrix}X-\sum ia_i+1\\\sum a_i\end{pmatrix}
\]</span></p>
<p>整理后得到贡献为 <span class="math display">\[
\boxed{\prod_{i=1}^{X}\frac{1}{a_i!}\left(\sum_{j=i}^{X}a_j(j+1-i)\right)^{c_i}}\cdot\left(\sum_{i=1}^{X} a_i\right)!\cdot(-1)^{X-\sum a_i}\cdot \begin{pmatrix}X-\sum ia_i+1\\\sum a_i\end{pmatrix}
\]</span></p>
<p>考虑从后往前对序列 <span class="math inline">\(a\)</span> DP。令 <span class="math inline">\(f_{i,j,k}\)</span> 表示固定 <span class="math inline">\(a_i,a_{i+1},\ldots,a_X\)</span>，<span class="math inline">\(\sum a_i=j\)</span>，<span class="math inline">\(\sum ia_i=k\)</span> 时，画框部分式子的和。后面部分可以在最后计算答案是加入贡献。转移为 <span class="math display">\[
f_{i,j,k}=\sum_{l=0}^{j} f_{i+1,j-l,k-i\cdot l}\cdot\frac{1}{l!}\cdot (k-(i-1)\cdot j)^{c_i}
\]</span></p>
<p>注意到有 <span class="math inline">\(k\ge ij,l\le j\)</span> 的限制，所以合法的 <span class="math inline">\((i,j,k,l)\)</span> 四元组数量约为 <span class="math display">\[X\sum_{i=1}^{X} \frac{X^2}{i^2}=O(X^3)\]</span></p>
<p><a href="https://atcoder.jp/contests/dwacon6th-prelims/submissions/16756836">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>概率</tag>
        <tag>期望</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>「AtCoder」「JSC 2019 Qual D」Classified</title>
    <url>/atcoder-jsc19qualD-sol/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_d">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>有一张 <span class="math inline">\(n\)</span> 个点的无向完全图 <span class="math inline">\(G=(V,E)\)</span>，你需要给每条边定一个正整数权值，使得<strong>不存在</strong>一条<strong>回路</strong>满足这条回路上的所有边权相等且回路长度为奇数。</p>
<p>你需要最小化最大的权值。请你输出一个解。</p>
<p><span class="math inline">\(n\le 500\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>题目里的条件相当于对于每一个权值 <span class="math inline">\(x\)</span>，记 <span class="math inline">\(E&#39;\)</span> 为所有边权等于 <span class="math inline">\(x\)</span> 的边组成的边集，满足 <span class="math inline">\(G&#39;=(V,E&#39;)\)</span> 是二分图。我们把 <span class="math inline">\(G&#39;\)</span> 叫做权值为 <span class="math inline">\(x\)</span> 的子图。</p>
<p>先猜一个结论，假设边权的最大值为 <span class="math inline">\(k\)</span>，则最大的有解的 <span class="math inline">\(n\)</span> 为 <span class="math inline">\(2^k\)</span>。用数学归纳法可以证明：</p>
<blockquote>
<p>显然 <span class="math inline">\(k=1,n=2\)</span> 是有解的，<span class="math inline">\(k=1,n=3\)</span> 是无解的。 假设我们已经证明了 <span class="math inline">\(k=t-1,n=2^{t-1}\)</span> 是有解的，<span class="math inline">\(k=t-1,n=2^{t-1}+1\)</span> 是无解的，我们要证明 <span class="math inline">\(k=t,n=2^t\)</span> 是有解的，<span class="math inline">\(k=t,n=2^t+1\)</span> 是无解的。 <span class="math inline">\(k=t,n=2^t\)</span> 是有解的很好证明，我们只要把这 <span class="math inline">\(n\)</span> 个点分成两个大小为 <span class="math inline">\(2^{t-1}\)</span> 的集合，两个集合之间的边边权为 <span class="math inline">\(t\)</span>，然后只要使得两个集合内部的边边权最大值为 <span class="math inline">\(t-1\)</span>，则权值为 <span class="math inline">\(t\)</span> 的子图已经符合条件。而对于两个集合，变成了两个相同的子问题，即 <span class="math inline">\(k=t-1,n=2^{t-1}\)</span>，我们已经证明了这是有解的，所以 <span class="math inline">\(k=t,n=2^t\)</span> 也是有解的。 <span class="math inline">\(k=t,n=2^t+1\)</span> 是无解的也很好证明。假设它是有解的，那么答案中权值为 <span class="math inline">\(t\)</span> 的子图一定是二分图且这个二分图的两个集合分别有解。由于总点数是 <span class="math inline">\(2^t+1\)</span>，那么这个二分图的两个集合中一定有一个集合大小 <span class="math inline">\(\ge 2^{t-1}+1\)</span>。已经证明 <span class="math inline">\(k=t-1,n=2^{t-1}+1\)</span> 是无解的，与“这个二分图的两个集合分别有解”矛盾，所以 <span class="math inline">\(k=t,n=2^t+1\)</span> 是无解的。</p>
</blockquote>
<p>所以答案为 <span class="math inline">\(\lceil \log_2 n\rceil\)</span>。考虑构造一个解。我们只要按照一个点的编号二进制下从右往左的第 <span class="math inline">\(\lceil \log_2 n\rceil\)</span> 位是 <span class="math inline">\(0\)</span> 还是 <span class="math inline">\(1\)</span> 分成两个集合，这两个集合之间的边边权设为 <span class="math inline">\(\lceil \log_2 n\rceil\)</span>，然后递归处理。</p>
<p>我们发现，两个点 <span class="math inline">\(i,j\)</span> 的边的边权其实就是 <span class="math inline">\(i\)</span> 与 <span class="math inline">\(j\)</span> 最高的不同的位从右往左的编号，也就是 <span class="math inline">\(\lfloor \log_2 (i \text{ xor }j)\rfloor+1\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, Log[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    Log[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n * <span class="number">2</span>; ++i) Log[i] = Log[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, Log[i ^ j] + <span class="number">1</span>), <span class="built_in">putchar</span>(<span class="string">&quot; \n&quot;</span>[j == n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>JSC 2019 Qual</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>「AtCoder」「JSC 2019 Qual F」Candy Retribution</title>
    <url>/atcoder-jsc19qualF-sol/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_f">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>求满足以下条件的长度为 <span class="math inline">\(n\)</span> 的非负整数序列 <span class="math inline">\(a_1,a_2,a_3,\cdots,a_n\)</span> 的方案数 <span class="math inline">\(\bmod 10^9+7\)</span> 的值：</p>
<ol type="1">
<li><span class="math inline">\(l\le \sum_{i=1}^n a_i\le r\)</span>；</li>
<li>将序列从大到小排序后，记为 <span class="math inline">\(a_1&#39;,a_2&#39;,a_3&#39;,\cdots,a_n&#39;\)</span>，满足 <span class="math inline">\(a_m&#39;=a_{m+1}&#39;\)</span>。</li>
</ol>
<p><span class="math inline">\(1\le m &lt; n\le 3\times 10^5,1\le l,r\le 3\times 10^5\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>显然第一个条件可以差分，假设总和的上界为 <span class="math inline">\(S\)</span>，用隔板法得到不考虑第二个条件的方案数为 <span class="math inline">\(C_{S+n}^n\)</span>。直接算满足第二个条件的不好算，我们考虑算不满足第二个条件的方案数，然后用总方案数减去即可。</p>
<p>我们枚举从大到小排序后的第 <span class="math inline">\(m\)</span> 个数为 <span class="math inline">\(x\)</span>，那么不满足条件的方案数等于在 <span class="math inline">\(n\)</span> 个位置中选出 <span class="math inline">\(m\)</span> 个位置使得这 <span class="math inline">\(m\)</span> 个位置的值 <span class="math inline">\(\ge x\)</span>，其余 <span class="math inline">\(n-m\)</span> 个位置的值 <span class="math inline">\(&lt; x\)</span>，<span class="math inline">\(n\)</span> 个数总和 <span class="math inline">\(\le S\)</span> 的方案数，减去在 <span class="math inline">\(n\)</span> 个位置中选出 <span class="math inline">\(m\)</span> 个位置使得这 <span class="math inline">\(m\)</span> 个位置的值 <span class="math inline">\(\ge x+1\)</span>，其余 <span class="math inline">\(n-m\)</span> 个位置的值 <span class="math inline">\(&lt; x\)</span>，<span class="math inline">\(n\)</span> 个数总和 <span class="math inline">\(\le S\)</span> 的方案数。</p>
<p>于是问题变成了求在 <span class="math inline">\(n\)</span> 个位置中选出 <span class="math inline">\(m\)</span> 个位置使得这 <span class="math inline">\(m\)</span> 个位置的值 <span class="math inline">\(\ge a\)</span>，其余 <span class="math inline">\(n-m\)</span> 个位置的值 <span class="math inline">\(&lt; b\)</span>，<span class="math inline">\(n\)</span> 个数总和 <span class="math inline">\(\le S\)</span> 的方案数。</p>
<p>发现隔板法可以解决的问题的条件是形如 <span class="math inline">\(a_i\ge lim_i\)</span> 这样的，于是我们把 <span class="math inline">\(&lt; b\)</span> 的部分容斥成这个形式。于是我们强制 <span class="math inline">\(i\)</span> 个位置 <span class="math inline">\(\ge b\)</span>，其他位置随便选。</p>
<p>问题变成了求在 <span class="math inline">\(n\)</span> 个位置中选出 <span class="math inline">\(m\)</span> 个位置使得这 <span class="math inline">\(m\)</span> 个位置的值 <span class="math inline">\(\ge a\)</span>，在剩余 <span class="math inline">\(n-m\)</span> 个位置中选 <span class="math inline">\(i\)</span> 个，使得这 <span class="math inline">\(i\)</span> 个位置的值 <span class="math inline">\(\ge b\)</span>，其他 <span class="math inline">\(n-m-i\)</span> 个位置的值 <span class="math inline">\(\ge 0\)</span>，总和 <span class="math inline">\(\le S\)</span> 的方案数。这个问题的答案就是 <span class="math inline">\(C_{n-m}^i\times C_{S-ma-ib+n}^n\)</span>。再乘上容斥系数 <span class="math inline">\((-1)^i\)</span> 即可。</p>
<p>由于需要保证 <span class="math inline">\(ix\le S\)</span>，复杂度是一个调和级数的形式，所以复杂度是 <span class="math inline">\(O(S\log S)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 600005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, fac[N], inv[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123; (a += b) &gt;= P ? a -= P : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123; (a -= b) &lt; <span class="number">0</span> ? a += P : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> (a += b) &gt;= P ? a - P : a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> (a -= b) &lt; <span class="number">0</span> ? a + P : a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = P - <span class="number">2</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1ll</span> * a * a % P) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1ll</span> * s * a % P;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    inv[n] = <span class="built_in">qpow</span>(fac[n]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i) inv[i - <span class="number">1</span>] = <span class="number">1ll</span> * inv[i] * i % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[n] * inv[m] % P * inv[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt;= n - m &amp;&amp; t &lt;= S; t += r, ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1ll</span> * <span class="built_in">C</span>(n - m, i) * <span class="built_in">C</span>(S - t + n, n) % P;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) <span class="built_in">dec</span>(res, s); <span class="keyword">else</span> <span class="built_in">inc</span>(res, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * res * <span class="built_in">C</span>(n, m) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">C</span>(S + n, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i * m &lt;= S; ++i)</span><br><span class="line">        <span class="built_in">dec</span>(res, <span class="built_in">minus</span>(<span class="built_in">get</span>(S - i * m, i), <span class="built_in">get</span>(S - (i + <span class="number">1</span>) * m, i)));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">init</span>(n + r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">minus</span>(<span class="built_in">solve</span>(r), <span class="built_in">solve</span>(l - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>JSC 2019 Qual</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>KEYENCE Programming Contest 2019 题解</title>
    <url>/atcoder-keyence2019/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/keyence2019">比赛地址</a></p>
<p>ABC 就不写了。</p>
<span id="more"></span>
<h3 id="d---double-landscape">D - Double Landscape</h3>
<h4 id="题意">题意</h4>
<p>在一个 <span class="math inline">\(N\times M\)</span> 的网格中不重复地填入 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\times M\)</span> 的整数，使得第 <span class="math inline">\(i\)</span> 行的最大值为 <span class="math inline">\(A_i\)</span>，第 <span class="math inline">\(j\)</span> 列的最大值为 <span class="math inline">\(B_j\)</span>，求方案数。对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(N,M\le 1000\)</span></p>
<h4 id="题解">题解</h4>
<p>将 <span class="math inline">\(A,B\)</span> 从小到大排序，显然不影响答案。</p>
<p>从大到小填数，分为若干种情况：</p>
<ul>
<li>若当前数是超过两行或超过两列的最大值，则一定无解。</li>
<li>若当前数是恰好一行和一列的最大值，则必然填在交界处。</li>
<li>若当前数是恰好一行或恰好一列的最大值，则必然填在该行或该列。</li>
<li>否则，该数可以填在最大值大于等于当前数的任意位置。</li>
</ul>
<p>时间复杂度 <span class="math inline">\(O(NM)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/keyence2019/submissions/17524084">代码</a></p>
<h3 id="e---connecting-cities">E - Connecting Cities</h3>
<h4 id="题意-1">题意</h4>
<p>有一张 <span class="math inline">\(N\)</span> 个点的无向完全图，第 <span class="math inline">\(i\)</span> 个点有点权 <span class="math inline">\(A_i\)</span>。定义一条边 <span class="math inline">\((i,j)\)</span> 的边权为 <span class="math inline">\(|i-j|\times D+A_i+A_j\)</span>。求最小生成树权值。</p>
<p><span class="math inline">\(N\le 2\times 10^5\)</span></p>
<h4 id="题解-1">题解</h4>
<p>直接套用 Boruvka 算法。</p>
<p>每次合并时，对于每个点 <span class="math inline">\(i\)</span>，可以对 <span class="math inline">\(j &lt; i\)</span> 和 <span class="math inline">\(j &gt; i\)</span> 两种情况分别求出不在同一连通块的最小边。</p>
<p>只需要正反扫一遍，维护最小值和与最小值不在同一连通块的最小值即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N\alpha(N)\log N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/keyence2019/submissions/17524608">代码</a></p>
<h3 id="f---paper-cutting">F - Paper Cutting</h3>
<h4 id="题意-2">题意</h4>
<p>有一个 <span class="math inline">\((H+1)\times (W+1)\)</span> 的网格，有 <span class="math inline">\(H\)</span> 条水平线和 <span class="math inline">\(W\)</span> 条垂直线。</p>
<p>你需要执行 <span class="math inline">\(K\)</span> 次操作，每次沿一条水平线或垂直线将网格切开。定义一次操作的权值为做完该操作后网格被分成的块数。</p>
<p>定义一个操作序列的权值为 <span class="math inline">\(K\)</span> 次操作的权值和。</p>
<p>求所有操作序列的权值之和。对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(H,W\le 10^7\)</span></p>
<h4 id="题解-2">题解</h4>
<p>考虑求出第 <span class="math inline">\(k\)</span> 次操作对答案的贡献，为 <span class="math display">\[k!(K-k)!\binom{H+W-k}{K-k}\sum_{i=0}^{k}\binom{H}{i}\binom{W}{k-i}(i+1)(k-i+1)\]</span></p>
<p>考虑优化后面部分，有 <span class="math display">\[
\begin{aligned}
&amp; \sum_{i=0}^{k}\binom{H}{i}\binom{W}{k-i}(i+1)(k-i+1) \\
=~&amp;(k+1)\sum_{i=0}^{k}\binom{H}{i}\binom{W}{k-i}+\sum_{i=0}^{k}i(k-i)\binom{H}{i}\binom{W}{k-i}\\
=~&amp;(k+1)\binom{H+W}{k}+HW\binom{H+W-2}{k-2}
\end{aligned}
\]</span></p>
<p>时间复杂度 <span class="math inline">\(O(H+W)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/keyence2019/submissions/17528071">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>Boruvka</tag>
      </tags>
  </entry>
  <entry>
    <title>Keyence Programming Contest 2020 题解</title>
    <url>/atcoder-keyence2020/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/keyence2020">比赛地址</a></p>
<span id="more"></span>
<p>来不及了，ABC 不写了。</p>
<h3 id="d---swap-and-flip">D - Swap and Flip</h3>
<h4 id="题意">题意</h4>
<p>有 <span class="math inline">\(n\)</span> 张卡片从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 排列，第 <span class="math inline">\(i\)</span> 张正面写着 <span class="math inline">\(A_i\)</span>，反面写着 <span class="math inline">\(B_i\)</span>，一开始都正面朝上。</p>
<p>你每次操作可以交换相邻两张卡片的位置并将这两张卡片翻面。</p>
<p>求使得朝上那面的数字不降的最小操作次数，或输出无解。</p>
<p><span class="math inline">\(n\le 18\)</span></p>
<h4 id="题解">题解</h4>
<p>假设最终序列中第 <span class="math inline">\(i\)</span> 张卡片是原来的第 <span class="math inline">\(p_i\)</span> 张卡片，那么如果 <span class="math inline">\(i\)</span> 与 <span class="math inline">\(p_i\)</span> 奇偶性相同，则朝上的是 <span class="math inline">\(A_{p_i}\)</span>，否则是 <span class="math inline">\(B_{p_i}\)</span>。另外，由于每次交换相邻的两张卡片，所以最小交换次数就是 <span class="math inline">\(p_i\)</span> 的逆序对数量。</p>
<p>于是我们可以考虑枚举奇数位置的卡片集合，然后我们就可以确定奇数位置和偶数位置的朝上的数的可重集合。由于我们最终求的是逆序对数量，所以如果两个数相等那一定是位置靠前的仍然靠前。所以我们可以确定一个 <span class="math inline">\(p_i\)</span>。直接求逆序对即可。</p>
<p>时间复杂度 <span class="math inline">\(O(2^nn^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/keyence2020/submissions/16605332">代码</a></p>
<h3 id="e---bichromization">E - Bichromization</h3>
<h4 id="题意-1">题意</h4>
<p>给定一个 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的无向连通图，每个点还有一个额外的值 <span class="math inline">\(D_i\)</span>。</p>
<p>你需要对每个点黑白染色，给每条边赋一个 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(10^9\)</span> 的整数权值，使得：</p>
<ul>
<li>至少有一个点是黑色，至少有一个点是白色。</li>
<li>对于每个点 <span class="math inline">\(u\)</span>，满足与它最近的异色点 <span class="math inline">\(v\)</span> 到 <span class="math inline">\(u\)</span> 的最短路为 <span class="math inline">\(D_u\)</span>。</li>
</ul>
<p><span class="math inline">\(n\le 10^5,m\le 2\times 10^5,D_i\le 10^9\)</span>。</p>
<h4 id="题解-1">题解</h4>
<p>首先如果存在一个点 <span class="math inline">\(u\)</span> 满足 <span class="math inline">\(\forall (u,v)\in E,D_v&gt;D_u\)</span>，此时 <span class="math inline">\(v\)</span> 如果与 <span class="math inline">\(u\)</span> 异色，则 <span class="math inline">\((u,v)\)</span> 的权值一定不小于 <span class="math inline">\(D_v\)</span>；如果 <span class="math inline">\(v\)</span> 与 <span class="math inline">\(u\)</span> 同色，则 <span class="math inline">\(D_v\)</span> 也无法更新 <span class="math inline">\(D_u\)</span>。所以此时 <span class="math inline">\(D_u\)</span> 不会被任何一个 <span class="math inline">\(v\)</span> 更新到，一定无解。</p>
<p>接下来我们考虑按照 <span class="math inline">\(D_u\)</span> 从小到大依次染色。</p>
<p>如果 <span class="math inline">\(u\)</span> 相连的点中已经存在被染色的点，那么我们任取其中一个 <span class="math inline">\(v\)</span>，将 <span class="math inline">\(u\)</span> 染成与 <span class="math inline">\(v\)</span> 异色的点，将 <span class="math inline">\((u,v)\)</span> 的边权置为 <span class="math inline">\(D_u\)</span>，此时 <span class="math inline">\(u\)</span> 一定会被 <span class="math inline">\(v\)</span> 更新到，而 <span class="math inline">\(v\)</span> 因为 <span class="math inline">\(D_v \le D_u\)</span>，不会被更新到。</p>
<p>如果不存在，则此时一定存在至少一个 <span class="math inline">\(v\)</span> 满足 <span class="math inline">\(D_v=D_u\)</span>，任取其中一个，将 <span class="math inline">\(u,v\)</span> 染不同颜色，将 <span class="math inline">\((u,v)\)</span> 的边权置为 <span class="math inline">\(D_u\)</span>，此时 <span class="math inline">\(u,v\)</span> 能互相被更新到。</p>
<p>可以发现，上述染色过程中，每次都可以保证当前被染色的点 <span class="math inline">\(u\)</span> 满足 <span class="math inline">\(D_u\)</span> 的限制。</p>
<p>剩下没有被赋权值的边全部赋成 <span class="math inline">\(10^9\)</span> 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n+m)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/keyence2020/submissions/16598216">代码</a></p>
<h3 id="f---monochromization">F - Monochromization</h3>
<h4 id="题意-2">题意</h4>
<p>有一个 <span class="math inline">\(H\times W\)</span> 的黑白矩阵 <span class="math inline">\(A\)</span>，求有多少个 <span class="math inline">\(H\times W\)</span> 的黑白矩阵可以通过 <span class="math inline">\(A\)</span> 按任意顺序执行任意次以下几种操作得到：</p>
<ul>
<li>选择一行，全部染成黑色或白色；</li>
<li>选择一列，全部染成黑色或白色。</li>
</ul>
<p>对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(H,W\le 10\)</span></p>
<h4 id="题解-2">题解</h4>
<p>首先我们考虑 <span class="math inline">\(A\)</span> 全白的情况。</p>
<p>对于一个矩阵，定义可移除行为颜色全相同的行，可移除列为颜色全相同的列。那么一个矩阵能得到当且仅当重复执行若干轮以下操作后变为空矩阵：</p>
<ul>
<li>将所有可移除行删除（剩下的行重新按顺序排列形成一个新的矩阵）；</li>
<li>将所有可移除列删除（剩下的列重新按顺序排列形成一个新的矩阵）。</li>
</ul>
<p>可以发现由于这两个操作交替地、重复地执行，且每次把能删除的都删除，一个矩阵对应的操作序列一定是唯一的。</p>
<p>这样我们避免了算重，只需要统计合法操作序列数量即可。</p>
<p>我们发现，需要关注的不仅仅是当前矩阵的行数和列数，上次删除的是行还是列，我们还需要关注上一次删除的行或列的颜色是否全部相等。</p>
<p>假设上一次删的全部是列，现在需要删除行。如果上次删的列颜色不全相等，那么再上一次删行时一定已经把能删的都删完了。</p>
<p>如果上次删的列颜色全部是黑色，那么如果有全黑色的行，那么我们把之前删的黑色的列重新加回去时，这一行仍然是全黑色的，我们可以在上一次删行时把这一行删掉。所以这一次删行时删的行一定都是白色，这样才能保证之前把能删的都删完了。</p>
<p>于是 <span class="math inline">\(f_{i,j,k}\)</span> 表示上一次删的是行，当前矩阵大小为 <span class="math inline">\(i\times j\)</span>，上一次删的行有 <span class="math inline">\(k\)</span> 种不同的颜色（<span class="math inline">\(k\in \{1,2\}\)</span>）。<span class="math inline">\(g_{i,j,k}\)</span> 类似，表示上一次删的是列。</p>
<p>转移比较简单，具体可以参考代码。要注意设置初始值是，应该把删除的行是同种颜色的方案也计入 <span class="math inline">\(f_{i,m,2}\)</span>，这是因为第一次删除列时没有再上一次的删除列操作，仍然可以删除不同颜色的列。</p>
<p>接下来回到原问题。此时一个矩阵能得到的条件是通过上述移除操作，直到无法移除后，每个位置的颜色与 <span class="math inline">\(A\)</span> 中对应位置（即没有进行移除操作前的位置）的颜色相同。</p>
<p>若最后的矩阵为空，与之前的问题相同，需要特殊处理。</p>
<p>否则，我们枚举最后保留的行和列，合法的条件是保留的行和列组成的矩阵不存在可移除行和可移除列。然后把方案数直接加上即可。注意此时由于固定了行和列，需要除以两个组合数。</p>
<p>时间复杂度 <span class="math inline">\(O(2^{H+W}(H+W))\)</span>。</p>
<p><a href="https://atcoder.jp/contests/keyence2020/submissions/16605241">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>M-SOLUTIONS Programming Contest 题解</title>
    <url>/atcoder-m-solutions2019/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/m-solutions2019">比赛地址</a></p>
<span id="more"></span>
<p>AB 就不写了。</p>
<h3 id="c---best-of-2n-1">C - Best-of-(2n-1)</h3>
<h4 id="题意">题意</h4>
<p>A 和 B 玩游戏，每一轮有 <span class="math inline">\(a\)</span> 的概率 A 获胜，<span class="math inline">\(b\)</span> 的概率 <span class="math inline">\(B\)</span> 获胜，<span class="math inline">\(1-a-b\)</span> 的概率平局。他们会一直玩直到某个人获胜了 <span class="math inline">\(n\)</span> 轮。</p>
<p>求期望轮数。</p>
<p><span class="math inline">\(n\le 10^5\)</span></p>
<h4 id="题解">题解</h4>
<p>假设最后 A 获胜了 <span class="math inline">\(n\)</span> 轮。考虑枚举 B 获胜的轮数 <span class="math inline">\(i\)</span>，确定 A 和 B 获胜的轮的相对顺序后，那么还有 <span class="math inline">\(i+n\)</span> 个空可以插入一段平局。一段平局加一轮不平局的期望轮数为 <span class="math display">\[
\sum_{i=0}^{\infty}\left(1-a-b\right)^i=\frac{1}{a+b}
\]</span></p>
<p>所以答案为 <span class="math display">\[
\sum_{i=0}^{n}\binom{n-1+i}{i}\left(\frac{a}{a+b}\right)^n\left(\frac{b}{a+b}\right)^i(i+n)\frac{1}{a+b}
\]</span></p>
<p><a href="https://atcoder.jp/contests/m-solutions2019/submissions/16967067">代码</a></p>
<h3 id="d---maximum-sum-of-minimum">D - Maximum Sum of Minimum</h3>
<h4 id="题意-1">题意</h4>
<p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，将 <span class="math inline">\(c_1,c_2,\ldots,c_n\)</span> 中的每个数填入树上的恰好一个点。定义一条边的边权为这条边连接的两个点上数字的较小值。</p>
<p>求所有边权之和的最大值，并构造一种填数方案。</p>
<p><span class="math inline">\(n\le 10^4\)</span></p>
<h4 id="题解-1">题解</h4>
<p>考虑从小到大填数。为了使大的数字贡献更多，我们一定会使当前数字的贡献尽量小。</p>
<p>那么我们从小到大填数，每次将当前数填入一个叶子，将该叶子删去即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/m-solutions2019/submissions/16967746">代码</a></p>
<h3 id="e---product-of-arithmetic-progression">E - Product of Arithmetic Progression</h3>
<h4 id="题意-2">题意</h4>
<p><span class="math inline">\(Q\)</span> 次询问，每次询问给定 <span class="math inline">\(x,d,n\)</span>，求 <span class="math display">\[
\prod_{i=0}^{n-1} (x+id)
\]</span></p>
<p>对 <span class="math inline">\(P=10^6+3\)</span> 取模。</p>
<p><span class="math inline">\(Q\le 10^5,0\le x,d &lt; P,n\le 10^9\)</span></p>
<h4 id="题解-2">题解</h4>
<p>先考虑 <span class="math inline">\(d=1\)</span> 的情况。若 <span class="math inline">\(x+d-1\ge P\)</span> 或 <span class="math inline">\(x=0\)</span>，那答案一定是 <span class="math inline">\(0\)</span>，否则答案就是 <span class="math inline">\(\frac{(x+d-1)!}{(x-1)!}\)</span>，直接预处理阶乘和阶乘逆元即可。</p>
<p><span class="math inline">\(d&gt;1\)</span> 时，我们可以将式子化为 <span class="math display">\[
d^n\prod_{i=0}^{n-1}\left(\frac{x}{d}+i\right)
\]</span></p>
<p>就与 <span class="math inline">\(d=1\)</span> 的情况一样了。注意特判 <span class="math inline">\(d=0\)</span> 的情况。</p>
<p><a href="https://atcoder.jp/contests/m-solutions2019/submissions/16968246">代码</a></p>
<h3 id="f---random-tournament">F - Random Tournament</h3>
<h4 id="题意-3">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个人参加比赛，给定两两之间比赛的输赢关系。</p>
<p>比赛规则是，先将 <span class="math inline">\(N\)</span> 个人按 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\)</span> 的顺序从左到右排列，每次随机相邻两个人进行比赛，输的人离开，直到剩下一个人，这个人就是冠军。</p>
<p>求有多少个人可能成为冠军。</p>
<p><span class="math inline">\(N\le 2000\)</span></p>
<h4 id="题解-3">题解</h4>
<p>一个朴素的区间 DP 是，令 <span class="math inline">\(f_{l,r,x}\)</span> 表示只考虑 <span class="math inline">\([l,r]\)</span> 中的人，<span class="math inline">\(x\)</span> 是否可能成为冠军。转移则需要考虑 <span class="math inline">\([l,x-1]\)</span> 中的冠军和 <span class="math inline">\([x+1,r]\)</span> 中的冠军。</p>
<p>注意到对于所有 <span class="math inline">\(l &lt; x &lt; r\)</span>，<span class="math inline">\(x\)</span> 能在 <span class="math inline">\([l,r]\)</span> 中取得冠军的充要条件是他在 <span class="math inline">\([l,x]\)</span> 中能取得冠军，<span class="math inline">\([x,r]\)</span> 中也能取得冠军。即有 <span class="math inline">\(f_{l,r,x}=f_{l,x,x}\land f_{x,r,x}\)</span>。</p>
<p>于是我们只需要记录 <span class="math inline">\(x\in \{l,r\}\)</span> 的状态即可，转移枚举 <span class="math inline">\([l+1,r]\)</span> 或 <span class="math inline">\([l,r-1]\)</span> 中的冠军即可。</p>
<p>写出转移式子后发现可以 bitset 优化。</p>
<p>时间复杂度 <span class="math inline">\(O(\frac{N^3}{w})\)</span>。</p>
<p><a href="https://atcoder.jp/contests/m-solutions2019/submissions/16971243">代码</a></p>
<p><a href="https://atcoder.jp/contests/m-solutions2019/submissions/16971201">bitset 优化前的代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>贪心</tag>
        <tag>概率</tag>
        <tag>期望</tag>
        <tag>数论</tag>
        <tag>bitset</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>NIKKEI Programming Contest 2019 题解</title>
    <url>/atcoder-nikkei2019-qual/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/nikkei2019-qual">比赛地址</a></p>
<p>ABCD 就不写了。</p>
<span id="more"></span>
<h3 id="e---weights-on-vertices-and-edges">E - Weights on Vertices and Edges</h3>
<h4 id="题意">题意</h4>
<p>给定一个 <span class="math inline">\(N\)</span> 个点 <span class="math inline">\(M\)</span> 条边的点带权、边带权无向连通图 <span class="math inline">\(G\)</span>，你需要删除一些边，使得对于留下的每条边边权小于等于该边所在连通块的点权之和。</p>
<p><span class="math inline">\(N,M\le 10^5\)</span></p>
<h4 id="题解">题解</h4>
<p>考虑一个 <span class="math inline">\(O(NM)\)</span> 的做法，每次将边权大于当前连通块的边全部删除，然后分治处理每个连通块。</p>
<p>显然这个做法与从大到小判断每条边是否满足条件，不满足则删去的做法是一样的。</p>
<p>注意到一条边若满足条件，那么该条边当前所在的连通块中的任意一条边都不会被删除。</p>
<p>于是用带撤销并查集维护即可。</p>
<p>时间复杂度 <span class="math inline">\(O(M\log M)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/nikkei2019-qual/submissions/17519750">代码</a></p>
<h3 id="f---jewels">F - Jewels</h3>
<h4 id="题意-1">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个珠宝，<span class="math inline">\(K\)</span> 种颜色，第 <span class="math inline">\(i\)</span> 个珠宝颜色为 <span class="math inline">\(C_i\)</span>，价值为 <span class="math inline">\(V_i\)</span>，保证每种颜色至少出现了两次。</p>
<p>你需要对于每个 <span class="math inline">\(1\le x\le N\)</span>，求出满足以下条件时，选择恰好 <span class="math inline">\(x\)</span> 个珠宝的最大价值和：</p>
<ul>
<li>对于选择的任意一个珠宝，存在另一个与它颜色相同的珠宝也被选择。</li>
</ul>
<p><span class="math inline">\(N\le 2\times 10^5\)</span></p>
<h4 id="题解-1">题解</h4>
<p>对于同种颜色价值最大的两个珠宝，一定会被同时选择。考虑将这样的两个珠宝捆在一起。</p>
<p>我们将所有珠宝按价值从大到小排序，特别地，对于两个捆在一起的珠宝，价值看成平均值，并且价值相等时强制排在其它珠宝前面。</p>
<p>对于一个 <span class="math inline">\(x\)</span>，若前 <span class="math inline">\(x\)</span> 个珠宝恰好可以被选择，那么答案一定为前 <span class="math inline">\(x\)</span> 个珠宝的价值和。</p>
<p>否则，我们可以先选择前 <span class="math inline">\(x-1\)</span> 个，然后考虑如何使数量增加 <span class="math inline">\(1\)</span>。我们在选择前 <span class="math inline">\(x-1\)</span> 个的基础上，定义以下集合（一种颜色使用过当且仅当选择的珠宝中存在该颜色的珠宝）：</p>
<ul>
<li><span class="math inline">\(P\)</span> 为被选择的珠宝中不是捆在一起的珠宝。</li>
<li><span class="math inline">\(Q\)</span> 为颜色使用过的珠宝中没有被选择的珠宝。</li>
<li><span class="math inline">\(R\)</span> 为颜色使用过的、捆在一起且其他该颜色的珠宝没有被选择的珠宝对。</li>
<li><span class="math inline">\(S\)</span> 为颜色没使用过的、捆在一起的珠宝对。</li>
<li><span class="math inline">\(T\)</span> 为颜色没使用过的、捆在一起的珠宝和其他该颜色的珠宝中价值最大的组成的三元组。</li>
</ul>
<p>那么有三种情况：</p>
<ul>
<li>添加一个 <span class="math inline">\(Q\)</span> 中的珠宝。</li>
<li>删去一个 <span class="math inline">\(P\)</span> 中的珠宝，添加一个 <span class="math inline">\(S\)</span> 中的珠宝对。</li>
<li>删去一个 <span class="math inline">\(R\)</span> 中的珠宝对，添加一个 <span class="math inline">\(T\)</span> 中的珠宝三元组。</li>
</ul>
<p>可以证明不可能存在这三种情况以外的调整方法。</p>
<p>于是我们使用 <code>std::multiset</code> 维护即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N\log N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/nikkei2019-qual/submissions/17522982">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>NOMURA Programming Competition 2020 题解</title>
    <url>/atcoder-nomura2020/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/nomura2020">比赛地址</a></p>
<span id="more"></span>
<p>ABC 之前做过，就不写了。</p>
<h3 id="d---urban-planning">D - Urban Planning</h3>
<h4 id="题意">题意</h4>
<p>有一个 <span class="math inline">\(n\)</span> 个点的无向图，初始没有边。</p>
<p>定义一个序列 <span class="math inline">\(a_1,a_2,\ldots,a_n\ (1\le a_i\le n,a_i\ne i)\)</span> 的权值为，要求对于每个 <span class="math inline">\(1\le i\le n\)</span>，最终的无向图中 <span class="math inline">\(i\)</span> 与 <span class="math inline">\(a_i\)</span> 连通，最少需要加入的边数。</p>
<p>给定序列 <span class="math inline">\(P_1,P_2,\ldots,P_n\)</span>，有些 <span class="math inline">\(P_i\)</span> 可能为 <span class="math inline">\(-1\)</span>，你需要将所有 <span class="math inline">\(P_i=-1\)</span> 的位置替换成一个不为 <span class="math inline">\(i\)</span> 的 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的整数，求所有这些序列的权值之和。对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(n\le 5000\)</span></p>
<h4 id="题解">题解</h4>
<p>显然序列 <span class="math inline">\(a_1,a_2,\ldots,a_n\)</span> 的权值为 <span class="math inline">\(i\)</span> 与 <span class="math inline">\(a_i\)</span> 连边时的最小生成森林大小，即点数减环数。那么不妨计算环数之和。考虑计算每个环对答案的贡献。</p>
<p>对于所有 <span class="math inline">\(P_i\ne -1\)</span> 的位置，我们将 <span class="math inline">\(i\)</span> 与 <span class="math inline">\(P_i\)</span> 连边，这样每个连通块就是一个基环树或树。</p>
<p>设 <span class="math inline">\(-1\)</span> 的数量为 <span class="math inline">\(k\)</span>。</p>
<p>对于是基环树的连通块，每一种方案都会包含这个环，所以答案直接加上 <span class="math inline">\((n-1)^k\)</span> 即可。</p>
<p>接下来我们考虑是树的连通块之间形成的环。假设这些连通块大小为 <span class="math inline">\(a_1,a_2,\ldots,a_m\)</span>。</p>
<p>若我们选出了 <span class="math inline">\(x_1,x_2,\ldots,x_l\)</span> 这些连通块连成一个基环树，那么方案数为 <span class="math display">\[(l-1)!\prod_{i=1}^{l} a_{x_i}\]</span></p>
<p>对答案的贡献只要再乘上 <span class="math inline">\((n-1)^{m-l}\)</span> 即可。</p>
<p>简单的 DP 即可。时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/nomura2020/submissions/16496184">代码</a></p>
<h3 id="e---binary-programming">E - Binary Programming</h3>
<h4 id="题意-1">题意</h4>
<p>有一个初始为空的字符串 <span class="math inline">\(S\)</span> 和初始为 <span class="math inline">\(0\)</span> 的整数变量 <span class="math inline">\(x\)</span>。</p>
<p>给定 01 字符串 <span class="math inline">\(T\)</span>，你可以执行以下操作 <span class="math inline">\(|T|\)</span> 次：</p>
<ul>
<li>在 <span class="math inline">\(S\)</span> 的任意位置插入字符 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span>。</li>
<li>将 <span class="math inline">\(x\)</span> 加上 <span class="math inline">\(S\)</span> 中奇数位置的数字之和。<span class="math inline">\(S\)</span> 从 <span class="math inline">\(1\)</span> 开始标号。</li>
</ul>
<p>你需要保证最后 <span class="math inline">\(S=T\)</span>。</p>
<p>求最终 <span class="math inline">\(x\)</span> 的最大值。</p>
<p><span class="math inline">\(|T|\le 2\times 10^5\)</span></p>
<h4 id="题解-1">题解</h4>
<p>首先我们可以将操作变成从 <span class="math inline">\(T\)</span> 中不断删除字符。</p>
<p>那么一定是先删 <span class="math inline">\(0\)</span> 再删 <span class="math inline">\(1\)</span>。</p>
<p>证明可以考虑如果当前存在 <span class="math inline">\(0\)</span> 但是删除了 <span class="math inline">\(1\)</span>，假设这个字符串是 <span class="math inline">\(S\)</span>，那么我们如果不删除这个 <span class="math inline">\(1\)</span>，改而删除这个 <span class="math inline">\(1\)</span> 左边或右边最近的一个 <span class="math inline">\(0\)</span>，得到的字符串 <span class="math inline">\(S&#39;\)</span> 相比于 <span class="math inline">\(S\)</span> 一定是某个位置的 <span class="math inline">\(0\)</span> 变成了 <span class="math inline">\(1\)</span>，不会更劣。</p>
<p>而删除 <span class="math inline">\(0\)</span> 时一定是不断删除第一个奇数位置的 <span class="math inline">\(0\)</span>。若不存在奇数位置的 <span class="math inline">\(0\)</span>，则从后往前依次删除 <span class="math inline">\(0\)</span>。</p>
<p>证明可以考虑对于一段长度为偶数的连续的 <span class="math inline">\(1\)</span>，在删除 <span class="math inline">\(0\)</span> 的过程中贡献一定相同，可以不考虑，直接删去。</p>
<p>于是我们可以将原串处理成没有连续两个 <span class="math inline">\(1\)</span> 相邻的形式。剩下对于所有 <span class="math inline">\(1\)</span> 的位置 <span class="math inline">\(i\)</span>，记 <span class="math inline">\(pre_i\)</span> 为 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(i\)</span> 中 <span class="math inline">\(0\)</span> 的数量，<span class="math inline">\(suf_i\)</span> 为 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(|T|\)</span> 中 <span class="math inline">\(0\)</span> 的数量，那么这个位置的 <span class="math inline">\(1\)</span> 在删除 <span class="math inline">\(0\)</span> 的过程中贡献最多为 <span class="math inline">\(\lfloor\frac{pre_i+1+i\bmod 2}{2}\rfloor+suf_i\)</span>，而上述删除顺序恰好可以达到该上界。</p>
<p>删除 <span class="math inline">\(1\)</span> 时的贡献可以简单的算出。</p>
<p>时间复杂度 <span class="math inline">\(O(|T|)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/nomura2020/submissions/16497230">代码</a></p>
<h3 id="f---sorting-game">F - Sorting Game</h3>
<h4 id="题意-2">题意</h4>
<p>A 和 B 玩游戏，过程如下：</p>
<ul>
<li>给出一个长度为 <span class="math inline">\(M\)</span>，元素为 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(2^N-1\)</span> 的整数的序列 <span class="math inline">\(a_1,\ldots,a_M\)</span>。</li>
<li>A 可以选择一些二进制位，将 <span class="math inline">\(a\)</span> 中每个数的这些二进制位置为 <span class="math inline">\(0\)</span>。</li>
<li>B 可以执行若干次交换 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{i+1}\)</span> 的操作，需要满足 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{i+1}\)</span> 二进制位恰好有一位不同。</li>
</ul>
<p>你需要求有多少种不同的序列 <span class="math inline">\(a\)</span>，使得 A 无论如何操作，B 都可以将 <span class="math inline">\(a\)</span> 从小到大排序。对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(N,M\le 5000\)</span></p>
<h4 id="题解-2">题解</h4>
<p>注意到合法的 <span class="math inline">\(a\)</span> 需要满足对于所有 <span class="math inline">\(1\le i &lt; j\le M\)</span>，<span class="math inline">\(a_i\)</span> 与 <span class="math inline">\(a_j\)</span> 从高到低第一次出现 <span class="math inline">\(a_i\)</span> 的这一位为 <span class="math inline">\(1\)</span>，<span class="math inline">\(a_j\)</span> 的这一位为 <span class="math inline">\(0\)</span> 的位置后，更低位都相同。</p>
<p>考虑 <span class="math inline">\(a_1,a_2,\ldots,a_M\)</span> 的最高位，有两种情况：</p>
<ul>
<li>形如 <span class="math inline">\(0\ldots01\ldots1\)</span>，这样我们就不需要考虑这一位，变成一个 <span class="math inline">\(N-1\)</span> 位的子问题，最高位的填数方案数为 <span class="math inline">\(M+1\)</span>。</li>
<li>形如 <span class="math inline">\(0\ldots0\mathbf{1x\ldots x0}1\ldots 1\)</span>，此时中间加粗部分的更低位需要全部相同，所以假设加粗部分的长度为 <span class="math inline">\(i\)</span>，那么变成了一个 <span class="math inline">\(N-1\)</span> 位，序列长度为 <span class="math inline">\(M-i+1\)</span> 的子问题，最高位的填数方案为 <span class="math inline">\((M-i+1)2^{i-2}\)</span>。</li>
</ul>
<p>可以证明除这两种情况以外的情况一定不合法。</p>
<p>所以我们就有了一个朴素的 <span class="math inline">\(O(NM^2)\)</span> DP，用前缀和优化可以做到 <span class="math inline">\(O(NM)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/nomura2020/submissions/16501398">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Tenka1 Programmer Contest 2019 题解</title>
    <url>/atcoder-tenka1-2019/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/tenka1-2019">比赛地址</a></p>
<span id="more"></span>
<h3 id="c---stones">C - Stones</h3>
<h4 id="题意">题意</h4>
<p>给定一个只由 <code>.</code> 和 <code>#</code> 组成的字符串 <span class="math inline">\(S\)</span>，你可以修改若干字符使得不存在子串 <code>#.</code>。求最少修改次数。</p>
<p><span class="math inline">\(|S|\le 2\times 10^5\)</span></p>
<h4 id="题解">题解</h4>
<p>显然最后 <span class="math inline">\(S\)</span> 一定是形如 <code>...###</code> 的。求出前缀 <code>#</code> 的数量和后缀 <code>.</code> 的数量后枚举分界线计算即可。</p>
<p>时间复杂度 <span class="math inline">\(O(|S|)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/tenka1-2019/submissions/17013771">代码</a></p>
<h3 id="d---three-colors">D - Three Colors</h3>
<h4 id="题意-1">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个整数 <span class="math inline">\(A_i\)</span>，将每个数染成红、绿、蓝三种颜色，记红、绿、蓝的数之和分别为 <span class="math inline">\(R,G,B\)</span>，求使得 <span class="math inline">\(R,G,B\)</span> 能组成一个面积为正数的三角形的染色方案数。对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(N\le 300,A_i\le 300\)</span></p>
<h4 id="题解-1">题解</h4>
<p>令 <span class="math inline">\(S\)</span> 为所有数之和，那么染色方案合法当且仅当 <span class="math inline">\(R,G,B &lt; \frac{S}{2}\)</span>。</p>
<p>考虑容斥，用背包计算方案数即可。</p>
<p>时间复杂度 <span class="math inline">\(O(NS)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/tenka1-2019/submissions/17014053">代码</a></p>
<h3 id="e---polynomial-divisors">E - Polynomial Divisors</h3>
<h4 id="题意-2">题意</h4>
<p>给定一个多项式 <span class="math inline">\(f(x)=\sum_{i=0}^{N}a_ix^i\)</span>，求出所有的质数 <span class="math inline">\(p\)</span> 满足对于任意整数 <span class="math inline">\(x\)</span>，都有 <span class="math inline">\(p\mid f(x)\)</span>。</p>
<p><span class="math inline">\(N\le 10^4,a_i\le 10^9\)</span></p>
<h4 id="题解-2">题解</h4>
<p>假设已经确定 <span class="math inline">\(p\)</span>，考虑判断是否合法。根据费马小定理，当 <span class="math inline">\(x\not\equiv 0\pmod{p}\)</span> 时，有 <span class="math inline">\(x^a\equiv x^{a\bmod (p-1)}\pmod{p}\)</span>，那么我们可以将原多项式化为以下形式： <span class="math display">\[
f(x)=\sum_{i=0}^{p-2}b_ix^i
\]</span></p>
<p>那么 <span class="math inline">\(p\)</span> 合法的充要条件是对于所有 <span class="math inline">\(0\le i &lt; p-1\)</span>，有 <span class="math inline">\(b_i\equiv 0\pmod{p}\)</span>。充分性显然，必要性证明如下：</p>
<p>因为对于所有 <span class="math inline">\(0\le x &lt; p\)</span>，都有 <span class="math inline">\(f(x)\equiv 0\pmod{p}\)</span>，相当于给定了多项式的 <span class="math inline">\(p\)</span> 个点值 <span class="math inline">\((x,0)\)</span>。由于 <span class="math inline">\(p\)</span> 个点值可以唯一确定一个小于 <span class="math inline">\(p\)</span> 次的多项式，而显然这个多项式一定是所有系数全 <span class="math inline">\(0\)</span> 的多项式，所以必然有 <span class="math inline">\(b_i\equiv 0\pmod{p}\)</span>。</p>
<p>于是我们枚举所有 <span class="math inline">\(N\)</span> 以内的质数和所有系数的 <span class="math inline">\(\gcd\)</span> 的质因子作为 <span class="math inline">\(p\)</span> 进行判断即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N(\pi(N)+\log a_i))\)</span>，其中 <span class="math inline">\(\pi(N)\)</span> 表示 <span class="math inline">\(N\)</span> 以内质数数量。</p>
<p><a href="https://atcoder.jp/contests/tenka1-2019/submissions/17014310">代码</a></p>
<h3 id="f---banned-x">F - Banned X</h3>
<h4 id="题意-3">题意</h4>
<p>求只包含 <span class="math inline">\(0,1,2\)</span> 的，长度为 <span class="math inline">\(N\)</span> 的，满足以下条件的序列数量：</p>
<ul>
<li>不包含和为 <span class="math inline">\(X\)</span> 的连续子序列。</li>
</ul>
<p>对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(N\le 3000\)</span></p>
<h4 id="题解-3">题解</h4>
<p>令 <span class="math inline">\(f_{i,j}\)</span> 表示长度为 <span class="math inline">\(i\)</span>，和为 <span class="math inline">\(j\)</span> 的方案数。<span class="math inline">\(j &lt; X\)</span> 可以直接转移，而 <span class="math inline">\(j=X\)</span> 则一定为 <span class="math inline">\(0\)</span>。接下来考虑 <span class="math inline">\(j &gt; X\)</span> 的情况。</p>
<p>注意到此时因为总和大于 <span class="math inline">\(X\)</span>，若我们对该序列作前缀和，那么一定存在相邻两个前缀和分别为 <span class="math inline">\(X-1\)</span> 和 <span class="math inline">\(X+1\)</span>，假设位置为 <span class="math inline">\(k\)</span> 和 <span class="math inline">\(k+1\)</span>。此时第一个数和第 <span class="math inline">\(k+1\)</span> 个数一定是 <span class="math inline">\(2\)</span>，所以第 <span class="math inline">\(2\)</span> 个数和第 <span class="math inline">\(k+2\)</span> 个数也一定是 <span class="math inline">\(2\)</span>……我们可以推出 <span class="math inline">\(k+1\)</span> 到 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n-k\)</span> 这些数都是 <span class="math inline">\(2\)</span>。</p>
<p>那么有 <span class="math inline">\(2(n-k)=j-(X-1)\)</span>，我们可以唯一确定这个 <span class="math inline">\(k\)</span>。于是就可以确定中间未填部分的长度与和，直接转移即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/tenka1-2019/submissions/17016278">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>Tokio Marine &amp; Nichido Fire Insurance Programming Contest 2020 题解</title>
    <url>/atcoder-tokiomarine2020/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/tokiomarine2020">比赛地址</a></p>
<span id="more"></span>
<p>ABC 之前做过，就不写了。</p>
<h3 id="d---knapsack-queries-on-a-tree">D - Knapsack Queries on a tree</h3>
<h4 id="题意">题意</h4>
<p>给定一个 <span class="math inline">\(N\)</span> 个点的完全二叉树，每个点上有一个重量为 <span class="math inline">\(W_i\)</span>，价值为 <span class="math inline">\(V_i\)</span> 的物品。</p>
<p><span class="math inline">\(Q\)</span> 次询问，每次询问给定 <span class="math inline">\(v,L\)</span>，求在 <span class="math inline">\(v\)</span> 到根路径上的物品中选出若干个（可以为 <span class="math inline">\(0\)</span> 个）重量和不超过 <span class="math inline">\(L\)</span> 的物品的最大价值和。</p>
<p><span class="math inline">\(N &lt; 2^{18}, Q\le 10^5, L\le 10^5\)</span></p>
<h4 id="题解">题解</h4>
<p>一个朴素 DP 是，用 <span class="math inline">\(f[i][j]\)</span> 表示在 <span class="math inline">\(i\)</span> 到根的路径上选出重量和不超过 <span class="math inline">\(j\)</span> 的物品的最大价值和。</p>
<p>直接 DP 是 <span class="math inline">\(O(NL)\)</span> 的，需要优化。</p>
<p>我们考虑只处理出前 <span class="math inline">\(9\)</span> 层节点的 DP 数组。然后对于每个询问，暴力枚举最后不超过 <span class="math inline">\(9\)</span> 个物品的选择状态即可。</p>
<p>时间复杂度 <span class="math inline">\(O(Q\sqrt{N})\)</span>。</p>
<p><a href="https://atcoder.jp/contests/tokiomarine2020/submissions/16493393">代码</a></p>
<h3 id="e---orand">E - O(rand)</h3>
<h4 id="题意-1">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个数 <span class="math inline">\(A_1,A_2,\ldots,A_N\)</span>，求在其中选出 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(K\)</span> 个满足以下条件的数的方案数：</p>
<ul>
<li>选择的数的 AND 和为 <span class="math inline">\(S\)</span>；</li>
<li>选择的数的 OR 和为 <span class="math inline">\(T\)</span>。</li>
</ul>
<p><span class="math inline">\(N\le 50,A_i &lt; 2^{18}\)</span></p>
<h4 id="题解-1">题解</h4>
<p>一个朴素的 <span class="math inline">\(3^{18}\)</span> 的容斥是，对于所有 <span class="math inline">\(S\)</span> 为 <span class="math inline">\(0\)</span>，<span class="math inline">\(T\)</span> 为 <span class="math inline">\(1\)</span> 的位，枚举是强制选 <span class="math inline">\(0\)</span>、强制选 <span class="math inline">\(1\)</span> 还是没有限制。</p>
<p>考虑优化，发现容斥系数只与有限制的位置数量有关，于是我们考虑枚举有限制的位置。然后我们再枚举一个数 <span class="math inline">\(A_i\)</span> 强制选择，这样我们就可以确定每一个有限制的位是填 <span class="math inline">\(0\)</span> 还是填 <span class="math inline">\(1\)</span>。</p>
<p>统计出合法的数字数量，用组合数计算即可。</p>
<p>时间复杂度 <span class="math inline">\(O(2^{18}N)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/tokiomarine2020/submissions/16493055">代码</a></p>
<h3 id="f---triangles">F - Triangles</h3>
<h4 id="题意-2">题意</h4>
<p>二维平面上有一个以 <span class="math inline">\((0,0)\)</span> 为左下角，<span class="math inline">\((W,H)\)</span> 为右上角的矩形。</p>
<p>你需要求满足以下条件的三角形数量：</p>
<ul>
<li>顶点为格点；</li>
<li>三个顶点分别在矩形的三条不同的边上，且不能在矩形的顶点上；</li>
<li>三角形内部（不包括边和顶点）的格点数不超过 <span class="math inline">\(K\)</span>。</li>
</ul>
<p><span class="math inline">\(W,H,K\le 10^5\)</span></p>
<h4 id="题解-2">题解</h4>
<p>下面我们考虑计算三个点分别为 <span class="math inline">\((0,y),(x_1,0),(x_1+d,H)\ (0 &lt; y &lt; H, 0 &lt; x_1 &lt; x_1+d &lt; W)\)</span> 的三角形数量，其他情况类似。</p>
<p>由皮克定理，设三角形面积为 <span class="math inline">\(S\)</span>，内部格点数为 <span class="math inline">\(i\)</span>，边和顶点上格点数为 <span class="math inline">\(b\)</span>，则有 <span class="math display">\[2S=2i+b-2\]</span></p>
<p>对于该三角形，有 <span class="math inline">\(2S=x_1H+dy,b=\gcd(d,H)+\gcd(x_1+d,H-y)+\gcd(x_1,y)\)</span>。</p>
<p>代入皮克定理的式子，得到</p>
<p><span class="math display">\[x_1H+dy=2i+\gcd(d,H)+\gcd(x_1+d,H-y)+\gcd(x_1,y)-2\]</span></p>
<p>显然当 <span class="math inline">\(x_1H+dy &gt;3H+2K\)</span> 时 <span class="math inline">\(i\le K\)</span> 不可能成立，所以有 <span class="math inline">\(dy\le 3H+2K\)</span>。于是我们可以考虑枚举 <span class="math inline">\(dy\)</span>，这一部分时间复杂度为 <span class="math inline">\(O((H+K)\log (H+K))\)</span>。</p>
<p>根据 <span class="math inline">\(i\le K\)</span> 写出不等式并将只与 <span class="math inline">\(d,y\)</span> 有关的项移到右边，得到</p>
<p><span class="math display">\[x_1H-\gcd(x_1+d,H-y)-\gcd(x_1,y)\le \gcd(d,H)+2K-2-dy\]</span></p>
<p>记右式的值为 <span class="math inline">\(R\)</span>，若 <span class="math inline">\(x_1\le \frac{R}{H}\)</span>，则一定成立；若 <span class="math inline">\(x_1\ge \frac{R}{H}+2\)</span>，则一定不成立。所以我们只要判断满足 <span class="math inline">\(\frac{R}{H} &lt; x_1 &lt; \frac{R}{H}+2\)</span> 的 <span class="math inline">\(x_1\)</span> 是否成立即可。这样的 <span class="math inline">\(x_1\)</span> 只有 <span class="math inline">\(O(1)\)</span> 个，每次判断需要求 <span class="math inline">\(\gcd\)</span>，复杂度为 <span class="math inline">\(O(\log (W+H))\)</span>。</p>
<p>所以总复杂度为 <span class="math inline">\(O((W+H+K)\log (W+H+K)\log (W+H))\)</span>。</p>
<p><a href="https://atcoder.jp/contests/tokiomarine2020/submissions/16494163">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>枚举</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT1734」「Xmas Contest 2015」Broken Christmas Tree</title>
    <url>/atcoder-xmas15B-sol/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/xmascontest2015noon/tasks/xmascontest2015_b">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p><span class="math inline">\(n\)</span> 个点的完全图中去掉给定的 <span class="math inline">\(m\)</span> 条边后，问是否存在一个生成树。若是，求出一种方案。</p>
<p><span class="math inline">\(n,m\le 2\times 10^5\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>显然贪心。假定以 <span class="math inline">\(1\)</span> 为根节点，把 <span class="math inline">\(1\)</span> 能连的点都与 <span class="math inline">\(1\)</span> 相连，然后对这些点进行同样的操作，直到所有点都相互连通。</p>
<p>用 <code>set</code> 记录每个点不能连的点，以及当前还有哪些点没有加入最小生成树（记做 <span class="math inline">\(num\)</span>）。用队列记录已经加入的点，对于队列中的点 <span class="math inline">\(u\)</span>，遍历 <span class="math inline">\(num\)</span>，若可以连则连，加入队列，并且从 <span class="math inline">\(num\)</span> 中删除；否则跳过。</p>
<p>关键是复杂度分析。对于遍历 <span class="math inline">\(num\)</span> 时可以连的情况，这种情况一定不会超过 <span class="math inline">\(n-1\)</span> 次，因为每次都会从 <span class="math inline">\(num\)</span> 中删除一个点；对于不可以连的情况，一定不会超过 <span class="math inline">\(m\)</span> 次，因为一条不能连的边不会重复遍历。所以总次数为 <span class="math inline">\(O(n+m)\)</span> 次。由于判断一个点与另一个点能否连接需要 <span class="math inline">\(O(\log n)\)</span>，所以总复杂度为 <span class="math inline">\(O((n+m)\log n)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">int</span> n, m, h, t, Q[N], cnt, x[N], y[N];</span><br><span class="line">std :: set&lt;<span class="keyword">int</span>&gt; num, E[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        E[x].<span class="built_in">insert</span>(y), E[y].<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) num.<span class="built_in">insert</span>(i);</span><br><span class="line">    h = <span class="number">0</span>, t = <span class="number">1</span>, Q[t] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; t)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q[++h];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = num.<span class="built_in">begin</span>(), It = it; it != num.<span class="built_in">end</span>(); ) <span class="comment">// 遍历，注意 auto 需要 C++11</span></span><br><span class="line">            <span class="keyword">if</span> (!E[u].<span class="built_in">count</span>(*it)) x[++cnt] = u, y[cnt] = *it, Q[++t] = *it, It = it, ++it, num.<span class="built_in">erase</span>(It);</span><br><span class="line">            <span class="keyword">else</span> ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num.<span class="built_in">size</span>()) <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x[i], y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>Xmas Contest 2015</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>复杂度分析</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT1735」「Xmas Contest 2015」Colored Tiles</title>
    <url>/atcoder-xmas15C-sol/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/xmascontest2015noon/tasks/xmascontest2015_c">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>这是一道交互题。</p>
<p>交互库中生成了一个 <span class="math inline">\(n\times m\)</span> 的每个格子有颜色的矩阵。颜色可以有任意多种。给定的是 <span class="math inline">\(n,m\)</span>。记矩阵中第 <span class="math inline">\(x\)</span> 行第 <span class="math inline">\(y\)</span> 列的颜色为 <span class="math inline">\(col(x,y)\)</span>（矩阵的行列下标从 <span class="math inline">\(1\)</span> 开始）。</p>
<p>你可以进行询问，询问的格式是 <code>? x1 y1 x2 y2</code>，交互库会告诉你 <span class="math inline">\(col(x1,y1)=col(x2,y2)\)</span> <strong>并且</strong> <span class="math inline">\(col(x1,y2)=col(x2,y1)\)</span> 是否成立。询问次数不能超过 <span class="math inline">\(4\,500\)</span>。</p>
<p>最后你应该输出 <code>! ans</code>，<span class="math inline">\(ans\)</span> 表示中心对称的子矩阵的数量。</p>
<p><span class="math inline">\(n\le 5,m\le 100\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p><img src="/files/at-xmas15c-pic1.png" class="lazyload" data-srcset="/files/at-xmas15c-pic1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>上图这个矩阵如果是中心对称的，那么 <span class="math inline">\(A\)</span> 反转一下一定与 <span class="math inline">\(B\)</span> 相等，且 <span class="math inline">\(C\)</span> 也是中心对称的。</p>
<p>那么考虑 <span class="math inline">\(A,B\)</span> 两行，设他们的行号分别为 <span class="math inline">\(i,j\)</span>，中间位置为 <span class="math inline">\(k\)</span>，两边为 <span class="math inline">\(l,r\)</span>，那么 <span class="math inline">\(A\)</span> 反转一下与 <span class="math inline">\(B\)</span> 相等可以转化成 <span class="math inline">\(\forall 0\le x\le k-l,col(i,k-x)=col(j,k+x)\text{ and }col(i,k+x)=col(j,k-x)\)</span>。这个与询问的格式就一样了。</p>
<p>并且可以发现，这是一个“类回文”的形式，所以可以用 manacher 解决，这样就可以减少询问次数。为了解决奇偶性问题，可以当作把每行扩展一倍，在相邻两个格子之间插入其他字符，注意询问时候要变回原来的下标。</p>
<p>就是说，对于任意两行 <span class="math inline">\(i,j(1\le i\le j\le n)\)</span>，求出每列向左右可以扩展的最多的列数。然后枚举矩阵的上下两行和对称中心所在的列数，求出在该条件下的极大中心对称的矩阵的列数，然后直接统计。</p>
<p>可以用 map 减少一定量的询问次数。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m, len[<span class="number">6</span>][<span class="number">6</span>][<span class="number">205</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; res.a || (a == res.a &amp;&amp; b &lt; res.b) || (a == res.a &amp;&amp; b == res.b &amp;&amp; c &lt; res.c) || (a == res.a &amp;&amp; b == res.b &amp;&amp; c == res.c &amp;&amp; d &lt; res.d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std :: map&lt;node, <span class="keyword">int</span>&gt; M;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2 || y1 &gt; y2 || x1 &lt; <span class="number">1</span> || x2 &gt; n || y1 &lt; <span class="number">1</span> || y2 &gt; (m &gt;&gt; <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (M.<span class="built_in">count</span>((node)&#123;x1, y1, x2, y2&#125;)) <span class="keyword">return</span> M[(node)&#123;x1, y1, x2, y2&#125;];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;? %d %d %d %d\n&quot;</span>, x1, y1, x2, y2), <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="keyword">char</span> opt[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">    <span class="keyword">return</span> M[(node)&#123;x1, y1, x2, y2&#125;] = (opt[<span class="number">0</span>] == <span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> *hw)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mr = <span class="number">0</span>, mid = <span class="number">0</span>, n = m;</span><br><span class="line">    hw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        hw[i] = i &lt;= mr ? std :: <span class="built_in">min</span>(hw[(mid &lt;&lt; <span class="number">1</span>) - i], mr - i + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i + hw[i] &lt;= mr) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> ((i - hw[i]) % <span class="number">2</span> == <span class="number">0</span> || <span class="built_in">check</span>(x, (i - hw[i] + <span class="number">1</span>) / <span class="number">2</span>, y, (i + hw[i] + <span class="number">1</span>) / <span class="number">2</span>)) ++hw[i];</span><br><span class="line">        <span class="keyword">if</span> (i + hw[i] - <span class="number">1</span> &gt; mr) mid = i, mr = i + hw[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt;= n; ++j)</span><br><span class="line">            <span class="built_in">manacher</span>(i, j, len[i][j]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k)&#123;</span><br><span class="line">                <span class="keyword">int</span> s = <span class="number">1e9</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> l = i, r = j; l &lt;= r; ++l, --r)</span><br><span class="line">                    s = std :: <span class="built_in">min</span>(s, len[l][r][k]);</span><br><span class="line">                ans += s &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;! %d\n&quot;</span>, ans), <span class="built_in">fflush</span>(stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>Xmas Contest 2015</category>
      </categories>
      <tags>
        <tag>交互</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2018之前</title>
    <url>/before-noip2018/</url>
    <content><![CDATA[<p>好久没更新博客了。</p>
<span id="more"></span>
<p>10/14初赛，当时感觉凉凉……emmm不过后来答案出来以后感觉也还可以，选择题连蒙带猜地做竟然只错了1个？</p>
<p>问题求解T2 想到根据二进制位分类讨论，但没往排列组合方面想。</p>
<p>估分93，ZJ提高，应该还可以吧。</p>
<p>坐等分数线。</p>
<p>虽然初赛还可以，但是ZJ提高组……感觉要凉啊。希望能拿一等。</p>
<p>只有20多天了，突然发现好像什么都不会了。</p>

]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>NOIP2018</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT1733」「Xmas Contest 2015」Accumulation</title>
    <url>/atcoder-xmas15A-sol/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/xmascontest2015noon/tasks/xmascontest2015_a">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">input n</span><br><span class="line">input <span class="keyword">x</span><span class="punctuation">,</span> t<span class="punctuation">,</span> a<span class="punctuation">,</span> b<span class="punctuation">,</span> <span class="keyword">c</span></span><br><span class="line">for i <span class="operator">=</span> <span class="number">1</span> .. n :</span><br><span class="line">    s_i <span class="operator">=</span> <span class="keyword">x</span></span><br><span class="line">    for j <span class="operator">=</span> <span class="number">1</span> .. t :</span><br><span class="line">        <span class="keyword">x</span> <span class="operator">=</span> (a * <span class="keyword">x</span> + b) mod <span class="keyword">c</span></span><br></pre></td></tr></table></figure>
<p>求 <span class="math inline">\(\sum\limits_{i=1}^{n} s_i\)</span> 的值（不需要对 <span class="math inline">\(c\)</span> 取模）。</p>
<p><span class="math inline">\(n\le 10^6, t\le 10^9,0\le x,a,b&lt; c\le 10^9\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>考虑快速进行 <code>for j = 1 .. t : x = (a * x + b) mod c</code> 这段操作。</p>
<p><span class="math display">\[\begin{aligned} j=1: &amp;\quad ax+b \\ j=2: &amp;\quad a(ax+b)+b=a^2x+ab+b \\ j=3: &amp; \quad a(a^2x+ab+b)+b=a^3x+a^2b+ab+b  \\ j=4: &amp; \quad a^4x+a^3b+a^2b+ab+b\\ \vdots&amp; \\ j=t:&amp;\quad a^tx+\sum_{k=0}^{t-1} a^kb=a^tx+b\sum_{k=0}^{t-1}a^k\end{aligned}\]</span></p>
<p>如果 <span class="math inline">\(c\)</span> 为质数，则这个式子可以直接用快速幂和等比数列求和公式进行计算。然而并没有保证 <span class="math inline">\(c\)</span> 是质数，怎么办呢？可以发现，<span class="math inline">\(x\)</span> 和 <span class="math inline">\(b\)</span> 在这个式子中是常数，而 <span class="math inline">\(a^t\)</span> 和 <span class="math inline">\(\sum\limits_{k=0}^{t-1}a^k\)</span> 有某种联系……</p>
<p>考虑用矩阵表示（记 <span class="math inline">\(f(t)=\sum\limits_{k=0}^{t-1}a^k\)</span>） <span class="math display">\[A=\begin{bmatrix} a^t &amp; f(t) \end{bmatrix},B=\begin{bmatrix} a^{t+1} &amp; f(t+1) \end{bmatrix}\]</span></p>
<p><span class="math inline">\(A\)</span> 如何才能转化为 <span class="math inline">\(B\)</span>，通过计算发现：<span class="math inline">\(a^{t+1}=a\cdot a^t,f(t+1)=a^t+f(t)\)</span>，那么很显然转移矩阵为 <span class="math display">\[C=\begin{bmatrix} a &amp; 1\\ 0 &amp; 1\end{bmatrix}\]</span></p>
<p>可以再验证一下 <span class="math inline">\(A\times C=B\)</span>。于是直接用矩阵快速幂进行优化即可。</p>
<p>可以发现，最后 <span class="math inline">\(x\)</span> 的转移一定可以表示为 <span class="math inline">\(px+q\)</span> 的形式，所以只要一开始预处理 <span class="math inline">\(p,q\)</span>，不需要每次进行矩阵快速幂。</p>
<p>时间复杂度 <span class="math inline">\(O(n+\log t)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, x, m, a, b, P;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;res) <span class="keyword">const</span> &#123;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        <span class="built_in">memset</span>(ret.a, <span class="number">0</span>, <span class="keyword">sizeof</span> ret.a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j)</span><br><span class="line">                    ret.a[i][j] = (ret.a[i][j] + <span class="number">1ll</span> * a[i][k] * res.a[k][j]) % P;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A, B;</span><br><span class="line"><span class="function">Matrix <span class="title">qpow</span><span class="params">(Matrix a, <span class="keyword">int</span> b)</span></span>&#123; <span class="comment">// 矩阵快速幂</span></span><br><span class="line">    Matrix s = a;</span><br><span class="line">    <span class="keyword">for</span> (--b; b; b &gt;&gt;= <span class="number">1</span>, a = a * a) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = s * a;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d%d&quot;</span>, &amp;n, &amp;x, &amp;m, &amp;a, &amp;b, &amp;P);</span><br><span class="line">    A.a[<span class="number">0</span>][<span class="number">0</span>] = a, A.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 初始矩阵</span></span><br><span class="line">    B.a[<span class="number">0</span>][<span class="number">0</span>] = a, B.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>, B.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>, B.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 转移矩阵</span></span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">1</span>) A = A * <span class="built_in">qpow</span>(B, m - <span class="number">1</span>);</span><br><span class="line">    a = A.a[<span class="number">0</span>][<span class="number">0</span>], b = <span class="number">1ll</span> * b * A.a[<span class="number">0</span>][<span class="number">1</span>] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans += x, x = (<span class="number">1ll</span> * a * x + b) % P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>upd: 修复了代码中的一个漏洞</p>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>Xmas Contest 2015</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Yahoo Programming Contest 2019 题解</title>
    <url>/atcoder-yahoo-procon2019-qual/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/yahoo-procon2019-qual">比赛地址</a></p>
<span id="more"></span>
<p>ABC 就不写了。</p>
<h3 id="d---ears">D - Ears</h3>
<h4 id="题意">题意</h4>
<p>数轴上有 <span class="math inline">\(L\)</span> 堆石头，第 <span class="math inline">\(i\)</span> 堆石头在坐标 <span class="math inline">\(i-0.5\)</span> 处，初始石子数量都为 <span class="math inline">\(0\)</span>。</p>
<p>你可以从任意整数下标出发，每次向左或向右移动一个单位，并在经过一个石子堆时将该石子堆的石子数量加 <span class="math inline">\(1\)</span>。你可以在任意位置结束移动。你不能移动到坐标小于 <span class="math inline">\(0\)</span> 或大于 <span class="math inline">\(L\)</span> 的位置。</p>
<p>给定 <span class="math inline">\(A_1,A_2,\ldots,A_L\)</span>，假设最后第 <span class="math inline">\(i\)</span> 堆石头数量为 <span class="math inline">\(x_i\)</span>，你需要最小化 <span class="math display">\[\sum_{i=1}^{L} |A_i-x_i|\]</span></p>
<p><span class="math inline">\(L\le 2\times 10^5\)</span></p>
<h4 id="题解">题解</h4>
<p>最后的 <span class="math inline">\(x\)</span> 一定形如 <span class="math inline">\(\{0,\ldots,0,2,\ldots,2,1,\ldots,1,2,\ldots,2,0,\ldots,0\}\)</span>，其中 <span class="math inline">\(2\)</span> 和 <span class="math inline">\(1\)</span> 分别可以替换成任意大于 <span class="math inline">\(0\)</span> 的偶数和奇数（不同位置可以不同）。</p>
<p>于是直接 DP 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(L)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/17389944">代码</a></p>
<h3 id="e---odd-subrectangles">E - Odd Subrectangles</h3>
<h4 id="题意-1">题意</h4>
<p>给定一个 <span class="math inline">\(N\times M\)</span> 的 01 矩阵，你可以从行集合中选出一个子集 <span class="math inline">\(A\)</span>，从列集合中选出一个子集 <span class="math inline">\(B\)</span>，取出相交的位置，可以得到一个 <span class="math inline">\(|A|\times |B|\)</span> 的子矩阵。</p>
<p>求使得这个子矩阵的和为奇数的方案数。对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(N,M\le 300\)</span></p>
<h4 id="题解-1">题解</h4>
<p>注意到对原矩阵做初等行变换和初等列变换都不会改变答案。</p>
<p>我们可以通过做初等行变换和初等列变换（即类似高斯消元的过程）将原矩阵变成每行每列最多只有一个 <span class="math inline">\(1\)</span>。</p>
<p>假设最后有 <span class="math inline">\(K\)</span> 个 <span class="math inline">\(1\)</span>，那么其余 <span class="math inline">\(N-K\)</span> 行和 <span class="math inline">\(M-K\)</span> 列可以任意选，最后乘上 <span class="math inline">\(2^{N-K+M-K}\)</span> 即可。</p>
<p>而对于这 <span class="math inline">\(K\)</span> 个 <span class="math inline">\(1\)</span>，我们要选择奇数个。枚举选择的个数 <span class="math inline">\(i\)</span>，那么其余 <span class="math inline">\(K-i\)</span> 个 <span class="math inline">\(1\)</span> 对应的行和列不能同时选，所以对答案的贡献为 <span class="math inline">\(\binom{K}{i}3^{K-i}\)</span>。</p>
<p>假设 <span class="math inline">\(N\)</span> 与 <span class="math inline">\(M\)</span> 同阶，时间复杂度 <span class="math inline">\(O(N^3)\)</span>，可以用 bitset 优化到 <span class="math inline">\(O(\frac{N^3}{w})\)</span>。</p>
<p><a href="https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/17390627">代码</a></p>
<h3 id="f---pass">F - Pass</h3>
<h4 id="题意-2">题意</h4>
<p>有 <span class="math inline">\(N\)</span> 个人从左到右排列，第 <span class="math inline">\(i\)</span> 个人手上有 <span class="math inline">\(2\)</span> 个球，其中 <span class="math inline">\(A_i\)</span> 个是红球，<span class="math inline">\(2-A_i\)</span> 个是蓝球。另外还有一个初始为空的序列 <span class="math inline">\(S\)</span>。</p>
<p>需要执行 <span class="math inline">\(2N\)</span> 次以下操作：</p>
<ul>
<li>每个有球的人同时选择一个手上的球，并将该球给左边的人。特别地，第一个人会将这个球放到 <span class="math inline">\(S\)</span> 的末尾。</li>
</ul>
<p>求最后可以得到多少个不同的 <span class="math inline">\(S\)</span>。注意相同颜色的球是相同的。对 <span class="math inline">\(998244353\)</span>。</p>
<p><span class="math inline">\(N\le 2000\)</span></p>
<h4 id="题解-2">题解</h4>
<p>考虑固定一个 <span class="math inline">\(S\)</span> 后如何判断。</p>
<p>从前往后依次判断，假设前 <span class="math inline">\(i-1\)</span> 个位置合法，那么第 <span class="math inline">\(i\)</span> 个位置合法当且仅当初始时前 <span class="math inline">\(\min(i,N)\)</span> 个人手中的球去掉前 <span class="math inline">\(i-1\)</span> 个球后存在一个球与第 <span class="math inline">\(i\)</span> 个球相同。</p>
<p>于是直接 DP，<span class="math inline">\(f_{i,j}\)</span> 表示 <span class="math inline">\(S\)</span> 中前 <span class="math inline">\(i\)</span> 个位置，有 <span class="math inline">\(j\)</span> 个红球时的方案数。转移只要考虑下一个是红球还是蓝球即可。</p>
<p>时间复杂度 <span class="math inline">\(O(N^2)\)</span>。</p>
<p><a href="https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/17391000">代码</a></p>

]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title>「AT1736」「Xmas Contest 2015」Destroy the Duplicated Poem</title>
    <url>/atcoder-xmas15D-sol/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/xmascontest2015noon/tasks/xmascontest2015_d">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>有 <span class="math inline">\(n+1\)</span> 个字符串 <span class="math inline">\(S_0,S_1,S_2,\cdots,S_n\)</span>。<span class="math inline">\(S_0\)</span> 是空串，<span class="math inline">\(S_i\)</span> 是 <span class="math inline">\(S_{a_i}\)</span> 后加上字符 <span class="math inline">\(c_i\)</span> 的字符串。<span class="math inline">\(a_i,c_i\)</span> 都是给定的且 <span class="math inline">\(0\le a_i&lt; i\)</span>，<span class="math inline">\(c_i\)</span> 是小写字母。</p>
<p>定义字符串 <span class="math inline">\(T\)</span> 的周期是所有满足 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(X\)</span> 重复无穷多次后的字符串的前缀的字符串 <span class="math inline">\(X\)</span> 中最短的。例如 <code>abcabca</code> 的周期是 <code>abc</code>。</p>
<p>求 <span class="math inline">\(S_1,S_2,S_3,\cdots,S_n\)</span> 的周期的长度。</p>
<p><span class="math inline">\(n\le 500\,000\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>由题目给定的字符串生成方式，可以想到字典树。所有字符串对应字典树上根到某个点的路径。</p>
<p>可以发现，字符串的周期一定是字符串的某个前缀。且这个前缀的长度一定是 <span class="math inline">\(T[1,m-x]=T[m-x+1,m]\)</span> 的 <span class="math inline">\(x\)</span> 中的最小值（<span class="math inline">\(T[l..r]\)</span> 表示 <span class="math inline">\(T\)</span> 中 <span class="math inline">\(l\)</span> 到 <span class="math inline">\(r\)</span> 的子串，<span class="math inline">\(m\)</span> 表示 <span class="math inline">\(T\)</span> 的长度）。<span class="math inline">\(x\)</span> 最小，那么 <span class="math inline">\(m-x\)</span> 是最大的，所以这是一个求所有前缀=后缀中最长的前缀的形式，那么很自然地能想到 KMP。</p>
<p>在 trie 上做 KMP，不能直接跳 fail，如下图所示的情况就可以卡成 <span class="math inline">\(O(n^2)\)</span> 的复杂度：</p>
<p><img src="/files/at-xmas15d-pic.png" class="lazyload" data-srcset="/files/at-xmas15d-pic.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>因为都是小写字母，所以用 <span class="math inline">\(go_{i,c}\)</span>（在节点 <span class="math inline">\(i\)</span> 表示的字符串后加入字符 <span class="math inline">\(c\)</span> 后最长的前缀=后缀所在的节点） 记下这个跳 fail 的过程即可（有点像 AC 自动机，但不完全一样）。</p>
<p>时间复杂度 <span class="math inline">\(O(nk)\)</span>，<span class="math inline">\(k\)</span> 是字符集大小，这里为 <span class="math inline">\(26\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">int</span> n, dep[N], fail[N], go[N][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">char</span> a[N];</span><br><span class="line"><span class="keyword">int</span> edge, hd[N], to[N], pr[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa = <span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">if</span> (~fa)&#123;</span><br><span class="line">        dep[u] = dep[fa] + <span class="number">1</span>, fail[u] = go[fa][a[u]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) go[u][i] = go[fail[u]][i];</span><br><span class="line">        <span class="keyword">if</span> (fail[u] == fa) go[u][a[u]] = u;</span><br><span class="line">        tmp = go[fa][a[u]], go[fa][a[u]] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u]; i; i = pr[i]) <span class="built_in">dfs</span>(to[i], u);</span><br><span class="line">    <span class="keyword">if</span> (~fa) go[fa][a[u]] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, fa; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;fa), <span class="built_in">addedge</span>(fa, i); <span class="comment">// 建树</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    dep[<span class="number">0</span>] = <span class="number">0</span>, <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dep[i] - dep[fail[i]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>Xmas Contest 2015</category>
      </categories>
      <tags>
        <tag>trie</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>「BZOJ1568」「JSOI2008」Blue Mary开公司</title>
    <url>/bzoj1568-sol-lcst-notes/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1568">题目传送门</a></p>
<p>李超线段树模板题。</p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>维护一个二维平面，支持两种操作：插入一条直线（<span class="math inline">\(y=kx+b\)</span>）；询问当前插入的所有直线<span class="math inline">\(x=x_0\)</span>时最大的纵坐标的值。</p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>李超线段树。</p>
<p>一个节点同样表示一个区间<span class="math inline">\([l,r]\)</span>，记录的是一条直线<span class="math inline">\(id[u]\)</span>，这条直线是<span class="math inline">\(x=mid\)</span>时纵坐标最大的直线。</p>
<p>插入一条直线时，流程如下：</p>
<ol type="1">
<li>直线<span class="math inline">\(id[u]\)</span>和<span class="math inline">\(i\)</span>没有交点：直接取<span class="math inline">\(y\)</span>值大的，退出。</li>
<li>如果当<span class="math inline">\(x=mid\)</span>时，直线<span class="math inline">\(i\)</span>的<span class="math inline">\(y\)</span>值比<span class="math inline">\(id[u]\)</span>大，那么<strong>交换</strong><span class="math inline">\(id[u],i\)</span>。</li>
<li>如果<span class="math inline">\(id[u]\)</span>和<span class="math inline">\(i\)</span>的交点在mid左边，即当<span class="math inline">\(x=l\)</span>时，直线<span class="math inline">\(i\)</span>的<span class="math inline">\(y\)</span>值大于等于<span class="math inline">\(id[u]\)</span>，那么递归处理<span class="math inline">\([l,mid]\)</span>，这种情况下其实<span class="math inline">\([mid+1,r]\)</span>的直线要改变，但因为询问时是从叶子节点到根节点取<span class="math inline">\(max\)</span>的，所以没有必要更新。</li>
<li>如果<span class="math inline">\(id[u]\)</span>和<span class="math inline">\(i\)</span>的交点在mid右边，即当<span class="math inline">\(x=r\)</span>时，直线<span class="math inline">\(i\)</span>的<span class="math inline">\(y\)</span>值大于等于<span class="math inline">\(id[u]\)</span>，那么递归处理<span class="math inline">\([mid+1,r]\)</span>，此时没有3中的情况。</li>
</ol>
<p>至于询问，已经提过，只要从叶节点到根取max就好了。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">int</span> n, m, x;</span><br><span class="line"><span class="keyword">double</span> k[N], b[N];</span><br><span class="line"><span class="keyword">char</span> opt[<span class="number">15</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Li_Chao_Segment_Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k[u] * (x - <span class="number">1</span>) + b[u] &lt;= k[v] * (x - <span class="number">1</span>) + b[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(id[u], x, l) &amp;&amp; <span class="built_in">check</span>(id[u], x, r)) <span class="keyword">return</span> id[u] = x, <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(id[u], x, mid)) std :: <span class="built_in">swap</span>(id[u], x);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(id[u], x, l)) <span class="built_in">Insert</span>(u &lt;&lt; <span class="number">1</span>, l, mid, x);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(id[u], x, r)) <span class="built_in">Insert</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> k[l] * (x - <span class="number">1</span>) + b[l];</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) ans = <span class="built_in">Query</span>(u &lt;&lt; <span class="number">1</span>, l, mid, x);</span><br><span class="line">        <span class="keyword">else</span> ans = <span class="built_in">Query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x);</span><br><span class="line">        <span class="keyword">return</span> std :: <span class="built_in">max</span>(ans, k[id[u]] * (x - <span class="number">1</span>) + b[id[u]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m); m--; )&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;P&#x27;</span>) ++n, <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, b + n, k + n), T.<span class="built_in">Insert</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">50000</span>, n);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in"><span class="keyword">int</span></span>(T.<span class="built_in">Query</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">50000</span>, x) / <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>JSOI</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>「BZOJ2753」「SCOI2012」滑雪与时间胶囊</title>
    <url>/bzoj2753-sol/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2753">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定一个<span class="math inline">\(n\)</span>个点，<span class="math inline">\(m\)</span>条边的有权无向图，每个点有一个高度，求一个以<span class="math inline">\(1\)</span>为根的树，满足父亲的高度大于等于儿子的高度。在树的节点数最多的情况下，树上的边权之和最小。</p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>如果没有高度限制，直接<span class="math inline">\(Kruskal\)</span>一遍就好了。</p>
<p>有了高度呢？其实变成了有向图，求一个点最多，边权值和最小的生成树。</p>
<p>第一问很好做，直接对这个有向图从<span class="math inline">\(1\)</span>开始<span class="math inline">\(bfs/dfs\)</span>一遍就好了。</p>
<p><span class="math inline">\(bfs/dfs\)</span>之后，原来的有向图就变成了从1开始能到达的所有点组成的一个有向图。</p>
<p>显然，如果两个点高度相同，那么这两个点之间连的边可以看成无向边，直接按边权排序做即可。</p>
<p>再考虑一个问题，两个点<span class="math inline">\(x,y\)</span>需要在树上联通，一定不会通过另一个高度比它们小的点进行联通的。</p>
<p>所以我们对于新图中的每条边<span class="math inline">\(u\to v\)</span>，优先按<span class="math inline">\(h_v\)</span>从大到小，<span class="math inline">\(h_v\)</span>相等按边权从小到大排序即可。</p>
<p>然后就是最简单的Kruskal了。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">    Problem: 2753</span></span><br><span class="line"><span class="comment">    User: rill7747</span></span><br><span class="line"><span class="comment">    Language: C++</span></span><br><span class="line"><span class="comment">    Result: Accepted</span></span><br><span class="line"><span class="comment">    Time:6972 ms</span></span><br><span class="line"><span class="comment">    Memory:84612 kb</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000005</span></span><br><span class="line"><span class="keyword">int</span> n, m, h[N], fa[N], cnt;</span><br><span class="line"><span class="keyword">int</span> edge, to[N], tw[N], pr[N], hd[N], vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    to[++edge] = v, tw[edge] = w, pr[edge] = hd[u], hd[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h[v] &gt; h[res.v] || h[v] == h[res.v] &amp;&amp; w &lt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;E[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    ++cnt, vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v = to[i]]) <span class="built_in">dfs</span>(v);</span><br><span class="line">        E[++m] = (node)&#123;u, v, tw[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = <span class="built_in">find</span>(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx == fy) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fa[fy] = fx, <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std :: <span class="built_in">sort</span>(E + <span class="number">1</span>, E + <span class="number">1</span> + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">merge</span>(E[i].u, E[i].v)) ans += E[i].w, ++sum;</span><br><span class="line">        <span class="keyword">if</span> (sum == cnt - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) h[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(), w = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (h[u] &gt;= h[v]) <span class="built_in">addedge</span>(u, v, w);</span><br><span class="line">        <span class="keyword">if</span> (h[v] &gt;= h[u]) <span class="built_in">addedge</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    m = <span class="number">0</span>, <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %lld&quot;</span>, cnt, <span class="built_in">Kruskal</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>SCOI</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>「BZOJ3083」遥远的国度</title>
    <url>/bzoj3083-sol/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3083">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定一棵有点权的树和初始的根，支持三种操作：换根，修改路径上的权值，查询子树权值<span class="math inline">\(min\)</span>。</p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>如果没有换根，这就是树剖+线段树裸题了。</p>
<p>那么有换根呢？首先我们一开始认定初始给定的根作为根进行树剖。</p>
<p>换根之后，路径修改显然不产生影响，直接用线段树维护就好了。假设现在的根为<span class="math inline">\(rt\)</span>，查询子树的根节点为<span class="math inline">\(x\)</span>，分以下三种情况（可以脑补一下或者画个图）：</p>
<ol type="1">
<li><span class="math inline">\(rt=x\)</span></li>
<li><span class="math inline">\(rt\)</span>在<span class="math inline">\(x\)</span>的子树外</li>
<li><span class="math inline">\(rt\)</span>在<span class="math inline">\(x\)</span>的子树内（不包括<span class="math inline">\(x\)</span>）</li>
</ol>
<p>注意这里的子树是相对于以初始根为根时的树而言的。</p>
<p>对于1，相当于查询整棵树的min，直接在整棵线段树上查询就好了。</p>
<p>对于2，又有两种情况：一种是<span class="math inline">\(x\)</span>在<span class="math inline">\(rt\)</span>的子树内（不包括<span class="math inline">\(rt\)</span>），另一种是<span class="math inline">\(x\)</span>的子树和<span class="math inline">\(rt\)</span>的子树互不包含。</p>
<p>画一下图即可知道，这两种情况是一样的，即不需要考虑换根，换根之后<span class="math inline">\(x\)</span>子树中的节点没有变化，直接查询以初始根为根时<span class="math inline">\(x\)</span>的子树min。</p>
<p>对于3，就有点麻烦了。我们设<span class="math inline">\(u\)</span>是<span class="math inline">\(x\)</span>到<span class="math inline">\(rt\)</span>这条链上除<span class="math inline">\(x\)</span>外的第二个点（<span class="math inline">\(x\)</span>的儿子）。那么在纸上画一下即可得知，换根后的<span class="math inline">\(x\)</span>的子树变为整棵树减去换根前<span class="math inline">\(u\)</span>的子树（注意不是<span class="math inline">\(x\)</span>的子树减去<span class="math inline">\(u\)</span>的子树）。</p>
<p>那么问题在于求u。算法描述如下（设树剖后节点<span class="math inline">\(i\)</span>所在重链的顶端节点为<span class="math inline">\(top[i]\)</span>，节点<span class="math inline">\(i\)</span>的父亲为<span class="math inline">\(fa[i]\)</span>，节点<span class="math inline">\(i\)</span>的重儿子是<span class="math inline">\(son[i]\)</span>）：</p>
<ol type="1">
<li><span class="math inline">\(u\gets rt\)</span></li>
<li>如果<span class="math inline">\(fa[top[u]]\)</span>在<span class="math inline">\(x\)</span>的子树中并且不等于<span class="math inline">\(x\)</span>，那么<span class="math inline">\(u\gets fa[top[u]]\)</span>。不断执行这一过程直至条件不成立。</li>
<li>如果<span class="math inline">\(fa[top[u]]=x\)</span>，那么<span class="math inline">\(u=top[u]\)</span>，否则<span class="math inline">\(u=son[x]\)</span></li>
</ol>
<p>解释一下第三步，因为最后如果<span class="math inline">\(fa[top[u]]=x\)</span>那么<span class="math inline">\(top[u]\)</span>刚好就是这条链上<span class="math inline">\(x\)</span>的儿子了，否则说明<span class="math inline">\(fa[top[u]]\)</span>是<span class="math inline">\(x\)</span>的祖先，即<span class="math inline">\(x\)</span>和<span class="math inline">\(u\)</span>在同一条重链上，那么这条链上<span class="math inline">\(x\)</span>的儿子就是<span class="math inline">\(x\)</span>的重儿子。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">    Problem: 3083</span></span><br><span class="line"><span class="comment">    User: rill7747</span></span><br><span class="line"><span class="comment">    Language: C++</span></span><br><span class="line"><span class="comment">    Result: Accepted</span></span><br><span class="line"><span class="comment">    Time:3312 ms</span></span><br><span class="line"><span class="comment">    Memory:13452 kb</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], rt;</span><br><span class="line"><span class="keyword">int</span> edge, to[N &lt;&lt; <span class="number">1</span>], pr[N &lt;&lt; <span class="number">1</span>], hd[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N], sz[N], son[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa[u])</span><br><span class="line">            fa[v] = u, dep[v] = dep[u] + <span class="number">1</span>, <span class="built_in">dfs</span>(v), sz[u] += sz[v], </span><br><span class="line">            !son[u] || sz[v] &gt; sz[son[u]] ? son[u] = v : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> top[N], idx, st[N], id[N], ed[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp, id[st[u] = ++idx] = u;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) <span class="built_in">dfs</span>(son[u], tp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa[u] &amp;&amp; v != son[u]) <span class="built_in">dfs</span>(v, v);</span><br><span class="line">    ed[u] = idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> val[N &lt;&lt; <span class="number">2</span>], lz[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> val[u] = a[id[l]], lz[u] = <span class="number">0</span>, <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    val[u] = std :: <span class="built_in">min</span>(val[u &lt;&lt; <span class="number">1</span>], val[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lz[u]) val[u &lt;&lt; <span class="number">1</span>] = val[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = lz[u &lt;&lt; <span class="number">1</span>] = lz[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = lz[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> val[u] = lz[u] = v, <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="built_in">down</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    val[u] = std :: <span class="built_in">min</span>(val[u &lt;&lt; <span class="number">1</span>], val[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> val[u];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">2147483647</span>; <span class="built_in">down</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) ans = std :: <span class="built_in">min</span>(ans, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, mid, L, R));</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid) ans = std :: <span class="built_in">min</span>(ans, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, L, R));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) std :: <span class="built_in">swap</span>(u, v);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, st[top[u]], st[u], w), u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) std :: <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, st[v], st[u], w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == rt) <span class="keyword">return</span> val[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (st[rt] &lt; st[u] || st[rt] &gt; ed[u]) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, st[u], ed[u]);</span><br><span class="line">    <span class="keyword">int</span> v = rt;</span><br><span class="line">    <span class="keyword">while</span> (st[fa[top[v]]] &gt; st[u] &amp;&amp; st[fa[top[v]]] &lt;= ed[u]) v = fa[top[v]];</span><br><span class="line">    <span class="keyword">if</span> (fa[top[v]] == u) v = top[v]; <span class="keyword">else</span> v = son[u];</span><br><span class="line">    <span class="keyword">return</span> std :: <span class="built_in">min</span>(<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, st[v] - <span class="number">1</span>), <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, ed[v] + <span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">        u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(), <span class="built_in">addedge</span>(u, v), <span class="built_in">addedge</span>(v, u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    rt = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(rt), <span class="built_in">dfs</span>(rt, rt), <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="built_in">read</span>(), x, y, w;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) rt = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">2</span>) x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), w = <span class="built_in">read</span>(), <span class="built_in">Modify</span>(x, y, w);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Query</span>(<span class="built_in">read</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>分类讨论</tag>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1119F」Niyaz and Small Degrees</title>
    <url>/cf1119f-sol/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1119/problem/F">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定一棵 <span class="math inline">\(n\)</span> 个节点的树，有边权，对于所有 <span class="math inline">\(x\ (0\le x &lt; n)\)</span>，可以删去一些边，求使得所有节点的度数 <span class="math inline">\(\le x\)</span> 的删掉的边的边权之和的最小值。</p>
<p>节点的度数指以该点为某一端点的边的数量。</p>
<p><span class="math inline">\(n\le 250\,000\)</span></p>
<span id="more"></span>
</div><h2 id="暴力独立求解">暴力——独立求解</h2><div class="story post-story">
<p>显然是树形 DP，记 <span class="math inline">\(dp_{u,0/1}\)</span> 表示 <span class="math inline">\(u\)</span> 与父亲的连边不删/删时，以 <span class="math inline">\(u\)</span> 为根的子树满足所有节点度数 <span class="math inline">\(\le x\)</span> 的删掉的边的最小值。</p>
<p>不考虑度数限制，显然有 <span class="math inline">\(dp_{u,0}=dp_{u,1}=\sum \min(dp_{v,0},dp_{v,1}+w)\)</span>（<span class="math inline">\(v\)</span> 是 <span class="math inline">\(u\)</span> 的儿子，<span class="math inline">\(w\)</span> 表示对应边的边权）。记 <span class="math inline">\(d_i\)</span> 表示 <span class="math inline">\(i\)</span> 的度数，把 <span class="math inline">\(dp_{v,1}+w\le dp_{v,0}\)</span> 的儿子 <span class="math inline">\(v\)</span> 叫做好儿子，其余叫做坏儿子。考虑度数限制，假设求 <span class="math inline">\(dp_{u,0}\)</span>（<span class="math inline">\(dp_{u,1}\)</span> 同理），记 <span class="math inline">\(cnt\)</span> 为好儿子数量，我们需要把 <span class="math inline">\(\max(0,d_i-x-cnt)\)</span> 个坏儿子变成好儿子。</p>
<p>只需要维护一个堆，将所有坏儿子 <span class="math inline">\(dp_{v,1}+w-dp_{v,0}\)</span> 的值压入堆中，将前 <span class="math inline">\(\max(0,d_i-x-cnt)\)</span> 小的值之和记为 <span class="math inline">\(sum\)</span>，则 <span class="math inline">\(dp_{u,0}=sum+\sum dp_{v,0}\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2\log n)\)</span>。</p>
</div><h2 id="暴力代码">暴力代码</h2><div class="story post-story">
<p>注意代码实现与上述有很大差别，但思想一致。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 250005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> edge, to[N &lt;&lt; <span class="number">1</span>], pr[N &lt;&lt; <span class="number">1</span>], tw[N &lt;&lt; <span class="number">1</span>], hd[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    to[++edge] = v, tw[edge] = w, pr[edge] = hd[u], hd[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> u, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    std :: vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; val;</span><br><span class="line">    dp[u][<span class="number">0</span>] = dp[u][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa) <span class="built_in">dfs</span>(X, v, u), val.<span class="built_in">push_back</span>(dp[v][<span class="number">1</span>] + tw[i] - dp[v][<span class="number">0</span>]), dp[u][<span class="number">0</span>] += dp[v][<span class="number">0</span>];</span><br><span class="line">    dp[u][<span class="number">1</span>] = dp[u][<span class="number">0</span>];</span><br><span class="line">    std :: <span class="built_in">sort</span>(val.<span class="built_in">begin</span>(), val.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> d = val.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d &amp;&amp; (i &lt; d - X || val[i] &lt; <span class="number">0</span>); ++i) dp[u][<span class="number">1</span>] += val[i];</span><br><span class="line">    <span class="keyword">if</span> (!X) <span class="keyword">return</span> dp[u][<span class="number">0</span>] = INF, <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">    ++d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d - <span class="number">1</span> &amp;&amp; (i &lt; d - X || val[i] &lt; <span class="number">0</span>); ++i) dp[u][<span class="number">0</span>] += val[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">        u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(), w = <span class="built_in">read</span>(), <span class="built_in">addedge</span>(u, v, w), <span class="built_in">addedge</span>(v, u, w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">dfs</span>(i, <span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="正解">正解</h2><div class="story post-story">
<p>可以发现对于某个 <span class="math inline">\(x\)</span>，若一个节点 <span class="math inline">\(u\)</span> 的度数 <span class="math inline">\(\le x\)</span>，那这个点本身就不需要考虑了，只需要将 <span class="math inline">\(w(u,v)\)</span> 加入与 <span class="math inline">\(v\)</span> 的堆中。</p>
<p>也就是说，我们把 <span class="math inline">\(u\)</span> 当做叶子节点来看待，即：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"> <span class="regexp">/\       /</span><span class="string">\</span></span><br><span class="line">/__<span class="string">\</span>     /__<span class="string">\</span></span><br><span class="line">    <span class="string">\</span>   /</span><br><span class="line">      u</span><br></pre></td></tr></table></figure>
<p>也相当于把 <span class="math inline">\(u\)</span> “删去”，不同的是，与 <span class="math inline">\(u\)</span> 相连的点的度数不会改变。</p>
<p>如果我们可以每次在把所有度数 <span class="math inline">\(\le x\)</span> 的点删去后的森林中进行 DP（对每棵树进行 DP 然后把每棵树根节点的 <span class="math inline">\(dp\)</span> 值加起来，具体是加 <span class="math inline">\(dp_{i,0}\)</span> 还是 <span class="math inline">\(dp_{i,1}\)</span> 要看写法），点数之和为 <span class="math inline">\(\sum_{x=0}^{n-1}\sum_{i=1}^{n} [d_i&gt;x]=\sum_{i=1}^{n} d_i=2n-2=O(n)\)</span>，总时间复杂度就变为 <span class="math inline">\(O(n\log n)\)</span> 了。</p>
<p>具体实现时，可以用两个普通堆实现一个支持删除的堆。每次“删去”一个点 <span class="math inline">\(u\)</span> 时，在所有与该点相连的点 <span class="math inline">\(v\)</span> 对应的堆中加入 <span class="math inline">\(w(u,v)\)</span>；DP 时，假设需要把 <span class="math inline">\(cnt\)</span> 个坏儿子变为好儿子，则我们强制使得堆中只有 <span class="math inline">\(cnt\)</span> 个值，同时记录堆中所有值之和，这样 <span class="math inline">\(dp\)</span> 值就可以很容易地求出；求出 <span class="math inline">\(dp\)</span> 值之后，为了避免每次重新执行所有“删点操作”，我们需要将堆中由“删点”得来的值保留，即把强制删去的值重新插入堆中，把 DP 时得来的值从堆中删去。</p>
</div><h2 id="正解代码">正解代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 250005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="keyword">int</span> n, d[N], X, vis[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line">std :: vector&lt; std :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; E[N];</span><br><span class="line">std :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; D[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    E[u].<span class="built_in">push_back</span>(std :: <span class="built_in">make_pair</span>(v, w)), ++d[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(std :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x, std :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d[x.first] &gt; d[y.first];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Normal_Heap</span>&#123;</span> <span class="comment">// 普通大根堆</span></span><br><span class="line">    std :: vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; a;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123; a.<span class="built_in">push_back</span>(x), std :: <span class="built_in">push_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">top</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> a[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123; std :: <span class="built_in">pop_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()), a.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">popn</span><span class="params">()</span></span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> x; <span class="keyword">return</span> std :: <span class="built_in">pop_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()), x = a[a.<span class="built_in">size</span>() - <span class="number">1</span>], a.<span class="built_in">pop_back</span>(), x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> a.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Erase_Heap</span>&#123;</span> <span class="comment">// 用两个普通堆实现的支持删除的大根堆</span></span><br><span class="line">    Normal_Heap a, b;</span><br><span class="line">    <span class="keyword">int</span> sz; <span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123; a.<span class="built_in">push</span>(x), ++sz, sum += x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123; b.<span class="built_in">push</span>(x), --sz, sum -= x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123; <span class="keyword">while</span> (a.<span class="built_in">size</span>() &amp;&amp; b.<span class="built_in">size</span>() &amp;&amp; a.<span class="built_in">top</span>() == b.<span class="built_in">top</span>()) a.<span class="built_in">pop</span>(), b.<span class="built_in">pop</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">top</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">pre</span>(), a.<span class="built_in">top</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123; <span class="built_in">pre</span>(), --sz, sum -= a.<span class="built_in">top</span>(), a.<span class="built_in">pop</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> sz; &#125;</span><br><span class="line">&#125;H[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="comment">// “删点”操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : E[u])&#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> v = to.first, w = to.second;</span><br><span class="line">        <span class="keyword">if</span> (d[v] &lt;= X) <span class="keyword">break</span>;</span><br><span class="line">        H[v].<span class="built_in">push</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[N][<span class="number">2</span>];</span><br><span class="line">std :: vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; tmp, del;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    vis[u] = X;</span><br><span class="line">    <span class="keyword">int</span> num = d[u] - X;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; H[u].<span class="built_in">size</span>() &gt; num; H[u].<span class="built_in">pop</span>()) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : E[u])&#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> v = to.first, w = to.second;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (d[v] &lt;= X) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.<span class="built_in">clear</span>(), del.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : E[u])&#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> v = to.first, w = to.second;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (d[v] &lt;= X) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = dp[v][<span class="number">1</span>] + w - dp[v][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">0</span>)&#123; --num, res += dp[v][<span class="number">1</span>] + w; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        res += dp[v][<span class="number">0</span>], H[u].<span class="built_in">push</span>(x), del.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; H[u].<span class="built_in">size</span>() &amp;&amp; H[u].<span class="built_in">size</span>() &gt; num; H[u].<span class="built_in">pop</span>()) tmp.<span class="built_in">push_back</span>(H[u].<span class="built_in">top</span>()); <span class="comment">// 强制弹堆</span></span><br><span class="line">    dp[u][<span class="number">0</span>] = res + H[u].sum;</span><br><span class="line">    <span class="keyword">for</span> (; H[u].<span class="built_in">size</span>() &amp;&amp; H[u].<span class="built_in">size</span>() &gt; num - <span class="number">1</span>; H[u].<span class="built_in">pop</span>()) tmp.<span class="built_in">push_back</span>(H[u].<span class="built_in">top</span>()); <span class="comment">// 强制弹堆</span></span><br><span class="line">    dp[u][<span class="number">1</span>] = res + H[u].sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : tmp) H[u].<span class="built_in">push</span>(i); <span class="comment">// 还原强制弹堆时删除的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : del) H[u].<span class="built_in">erase</span>(i); <span class="comment">// 删除 DP 得来的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">        u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(), w = <span class="built_in">read</span>(), <span class="built_in">addedge</span>(u, v, w), <span class="built_in">addedge</span>(v, u, w), sum += w;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        D[i] = std :: <span class="built_in">make_pair</span>(d[i], i), std :: <span class="built_in">sort</span>(E[i].<span class="built_in">begin</span>(), E[i].<span class="built_in">end</span>(), cmp);</span><br><span class="line">    std :: <span class="built_in">sort</span>(D + <span class="number">1</span>, D + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (X = <span class="number">1</span>; X &lt; n; ++X)&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n &amp;&amp; D[i].first == X) <span class="built_in">die</span>(D[i].second), ++i;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> v = D[j].second;</span><br><span class="line">            <span class="keyword">if</span> (vis[v] == X) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(v), ans += dp[v][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %lld&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1204D2」Kirk and a Binary String (hard version)</title>
    <url>/cf1204d2-sol/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1204/problem/D2">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(01\)</span> 字符串 <span class="math inline">\(s\)</span>，求一个长度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(01\)</span> 字符串 <span class="math inline">\(t\)</span>，满足 <span class="math inline">\(\forall 1\le l\le r\le n:f(s[l,r])=f(t[l,r])\)</span>，其中 <span class="math inline">\(f(s[l,r])\)</span> 表示 <span class="math inline">\(s\)</span> 中第 <span class="math inline">\(l\)</span> 个字符到第 <span class="math inline">\(r\)</span> 个字符组成的子串的最长<strong>不下降子序列</strong>的长度，<span class="math inline">\(f(t[l,r])\)</span> 同理。</p>
<p>在满足以上条件的同时，你需要最大化 <span class="math inline">\(t\)</span> 中 <span class="math inline">\(0\)</span> 的数量。</p>
<p><span class="math inline">\(n\le 10^5\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>显然一定是把 <span class="math inline">\(s\)</span> 中的若干个 <span class="math inline">\(1\)</span> 改成 <span class="math inline">\(0\)</span>，且每段连续的 <span class="math inline">\(1\)</span> 一定是修改它的一个前缀。</p>
<p>我们发现，一个区间的最长不下降子序列一定可以表示成在区间的某个位置断开（特殊地，也可以在左端点的前面或右端点的后面），然后选断点左边的 <span class="math inline">\(0\)</span> 和断点右边的 <span class="math inline">\(1\)</span>，显然这个断点需要满足左边 <span class="math inline">\(0\)</span> 的个数加上右边 <span class="math inline">\(1\)</span> 的个数等于这个区间的最长不下降子序列长度。我们称这样的断点为这个区间的答案断点。显然答案断点必须满足右边 <span class="math inline">\(1\)</span> 的个数大于等于 <span class="math inline">\(0\)</span> 的个数，左边 <span class="math inline">\(0\)</span> 的个数大于等于 <span class="math inline">\(1\)</span> 的个数。但这个不是充要条件。</p>
<p>考虑一个 <span class="math inline">\(1\)</span> 能变成 <span class="math inline">\(0\)</span> 的条件，假设这个位置为 <span class="math inline">\(i\)</span>，那就是所有 <span class="math inline">\(i+1\)</span> 开始的所有区间必须存在一个最长不下降子序列是全为 <span class="math inline">\(1\)</span> 的。</p>
<p>我们又发现，只要 <span class="math inline">\([i+1,n]\)</span> 这个区间满足条件，所有区间就一定满足条件。</p>
<p>先给出做法：从后往前扫，记 <span class="math inline">\(cnt_i\)</span> 表示 <span class="math inline">\(i\sim n\)</span> <strong>没有改变的位置中</strong> <span class="math inline">\(0\)</span> 的个数减去 <span class="math inline">\(1\)</span> 的个数的值，那么 <span class="math inline">\(cnt_{i+1}=0\)</span> 时把 <span class="math inline">\(i\)</span> 这个位置改成 <span class="math inline">\(0\)</span>。</p>
<p>考虑这样为什么是对的（以下内容纯属口胡）。对于 <span class="math inline">\([i+1,n]\)</span> 的某个点 <span class="math inline">\(j\)</span>，我们把 <span class="math inline">\(j\sim n\)</span> 的<strong>所有位置中</strong> <span class="math inline">\(0\)</span> 的个数减去 <span class="math inline">\(1\)</span> 的个数的值记为 <span class="math inline">\(sum_j\)</span>。由于改变只会是 <span class="math inline">\(1\)</span> 变成 <span class="math inline">\(0\)</span>，所以有 <span class="math inline">\(cnt_j\le sum_j\)</span>。又因为只要碰到 <span class="math inline">\(1\)</span> 且 <span class="math inline">\(cnt_j=0\)</span> 就会改变，所以 <span class="math inline">\(sum_j\ge cnt_j\ge 0\)</span>。要 <span class="math inline">\(j\)</span> 前面的位置要成为答案断点，必须有 <span class="math inline">\(sum_j\le 0\)</span>，所以 <span class="math inline">\(sum_j\)</span> 只能等于 <span class="math inline">\(0\)</span>，即 <span class="math inline">\(0\)</span> 的个数等于 <span class="math inline">\(1\)</span> 的个数。因为 <span class="math inline">\(j\sim n\)</span> 满足这个条件，当前的 <span class="math inline">\(cnt_{i+1}=0\)</span>，所以 <span class="math inline">\(i+1\sim j-1\)</span> 所有位置中 <span class="math inline">\(0\)</span> 的个数一定小于等于 <span class="math inline">\(1\)</span> 的个数，要符合答案断点的必要条件，又只能是取等于。于是我们可以把 <span class="math inline">\(i+1\sim j-1\)</span> 的决策替换成 <span class="math inline">\(1\)</span>，于是 <span class="math inline">\(i+1\sim n\)</span> 就一定存在一个全为 <span class="math inline">\(1\)</span> 的最长不下降子序列。</p>
<p>差不多口胡完了，直接做就可以了。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>), n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n, cnt = <span class="number">0</span>; i; --i) </span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) ++cnt;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt) --cnt;</span><br><span class="line">        <span class="keyword">else</span> s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1067A」Array Without Local Maximums</title>
    <url>/cf1067a-sol/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1067/problem/A">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，有些位置是 <span class="math inline">\(-1\)</span>，其余位置是 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(200\)</span> 的一个整数。你需要在 <span class="math inline">\(-1\)</span> 的位置填上<span class="math inline">\(1\)</span> 到 <span class="math inline">\(200\)</span> 的一个整数，使得序列 <span class="math inline">\(a\)</span> 是好的。一个序列 <span class="math inline">\(a\)</span> 是好的当且仅当满足以下三个条件：</p>
<ol type="1">
<li><span class="math inline">\(a_1\le a_2\)</span></li>
<li><span class="math inline">\(a_n\le a_{n-1}\)</span></li>
<li><span class="math inline">\(\forall i\in [2,n-1],a_i\le \max(a_{i-1},a_{i+1})\)</span></li>
</ol>
<p>求方案数 <span class="math inline">\(\bmod 998244353\)</span> 的值。</p>
<p><span class="math inline">\(n\le 10^5\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>考虑 DP，<span class="math inline">\(dp_{i,j,0/1}\)</span> 表示前 <span class="math inline">\(i\)</span> 个数，<span class="math inline">\(a_i\)</span> 为 <span class="math inline">\(j\)</span>，<span class="math inline">\(a_{i-1}&lt; a_i\)</span> / <span class="math inline">\(a_{i-1}\ge a_i\)</span> 时的方案数。有转移</p>
<p><span class="math display">\[\begin{aligned} dp_{i,j,0}&amp;=\sum_{k=1}^{j-1} dp_{i-1,k,0}+dp_{i-1,k,1}\\ dp_{i,j,1}&amp;=dp_{i-1,j,0}+\sum_{k=j}^{200} dp_{i-1,k,1}\end{aligned}\]</span></p>
<p>可以发现这个式子可以用前缀和优化。</p>
<p>时间复杂度 <span class="math inline">\(O(nm)\)</span>，其中 <span class="math inline">\(m=200\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 998244353</span></span><br><span class="line"><span class="keyword">int</span> n, a[N], dp[N][<span class="number">205</span>][<span class="number">2</span>], pre[N][<span class="number">205</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x += y) &gt;= P ? x - P : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x -= y) &lt; <span class="number">0</span> ? x + P : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">suf</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">del</span>(pre[i][<span class="number">200</span>][k], pre[i][j - <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="number">-1</span> || i == a[<span class="number">1</span>]) dp[<span class="number">1</span>][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        pre[<span class="number">1</span>][i][<span class="number">0</span>] = <span class="built_in">add</span>(pre[<span class="number">1</span>][i - <span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">200</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="number">-1</span> || a[i] == j)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = <span class="built_in">add</span>(pre[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>], pre[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = <span class="built_in">add</span>(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], <span class="built_in">suf</span>(i - <span class="number">1</span>, j, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            pre[i][j][<span class="number">0</span>] = <span class="built_in">add</span>(pre[i][j - <span class="number">1</span>][<span class="number">0</span>], dp[i][j][<span class="number">0</span>]);</span><br><span class="line">            pre[i][j][<span class="number">1</span>] = <span class="built_in">add</span>(pre[i][j - <span class="number">1</span>][<span class="number">1</span>], dp[i][j][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pre[n][<span class="number">200</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1156E」Special Segments of Permutation</title>
    <url>/cf1156e-sol/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1156/problem/E">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的排列 <span class="math inline">\(a\)</span>，求有多少区间 <span class="math inline">\([l,r]\)</span> 满足 <span class="math inline">\(a_l+a_r=\max\limits_{i=l}^{r}a_i\)</span>。</p>
<p><span class="math inline">\(n\le 200\,000\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>用单调栈对每一个 <span class="math inline">\(a_i\)</span> 求出 <span class="math inline">\(l_i=j+1\)</span>，<span class="math inline">\(j\)</span> 是从 <span class="math inline">\(i\)</span> 向左第一个满足 <span class="math inline">\(a_j&gt;a_i\)</span> 的位置，<span class="math inline">\(r_i\)</span> 同理。</p>
<p>那么题目变为对于每个 <span class="math inline">\(i\)</span> 求在 <span class="math inline">\([l_i,i-1]\)</span> 和 <span class="math inline">\([i+1,r_i]\)</span> 中各选出一个数使得这两个数之和为 <span class="math inline">\(a_i\)</span> 的方案数。</p>
<p>结论是，我们只要枚举这两个区间中短的那个区间的每个数 <span class="math inline">\(a_j\)</span>，然后在另一个区间中查询 <span class="math inline">\(a_i-a_j\)</span> 是否存在即可。</p>
<p>看起来是 <span class="math inline">\(O(n^2)\)</span>，其实是 <span class="math inline">\(O(n\log n)\)</span> 的，因为每个数最多会被枚举到 <span class="math inline">\(\log n\)</span> 次。假设某个数被枚举到的所有区间 <span class="math inline">\([l_i,r_i]\)</span> 中，最大的区间长度为 <span class="math inline">\(m\)</span>，那么由于枚举的是短的区间，短的区间长度不会超过 <span class="math inline">\(\frac{m}{2}\)</span>。而如果这个数要被另一个区间枚举到，这个区间一定被之前那个短的区间包含，所以这个区间总长度不会超过 <span class="math inline">\(\frac{m}{2}\)</span>，而且又是短的区间，所以变成了 <span class="math inline">\(\frac{m}{4}\)</span>……感性理解一下，每个数枚举到的次数不会超过 <span class="math inline">\(\log n\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">int</span> n, a[N], p[N], l[N], r[N], top, sta[N], ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l &lt;= p[x] &amp;&amp; p[x] &lt;= r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i), p[a[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[sta[top]]) --top;</span><br><span class="line">        l[i] = sta[top] + <span class="number">1</span>;</span><br><span class="line">        sta[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sta[top = <span class="number">0</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[sta[top]]) --top;</span><br><span class="line">        r[i] = sta[top] - <span class="number">1</span>;</span><br><span class="line">        sta[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = l[i], r1 = i - <span class="number">1</span>, l2 = i + <span class="number">1</span>, r2 = r[i];</span><br><span class="line">        <span class="keyword">if</span> (r1 - l1 &gt; r2 - l2) std :: <span class="built_in">swap</span>(l1, l2), std :: <span class="built_in">swap</span>(r1, r2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = l1; j &lt;= r1; ++j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">in</span>(a[i] - a[j], l2, r2)) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>复杂度分析</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1214D」Treasure Island</title>
    <url>/cf1214d-sol/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1214/problem/D">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定一个 <span class="math inline">\(n\times m\)</span> 的地图，每个格子要么是障碍，要么是空格。你可以把除 <span class="math inline">\((1,1)\)</span> 和 <span class="math inline">\((n,m)\)</span> 外的若干个格子变成障碍，求使得 <span class="math inline">\((1,1)\)</span> 到 <span class="math inline">\((n,m)\)</span> <strong>没有路径</strong>最少需要把几个格子变成障碍。</p>
<p><span class="math inline">\(3\le n\cdot m\le 10^6\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>答案只可能是 <span class="math inline">\(0,1,2\)</span> 中的一种。</p>
<p><span class="math inline">\(0\)</span> 可以直接判；<span class="math inline">\(1\)</span> 就是 <span class="math inline">\((1,1)\)</span> 能走到 <span class="math inline">\((n,m)\)</span> 但必须都经过某个格子 <span class="math inline">\((x,y)\)</span>；否则就是 <span class="math inline">\(2\)</span>。</p>
<p>那么只要找出一条路径，若找不到就是 <span class="math inline">\(0\)</span>；然后再找一条强制不经过第一条路径中的点的路径，若找不到就是 <span class="math inline">\(1\)</span>；否则就是 <span class="math inline">\(2\)</span>。</p>
<p>吐槽一句：我一开始写了个求起点、终点到某个点的路径数量，然后用乘法原理判断，只可惜这东西要取模，于是愉快地 WA on 233 了（<a href="https://codeforces.com/contest/1214/submission/60334654">Submission #60334654</a>）</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m, a[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">char</span> t[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || j &lt; <span class="number">1</span> || i &gt; n || j &gt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a[(i - <span class="number">1</span>) * m + j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    a[(i - <span class="number">1</span>) * m + j] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GG</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n || j &gt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ((i != <span class="number">1</span> || (j != <span class="number">1</span>)) &amp;&amp; <span class="built_in">get</span>(a, i, j)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == n &amp;&amp; j == m) <span class="built_in">GG</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">set</span>(a, i, j, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(i + <span class="number">1</span>, j), <span class="built_in">dfs2</span>(i, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n || j &gt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ((i != <span class="number">1</span> || (j != <span class="number">1</span>)) &amp;&amp; <span class="built_in">get</span>(a, i, j)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == n &amp;&amp; j == m) <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">GG</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">set</span>(a, i, j, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs1</span>(i + <span class="number">1</span>, j), <span class="built_in">dfs1</span>(i, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (t[j] == <span class="string">&#x27;#&#x27;</span>) <span class="built_in">set</span>(a, i, j, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">GG</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1214F」Employment</title>
    <url>/cf1214f-sol/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1214/problem/F">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>有一个大小为 <span class="math inline">\(m\)</span> 的环，还上有 <span class="math inline">\(n\)</span> 个点有工作单位，并且有 <span class="math inline">\(n\)</span> 个点上住着一个人。你需要为每个人分配一个工作单位，使得所有人到工作单位的距离之和最短。输出一个方案。</p>
<p><span class="math inline">\(m\le 10^9,n\le 2\times 10^5\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>下面的数组都从 <span class="math inline">\(0\)</span> 开始标号。先将 <span class="math inline">\(a,b\)</span> 数组分别从小到大排序，然后把 <span class="math inline">\(b\)</span> 数组变成 <span class="math inline">\(b_0,b_1,b_2,\cdots,b_{n-1},b_0+m,b_1+m,\cdots,b_{n-1}+m,b_0+2m,b_1+2m,\cdots,b_{n-1}+2m\)</span>，把 <span class="math inline">\(a\)</span> 数组变成 <span class="math inline">\(a_0+m,a_1+m,a_2+m,\cdots,a_{n-1}+m\)</span>。</p>
<p>考虑贪心，显然两个人的路径不能“交叉”，所以一定是小的和小的匹配，大的和大的匹配。问题变成了求 <span class="math inline">\(\min\limits_{0\le x\le 2n} \sum\limits_{i=0}^{n-1} |a_i-b_{i+x}|\)</span> 的值。</p>
<p>记 <span class="math inline">\(ans_x=\sum\limits_{i=0}^{n-1} |a_i-b_{i+x}|\)</span>，把绝对值拆开，则变成了</p>
<p><span class="math display">\[\begin{aligned}ans_x&amp;=\sum\limits_{i=0}^{n-1} |a_i-b_{i+x}| \\ &amp;=\sum\limits_{i=0}^{n-1} ([a_i &gt; b_{i+x}]a_i-[a_i &lt; b_{i+x}]a_i-[a_i &gt; b_{i+x}]b_{i+x}+[a_i &lt; b_{i+x}]b_{i+x})\end{aligned}\]</span></p>
<p>记 <span class="math inline">\(sa_{x}=\sum\limits_{i=0}^{n-1} ([a_i &gt; b_{i+x}]a_i-[a_i &lt; b_{i+x}]a_i),sb_{x}=\sum\limits_{i=0}^{n-1} ([a_i &lt; b_{i+x}]b_{i+x}-[a_i &gt; b_{i+x}]b_{i+x})\)</span>。考虑单独计算。</p>
<p>我们将 <span class="math inline">\(sa\)</span> 差分，发现 <span class="math inline">\(sa_x-sa_{x-1}=\sum\limits_{i=0}^{n-1} ([a_i &gt; b_{i+x}]a_i-[a_i &lt; b_{i+x}]a_i-[a_i &gt; b_{i+x-1}]a_i+[a_i &lt; b_{i+x-1}]a_i)\)</span>，发现若 <span class="math inline">\(a_i \le b_{i+x-1} \le b_{i+x}\)</span> 或 <span class="math inline">\(b_{i+x-1} \le b_{i+x} \le a_i\)</span> 时，这个式子恰好为 <span class="math inline">\(0\)</span>，只有当 <span class="math inline">\(b_{i+x-1} &lt; a_i &lt; b_{i+x}\)</span> 时，这个式子的值为 <span class="math inline">\(-2a_i\)</span>，而这个 <span class="math inline">\(x\)</span> 又是唯一的。于是对于每个 <span class="math inline">\(a_i\)</span> 求出这个唯一的 <span class="math inline">\(x\)</span>，在差分数组上直接修改即可。</p>
<p>我们依次考虑每个 <span class="math inline">\(b_i\)</span>，发现当 <span class="math inline">\(x\)</span> 小于某个值时，<span class="math inline">\(b_i\)</span> 对 <span class="math inline">\(sb_x\)</span> 的贡献是负的，否则是正的。于是我们求出这个值，然后区间加贡献即可。这个也可以用差分简单的实现。</p>
<p>发现求 <span class="math inline">\(sa_x,sb_x\)</span> 在实现的过程中都需要差分，不需要分开计算。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = <span class="built_in">getchar</span>(), f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">int</span> n, ansi, ansid[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m, ans[N &lt;&lt; <span class="number">1</span>], Ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; rhs.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N], b[N * <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">abs</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; <span class="number">0</span> ? a : -a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">long</span> <span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    ans[l] += v, ans[r] -= v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m = <span class="built_in">read</span>(), n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i].v = <span class="built_in">read</span>(), a[i].id = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) b[i].v = <span class="built_in">read</span>(), b[i].id = i;</span><br><span class="line">    std :: <span class="built_in">sort</span>(a, a + n), std :: <span class="built_in">sort</span>(b, b + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i].v += m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); ++i) b[i + n] = b[i], b[i + n].v += m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ans[<span class="number">0</span>] += a[i].v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = std :: <span class="built_in">lower_bound</span>(b, b + <span class="number">3</span> * n, a[i]) - b;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; i &amp;&amp; j &lt;= i + (n &lt;&lt; <span class="number">1</span>)) ans[j - i] -= <span class="number">2</span> * a[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span> * n; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; n)&#123; <span class="built_in">add</span>(<span class="number">0</span>, j + <span class="number">1</span>, -b[j].v); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= (n &lt;&lt; <span class="number">1</span>))&#123; <span class="built_in">add</span>(j - n + <span class="number">1</span>, (n &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, b[j].v); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> i = std :: <span class="built_in">upper_bound</span>(a, a + n, b[j]) - a;</span><br><span class="line">        <span class="built_in">add</span>(j - i + <span class="number">1</span>, j + <span class="number">1</span>, b[j].v), <span class="built_in">add</span>(j - n + <span class="number">1</span>, j - i + <span class="number">1</span>, -b[j].v);</span><br><span class="line">    &#125;</span><br><span class="line">    Ans = ans[<span class="number">0</span>], ansi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); ++i)&#123;</span><br><span class="line">        ans[i] += ans[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (ans[i] &lt; Ans) Ans = ans[i], ansi = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        ansid[a[i].id] = b[(i + ansi) % n].id;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ansid[i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1214E」Petya and Construction Set</title>
    <url>/cf1214e-sol/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1214/problem/E">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>构造一个 <span class="math inline">\(2n-1\)</span> 个节点的树，满足 <span class="math inline">\(\forall i\in [1,n] : dis(2i-1,2i)=d_i\)</span>，<span class="math inline">\(dis(x,y)\)</span> 表示树上 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的距离，<span class="math inline">\(d_i\)</span> 是给定的。</p>
<p><span class="math inline">\(n\le 10^5\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>将 <span class="math inline">\(d_i\)</span> 从大到小排序，然后依次把所有奇数连成一条链（按对应的 <span class="math inline">\(d_i\)</span> 从大到小的顺序）。</p>
<p>然后依次考虑链上每个点对应的偶数点的位置。假设这个点是链上第 <span class="math inline">\(k\)</span> 个点，对应的 <span class="math inline">\(d_i\)</span> 记为 <span class="math inline">\(D\)</span>，那么显然只要把这个偶数点挂在链上第 <span class="math inline">\(k+D-1\)</span> 个点下面即可。要注意的是，如果第 <span class="math inline">\(k+D-1\)</span> 个点是链上最后一个点，那么再挂一个点要把链进行“扩充”。可以证明，在处理第 <span class="math inline">\(k\)</span> 个点时，链上一定存在 <span class="math inline">\(k+D-1\)</span> 个点（根据 <span class="math inline">\(d_i\)</span> 从大到小进行证明）。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = <span class="built_in">getchar</span>(), f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, cnt, id[<span class="number">100005</span>];</span><br><span class="line">std :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; d[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i].first = -<span class="built_in">read</span>(), d[i].second = i;</span><br><span class="line">    std :: <span class="built_in">sort</span>(d + <span class="number">1</span>, d + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, <span class="number">2</span> * d[i].second - <span class="number">1</span>, <span class="number">2</span> * d[i + <span class="number">1</span>].second - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> x = i - d[i].first - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= n) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, <span class="number">2</span> * d[x].second - <span class="number">1</span>, <span class="number">2</span> * d[i].second);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, id[x - n], <span class="number">2</span> * d[i].second);</span><br><span class="line">        <span class="keyword">if</span> (x - n == cnt) id[++cnt] = <span class="number">2</span> * d[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1244F」Chips</title>
    <url>/cf1244f-sol/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1244/problem/F">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>有一个大小为 <span class="math inline">\(n\)</span> 的环，环上每个点有一个颜色（黑/白）。定义一次操作是，对于每个点 <span class="math inline">\(i\)</span>，若他和他相邻的两个点中，白点多于黑点，则在新的环中， <span class="math inline">\(i\)</span> 变成白色，否则变为黑色。</p>
<p>求进行 <span class="math inline">\(k\)</span> 次操作后每个点的颜色。</p>
<p><span class="math inline">\(n\le 2\times 10^5,k\le 10^9\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>变色的条件相当于 <span class="math inline">\(i\)</span> 相邻两个点的颜色都与 <span class="math inline">\(i\)</span> 的颜色不同。对于一段长度 <span class="math inline">\(\ge 2\)</span> 的颜色相同的段，显然颜色是永远不会变的。只有这样的段之间的这些颜色交替改变的点的颜色会发生变化。例如 <code>WWWBWBWBWBBB</code> -&gt; <code>WWWWBWBWBBBB</code> -&gt; <code>WWWWWBWBBBBB</code> -&gt; <code>WWWWWWBBBBBB</code>。</p>
<p>考虑中间的颜色交替改变的一段（如上例中 <code>BWBWBW</code>），发现每进行一次操作，两边的点会向两边的颜色相同的连续段合并，中间的点会改变颜色。记这样的段中某个点 <span class="math inline">\(i\)</span> 到两边颜色相同连续段的距离是 <span class="math inline">\(a_i,b_i\)</span>，那么他会在第 <span class="math inline">\(\min(a_i,b_i)\)</span> 次操作被合并，颜色要看两边段的颜色和具体往哪边合并，被合并之后颜色就不会再变化，而在被合并之前颜色则是交替变化。所以只要根据 <span class="math inline">\(k\)</span> 和 <span class="math inline">\(\min(a_i,b_i)\)</span> 的大小进行讨论即可。</p>
<p>要注意的是，可能题目给定字符串的最前面一段和最后面一段是可以拼起来的，所以要对顺序进行一定的调整。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 400005</span></span><br><span class="line"><span class="keyword">int</span> n, k, d, dis1[N], dis2[N];</span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;k, a + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) std :: <span class="built_in">reverse</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a + <span class="number">1</span>), <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[n + i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n + <span class="number">2</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] != a[i] &amp;&amp; a[i] != a[i + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123; d = i - <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (!d) d = (n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = d - n + <span class="number">1</span>; i &lt;= d; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] != a[i] &amp;&amp; a[i] != a[i + <span class="number">1</span>]) dis1[i] = dis1[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dis1[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = d; i &gt; d - n; --i)</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] != a[i] &amp;&amp; a[i] != a[i + <span class="number">1</span>]) dis2[i] = dis2[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dis2[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = d - n + <span class="number">1</span>; i &lt;= d; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] != a[i] &amp;&amp; a[i] != a[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> (k &gt;= std :: <span class="built_in">min</span>(dis1[i], dis2[i]))</span><br><span class="line">                <span class="keyword">if</span> (dis1[i] &lt; dis2[i]) b[i] = a[i - dis1[i]];</span><br><span class="line">                <span class="keyword">else</span> b[i] = a[i + dis2[i]];</span><br><span class="line">            <span class="keyword">else</span> b[i] = a[i] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; (k &amp; <span class="number">1</span>) || (a[i] == <span class="string">&#x27;W&#x27;</span> &amp;&amp; (k &amp; <span class="number">1</span> ^ <span class="number">1</span>)) ? <span class="string">&#x27;W&#x27;</span> : <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> b[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d - n; ++i) <span class="built_in">putchar</span>(b[i + n]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = d - n + <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">putchar</span>(b[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1244E」Minimizing Difference</title>
    <url>/cf1244e-sol/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1244/problem/E">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，一次操作可以将序列中的某个数 <span class="math inline">\(+1\)</span> 或 <span class="math inline">\(-1\)</span>。</p>
<p>定义一个序列的差值为序列的最大值减去最小值得到的数。</p>
<p>求进行至多 <span class="math inline">\(k\)</span> 次操作后序列差值的最小值。</p>
<p><span class="math inline">\(n\le 10^5,a_i\le 10^9,k\le 10^{14}\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>显然可以二分答案 <span class="math inline">\(x\)</span>，然后就是求使得差值 <span class="math inline">\(\le x\)</span> 需要进行至少多少次操作。</p>
<p>将 <span class="math inline">\(a_i\)</span> 排序，假设最后的序列中的数在 <span class="math inline">\([p,p+x]\)</span> 中，记序列中最后一个 <span class="math inline">\(&lt; p\)</span> 的数为 <span class="math inline">\(a_l\)</span>，第一个 <span class="math inline">\(&gt;p+x\)</span> 的数为 <span class="math inline">\(a_r\)</span>，那么需要进行的操作数量是 <span class="math inline">\(p\times l-\sum_{i=1}^{l}a_i+\sum_{i=r}^{n}a_i-(p+x)\times (n-r+1)\)</span>。根据这个式子我们可以发现 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(p+x\)</span> 这两个数中一定有一个数是存在于原序列中的，否则可以进行调整使得操作次数更少。于是我们枚举所有情况进行判断即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log \max a_i)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k, a[N], sum[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= n &amp;&amp; a[j] - a[i] &lt;= x) ++j;</span><br><span class="line">        <span class="keyword">if</span> (a[i] * (i - <span class="number">1</span>) - sum[i - <span class="number">1</span>] + sum[n] - sum[j - <span class="number">1</span>] - (a[i] + x) * (n - j + <span class="number">1</span>) &lt;= k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (a[i] - a[j] &gt; x) ++j;</span><br><span class="line">        <span class="keyword">if</span> ((a[i] - x) * (j - <span class="number">1</span>) - sum[j - <span class="number">1</span>] + sum[n] - sum[i] - a[i] * (n - i) &lt;= k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    std :: <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = a[n] - a[<span class="number">1</span>], md, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) <span class="keyword">if</span> (<span class="built_in">check</span>(md = (l + r) &gt;&gt; <span class="number">1</span>)) r = md - <span class="number">1</span>, ans = md; <span class="keyword">else</span> l = md + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #628 (Div. 2) 爆蛋记</title>
    <url>/cf1325/</url>
    <content><![CDATA[<p>完全爆蛋，小号三场上橙无望 /kk</p>
<p><a href="https://codeforces.com/contest/1325/standings/participant/34006907#p34006907">爆蛋链接</a></p>
<span id="more"></span>
<h2 id="a---ehab-and-gcd">A - EhAb AnD gCd</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1325/problem/A">题目传送门</a></p>
<h3 id="题意">题意</h3>
<p>构造正整数 <span class="math inline">\(a,b\)</span> 满足 <span class="math inline">\(\gcd(a,b)+\operatorname{lcm}(a,b)=x\)</span>。</p>
<p><span class="math inline">\(x\le 10^9\)</span></p>
<h3 id="题解">题解</h3>
<p>构造 <span class="math inline">\(a=1,b=x-1\)</span> 即可。</p>
<h3 id="代码">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="string">&#x27; &#x27;</span>), <span class="built_in">print</span>(x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="b---copycopycopycopycopy">B - CopyCopyCopyCopyCopy</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1325/problem/B">题目传送门</a></p>
<h3 id="题意-1">题意</h3>
<p>求将一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span> 复制 <span class="math inline">\(n\)</span> 次后的 LIS 长度。</p>
<p><span class="math inline">\(n\le 10^5\)</span></p>
<h3 id="题解-1">题解</h3>
<p>显然最优方案是在复制的第一份中选最小值，第二份中选次小值……</p>
<p>所以 LIS 长度就是所有数去重后的数量。</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="built_in">print</span>(std::<span class="built_in">unique</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n) - a - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="c---ehab-and-path-etic-mexs">C - Ehab and Path-etic MEXs</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1325/problem/C">题目传送门</a></p>
<h3 id="题意-2">题意</h3>
<p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，你需要给每条边定上互不相同的 <span class="math inline">\(0\sim n-2\)</span> 的整数权值，使得 <span class="math inline">\(\max\limits_{u,v} \operatorname{mex}(\operatorname{path}(u,v))\)</span> 最小。<span class="math inline">\(\operatorname{path}(u,v)\)</span> 表示 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 路径上所有边边权组成的集合。</p>
<p><span class="math inline">\(n\le 10^5\)</span></p>
<h3 id="题解-2">题解</h3>
<p>对于 <span class="math inline">\(n&gt;2\)</span> 时，我们始终可以找到一条包含 <span class="math inline">\(0,1\)</span> 的路径，所以有答案 <span class="math inline">\(\ge 2\)</span>。</p>
<p>我们只要找到一个度数 <span class="math inline">\(\ge 3\)</span> 的点，把 <span class="math inline">\(0,1,2\)</span> 放在这个点连出去的边中，就可以保证不存在某条路径同时包含 <span class="math inline">\(0,1,2\)</span>，即达到了答案的下界。</p>
<p>若没有度数 <span class="math inline">\(\ge 3\)</span> 的点，此时树的形态是一条链，答案显然为 <span class="math inline">\(n-1\)</span>，任意构造即可。</p>
<h3 id="代码-2">代码</h3>
<p>考场上想复杂了，尝试以某个叶子节点为根以后去考虑 <span class="math inline">\(0,1,2\)</span> 的放置，于是罚时罚没了（成功搞炸心态）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, ans[N];</span><br><span class="line">std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; E[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>, u, v; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), E[u].<span class="built_in">push_back</span>(&#123;v, i&#125;), E[v].<span class="built_in">push_back</span>(&#123;u, i&#125;), ans[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (E[i].<span class="built_in">size</span>() == <span class="number">1</span>) ++cnt, id = i;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) <span class="built_in">print</span>(i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[E[id][<span class="number">0</span>].second] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = E[id][<span class="number">0</span>].first, lst = id, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (E[u].<span class="built_in">size</span>() == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[u][<span class="number">0</span>].first ^ E[u][<span class="number">1</span>].first ^ lst;</span><br><span class="line">        lst = u, u = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : E[u]) <span class="keyword">if</span> (p.first != lst) ans[p.second] = ++now;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == <span class="number">-1</span>) ans[i] = ++now;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) <span class="built_in">print</span>(ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="d---ehab-the-xorcist">D - Ehab the Xorcist</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1325/problem/D">题目传送门</a></p>
<h3 id="题意-3">题意</h3>
<p>构造一个最短的序列使得异或和为 <span class="math inline">\(u\)</span>，和为 <span class="math inline">\(v\)</span>。</p>
<p><span class="math inline">\(u,v\le 10^{18}\)</span></p>
<h3 id="题解-3">题解</h3>
<p>考场上尝试从高位到低位逐位构造，但是他先 WA9 然后 WA18 了。</p>
<p>神仙 Froggy 告诉我本题考查了 if 语句。</p>
<p>我离当场去世真的只差一点.jpg</p>
<h3 id="代码-3">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> u, v;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (v &lt; u || (v - u) &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">print</span>(<span class="number">-1</span>), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">print</span>(<span class="number">0</span>), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">print</span>(<span class="number">2</span>), <span class="built_in">print</span>(v &gt;&gt; <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>), <span class="built_in">print</span>(v &gt;&gt; <span class="number">1</span>), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> <span class="built_in">print</span>(<span class="number">1</span>), <span class="built_in">print</span>(u), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (u &amp; ((v - u) &gt;&gt; <span class="number">1</span>)) <span class="keyword">return</span> <span class="built_in">print</span>(<span class="number">3</span>), <span class="built_in">print</span>(u, <span class="string">&#x27; &#x27;</span>), <span class="built_in">print</span>((v - u) &gt;&gt; <span class="number">1</span>), <span class="built_in">print</span>((v - u) &gt;&gt; <span class="number">1</span>), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">print</span>(<span class="number">2</span>), <span class="built_in">print</span>(u + ((v - u) &gt;&gt; <span class="number">1</span>), <span class="string">&#x27; &#x27;</span>), <span class="built_in">print</span>((v - u) &gt;&gt; <span class="number">1</span>), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="e---ehabs-real-number-theory-problem">E - Ehab's REAL Number Theory Problem</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1325/problem/E">题目传送门</a></p>
<h3 id="题意-4">题意</h3>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，求出所有乘积为完全平方数的子序列（可以不连续）的最短长度。</p>
<p>保证 <span class="math inline">\(a_i\)</span> 的因数个数不超过 <span class="math inline">\(7\)</span>。</p>
<p><span class="math inline">\(n\le 10^5,a_i\le 10^6\)</span></p>
<h3 id="题解-4">题解</h3>
<p>由于包含三个不同质因子的数至少有 <span class="math inline">\((1+1)^3=8\)</span> 个因数，所以因数个数不超过 <span class="math inline">\(7\)</span> 说明不同质因子数量不超过 <span class="math inline">\(2\)</span>。</p>
<p>并且，我们可以去掉 <span class="math inline">\(a_i\)</span> 中包含的完全平方因子，这样处理后 <span class="math inline">\(a_i\)</span> 只会包含至多两个次数为 <span class="math inline">\(1\)</span> 的质因子。</p>
<p>于是我们可以把 <span class="math inline">\(a_i\)</span> 表示成 <span class="math inline">\(p\times q\)</span> 的形式，其中 <span class="math inline">\(p,q\)</span> 为质数或 <span class="math inline">\(1\)</span>。我们把这样的 <span class="math inline">\(a_i\)</span> 看成一条连接 <span class="math inline">\(p,q\)</span> 的无向边。</p>
<p>现在问题是在这样得到的图中选择最少数量的边（至少一条），使得只保留这些边后图中每个点的度数为偶数。</p>
<p>显然存在度数 <span class="math inline">\(&gt;2\)</span> 的点是不优的，所以我们可以强制最后每个点的度数为 <span class="math inline">\(2\)</span>（不考虑度数为 <span class="math inline">\(0\)</span> 的点）。</p>
<p>这意味着我们要求新图的最小环。</p>
<hr />
<p>考场上<del>被人误导</del>想了一个假算法，就是把 <span class="math inline">\(&gt;1000\)</span> 的点扔掉，直接在他连的点之间互相连边以后跑 Floyd。</p>
<p>但是显然这样做是错的，会导致一个数被选多次。</p>
<hr />
<p>考场上只想到了上面部分，于是当场去世了。</p>
<p>我们需要求出一个无向图的最小环。那么我们考虑枚举一个点 <span class="math inline">\(s\)</span> 以及一条边 <span class="math inline">\((u,v)\)</span>，得到以 <span class="math inline">\(s\)</span> 为起点的最短路树，求出包含点 <span class="math inline">\(s\)</span> 和<strong>非树边</strong> <span class="math inline">\((u,v)\)</span> 的最小环。</p>
<p>考虑最短路树上加入 <span class="math inline">\((u,v)\)</span>，我们得到了一个包含 <span class="math inline">\((u,v)\)</span> 但有可能不包含 <span class="math inline">\(s\)</span> 的环。</p>
<p>可以发现，我们直接用 <span class="math inline">\(\operatorname{dist}(s,u)+\operatorname{dist}(s,v)\)</span> 更新答案一定是对的，因为如果上面得到的环不包含 <span class="math inline">\(s\)</span>，一定会在枚举其他起点时被计算入答案，并且一定优于 <span class="math inline">\(\operatorname{dist}(s,u)+\operatorname{dist}(s,v)\)</span>，所以我们并不需要判断这个环是否包含 <span class="math inline">\(s\)</span>。</p>
<p>我们仍然需要考虑的是上述算法是否能覆盖到最优解。考虑最优解环上任意一个点 <span class="math inline">\(s\)</span>，环上一定存在一条边 <span class="math inline">\((u,v)\)</span> 不在以 <span class="math inline">\(s\)</span> 为起点形成的最短路树上。如果 <span class="math inline">\(u,v\)</span> 在这棵树上的 LCA 不是 <span class="math inline">\(s\)</span>，说明存在一个更小的环，与假设矛盾；否则此时 <span class="math inline">\(\operatorname{dist}(s,u)+\operatorname{dist}(s,v)\)</span> 一定就是最优解的环长。由于我们枚举了所有 <span class="math inline">\(s,u,v\)</span>，所以一定能覆盖到最优解。</p>
<hr />
<p>然而上面的算法是 <span class="math inline">\(O(nm)\)</span> 的。</p>
<p>设 <span class="math inline">\(m=\max \{a_i\}\)</span>，可以发现我们需要求最小环的图与一般的图有一个很大的区别是，两个点 <span class="math inline">\(u,v\)</span> 若 <span class="math inline">\(uv&gt;m\)</span> 是不可能有边的，所以一定不会存在 <span class="math inline">\(u,v&gt;\sqrt{m}\)</span> 的连边。</p>
<p>那么显然一个环内至少存在一个点的编号是 <span class="math inline">\(\le \sqrt{m}\)</span> 的。根据上面算法能覆盖到最优解的证明过程，我们只要能够枚举到环上任意一个点作为 <span class="math inline">\(s\)</span> 就可以覆盖到这个环。所以，我们只要将上面求最小环的算法中 <span class="math inline">\(s\)</span> 的枚举范围缩小到 <span class="math inline">\(\sqrt{m}\)</span> 即可。</p>
<p>时间复杂度根据实现为 <span class="math inline">\(O(n\frac{\sqrt{m}}{\log m})\)</span> 或 <span class="math inline">\(O((n+\frac{m}{\log m})\frac{\sqrt{m}}{\log m})\)</span>。</p>
<p>除以 <span class="math inline">\(\log m\)</span> 是因为只需要考虑质数。</p>
<h3 id="代码-4">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000005</span>, M = <span class="number">100005</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> cnt, p[N], vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 欧拉筛预处理所有质数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) p[++cnt] = i, vis[i] = cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] * i &lt;= n; ++j)&#123;</span><br><span class="line">            vis[p[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v[M];</span><br><span class="line">std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; E[N];</span><br><span class="line"><span class="keyword">int</span> ans, ont[M], tim[N], dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123; <span class="comment">// bfs 求出最短路树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ont[i] = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push_back</span>(S), tim[S] = S, dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将 tim 置为每次 bfs 的起点，可以避免每次需要重置 dis 数组导致复杂度变劣</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)Q.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : E[u])&#123;</span><br><span class="line">            <span class="keyword">int</span> v = p.first, eid = p.second;</span><br><span class="line">            <span class="keyword">if</span> (tim[v] != S) Q.<span class="built_in">push_back</span>(v), tim[v] = S, dis[v] = dis[u] + <span class="number">1</span>, ont[eid] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">// 枚举每条非树边，更新答案</span></span><br><span class="line">        <span class="keyword">if</span> (!ont[i] &amp;&amp; tim[v[i][<span class="number">0</span>]] == S &amp;&amp; tim[v[i][<span class="number">1</span>]] == S)</span><br><span class="line">            ans = std::<span class="built_in">min</span>(ans, dis[v[i][<span class="number">0</span>]] + dis[v[i][<span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">1000000</span>), p[<span class="number">0</span>] = <span class="number">1</span>, vis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="number">1ll</span> * p[j] * p[j] &lt;= x; ++j)</span><br><span class="line">            <span class="keyword">if</span> (x % p[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (x % p[j] == <span class="number">0</span>) x /= p[j], k ^= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (k) v[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>) v[i].<span class="built_in">push_back</span>(vis[x]);</span><br><span class="line">        <span class="keyword">while</span> (v[i].<span class="built_in">size</span>() &lt; <span class="number">2</span>) v[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        E[v[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(&#123;v[i][<span class="number">0</span>], i&#125;), E[v[i][<span class="number">0</span>]].<span class="built_in">push_back</span>(&#123;v[i][<span class="number">1</span>], i&#125;);</span><br><span class="line">        <span class="comment">// 连边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; ++i) tim[i] = <span class="number">-1</span>;</span><br><span class="line">    ans = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="keyword">if</span> (p[i] &lt;= <span class="number">1000</span>) <span class="built_in">bfs</span>(i); <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 只需要考虑编号 &lt;=1000 且为质数的点</span></span><br><span class="line">    <span class="keyword">if</span> (ans == INF) <span class="built_in">print</span>(<span class="number">-1</span>); <span class="keyword">else</span> <span class="built_in">print</span>(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="f---ehabs-last-theorem">F - Ehab's Last Theorem</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1325/problem/F">题目传送门</a></p>
<p>咕咕咕...</p>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>BFS</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Global Round 7 上 IM 记</title>
    <url>/cf1326/</url>
    <content><![CDATA[<p>终于上 IM 了（</p>
<span id="more"></span>
<h2 id="a---bad-ugly-numbers">A - Bad Ugly Numbers</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1326/problem/A">题目传送门</a></p>
<h3 id="题解">题解</h3>
<p>为什么您们都能想到构造 <span class="math inline">\(2333\cdots 333\)</span> 啊 QAQ</p>
<p>显然一个能被 <span class="math inline">\(p\)</span> 整除的数，加或减一个不能被 <span class="math inline">\(p\)</span> 整除的数后，不能被 <span class="math inline">\(p\)</span> 整除。</p>
<p>我们考虑 <span class="math inline">\(777\cdots 777\)</span> 能被 <span class="math inline">\(7\)</span> 整除，而 <span class="math inline">\(777\cdots 77x\)</span>（<span class="math inline">\(x &gt; 0\)</span>）不能被 <span class="math inline">\(7\)</span> 整除。</p>
<p>又<del>根据小学数学知识</del>，能被 <span class="math inline">\(4\)</span> 整除的数的特征是最后两位能被 <span class="math inline">\(4\)</span> 整除，由于 <span class="math inline">\(74\bmod 4\ne 0\)</span>，所以我们构造 <span class="math inline">\(777\cdots 774\)</span> 即可。</p>
<p>注意需要特判 <span class="math inline">\(n=1\)</span>。</p>
<h3 id="代码">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">print</span>(<span class="number">-1</span>), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="built_in">putchar</span>(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;4&#x27;</span>), <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="b---maximums">B - Maximums</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1326/problem/B">题目传送门</a></p>
<h3 id="题解-1">题解</h3>
<p>由 <span class="math inline">\(c_i\)</span> 的定义可得 <span class="math display">\[\begin{aligned} b_i&amp;=a_i-c_i \\&amp;=a_i-\max\{0,\max\limits_{j=1}^{i-1} a_j\} \end{aligned}\]</span></p>
<p>移项后可得 <span class="math display">\[a_i=b_i+\max\{0,\max\limits_{j=1}^{i-1}a_j\}\]</span></p>
<p>我们只要在递推的同时维护 <span class="math inline">\(a_1,a_2,\cdots,a_{i-1}\)</span> 的最大值即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) now += a[i], <span class="built_in">print</span>(now, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">print</span>(now + a[i], <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="c---permutation-partitions">C - Permutation Partitions</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1326/problem/C">题目传送门</a></p>
<h3 id="题解-2">题解</h3>
<p>考场上我看到本题一脸懵逼，我发现我好像不会第一问...</p>
<p>冷静一下，发现显然答案的上界是取最大的 <span class="math inline">\(k\)</span> 个数，即 <span class="math inline">\((n-k+1)+(n-k+2)+\cdots+n=\frac{(2n-k+1)k}{2}\)</span>。</p>
<p>我们可以在原排列中标记出这最大的 <span class="math inline">\(k\)</span> 个数，记从左往右第 <span class="math inline">\(i\)</span> 个被标记的位置为 <span class="math inline">\(x_i\)</span>。</p>
<p>我们要把原排列划分成 <span class="math inline">\(k\)</span> 段意味着我们要找到 <span class="math inline">\(k-1\)</span> 个分界点，并且我们现在要求两个分界点之间恰好包含一个被标记的数。</p>
<p>那么显然第 <span class="math inline">\(i\)</span> 个分界点应该选在 <span class="math inline">\(x_i\)</span> 到 <span class="math inline">\(x_{i+1}\)</span> 之间。</p>
<p>每个分界点的选择是独立的（即不会影响其他分界点的选择），所以根据乘法原理，把每个分界点的方案数相乘即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h3 id="代码-2">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(k);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lst = <span class="number">0</span>, ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; n - k)&#123;</span><br><span class="line">            sum += a[i];</span><br><span class="line">            <span class="keyword">if</span> (lst) ans = <span class="number">1ll</span> * ans * (i - lst) % P;</span><br><span class="line">            lst = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(sum, <span class="string">&#x27; &#x27;</span>), <span class="built_in">print</span>(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="d2---prefix-suffix-palindrome-hard-version">D2 - Prefix-Suffix Palindrome (Hard version)</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1326/problem/D2">题目传送门</a></p>
<h3 id="题解-3">题解</h3>
<p>考场上看到本题的第一想法是枚举前后缀匹配的长度 <span class="math inline">\(l\)</span>，然后要求从 <span class="math inline">\(l+1\)</span> 开始的最长回文串或者以 <span class="math inline">\(n-l\)</span> 结尾的最长回文串。</p>
<p>刚打算去隔壁 <a href="https://www.luogu.com.cn/problem/P4555">最长双回文串</a> 复制一个代码，意识到了不对...</p>
<p>如果求出来的回文串与前后缀有重叠怎么办？</p>
<p>考虑上面这个想法用暴力怎么实现。在我们将原串中间插入 <code>#</code> 后，用 manacher 算法以 <span class="math inline">\(i\)</span> 为回文中心的回文半径 <span class="math inline">\(d_i\)</span>。</p>
<p>然后我们枚举前后缀匹配长度 <span class="math inline">\(l\)</span>，分两种情况：</p>
<ul>
<li>对于所有 <span class="math inline">\(l+1\le i\le \frac{|s|+1}{2}\)</span> 且 <span class="math inline">\(i-d_i+1\le l+1\)</span>，求出 <span class="math inline">\(i\)</span> 的最大值；</li>
<li>对于所有 <span class="math inline">\(\frac{|s|+1}{2}\le i\le n-l\)</span> 且 <span class="math inline">\(i+d_i-1\ge n-l\)</span>，求出 <span class="math inline">\(i\)</span> 的最小值。</li>
</ul>
<p>可以发现，<span class="math inline">\(l\)</span> 越大，越容易满足限制，越容易使得 <span class="math inline">\(i\)</span> 取到极值。</p>
<p>所以我们求出最大的 <span class="math inline">\(l\)</span> 以后用上面的暴力实现即可。</p>
<p><del>如果你不怕被 hack 的话</del> manacher 也可以用哈希实现。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h3 id="代码-3">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000005</span>; <span class="comment">// 注意数组开大一倍</span></span><br><span class="line"><span class="keyword">int</span> n, d[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">(<span class="keyword">int</span> *d, <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, m = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        d[i] = i &gt; r ? <span class="number">0</span> : std::<span class="built_in">min</span>(r - i + <span class="number">1</span>, d[m - (i - m)]);</span><br><span class="line">        <span class="keyword">while</span> (i - d[i] &gt; <span class="number">0</span> &amp;&amp; i + d[i] &lt;= n &amp;&amp; s[i - d[i]] == s[i + d[i]]) ++d[i];</span><br><span class="line">        <span class="keyword">if</span> (i + d[i] - <span class="number">1</span> &gt; r) m = i, r = i + d[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">reads</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i) s[i &lt;&lt; <span class="number">1</span>] = s[i], s[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    s[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>, n = n * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">manacher</span>(d, s, n);</span><br><span class="line">    <span class="comment">// for (register int i = 1; i &lt;= n; ++i) debug(&quot;%d &quot;, d[i]); debug(&quot;\n&quot;);</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[n - i + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> ++len;</span><br><span class="line">    <span class="comment">// debug(&quot;%d\n&quot;, len);</span></span><br><span class="line">    <span class="keyword">int</span> d1 = <span class="number">0</span>, d2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = len + <span class="number">1</span>; i &lt;= (n + <span class="number">1</span>) / <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i - d[i] + <span class="number">1</span> &lt;= len + <span class="number">1</span>) d1 = std::<span class="built_in">max</span>(d1, (i - len) * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = (n + <span class="number">1</span>) / <span class="number">2</span>; i &lt;= n - len; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i + d[i] - <span class="number">1</span> &gt;= n - len) d2 = std::<span class="built_in">max</span>(d2, (n - len - i + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (d1 &gt; d2)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len + d1; ++i)</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27;#&#x27;</span>) <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - len + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27;#&#x27;</span>) <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27;#&#x27;</span>) <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - len - d2 + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27;#&#x27;</span>) <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="e---bombs">E - Bombs</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1326/problem/E">题目传送门</a></p>
<h3 id="题解-4">题解</h3>
<p>发现答案单调递减，可以考虑枚举答案 <span class="math inline">\(x\)</span>。</p>
<p>将 <span class="math inline">\(&gt; x\)</span>（即必须炸掉的数）的位置置为 <span class="math inline">\(1\)</span>，炸弹置为 <span class="math inline">\(-1\)</span>，其他位置置为 <span class="math inline">\(0\)</span>。</p>
<p>则合法的条件是所有后缀和 <span class="math inline">\(\le 0\)</span>。</p>
<p>用线段树维护即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>别问我为什么对，感觉挺对的就行了（雾</p>
<h3 id="代码-4">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300005</span>;</span><br><span class="line"><span class="keyword">int</span> n, p[N], q[N], pos[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mx[N &lt;&lt; <span class="number">2</span>], lz[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123; mx[u] += v, lz[u] += v; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="built_in">add</span>(u &lt;&lt; <span class="number">1</span>, lz[u]), <span class="built_in">add</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, lz[u]), lz[u] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">add</span>(u, v), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> md = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">down</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= md) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, md, L, R, v);</span><br><span class="line">        <span class="keyword">if</span> (R &gt; md) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, md + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">        mx[u] = std::<span class="built_in">max</span>(mx[u &lt;&lt; <span class="number">1</span>], mx[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(p[i]), pos[p[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(q[i]);</span><br><span class="line">    <span class="built_in">print</span>(n, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">int</span> now = n;</span><br><span class="line">    T.<span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, pos[n], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        T.<span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, q[i], <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (T.mx[<span class="number">1</span>] &lt;= <span class="number">0</span>) --now, T.<span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, pos[now], <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">print</span>(now, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="f1---wise-men-easy-version">F1 - Wise Men (Easy Version)</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1326/problem/F1">题目传送门</a></p>
<h3 id="题解-5">题解</h3>
<p>考场上看到 Easy Version <span class="math inline">\(n\le 14\)</span>，Hard Version <span class="math inline">\(n\le 18\)</span>，莫名就想到了 meet in middle...</p>
<p>可以预处理出 <span class="math inline">\(f_{S,T,i}\)</span> 表示当前排列中数的集合为 <span class="math inline">\(S\)</span>，导出的 01 字符串为 <span class="math inline">\(T\)</span>，且排列中最后一个数为 <span class="math inline">\(i\)</span> 的方案数。</p>
<p>然后考虑 meet in middle，合并两边的方案。</p>
<p>问题来了，我好像不会快速合并两边的方案 QAQ</p>
<p>但是问题不大，我们可以 <strong>暴力合并</strong>！</p>
<p>直接枚举左边的数集 <span class="math inline">\(S\)</span>，最后的 01 串 <span class="math inline">\(T\)</span>，以及中间相邻的两个数，显然方案数可以利用 <span class="math inline">\(f\)</span> 进行计算。</p>
<p>但是，你可能需要一些卡常技巧（设两边的大小分别为 <span class="math inline">\(B_1,B_2\)</span>）：</p>
<ol type="1">
<li><span class="math inline">\(f\)</span> 数组只需要预处理所有 <span class="math inline">\(|S|=B_1\)</span> 或 <span class="math inline">\(|S|=B_2\)</span> 的位置，可以直接枚举所有排列进行统计，不需要进行 DP。</li>
<li>显然 01 串反转以后答案是不变的，所以我们只计算 <span class="math inline">\(T\le \operatorname{rev}(T)\)</span> 的位置即可。</li>
<li>可以预处理 <span class="math inline">\(2^n-1,2^{B_1-1}-1,2^{B_2-1}-1\)</span> 的值来减少运算次数。</li>
<li>由于枚举 <span class="math inline">\(T\)</span> 以后我们可以知道中间相邻两个数是否有边，我们可以预处理出与一个点有边/无边的点来快速枚举。</li>
<li>根据代码常数调整 <span class="math inline">\(B_1,B_2\)</span> 的大小。</li>
</ol>
<p>为了保险，你可以再加上 Ofast 和 O3 优化。</p>
<p>理论时间复杂度 <span class="math inline">\(O(C_{n}^{B_1}(B_1!+B_2!+2^n n^2))\)</span>，事实上有好几个 <span class="math inline">\(\frac{1}{2}\)</span> 的常数。</p>
<h3 id="代码-5">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, E[<span class="number">14</span>][<span class="number">14</span>], bitcnt[<span class="number">1</span> &lt;&lt; <span class="number">14</span>], rev[<span class="number">1</span> &lt;&lt; <span class="number">14</span>], p[<span class="number">14</span>], f[<span class="number">1</span> &lt;&lt; <span class="number">14</span>][<span class="number">1</span> &lt;&lt; <span class="number">6</span>][<span class="number">14</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">1</span> &lt;&lt; <span class="number">14</span>];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; G[<span class="number">14</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(E[i][j] = <span class="built_in">getchar</span>())) ;</span><br><span class="line">            E[i][j] ^= <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            G[i][E[i][j]].<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    bitcnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) bitcnt[i] = bitcnt[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    rev[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); ++i) rev[i] = rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (i &amp; <span class="number">1</span>) &lt;&lt; (n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> B1 = n &gt;&gt; <span class="number">1</span>, B2 = n - B1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; n); ++S)</span><br><span class="line">        <span class="keyword">if</span> (bitcnt[S] == B1 || bitcnt[S] == B2)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                <span class="keyword">if</span> (S &gt;&gt; i &amp; <span class="number">1</span>) p[cnt++] = i;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> T = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt - <span class="number">1</span>; ++i)</span><br><span class="line">                    <span class="keyword">if</span> (E[p[i]][p[i + <span class="number">1</span>]]) T |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                ++f[S][T][p[cnt - <span class="number">1</span>]];</span><br><span class="line">                <span class="keyword">if</span> (!std::<span class="built_in">next_permutation</span>(p, p + cnt)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> U = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>, U1 = (<span class="number">1</span> &lt;&lt; (B1 - <span class="number">1</span>)) - <span class="number">1</span>, U2 = (<span class="number">1</span> &lt;&lt; (B2 - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; n); ++S)</span><br><span class="line">        <span class="keyword">if</span> (bitcnt[S] == B1)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> T = <span class="number">0</span>; T &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); ++T)</span><br><span class="line">                <span class="keyword">if</span> (T &lt;= rev[T])&#123;</span><br><span class="line">                    <span class="keyword">int</span> T1 = T &amp; U1, T2 = rev[T] &amp; U2, t = (T &gt;&gt; (B1 - <span class="number">1</span>)) &amp; <span class="number">1</span>, _S = U ^ S;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                        <span class="keyword">if</span> (f[S][T1][i])</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> j : G[i][t])</span><br><span class="line">                                ans[T] += f[S][T1][i] * f[_S][T2][j];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> T = <span class="number">0</span>; T &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); ++T)</span><br><span class="line">        <span class="keyword">if</span> (T &lt;= rev[T]) <span class="built_in">print</span>(ans[T], <span class="string">&#x27; &#x27;</span>); <span class="keyword">else</span> <span class="built_in">print</span>(ans[rev[T]], <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一分钟绝杀的感觉真的非常舒适（</p>
</div><h2 id="f2---wise-men-hard-version">F2 - Wise Men (Hard Version)</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1326/problem/F2">题目传送门</a></p>
<p>来了来了，来填坑了。</p>
<h3 id="题解-6">题解</h3>
<p>发现既有有边又有没边的限制非常难搞，于是我们考虑容斥，即计算 <span class="math inline">\(ans_A\)</span> 为对于所有 <span class="math inline">\(A\)</span> 中为 <span class="math inline">\(1\)</span> 的位置 <span class="math inline">\(i\)</span>，满足 <span class="math inline">\(p_i\)</span> 与 <span class="math inline">\(p_{i+1}\)</span> 有边的排列 <span class="math inline">\(p\)</span> 的数量（对于 <span class="math inline">\(0\)</span> 的位置没有限制）。</p>
<p>计算出 <span class="math inline">\(ans_A\)</span> 后，只要用类似于「逆高维前缀和」的方法，就可以在 <span class="math inline">\(O(2^nn)\)</span> 求出真正的答案。</p>
<p>考虑如何计算 <span class="math inline">\(ans_A\)</span>。发现 <span class="math inline">\(ans_A\)</span> 的值只与 <span class="math inline">\(A\)</span> 中 <span class="math inline">\(1\)</span> 连续段的长度形成的<strong>可重</strong>集合有关。如 <span class="math inline">\(A=\{0,1,1,1,0,0,1\}\)</span> 时，所有 <span class="math inline">\(1\)</span> 连续段长度形成的集合就是 <span class="math inline">\(\{1,1,2,4\}\)</span>（原长加 <span class="math inline">\(1\)</span>）。</p>
<p>可以发现，对于任意 <span class="math inline">\(A\)</span>，对应的 <span class="math inline">\(1\)</span> 连续段长度形成的可重集合中所有元素的和一定恰好为 <span class="math inline">\(n\)</span>。这意味着不同的集合数量等于 <span class="math inline">\(n\)</span> 的划分数。</p>
<p>对于一个划分 <span class="math inline">\(P=\{a_1,a_2,\cdots,a_k\}\)</span>，可以发现对应的方案数实质上是在原图中选出 <span class="math inline">\(k\)</span> 条不相交的简单路径，满足第 <span class="math inline">\(i\)</span> 条路径的点数为 <span class="math inline">\(a_i\)</span> 的方案数。</p>
<p>那么我们先考虑选 <span class="math inline">\(1\)</span> 条路径。可以用 DP 求出 <span class="math inline">\(f_{u,S}\)</span> 表示当前在节点 <span class="math inline">\(u\)</span>，经过的点集为 <span class="math inline">\(S\)</span> 时的路径条数，进而求出 <span class="math inline">\(g_S\)</span> 表示经过的点集为 <span class="math inline">\(S\)</span> 的路径条数。</p>
<p>那么对于一个划分 <span class="math inline">\(P=\{a_1,a_2,\cdots,a_k\}\)</span>，答案即为 <span class="math display">\[\sum_{S_1,S_2,\cdots,S_k} \left[|S_i|=a_i\right]\left[\forall i\ne j:S_i\cap S_j=\varnothing\right]\left[\bigcup\limits_{i=1}^{k}S_i=U\right]\prod\limits_{i=1}^{k} g_{S_i}\]</span></p>
<p>其中 <span class="math inline">\(U\)</span> 表示全集。</p>
<p>注意到由于 <span class="math inline">\(\sum\limits_{i=1}^{k} a_i=n\)</span>，后面两个条件只需要保留一个即可。第二个条件很难处理，我们考虑保留第三个。若不考虑前两个条件，只考虑第三个条件，只需要用 FWT 即可方便地求出答案。</p>
<p>存在第一个条件时，我们只要将 <span class="math inline">\(g\)</span> 加上一维，<span class="math inline">\(g_{l,S}\)</span> 表示长度为 <span class="math inline">\(l\)</span>，经过点集为 <span class="math inline">\(S\)</span> 的简单路径数量。对于 <span class="math inline">\(|S|\ne l\)</span> 的位置就置为 <span class="math inline">\(0\)</span>。那么答案式子变成了 <span class="math display">\[\sum_{S_1,S_2,\cdots,S_k} \left[\bigcup\limits_{i=1}^{k}S_i=U\right]\prod\limits_{i=1}^{k} g_{a_i,S_i}\]</span></p>
<p>直接将所有 <span class="math inline">\(g_i\)</span> 进行一次 FWT 后，枚举划分时直接点乘。由于我们实际只需要卷积结果中 <span class="math inline">\(2^n-1\)</span> 位置的值，所以我们不需要每次 IFWT，直接根据实际意义用容斥就可以 <span class="math inline">\(O(2^n)\)</span> 求出这个值。</p>
<p>总时间复杂度 <span class="math inline">\(O(2^n(P(n)+n^2))\)</span>，其中 <span class="math inline">\(P(n)\)</span> 表示 <span class="math inline">\(n\)</span> 的划分数。</p>
<p>实现得不好可能会变成 <span class="math inline">\(O(2^n(S(n)+n^2))\)</span> 或 <span class="math inline">\(O(2^nn(P(n)+n))\)</span>，其中 <span class="math inline">\(S(n)\)</span> 表示 <span class="math inline">\(n\)</span> 的所有划分的大小之和。</p>
<h3 id="代码-6">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; bitcnt;</span><br><span class="line">std::vector&lt;std::vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; f;</span><br><span class="line">std::vector&lt;std::vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; g;</span><br><span class="line">std::map&lt;std::vector&lt;<span class="keyword">int</span>&gt;, std::vector&lt;<span class="keyword">int</span>&gt;&gt; part;</span><br><span class="line">std::vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt; &amp;l, <span class="keyword">const</span> std::vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!r)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)</span><br><span class="line">            <span class="keyword">if</span> (bitcnt[mask ^ i] &amp; <span class="number">1</span>) res -= s[i]; <span class="keyword">else</span> res += s[i];</span><br><span class="line">        <span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt; &amp;p = part[l];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : p) ans[v] += res;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lst = l.<span class="built_in">empty</span>() ? <span class="number">1</span> : l.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = lst; k &lt;= r; ++k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; r &amp;&amp; r - k &lt; k) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">nl</span><span class="params">(l)</span></span>;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">ns</span><span class="params">(s)</span></span>;</span><br><span class="line">        nl.<span class="built_in">push_back</span>(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) ns[i] *= g[k - <span class="number">1</span>][i];</span><br><span class="line">        <span class="built_in">dfs</span>(r - k, nl, ns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">E</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch;</span><br><span class="line">            <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>())) ;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;1&#x27;</span>) E[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    bitcnt.<span class="built_in">resize</span>(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">    bitcnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) bitcnt[i] = bitcnt[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    f.<span class="built_in">resize</span>(n, std::vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">1</span> &lt;&lt; n, <span class="number">0</span>));</span><br><span class="line">    g.<span class="built_in">resize</span>(n, std::vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">1</span> &lt;&lt; n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i][<span class="number">1</span> &lt;&lt; i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> S = <span class="number">1</span>; S &lt; (<span class="number">1</span> &lt;&lt; n); ++S)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (f[i][S])&#123;</span><br><span class="line">                g[bitcnt[S] - <span class="number">1</span>][S] += f[i][S];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v : E[i]) <span class="keyword">if</span> (!(S &gt;&gt; v &amp; <span class="number">1</span>)) f[v][S | (<span class="number">1</span> &lt;&lt; v)] += f[i][S];</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; n); ++S)</span><br><span class="line">                <span class="keyword">if</span> (S &gt;&gt; i &amp; <span class="number">1</span>) g[k][S] += g[k][S ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); ++S)&#123;</span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (S &gt;&gt; i &amp; <span class="number">1</span>) ++x; <span class="keyword">else</span> p.<span class="built_in">push_back</span>(x), x = <span class="number">1</span>;</span><br><span class="line">        p.<span class="built_in">push_back</span>(x);</span><br><span class="line">        std::<span class="built_in">sort</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">        part[p].<span class="built_in">push_back</span>(S);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">resize</span>(<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(n, std::vector&lt;<span class="keyword">int</span>&gt;(), std::vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">1</span> &lt;&lt; n, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); ++S)</span><br><span class="line">            <span class="keyword">if</span> (S &gt;&gt; i &amp; <span class="number">1</span>) ans[S ^ (<span class="number">1</span> &lt;&lt; i)] -= ans[S];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> v : ans) <span class="built_in">print</span>(v, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="g---spiderweb-trees">G - Spiderweb Trees</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1326/problem/G">题目传送门</a></p>
<p>tourist 都没过的题，鸽了鸽了。</p>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>manacher</tag>
        <tag>线段树</tag>
        <tag>递推</tag>
        <tag>meet in middle</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 84 (Rated for Div. 2) 自闭记</title>
    <url>/cf1327/</url>
    <content><![CDATA[<p>自闭了。</p>
<span id="more"></span>
<h2 id="a---sum-of-odd-integers">A - Sum of Odd Integers</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1327/problem/A">题目传送门</a></p>
<h3 id="题解">题解</h3>
<p>首先，我们尝试取出最小的 <span class="math inline">\(k\)</span> 个正奇数：<span class="math inline">\(1,3,5,7,\cdots,2k-1\)</span>。</p>
<p>这些奇数的和为 <span class="math inline">\(\frac{(1+2k-1)k}{2}=k^2\)</span>。</p>
<p>那么我们如何构造才能使得 <span class="math inline">\(k\)</span> 个奇数互不相同且和为 <span class="math inline">\(n\)</span> 呢？</p>
<p>只要不断将最大的奇数加 <span class="math inline">\(2\)</span> 即可。</p>
<p>所以当 <span class="math inline">\(n-k^2\)</span> 是大于等于 <span class="math inline">\(0\)</span> 的偶数时，一定能够构造出解。</p>
<p>而当 <span class="math inline">\(n &lt; k^2\)</span> 时，最小的 <span class="math inline">\(k\)</span> 个正奇数的和已经有 <span class="math inline">\(k^2\)</span>，那么一定不能构造出解。</p>
<p>当 <span class="math inline">\(n-k^2\)</span> 不为偶数时，由于任意 <span class="math inline">\(k\)</span> 个奇数一定可以通过最小的 <span class="math inline">\(k\)</span> 个正奇数中的数 <span class="math inline">\(+2,-2\)</span> 得到，所以任意 <span class="math inline">\(k\)</span> 个奇数的和一定与 <span class="math inline">\(k^2\)</span> 的奇偶性相同，而 <span class="math inline">\(n\)</span> 的奇偶性与 <span class="math inline">\(k^2\)</span> 不同，所以一定不能构造出解。</p>
<p>所以「<span class="math inline">\(n-k^2\)</span> 是大于等于 <span class="math inline">\(0\)</span> 的偶数」是能构造出解的充要条件。</p>
<p>注意计算 <span class="math inline">\(k^2\)</span> 时要开 <code>long long</code>。另外，<span class="math inline">\(k\)</span> 与 <span class="math inline">\(k^2\)</span> 的奇偶性一定是相同的，所以我们判断 <span class="math inline">\(n\)</span> 与 <span class="math inline">\(k^2\)</span> 的奇偶性是否相同只需要判断 <span class="math inline">\(n\)</span> 与 <span class="math inline">\(k\)</span> 的奇偶性是否相同。</p>
<h3 id="代码">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(k);</span><br><span class="line">    <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == (k &amp; <span class="number">1</span>) &amp;&amp; <span class="number">1ll</span> * k * k &lt;= n) <span class="built_in">prints</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">prints</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="b---princesses-and-princes">B - Princesses and Princes</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1327/problem/B">题目传送门</a></p>
<h3 id="题解-1">题解</h3>
<p>我这个彩笔又看错题了...</p>
<p>题目里说只要能够增加就行...而我以为要取增加最多的方案...</p>
<p>那么只要模拟一遍以后，如果存在一个没有匹配的公主，任选一个王子与她匹配即可。</p>
<p>如果需要「增加最多」，这样构造是否正确呢 QAQ</p>
<p>有没有神仙来证明一下或者给出一个反例啊 QAQ</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, vis[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; E[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        vis[i] = <span class="number">0</span>, E[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, k; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">read</span>(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>, x; j &lt; k; ++j)</span><br><span class="line">            <span class="built_in">read</span>(x), E[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> add_x = <span class="number">0</span>, add_y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)E[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            <span class="keyword">if</span> (!vis[E[i][j]])&#123; vis[E[i][j]] = <span class="number">1</span>, flag = <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag || add_x) <span class="keyword">continue</span>;</span><br><span class="line">        add_x = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!add_x) <span class="built_in">prints</span>(<span class="string">&quot;OPTIMAL&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        add_y = n;</span><br><span class="line">        <span class="keyword">while</span> (vis[add_y]) --add_y;</span><br><span class="line">        <span class="built_in">prints</span>(<span class="string">&quot;IMPROVE&quot;</span>), <span class="built_in">print</span>(add_x, <span class="string">&#x27; &#x27;</span>), <span class="built_in">print</span>(add_y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="c---game-with-chips">C - Game with Chips</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1327/problem/C">题目传送门</a></p>
<h3 id="题解-2">题解</h3>
<p>考场上的我甚至想过把坐标旋转 <span class="math inline">\(x,y\)</span> 独立等等奇怪的玩意。</p>
<p>在想这东西的时候，发现这东西是有边界的，而且到边界他就不会继续走了。</p>
<p>于是我不会了。</p>
<p>转念一想，既然可以走 <span class="math inline">\(2nm\)</span> 步，好像直接把所有点移到 <span class="math inline">\((1,1)\)</span>，然后把所有点走一遍就好了！</p>
<p>移到 <span class="math inline">\((1,1)\)</span> 需要 <span class="math inline">\(n+m-2\)</span> 步，遍历所有点需要 <span class="math inline">\(nm-1\)</span> 步，步数显然是不超过 <span class="math inline">\(2nm\)</span> 的。</p>
<p>代码里移动到 <span class="math inline">\((1,1)\)</span> 用了 <span class="math inline">\(n+m\)</span> 步。</p>
<h3 id="代码-2">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= k; ++i) <span class="built_in">read</span>(x), <span class="built_in">read</span>(y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= k; ++i) <span class="built_in">read</span>(x), <span class="built_in">read</span>(y);</span><br><span class="line">    <span class="built_in">print</span>(n + m + n * m - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">putchar</span>(<span class="string">&#x27;U&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">putchar</span>(<span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) <span class="built_in">putchar</span>(i &amp; <span class="number">1</span> ? <span class="string">&#x27;R&#x27;</span> : <span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) <span class="built_in">putchar</span>(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="d---infinite-path">D - Infinite Path</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1327/problem/D">题目传送门</a></p>
<h3 id="题解-3">题解</h3>
<p>首先看到一个排列求 <span class="math inline">\(k\)</span> 次幂，容易想到将排列看成若干置换环的形式。</p>
<p>如排列 <span class="math inline">\(p=\{2,4,1,3,6,5\}\)</span> 可以看成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 --&gt; 2</span><br><span class="line">^     |</span><br><span class="line">|     v</span><br><span class="line">3 &lt;-- 4</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 &lt;==&gt; 6</span><br></pre></td></tr></table></figure>
<p>两个置换环。</p>
<p>将一个排列求 <span class="math inline">\(k\)</span> 次幂以后，某个点 <span class="math inline">\(i\)</span> 会重新指向原来环上从 <span class="math inline">\(i\)</span> 开始第 <span class="math inline">\(k\)</span> 个点。</p>
<p>那么由于我们只需要一个环满足颜色相等，容易想到将每个环单独处理以后取 <span class="math inline">\(\min\)</span> 即可。</p>
<p>对于一个环长为 <span class="math inline">\(l\)</span> 的环，我们将环上的点从某个点开始重新标号。我们判断一个 <span class="math inline">\(k\)</span> 是否可行，只需要记 <span class="math inline">\(p=\gcd(k,l)\)</span>，我们判断是否存在一个 <span class="math inline">\(0\le t &lt; p\)</span> 使得环上所有模 <span class="math inline">\(p\)</span> 等于 <span class="math inline">\(t\)</span> 的点颜色是否相同即可。</p>
<p>那么显然只要枚举所有 <span class="math inline">\(l\)</span> 的因数 <span class="math inline">\(k\)</span> 即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\sqrt{n})\)</span>。</p>
<h3 id="代码-3">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> n, p[N], c[N], vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    <span class="keyword">int</span> l = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">1ll</span> * i * i &lt;= l; ++i) <span class="comment">// 求因数</span></span><br><span class="line">        <span class="keyword">if</span> (l % i == <span class="number">0</span>)&#123;</span><br><span class="line">            d.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i * i &lt; l) d.<span class="built_in">push_back</span>(l / i);</span><br><span class="line">        &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k : d)&#123; <span class="comment">// 枚举 k</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt; l; j += k)</span><br><span class="line">                flag &amp;= a[j] == a[i]; <span class="comment">// 判断颜色是否相同</span></span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(p[i]), vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])&#123;</span><br><span class="line">            std::vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(c[i]), vis[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = p[i]; j != i; j = p[j])</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(c[j]), vis[j] = <span class="number">1</span>;</span><br><span class="line">            ans = std::<span class="built_in">min</span>(ans, <span class="built_in">solve</span>(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">print</span>(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="e---count-the-blocks">E - Count The Blocks</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1327/problem/E">题目传送门</a></p>
<h3 id="题解-4">题解</h3>
<p>设答案为 <span class="math inline">\(g_i\)</span>，考虑计算出 <span class="math inline">\(f_i=\sum\limits_{j=i}^{n} (j-i+1)g_j\)</span>，根据 <span class="math inline">\(f_i\)</span> 的实际意义，显然有 <span class="math inline">\(f_i=(n-i+1)\times 10^{n-i+1}\)</span>。</p>
<p>根据容斥，可以得到 <span class="math inline">\(g_i=f_i-2f_{i-1}+f_{i-2}\)</span>。这个式子的正确性也可以将 <span class="math inline">\(f_i\)</span> 的定义式子代入证明。</p>
<h3 id="代码-4">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123; (a += b) &gt;= P ? a -= P : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123; a &lt; b ? a += P - b : a -= b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">int</span> pw = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i)&#123;</span><br><span class="line">        f[i] = <span class="number">1ll</span> * pw * (n - i + <span class="number">1</span>) % P;</span><br><span class="line">        pw = <span class="number">10ll</span> * pw % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">dec</span>(f[i], f[i + <span class="number">1</span>]), <span class="built_in">dec</span>(f[i], f[i + <span class="number">1</span>]), <span class="built_in">inc</span>(f[i], f[i + <span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">print</span>(f[i], <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="f---and-segments">F - AND Segments</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1327/problem/F">题目传送门</a></p>
<h3 id="题解-5">题解</h3>
<p>不错，最后 5min 开始写代码，没调出来，直接死在这题上了。</p>
<hr />
<p>上面是一个菜鸡 xjb BB，不要管他。</p>
<p>首先看到这题，一看是位运算，先考虑每位是否独立。</p>
<p>因为只有 and 运算的限制，所以很显然每一位是独立的。那么我们只需要求出每一位满足限制的方案数，然后乘起来即可。</p>
<p>对于当前位，有若干个限制，每个限制规定了一个区间的 and 和是 <span class="math inline">\(0\)</span> 还是 <span class="math inline">\(1\)</span>。</p>
<p>对于限制为 <span class="math inline">\(1\)</span> 的区间，直接强制每一位必须填 <span class="math inline">\(1\)</span>。而对于限制为 <span class="math inline">\(0\)</span> 的区间，看上去非常难搞。</p>
<p>一开始我以为可以容斥，但是若干区间取并这玩意非常难处理。</p>
<p>突然想到了联赛前的一道作业题：<a href="https://www.luogu.com.cn/problem/P4229">P4229 某位歌姬的故事</a>。</p>
<p>那题由于需要离散，并且限制比较宽，所以 DP 是 <span class="math inline">\(O(nq)\)</span> 的。</p>
<p>然而这题不需要离散，并且只有 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span>，所以我们尝试去优化这个 DP。</p>
<p>预处理 <span class="math inline">\(\operatorname{pos}[i]\)</span> 表示 <span class="math inline">\(i\)</span> 之前（不包括 <span class="math inline">\(i\)</span>）第一个 <span class="math inline">\(0\)</span> 至少填在 <span class="math inline">\(\operatorname{pos}[i]\)</span> 位置。这个预处理可以参考 P4229 中的预处理。</p>
<p>考虑 DP，<span class="math inline">\(f[i][j]\)</span> 表示前 <span class="math inline">\(i\)</span> 位，最后一个 <span class="math inline">\(0\)</span> 的位置为 <span class="math inline">\(j\)</span> 时满足限制的方案数。分三种情况进行转移：</p>
<ul>
<li><span class="math inline">\(j&lt;\operatorname{pos}[i]\)</span> 时，有 <span class="math inline">\(f[i][j]=0\)</span>；</li>
<li><span class="math inline">\(\operatorname{pos}[i]\le j &lt; i\)</span> 时，有 <span class="math inline">\(f[i][j]=f[i-1][j]\)</span>；</li>
<li><span class="math inline">\(j=i\)</span> 时，若根据 <span class="math inline">\(1\)</span> 的限制，第 <span class="math inline">\(i\)</span> 位强制选 <span class="math inline">\(1\)</span>，那么 <span class="math inline">\(f[i][j]=0\)</span>；否则 <span class="math inline">\(f[i][j]=\sum\limits_{k=\operatorname{pos}[i]}^{i-1} f[i-1][k]\)</span>。</li>
</ul>
<p>对于第一种情况，我们只需要维护一个最左边不为 <span class="math inline">\(0\)</span> 的指针，每次把 <span class="math inline">\(&lt; \operatorname{pos}[i]\)</span> 的位置刷成 <span class="math inline">\(0\)</span> 即可。</p>
<p>对于第二种情况，由于没有任何改变，所以我们不需要进行任何处理。</p>
<p>对于第三种情况，我们只要单点修改第 <span class="math inline">\(i\)</span> 个位置的值即可。注意需要实时维护当前行的和。</p>
<p>于是这个 DP 的复杂度变成了 <span class="math inline">\(O(n)\)</span>。</p>
<p>每一位预处理复杂度为 <span class="math inline">\(O(m)\)</span>，所以总时间复杂度 <span class="math inline">\(O(k(n+m))\)</span>。</p>
<hr />
<p>我的做法好像比官方题解的做法复杂一万倍。</p>
<p>另：这题跟绍一新生考试的 F 好像差不多...</p>
<h3 id="代码-5">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500005</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, m, a[N], l[N], r[N], x[N], f[N], pos[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123; (a += b) &gt;= P ? a -= P : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123; a &lt; b ? a += P - b : a -= b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(k), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">read</span>(l[i]), <span class="built_in">read</span>(r[i]), ++r[i], <span class="built_in">read</span>(x[i]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> p = <span class="number">0</span>; p &lt; k; ++p)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) pos[i] = <span class="number">0</span>, a[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">if</span> (x[i] &gt;&gt; p &amp; <span class="number">1</span>) ++a[l[i]], --a[r[i]]; <span class="comment">// 差分实现区间加</span></span><br><span class="line">            <span class="keyword">else</span> pos[r[i]] = std::<span class="built_in">max</span>(pos[r[i]], l[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + <span class="number">1</span>; ++i) a[i] += a[i - <span class="number">1</span>], pos[i] = std::<span class="built_in">max</span>(pos[i], pos[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// a 预处理第 i 位是否强制选 1</span></span><br><span class="line">        <span class="comment">// pos 预处理 i 之前第一个 0 至少选在哪里</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; ++i) f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; pos[i]) <span class="built_in">dec</span>(sum, f[l]), f[l] = <span class="number">0</span>, ++l; <span class="comment">// 把 &lt; pos[i] 的位置刷成 0</span></span><br><span class="line">            f[i] = a[i] ? <span class="number">0</span> : sum, <span class="built_in">inc</span>(sum, f[i]); <span class="comment">// 修改第 i 个位置的 dp 值</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">1ll</span> * ans * f[n + <span class="number">1</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="g---letters-and-question-marks">G - Letters and Question Marks</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1327/problem/G">题目传送门</a></p>
<h3 id="题解-6">题解</h3>
<p>事实上这个题还是非常简单的。（别问我为什么现场没过</p>
<p>首先可以对所有模式串建个 AC 自动机，每个点的权值就是这个点在 <span class="math inline">\(fail\)</span> 树上到根路径上所有点对应的字符串的权值和。</p>
<p>如果字符串 <span class="math inline">\(s\)</span> 已经全部确定，那么我们只要把 <span class="math inline">\(s\)</span> 在这个自动机上跑一遍，把经过节点的点权累加即可。</p>
<p>但是现在 <span class="math inline">\(s\)</span> 有若干个字符不确定。我们考虑对于 <span class="math inline">\(s\)</span> 的每段确定的极大子串，以及 AC 自动机上的点 <span class="math inline">\(u\)</span>，预处理从 <span class="math inline">\(u\)</span> 开始，按照这段子串跑，最终跑到的点以及沿路经过的点权和。</p>
<p>然后我们就可以 DP 了。记 <span class="math inline">\(f_{S,u}\)</span> 表示当前问号的位置用了 <span class="math inline">\(S\)</span> 这些字符，跑到自动机上的节点 <span class="math inline">\(u\)</span> 时，最大的权值和。</p>
<p>转移只需要枚举下一个问号填的字符即可。</p>
<p>记 <span class="math inline">\(n\)</span> 为字符串 <span class="math inline">\(s\)</span> 的长度，<span class="math inline">\(m\)</span> 为模式串的长度之和，<span class="math inline">\(c\)</span> 为字符集大小，则复杂度为 <span class="math inline">\(O(nm+2^cmc)\)</span>，可以通过本题。</p>
<h3 id="代码-6">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>, C = <span class="number">14</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> t[N], s[<span class="number">400005</span>];</span><br><span class="line">std::pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; go[N][C + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> bitcnt[<span class="number">1</span> &lt;&lt; C];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">1</span> &lt;&lt; C][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC_Automaton</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> rt, cnt, trans[N][C], fail[N];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> w[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">new_node</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = cnt++;</span><br><span class="line">        w[u] = <span class="number">0</span>, fail[u] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; ++i) trans[u][i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cnt = <span class="number">0</span>, rt = <span class="built_in">new_node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt; &amp;s, <span class="keyword">long</span> <span class="keyword">long</span> _w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = rt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (trans[u][s[i]] == <span class="number">-1</span>) trans[u][s[i]] = <span class="built_in">new_node</span>();</span><br><span class="line">            u = trans[u][s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        w[u] += _w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        fail[rt] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; ++i)</span><br><span class="line">            <span class="keyword">if</span> (~trans[rt][i]) Q.<span class="built_in">push_back</span>(trans[rt][i]), fail[trans[rt][i]] = rt;</span><br><span class="line">            <span class="keyword">else</span> trans[rt][i] = rt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)Q.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q[i];</span><br><span class="line">            w[u] += w[fail[u]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j)</span><br><span class="line">                <span class="keyword">if</span> (~trans[u][j]) Q.<span class="built_in">push_back</span>(trans[u][j]), fail[trans[u][j]] = trans[fail[u]][j];</span><br><span class="line">                <span class="keyword">else</span> trans[u][j] = trans[fail[u]][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">run</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt; &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            u = trans[u][s[i]], sum += w[u];</span><br><span class="line">        <span class="keyword">return</span> &#123;u, sum&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AT_HOME</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;test.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;test.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    A.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">reads</span>(t), w;</span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">read</span>(w);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) tmp.<span class="built_in">push_back</span>(t[j] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        A.<span class="built_in">insert</span>(tmp, w);</span><br><span class="line">    &#125;</span><br><span class="line">    A.<span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">reads</span>(s);</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i == len || s[i] == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A.cnt; ++j)</span><br><span class="line">                go[j][cnt] = A.<span class="built_in">run</span>(j, tmp);</span><br><span class="line">            tmp.<span class="built_in">clear</span>(), ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> tmp.<span class="built_in">push_back</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    bitcnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; C); ++i)</span><br><span class="line">        bitcnt[i] = bitcnt[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; C); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A.cnt; ++j)</span><br><span class="line">            f[i][j] = -INF;</span><br><span class="line">    f[<span class="number">0</span>][go[A.rt][<span class="number">0</span>].first] = go[A.rt][<span class="number">0</span>].second;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; C); ++S)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = bitcnt[S] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == cnt)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> u = <span class="number">0</span>; u &lt; A.cnt; ++u)</span><br><span class="line">                ans = std::<span class="built_in">max</span>(ans, f[S][u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= cnt) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> u = <span class="number">0</span>; u &lt; A.cnt; ++u)</span><br><span class="line">            <span class="keyword">if</span> (f[S][u] != -INF)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; ++i)</span><br><span class="line">                    <span class="keyword">if</span> (!(S &gt;&gt; i &amp; <span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="keyword">int</span> v = A.trans[u][i];</span><br><span class="line">                        <span class="keyword">int</span> S_ = S | (<span class="number">1</span> &lt;&lt; i), u_ = go[v][k].first;</span><br><span class="line">                        f[S_][u_] = std::<span class="built_in">max</span>(f[S_][u_], f[S][u] + A.w[v] + go[v][k].second);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我还是太菜了 /kk</p>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>容斥</tag>
        <tag>模拟</tag>
        <tag>状压DP</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #632 (Div. 2) 裂开记</title>
    <url>/cf1333/</url>
    <content><![CDATA[<p>打得非常裂开，被 D 续了半年。</p>
<span id="more"></span>
<h2 id="a---little-artem">A - Little Artem</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1333/problem/A">题目传送门</a></p>
<h3 id="题解">题解</h3>
<p>首先我们考虑将所有格子填上黑色，此时 <span class="math inline">\(B=W=0\)</span>。</p>
<p>我们尝试将一个格子变成白色，可以发现将一个格子变成白色会使得 <span class="math inline">\(W\)</span> 变成 <span class="math inline">\(1\)</span>，<span class="math inline">\(B\)</span> 变成这个格子上下左右的黑色格子数量。</p>
<p>我们的目标是使得 <span class="math inline">\(B=2,W=1\)</span>，那么我们只要选择角落上的格子变成白色即可。</p>
<h3 id="代码">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == n &amp;&amp; j == m) &#123;</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">&#x27;W&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="b---kind-anton">B - Kind Anton</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1333/problem/B">题目传送门</a></p>
<h3 id="题解-1">题解</h3>
<p>考虑从后往前依次将 <span class="math inline">\(a_i\)</span> 变成 <span class="math inline">\(b_i\)</span>。</p>
<p>考虑对于当前位置 <span class="math inline">\(i\)</span>，若 <span class="math inline">\(b_i &lt; a_i\)</span>（即需要变小），那么显然只需要存在一个 <span class="math inline">\(j\)</span> 满足 <span class="math inline">\(j &lt; i\)</span> 且 <span class="math inline">\(a_j=-1\)</span> 就可以不断将 <span class="math inline">\(a_i\)</span> 减 <span class="math inline">\(1\)</span> 直到等于 <span class="math inline">\(b_i\)</span>；同理，若 <span class="math inline">\(b_i &gt; a_i\)</span>（即需要变大），那么只需要存在一个 <span class="math inline">\(j\)</span> 满足 <span class="math inline">\(j &lt; i\)</span> 且 <span class="math inline">\(a_j=1\)</span> 就可以不断将 <span class="math inline">\(a_i\)</span> 加 <span class="math inline">\(1\)</span> 直到等于 <span class="math inline">\(b_i\)</span>。</p>
<p>那么我们只需要从左往右找到第一个 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(-1\)</span> 然后进行判断即可。</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">1</span>, p2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= n &amp;&amp; a[p1] &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[p1] &lt; b[p1]) &#123;</span><br><span class="line">            <span class="built_in">printStr</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 &lt;= n &amp;&amp; a[p1] &lt; b[p1]) &#123;</span><br><span class="line">        <span class="built_in">printStr</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= n &amp;&amp; a[p2] &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[p2] &gt; b[p2]) &#123;</span><br><span class="line">            <span class="built_in">printStr</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2 &lt;= n &amp;&amp; a[p2] &gt; b[p2]) &#123;</span><br><span class="line">        <span class="built_in">printStr</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printStr</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="c---eugene-and-an-array">C - Eugene and an array</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1333/problem/C">题目传送门</a></p>
<h3 id="题解-2">题解</h3>
<p>不知道为什么 CF 的评论里有很多人说这题很难，感觉好像就是个套路题？</p>
<p>首先考虑求出 <span class="math inline">\(a_i\)</span> 的前缀和 <span class="math inline">\(b_i=\sum\limits_{j=1}^{i} a_j\)</span>，那么一个区间 <span class="math inline">\((l,r]\)</span> 合法当且仅当不存在 <span class="math inline">\(l\le j &lt; i\le r\)</span> 使得 <span class="math inline">\(b_i=b_j\)</span>。</p>
<p>考虑对于一个 <span class="math inline">\(b_i\)</span>，求出上一个与 <span class="math inline">\(b_i\)</span> 相同的位置 <span class="math inline">\(lst_i\)</span>，即 <span class="math display">\[lst_i=\max\{j\ |\ j&lt;i,b_j=b_i\}\]</span></p>
<p>不存在则 <span class="math inline">\(lst_i=-1\)</span>。</p>
<p>那么区间 <span class="math inline">\((l,r]\)</span> 合法的条件变为对于所有 <span class="math inline">\(0\le i\le n\)</span>，满足 <span class="math inline">\(l &gt; lst_i\)</span> 或 <span class="math inline">\(r &lt; i\)</span>。</p>
<p>那么我们只要从左往右枚举 <span class="math inline">\(r\)</span>，那么 <span class="math inline">\(l\)</span> 需要大于 <span class="math inline">\(\max\{lst_j\ |\ j \le r\}\)</span>，直接在枚举的同时维护 <span class="math inline">\(lst\)</span> 数组的前缀 <span class="math inline">\(\max\)</span> 即可。</p>
<h3 id="代码-2">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, lst[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[N];</span><br><span class="line">std::map&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123; <span class="comment">// 用 std::map 计算 lst 数组</span></span><br><span class="line">        <span class="keyword">if</span> (!M.<span class="built_in">count</span>(a[i])) &#123;</span><br><span class="line">            lst[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lst[i] = M[a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        M[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        mx = std::<span class="built_in">max</span>(mx, lst[i]);</span><br><span class="line">        ans += i - mx - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="d---challenges-in-school-41">D - Challenges in school №41</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1333/problem/D">题目传送门</a></p>
<h3 id="题解-3">题解</h3>
<p>考场上的我不知道在干什么...</p>
<p>首先我们把 <span class="math inline">\(\mathtt{R}\)</span> 看成 <span class="math inline">\(1\)</span>，<span class="math inline">\(\mathtt{L}\)</span> 看成 <span class="math inline">\(0\)</span>，那么交换轮数的上界为逆序对数。如果 <span class="math inline">\(k\)</span> 大于逆序对数，那一定无解。</p>
<p>然后我们考虑求出交换轮数的下界并求出一组解。</p>
<p>由于总交换次数固定，为逆序对数，那么我们只要每一轮贪心地将可以交换的相邻的数对交换即可。</p>
<p>考场上并没有过多的时间证明交换轮数下界的级别，所以代码中我直接使用了 <span class="math inline">\(\mathtt{set}\)</span> 来快速找到所有需要交换的数对。</p>
<p>在求出达到下界的这一组解后，若 <span class="math inline">\(k\)</span> 大于这个下界，我们只需要将同一轮中的若干次交换拆成若干轮，直到轮数搞好为 <span class="math inline">\(k\)</span> 即可。</p>
<p>由于我使用了 <span class="math inline">\(\mathtt{set}\)</span>，所以复杂度是 <span class="math inline">\(O(n^2\log n)\)</span> 的，可以通过此题。</p>
<hr />
<p>另外，可以证明下界一定是 <span class="math inline">\(O(n)\)</span> 级别的（根据官方题解的下界求法），所以直接每次暴力找可以交换的数对，时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="代码-3">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, a[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">std::set&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; move;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(k), <span class="built_in">readStr</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = (s[i] == <span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> || a[i] != a[i - <span class="number">1</span>]) S.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    S.<span class="built_in">insert</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[x] || x == <span class="number">1</span>) &#123;</span><br><span class="line">                x = *S.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p.<span class="built_in">push_back</span>(x - <span class="number">1</span>);</span><br><span class="line">            std::<span class="built_in">swap</span>(a[x], a[x - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> tmp = *S.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">2</span> &amp;&amp; !a[x - <span class="number">2</span>]) &#123;</span><br><span class="line">                S.<span class="built_in">erase</span>(x - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                S.<span class="built_in">insert</span>(x - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!a[x + <span class="number">1</span>]) &#123;</span><br><span class="line">                S.<span class="built_in">insert</span>(x + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            x = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : p) &#123;</span><br><span class="line">            move.<span class="built_in">push_back</span>(&#123;v, cnt&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; cnt || k &gt; (<span class="keyword">int</span>)move.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)move.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        move[i].second -= move[i - <span class="number">1</span>].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)move.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (move[i].second) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == k) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        move[i].second = <span class="number">1</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(k);</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : move) &#123;</span><br><span class="line">        now += p.second;</span><br><span class="line">        <span class="comment">// debug(&quot;%d %d\n&quot;, p.first, p.second);</span></span><br><span class="line">        ans[now - <span class="number">1</span>].<span class="built_in">push_back</span>(p.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : ans) &#123;</span><br><span class="line">        <span class="built_in">print</span>((<span class="keyword">int</span>)p.<span class="built_in">size</span>(), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : p) &#123;</span><br><span class="line">            <span class="built_in">print</span>(v, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="e---road-to-1600">E - Road to 1600</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1333/problem/E">题目传送门</a></p>
<h3 id="题解-4">题解</h3>
<p>直接考虑一个很大的棋盘看上去非常难做。我们考虑首先将车和后延一条固定的、相同的路径引导至一个较小的棋盘内。</p>
<p>考虑到 <span class="math inline">\(n\le 2\)</span> 时一定无解，我们只要将最后的棋盘控制在 <span class="math inline">\(3\times 3\)</span> 的规模即可。</p>
<p>如何构造一个满足题目条件的 <span class="math inline">\(3\times 3\)</span> 的棋盘？</p>
<p>一共只有 <span class="math inline">\(3\times 3=9\)</span> 个数，我们可以直接暴力枚举所有棋盘！</p>
<p>注意这个棋盘的最小值所在的格子必须与路径的终点在同一行或同一列，这样才可以保证车和后在这个棋盘中的起点相同。</p>
<h3 id="暴力代码">暴力代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">5</span>], p[<span class="number">15</span>], vis[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">rook</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x1 == x2 || y1 == y2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queen</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x1 == x2 || y1 == y2 || x1 + y1 == x2 + y2 || x1 - y1 == x2 - y2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(T check)</span> </span>&#123; <span class="comment">// check 是一个判断两点是否可以互相到达的函数（上方 rook 和 queen 中的一种）</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                x = i, y = j;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> nx = <span class="number">0</span>, ny = <span class="number">0</span>, mn = <span class="number">10</span>, type = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tp = !<span class="built_in">check</span>(x, y, i, j);</span><br><span class="line">                    <span class="keyword">if</span> (tp &lt; type || (tp == type &amp;&amp; a[i][j] &lt; mn)) &#123;</span><br><span class="line">                        nx = i, ny = j, mn = a[i][j], type = tp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += type, x = nx, y = ny, vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                a[i][j] = p[(i - <span class="number">1</span>) * <span class="number">3</span> + j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">work</span>(rook) &lt; <span class="built_in">work</span>(queen)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">                <span class="built_in">print</span>(p[i], <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!std::<span class="built_in">next_permutation</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + <span class="number">9</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码-4">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> B = n * n - <span class="number">9</span>;</span><br><span class="line">    a[<span class="number">1</span>][<span class="number">1</span>] = B + <span class="number">1</span>, a[<span class="number">1</span>][<span class="number">2</span>] = B + <span class="number">2</span>, a[<span class="number">1</span>][<span class="number">3</span>] = B + <span class="number">4</span>;</span><br><span class="line">    a[<span class="number">2</span>][<span class="number">1</span>] = B + <span class="number">5</span>, a[<span class="number">2</span>][<span class="number">2</span>] = B + <span class="number">3</span>, a[<span class="number">2</span>][<span class="number">3</span>] = B + <span class="number">8</span>;</span><br><span class="line">    a[<span class="number">3</span>][<span class="number">1</span>] = B + <span class="number">9</span>, a[<span class="number">3</span>][<span class="number">2</span>] = B + <span class="number">6</span>, a[<span class="number">3</span>][<span class="number">3</span>] = B + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                a[i][j] = ++now;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j; --j) &#123;</span><br><span class="line">                a[j][i] = ++now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                a[j][i] = ++now;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j; --j) &#123;</span><br><span class="line">                a[i][j] = ++now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">print</span>(a[i][j], <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="f---kate-and-imperfection">F - Kate and imperfection</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1333/problem/F">题目传送门</a></p>
<h3 id="题解-5">题解</h3>
<p>考虑依次求出 <span class="math inline">\(I_2,I_3,\cdots,I_n\)</span>。</p>
<p>开始时集合大小为 <span class="math inline">\(1\)</span>，我们强制集合中只包含 <span class="math inline">\(1\)</span>。我们贪心地往集合内加入元素。</p>
<p>由于我们需要使集合中两两 <span class="math inline">\(\gcd\)</span> 的最大值最小，一开始我们一定是考虑依次加入所有质数。</p>
<p>加入完所有质数后，我们不可能再保证答案为 <span class="math inline">\(1\)</span>，我们考虑放宽限制，使得两两 <span class="math inline">\(\gcd\)</span> 的最大值为 <span class="math inline">\(2\)</span>。</p>
<p>显然，我们可以加入 <span class="math inline">\(4=2\times 2\)</span>，但不可以加入 <span class="math inline">\(6=2\times 3,8=2\times 4,\cdots\)</span>。</p>
<p>然后我们考虑使得最大值为 <span class="math inline">\(3\)</span>，那么我们可以加入 <span class="math inline">\(6=2\times 3,9=3\times 3\)</span>，但不能加入 <span class="math inline">\(12=4\times 3,\cdots\)</span>。</p>
<p>接下来考虑使得最大值为 <span class="math inline">\(4\)</span>，我们可以加入 <span class="math inline">\(8=2\times 4\)</span>，可是我们不能加入 <span class="math inline">\(12=3\times 4\)</span>，因为之前已经加入了 <span class="math inline">\(6\)</span>。</p>
<p>那么什么时候可以加入 <span class="math inline">\(12\)</span>？在我们枚举最大值为 <span class="math inline">\(6\)</span> 时才可以加入 <span class="math inline">\(12\)</span>。</p>
<p>再往后模拟若干次，大胆猜想，一个数 <span class="math inline">\(x\)</span> 会在枚举最大值为 <span class="math inline">\(x\)</span> 的最大真因子（即不等于本身的因子）时被加入集合。</p>
<p>直接使用欧拉筛求出 <span class="math inline">\(2\)</span> 到 <span class="math inline">\(n\)</span> 每个数的最大真因子即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p>（做题全靠猜结论.jpg）</p>
<hr />
<p>上述做法的正确性可以参考官方题解。</p>
<h3 id="代码-5">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c[N];</span><br><span class="line"><span class="keyword">int</span> cnt, p[N], vis[N], minp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            p[++cnt] = i;</span><br><span class="line">            minp[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="number">1ll</span> * p[j] * i &lt;= n; ++j) &#123;</span><br><span class="line">            vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            minp[i * p[j]] = p[j];</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ++c[i / minp[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c[i]; ++j) &#123;</span><br><span class="line">            <span class="built_in">print</span>(i, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1214G」Feeling Good</title>
    <url>/cf1214g-sol/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1214/problem/G">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>有一个 <span class="math inline">\(n\times m\)</span> 的黑白矩阵，初始时是全白的。有 <span class="math inline">\(q\)</span> 次操作，每次操作形如 <span class="math inline">\(a_i,l_i,r_i\)</span>，表示把 <span class="math inline">\(a_i\)</span> 行的 <span class="math inline">\(l_i\)</span> 列到 <span class="math inline">\(r_i\)</span> 列的格子反转颜色。</p>
<p>每次操作后，你要找出 <span class="math inline">\(x_1,y_1,x_2,y_2\)</span>，满足 <span class="math inline">\(x_1 &lt; x_2,y_1 &lt; y_2, col(x_1,y_1)=col(x_2,y_2),col(x_1,y_2)=col(x_2,y_1),col(x_1,y_1)\ne col(x_1,y_2)\)</span>。若不存在则输出 <span class="math inline">\(-1\)</span>。</p>
<p><span class="math inline">\(n,m\le 2000,q\le 5\times 10^5\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>考虑如何判断是否有解。</p>
<p>记 <span class="math inline">\(S_i=\{j\mid col(i,j)=\text{black}\}\)</span>。对于固定的两行 <span class="math inline">\(x_1,x_2\)</span>，有解的条件是 <span class="math inline">\(S_{x_1}\)</span> 不是 <span class="math inline">\(S_{x_2}\)</span> 的子集且 <span class="math inline">\(S_{x_2}\)</span> 不是 <span class="math inline">\(S_{x_1}\)</span> 的子集。</p>
<p>我们把这些集合按大小从小到大排序，若 <span class="math inline">\(S_1\subseteq S_2\subseteq S_3\subseteq\cdots\subseteq S_n\)</span>，则一定无解，否则一定存在一个 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(S_{i}\)</span> 不是 <span class="math inline">\(S_{i+1}\)</span> 的子集，又因为是按集合大小从小到大排序的，<span class="math inline">\(S_{i+1}\)</span> 也一定不是 <span class="math inline">\(S_i\)</span> 的子集，那么这两行就是满足条件的。</p>
<p>然后考虑求出一组解，我们只要把所有满足条件的 <span class="math inline">\(i\)</span> 都记下来。对于两个集合 <span class="math inline">\(S_{i},S_{i+1}\)</span>，其中一个 <span class="math inline">\(y\)</span> 一定是在 <span class="math inline">\(S_{i}\)</span> 中是黑色的但在 <span class="math inline">\(S_{i+1}\)</span> 中是白色的，另一个 <span class="math inline">\(y\)</span> 反之。</p>
<p>用 bitset 维护这些集合，然后用位运算和 <code>_Find_First</code> 函数即可求出 <span class="math inline">\(y_1,y_2\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(q(\frac{m}{w}+\log n))\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = <span class="built_in">getchar</span>(), f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2005</span></span><br><span class="line"><span class="keyword">int</span> n, m, q, x1, _y1, x2, _y2;</span><br><span class="line">std :: bitset&lt;N&gt; a[N], nw[N], tmp;</span><br><span class="line">std :: set&lt; std :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; S, ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a[i] &amp; a[j]) != a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(std :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(p.first, p.second)) ans.<span class="built_in">insert</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(std :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(p.first, p.second)) ans.<span class="built_in">erase</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(std :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nx, i, pr;</span><br><span class="line">    <span class="keyword">auto</span> it = S.<span class="built_in">lower_bound</span>(x), tmp = it;</span><br><span class="line">    i = x.second, nx = (++tmp) -&gt; second, pr = (--it) -&gt; second;</span><br><span class="line">    <span class="built_in">del</span>(std :: <span class="built_in">make_pair</span>(pr, i)), <span class="built_in">del</span>(std :: <span class="built_in">make_pair</span>(i, nx)), <span class="built_in">add</span>(std :: <span class="built_in">make_pair</span>(pr, nx));</span><br><span class="line">    S.<span class="built_in">erase</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(std :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nx, i, pr;</span><br><span class="line">    <span class="keyword">auto</span> it = S.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">    i=  x.second, nx = it -&gt; second, pr = (--it) -&gt; second;</span><br><span class="line">    <span class="built_in">add</span>(std :: <span class="built_in">make_pair</span>(pr, i)), <span class="built_in">add</span>(std :: <span class="built_in">make_pair</span>(i, nx)), <span class="built_in">del</span>(std :: <span class="built_in">make_pair</span>(pr, nx));</span><br><span class="line">    S.<span class="built_in">insert</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    nw[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) nw[i] = nw[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span> | nw[<span class="number">1</span>];</span><br><span class="line">    a[n + <span class="number">1</span>] = nw[m], S.<span class="built_in">insert</span>(std :: <span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) S.<span class="built_in">insert</span>(std :: <span class="built_in">make_pair</span>(<span class="number">0</span>, i));</span><br><span class="line">    S.<span class="built_in">insert</span>(std :: <span class="built_in">make_pair</span>(m, n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">read</span>(), l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">Erase</span>(std :: <span class="built_in">make_pair</span>(a[k].<span class="built_in">count</span>(), k));</span><br><span class="line">        a[k] ^= nw[r - l + <span class="number">1</span>] &lt;&lt; (l - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Insert</span>(std :: <span class="built_in">make_pair</span>(a[k].<span class="built_in">count</span>(), k));</span><br><span class="line">        <span class="keyword">if</span> (ans.<span class="built_in">empty</span>()) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            x1 = ans.<span class="built_in">begin</span>() -&gt; first, x2 = ans.<span class="built_in">begin</span>() -&gt; second;</span><br><span class="line">            _y1 = ((a[x1] ^ a[x2]) &amp; a[x1])._Find_first(), _y2 = ((a[x1] ^ a[x2]) &amp; a[x2])._Find_first();</span><br><span class="line">            <span class="keyword">if</span> (x1 &gt; x2) std :: <span class="built_in">swap</span>(x1, x2);</span><br><span class="line">            <span class="keyword">if</span> (_y1 &gt; _y2) std :: <span class="built_in">swap</span>(_y1, _y2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, x1, _y1 + <span class="number">1</span>, x2, _y2 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #630 (Div. 2) 被爆踩记</title>
    <url>/cf1332/</url>
    <content><![CDATA[<p>被神仙 Froggy 爆踩了。</p>
<span id="more"></span>
<h2 id="a---exercising-walk">A - Exercising Walk</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1332/problem/A">题目传送门</a></p>
<h3 id="题意">题意</h3>
<p>在二维平面上有一个矩形 <span class="math inline">\((x_1,y_1),(x_2,y_2)\)</span>，你初始在 <span class="math inline">\((x,y)\)</span>。你被强制规定往左、右、上、下四个方向分别走恰好 <span class="math inline">\(a,b,c,d\)</span> 步。</p>
<p>你可以任意调整走的顺序。判断是否可以不走出这个矩形。</p>
<p><span class="math inline">\(0\le a,b,c,d\le 10^8,-10^8\le x_1\le x\le x_2\le 10^8,-10^8\le y_1\le y\le y_2\le 10^8\)</span>。</p>
<h3 id="题解">题解</h3>
<p>如果 <span class="math inline">\(a+b \ge 1\)</span> 且 <span class="math inline">\(x_1=x=x_2\)</span>，那么一定不合法。纵坐标同理。</p>
<p>首先因为走的步数是强制规定的，所以我们可以得到终点 <span class="math inline">\((x_t,y_t)\)</span>。</p>
<p>我们考虑先在原地不断左右来回走，把 <span class="math inline">\(a,b\)</span> 抵消成只剩一个。然后直接沿着剩下那个的方向走完即可。纵坐标同理。</p>
<p>可以发现，这样走一定能始终保持在 <span class="math inline">\((x,y)\)</span> 和 <span class="math inline">\((x_t,y_t)\)</span> 形成的矩形内。</p>
<p>那么我们只要判断 <span class="math inline">\((x_t,y_t)\)</span> 是否在 <span class="math inline">\((x_1,y_1),(x_2,y_2)\)</span> 这个矩形内即可。</p>
<h3 id="代码">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c, d, x, y, x1, y1, x2, y2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(a), <span class="built_in">read</span>(b), <span class="built_in">read</span>(c), <span class="built_in">read</span>(d);</span><br><span class="line">    <span class="built_in">read</span>(x), <span class="built_in">read</span>(y), <span class="built_in">read</span>(x1), <span class="built_in">read</span>(y1), <span class="built_in">read</span>(x2), <span class="built_in">read</span>(y2);</span><br><span class="line">    <span class="keyword">if</span> ((a || b) &amp;&amp; x1 == x2) <span class="keyword">return</span> <span class="built_in">prints</span>(<span class="string">&quot;No&quot;</span>), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((c || d) &amp;&amp; y1 == y2) <span class="keyword">return</span> <span class="built_in">prints</span>(<span class="string">&quot;No&quot;</span>), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">    x = x + b - a, y = y + d - c;</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt;= x &amp;&amp; x &lt;= x2 &amp;&amp; y1 &lt;= y &amp;&amp; y &lt;= y2) <span class="keyword">return</span> <span class="built_in">prints</span>(<span class="string">&quot;Yes&quot;</span>), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">prints</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="b---composite-coloring">B - Composite Coloring</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1332/problem/B">题目传送门</a></p>
<h3 id="题意-1">题意</h3>
<p>有 <span class="math inline">\(n\)</span> 个大于 <span class="math inline">\(1\)</span> 的合数 <span class="math inline">\(a_i\)</span>，你需要给每个数一个颜色 <span class="math inline">\(c_i\)</span>，使得对于任意颜色相同的点对 <span class="math inline">\(i,j\ (i\ne j)\)</span>，满足 <span class="math inline">\(\gcd(a_i,a_j) &gt; 1\)</span>。</p>
<p>你不需要最小化颜色数，但是你需要保证颜色数不超过 <span class="math inline">\(11\)</span>，并且每种颜色都出现。</p>
<p><span class="math inline">\(1\le n\le 1000,4\le a_i\le 1000\)</span>。</p>
<h3 id="题解-1">题解</h3>
<p>我这个憨批一直把 <span class="math inline">\(\sqrt{1000}\)</span> 当作 <span class="math inline">\(300\)</span> 左右在算...我也不知道我在想什么...</p>
<p>事实上，<span class="math inline">\(\lfloor\sqrt{1000}\rfloor=31\)</span>，这意味着任意 <span class="math inline">\(a_i\)</span> 都含有一个不超过 <span class="math inline">\(31\)</span> 的质因子。</p>
<p>而 <span class="math inline">\(31\)</span> 以内的质数只有 <span class="math inline">\(11\)</span> 个，分别是 <span class="math inline">\(2,3,5,7,11,13,17,19,23,29,31\)</span>。</p>
<p>直接求出每个数的最小质因子 <span class="math inline">\(p_i\)</span> 后，把 <span class="math inline">\(p_i\)</span> 相同的数颜色染成相同即可。</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n, c[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; b[<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; ++i) b[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span> (x % p[j] == <span class="number">0</span>)&#123; b[j].<span class="built_in">push_back</span>(i); <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (b[i].<span class="built_in">size</span>())&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v : b[i]) c[v] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">print</span>(cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">print</span>(c[i], <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="c---k-complete-word">C - K-Complete Word</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1332/problem/C">题目传送门</a></p>
<h3 id="题意-2">题意</h3>
<p>一个长度为 <span class="math inline">\(n\)</span> 的字符串 <span class="math inline">\(s\)</span> 被称作 <span class="math inline">\(k\)</span>-complete 的当且仅当满足以下条件：</p>
<ul>
<li><span class="math inline">\(s\)</span> 是回文串，即对于所有 <span class="math inline">\(1\le i\le n\)</span> 满足 <span class="math inline">\(s_i=s_{n-i+1}\)</span>；</li>
<li><span class="math inline">\(s\)</span> 存在一个长度为 <span class="math inline">\(k\)</span> 的周期，即对于所有 <span class="math inline">\(1\le i\le n-k\)</span>，满足 <span class="math inline">\(s_i=s_{i+k}\)</span>。</li>
</ul>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的小写字母串 <span class="math inline">\(s\)</span> 和正整数 <span class="math inline">\(k\)</span>，每次可以修改 <span class="math inline">\(s\)</span> 某个位置的字符，求最少修改次数使得 <span class="math inline">\(s\)</span> 是 <span class="math inline">\(k\)</span>-complete 的。</p>
<p><span class="math inline">\(1\le k &lt; n\le 2\times 10^5\)</span>，<strong><span class="math inline">\(n\)</span> 能被 <span class="math inline">\(k\)</span> 整除</strong>。</p>
<h3 id="题解-2">题解</h3>
<p>显然满足条件的 <span class="math inline">\(s\)</span> 一定是一个长度为 <span class="math inline">\(k\)</span> 的回文串重复 <span class="math inline">\(\frac{n}{k}\)</span> 次拼接而成的。</p>
<p>这就意味着，我们可以把 <span class="math inline">\(s\)</span> 中的所有字符分成若干组，每一组中的字符都要相等。</p>
<p>那么我们只要将每一组的字符都修改成这一组中出现次数最多的那个字符即可。</p>
<h3 id="代码-2">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">char</span> s[N], a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(k), <span class="built_in">reads</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (k + <span class="number">1</span>) / <span class="number">2</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) c[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt; n; j += k) ++c[s[j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = k - i - <span class="number">1</span>; j &lt; n; j += k) ++c[s[j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">char</span> mx = std::<span class="built_in">max_element</span>(c, c + <span class="number">26</span>) - c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt; n; j += k) a[j] = mx + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = k - i - <span class="number">1</span>; j &lt; n; j += k) a[j] = mx + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ans += a[i] != s[i];</span><br><span class="line">    <span class="comment">// debug(&quot;%s\n&quot;, a);</span></span><br><span class="line">    <span class="built_in">print</span>(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="d---walk-on-matrix">D - Walk on Matrix</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1332/problem/D">题目传送门</a></p>
<h3 id="题意-3">题意</h3>
<p>有一个问题：</p>
<blockquote>
<p>给定一个 <span class="math inline">\(n\times m\)</span> 的矩阵 <span class="math inline">\(\{a_{i,j}\}\)</span>，求一条从 <span class="math inline">\((1,1)\)</span> 到 <span class="math inline">\((n,m)\)</span> 的路径，使得路径上所有数按位与（<span class="math inline">\(\operatorname{and}\)</span>）的结果最大。</p>
</blockquote>
<p>有一个错误的 DP 做法：</p>
<p><img src="https://espresso.codeforces.com/52569ca543bc97ed169bbc3ee5e3975b65a6b3b6.png" class="lazyload" data-srcset="https://espresso.codeforces.com/52569ca543bc97ed169bbc3ee5e3975b65a6b3b6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p>请你构造一个满足 <span class="math inline">\(1\le n,m\le 500,0\le a_{i,j}\le 3\times 10^5\)</span> 的矩阵，使得最优答案与这个错误 DP 得到的答案恰好差 <span class="math inline">\(k\)</span>。</p>
<p><span class="math inline">\(0\le k\le 10^5\)</span>。</p>
<h3 id="题解-3">题解</h3>
<p>我们可以把 <span class="math inline">\(a_{i,j}=0\)</span> 的位置视为不能经过的点，那么我们只需要构造一个点 <span class="math inline">\((x,y)\)</span> 使得：</p>
<ul>
<li>所有 <span class="math inline">\((1,1)\)</span> 到 <span class="math inline">\((n,m)\)</span> 的路径必须经过 <span class="math inline">\((x,y)\)</span>。</li>
<li><span class="math inline">\((x,y)\)</span> 到 <span class="math inline">\((n,m)\)</span> 的路径唯一（为了方便构造）。</li>
<li>记 <span class="math inline">\(P_1\)</span> 为从 <span class="math inline">\((1,1)\)</span> 到 <span class="math inline">\((n,m)\)</span> 的最优路径，<span class="math inline">\(P_2\)</span> 为从 <span class="math inline">\((1,1)\)</span> 到 <span class="math inline">\((x,y)\)</span> 的最优路径加上 <span class="math inline">\((x,y)\)</span> 到 <span class="math inline">\((n,m)\)</span> 的唯一路径，需要满足 <span class="math inline">\(w(P_1)-w(P_2)=k\)</span>。</li>
<li>记 <span class="math inline">\(P_1\)</span> 为从 <span class="math inline">\((1,1)\)</span> 到 <span class="math inline">\((n,m)\)</span> 的最优路径上 <span class="math inline">\((1,1)\)</span> 到 <span class="math inline">\((x,y)\)</span> 的路径，<span class="math inline">\(P_2\)</span> 为从 <span class="math inline">\((1,1)\)</span> 到 <span class="math inline">\((x,y)\)</span> 的最优路径，需要满足 <span class="math inline">\(w(P_1) &lt; w(P_2)\)</span>。</li>
</ul>
<p>其中 <span class="math inline">\(w(P)\)</span> 表示路径 <span class="math inline">\(P\)</span> 上所有数的 <span class="math inline">\(\operatorname{and}\)</span> 和。</p>
<p>那么构造就非常简单了，我们只要构造矩阵 <span class="math display">\[\begin{bmatrix} 2^{18}-1 &amp; 2^{17} \\ k &amp; 2^{18}-1 \\ 0 &amp; k\end{bmatrix}\]</span></p>
<p>即可满足条件。</p>
<h3 id="代码-3">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(k);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>, <span class="string">&#x27; &#x27;</span>), <span class="built_in">print</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">print</span>((<span class="number">1</span> &lt;&lt; <span class="number">18</span>) - <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>), <span class="built_in">print</span>(<span class="number">1</span> &lt;&lt; <span class="number">17</span>);</span><br><span class="line">    <span class="built_in">print</span>(k, <span class="string">&#x27; &#x27;</span>), <span class="built_in">print</span>((<span class="number">1</span> &lt;&lt; <span class="number">18</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27; &#x27;</span>), <span class="built_in">print</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="e---height-all-the-same">E - Height All the Same</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1332/problem/E">题目传送门</a></p>
<h3 id="题意-4">题意</h3>
<p>考虑一个 <span class="math inline">\(n\times m\)</span> 的矩阵 <span class="math inline">\(\{a_{i,j}\}\)</span>，每次可以执行两种操作中的一种：</p>
<ul>
<li>把相邻两个元素分别加 <span class="math inline">\(1\)</span>。</li>
<li>将某个元素加 <span class="math inline">\(2\)</span>;</li>
</ul>
<p>我们称这个矩阵是好的当且仅当你可以通过若干次操作使得所有元素相等。</p>
<p>给定 <span class="math inline">\(n,m,l,r\)</span>，求满足 <span class="math inline">\(l\le a_{i,j}\le r\)</span> 的好的矩阵数量。</p>
<p><span class="math inline">\(1\le n,m\le 10^9,1\le l\le r\le 10^9\)</span>。</p>
<h3 id="题解-4">题解</h3>
<p>当整个矩阵的奇偶性相同时，我们只要用若干次 <span class="math inline">\(2\)</span> 操作调整即可。</p>
<p><span class="math inline">\(1\)</span> 操作相当于改变了相邻两个元素的奇偶性。对于任意两个元素，我们可以将这两个元素路径上相邻两个元素执行 <span class="math inline">\(1\)</span> 操作，就可以改变这两个元素的奇偶性而不改变其他元素的奇偶性。</p>
<p>那么我们只需要使得初始矩阵奇数数量或偶数数量为偶数即可。问题得到了转化。</p>
<hr />
<p>现在需要解决的问题是：</p>
<blockquote>
<p>有 <span class="math inline">\(n\)</span> 个数，每个数有 <span class="math inline">\(p\)</span> 的概率是奇数，<span class="math inline">\(1-p\)</span> 的概率是偶数。记 <span class="math inline">\(n_0\)</span> 为这 <span class="math inline">\(n\)</span> 个数中偶数的数量，<span class="math inline">\(n_1\)</span> 为奇数的数量，求满足 <span class="math inline">\(n_0\)</span> 或 <span class="math inline">\(n_1\)</span> 至少有一个是偶数的概率。</p>
</blockquote>
<p>因为有 <span class="math inline">\(n_0+n_1=n\)</span>，所以当 <span class="math inline">\(n\)</span> 是奇数时，<span class="math inline">\(n_0,n_1\)</span> 的奇偶性不相同，一定有一个偶数，所以概率为 <span class="math inline">\(1\)</span>。</p>
<p>否则，<span class="math inline">\(n_0,n_1\)</span> 奇偶性相同，我们只需要计算 <span class="math inline">\(n_1\)</span> 为偶数时的概率。</p>
<p>答案式子为 <span class="math display">\[
\begin{aligned}
f_n &amp;=\sum_{i=0}^{\lfloor\frac{n}{2}\rfloor} \begin{pmatrix} n \\ 2i \end{pmatrix} p^{2i} (1-p)^{n-2i} \\
&amp;=(1-p)\sum_{i=0}^{\lfloor\frac{n}{2}\rfloor} \left(\begin{pmatrix} n-1 \\ 2i \end{pmatrix}+\begin{pmatrix} n-1 \\ 2i-1 \end{pmatrix}\right) p^{2i} (1-p)^{(n-1)-2i} \\
&amp;=(1-p)\left(\sum_{i=0}^{\lfloor\frac{n-1}{2}\rfloor} \begin{pmatrix} n-1 \\ 2i \end{pmatrix}p^{2i}(1-p)^{(n-1)-2i} + \frac{p}{1-p} \sum_{i=1}^{\lfloor\frac{n}{2}\rfloor} \begin{pmatrix} n-1 \\ 2i-1 \end{pmatrix}p^{2i-1}(1-p)^{(n-1)-(2i-1)}\right) \\
&amp;=(1-p)\left(f_{n-1}+\frac{p}{1-p}\left(-f_{n-1}+\sum_{i=0}^{n-1} \begin{pmatrix} n-1 \\ i \end{pmatrix} p^i (1-p)^{(n-1)-i}\right) \right) \\
&amp;=(1-p)(f_{n-1}+\frac{p}{1-p}(-f_{n-1}+(p+(1-p))^{n-1})) \\
&amp;=(1-2p)f_{n-1}+p
\end{aligned}
\]</span></p>
<p>用特征方程或者错位相减等方法，化简后可以得到 <span class="math inline">\(f_n\)</span> 的通项公式 <span class="math display">\[f_n=\frac{1+(1-2p)^n}{2}\]</span></p>
<hr />
<p>注意到模数为 <span class="math inline">\(998\,244\,353\)</span>，而 <span class="math inline">\(l,r\)</span> 的范围是 <span class="math inline">\(10^9\)</span>，在算 <span class="math inline">\(p\)</span> 时可能会出现 <span class="math inline">\(r-l+1\)</span> 没有逆元的情况。一种解决方案是将 <span class="math inline">\(p\)</span> 写成 <span class="math inline">\(\frac{c}{r-l+1}\)</span> 的形式，将最后的 <span class="math inline">\((r-l+1)^n\)</span> 乘进去后化简，可以去掉分母中的 <span class="math inline">\(r-l+1\)</span>。</p>
<h3 id="代码-4">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, Inv2 = (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, l, r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1ll</span> * a * a % P) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1ll</span> * s * a % P;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(l), <span class="built_in">read</span>(r);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1ll</span> * n * m % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">print</span>(<span class="built_in">qpow</span>(r - l + <span class="number">1</span>, <span class="number">1ll</span> * n * m)), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((r - l + <span class="number">1</span>) &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">print</span>(<span class="number">1ll</span> * (<span class="built_in">qpow</span>(r - l + <span class="number">1</span>, <span class="number">1ll</span> * n * m) + <span class="number">1</span>) * Inv2 % P), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">print</span>(<span class="number">1ll</span> * <span class="built_in">qpow</span>(r - l + <span class="number">1</span>, <span class="number">1ll</span> * n * m) * Inv2 % P), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="f---independent-set">F - Independent Set</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1332/problem/F">题目传送门</a></p>
<h3 id="题意-5">题意</h3>
<p>对于一个无向图 <span class="math inline">\(G=(V,E)\)</span>，一个<strong>独立集</strong>是一个 <span class="math inline">\(V\)</span> 的子集 <span class="math inline">\(V&#39;\)</span>，满足对于所有 <span class="math inline">\(u,v\in V&#39;\)</span>，有 <span class="math inline">\((u,v)\not\in E\)</span>。</p>
<p>一个<strong>边导出子图</strong>是由边集 <span class="math inline">\(E\)</span> 的一个子集 <span class="math inline">\(E&#39;\)</span> 以及所有在 <span class="math inline">\(E&#39;\)</span> 的边中出现至少一次的点组成的。</p>
<p>给定一棵树 <span class="math inline">\(G=(V,E)\)</span>，我们定义 <span class="math inline">\(G[E&#39;]\)</span> 表示边集为 <span class="math inline">\(E&#39;\)</span> 时 <span class="math inline">\(G\)</span> 的边导出子图，<span class="math inline">\(w(G)\)</span> 表示图 <span class="math inline">\(G\)</span> 的独立集数量。求 <span class="math display">\[\sum_{E&#39;\subset E, E&#39;\ne \varnothing} w(G[E&#39;])\]</span></p>
<p><span class="math inline">\(n\le 3\times 10^5\)</span>，答案对 <span class="math inline">\(998\,244\,353\)</span> 取模。</p>
<h3 id="题解-5">题解</h3>
<p>对于一棵树求独立集数量，这个问题可以用简单的 DP 解决。</p>
<p>在这个问题中，无非就是多了另外一个决策——断边。我们仍然考虑使用 DP 去解决这个问题。首先我们强制以 <span class="math inline">\(1\)</span> 为根。</p>
<p>设 <span class="math inline">\(f_{u,0/1,0/1}\)</span> 表示以 <span class="math inline">\(u\)</span> 为根的子树，<span class="math inline">\(u\)</span> 与父亲的边在/不在边导出子图内，<span class="math inline">\(u\)</span> 在/不在独立集内时的方案数。转移如下： <span class="math display">\[
\begin{aligned}
f_{u,1,1} &amp;= \prod_{v\in \operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1}+f_{v,1,0}) \\
f_{u,1,0} &amp;= \prod_{v\in \operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1}+f_{v,1,0}+f_{v,1,1}) \\
f_{u,0,1} &amp;= \prod_{v\in \operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1}+f_{v,1,0}) - \prod_{v\in \operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1})\\
f_{u,0,0} &amp;= \prod_{v\in \operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1}+f_{v,1,0}+f_{v,1,1})
\end{aligned}
\]</span></p>
<p>当 <span class="math inline">\(u\)</span> 的连边都不在边导出子图内时也是合法的，但是此时 <span class="math inline">\(u\)</span> 不能选在独立集内，所以 <span class="math inline">\(f_{u,0,1}\)</span> 的转移需要减去所有与儿子的边都不在子图内的情况，而 <span class="math inline">\(f_{u,0,0}\)</span> 不需要减。</p>
<p>最后答案即为 <span class="math inline">\(f_{1,0,0}+f_{1,0,1}-1\)</span>（减 <span class="math inline">\(1\)</span> 是减去边集为空的情况）。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h3 id="代码-5">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300005</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; E[N];</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mul = <span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">1</span>][<span class="number">0</span>] = f[u][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : E[u])</span><br><span class="line">        <span class="keyword">if</span> (v != fa)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            f[u][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1ll</span> * f[u][<span class="number">1</span>][<span class="number">0</span>] * (<span class="number">0ll</span> + f[v][<span class="number">0</span>][<span class="number">0</span>] + f[v][<span class="number">0</span>][<span class="number">1</span>] + f[v][<span class="number">1</span>][<span class="number">0</span>] + f[v][<span class="number">1</span>][<span class="number">1</span>]) % P;</span><br><span class="line">            f[u][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1ll</span> * f[u][<span class="number">1</span>][<span class="number">1</span>] * (<span class="number">0ll</span> + f[v][<span class="number">0</span>][<span class="number">0</span>] + f[v][<span class="number">0</span>][<span class="number">1</span>] + f[v][<span class="number">1</span>][<span class="number">0</span>]) % P;</span><br><span class="line">            mul = <span class="number">1ll</span> * mul * (<span class="number">0ll</span> + f[v][<span class="number">0</span>][<span class="number">0</span>] + f[v][<span class="number">0</span>][<span class="number">1</span>]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    f[u][<span class="number">0</span>][<span class="number">1</span>] = (f[u][<span class="number">1</span>][<span class="number">1</span>] - mul + P) % P;</span><br><span class="line">    f[u][<span class="number">0</span>][<span class="number">0</span>] = f[u][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) E[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), E[u].<span class="built_in">push_back</span>(v), E[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print</span>((<span class="number">0ll</span> + f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] + P - <span class="number">1</span>) % P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="g---no-monotone-triples">G - No Monotone Triples</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1332/problem/G">题目传送门</a></p>
<p>咕咕咕...</p>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>容斥</tag>
        <tag>模拟</tag>
        <tag>状压DP</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 85 (Rated for Div. 2)</title>
    <url>/cf1334/</url>
    <content><![CDATA[<p>罚时被 E 搞没了。</p>
<span id="more"></span>
<h2 id="a---level-statistics">A - Level Statistics</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1334/problem/A">题目传送门</a></p>
<h3 id="题解">题解</h3>
<p>初始状态为 <span class="math inline">\(p_0=0,c_0=0\)</span>。</p>
<p>由于每进行一次游戏，<span class="math inline">\(p\)</span> 一定会加 <span class="math inline">\(1\)</span>，而 <span class="math inline">\(c\)</span> 可能加 <span class="math inline">\(1\)</span> 也有可能不变，所以 <span class="math inline">\(p\)</span> 增加的值一定大于等于 <span class="math inline">\(c\)</span> 增加的值，并且他们增加的值必须非负。</p>
<p>所以只要判断是否所有 <span class="math inline">\(i\)</span> 都满足 <span class="math inline">\(p_{i-1} \le p_i,c_{i-1} \le c_i,p_i-p_{i-1}\ge c_{i}-c_{i-1}\)</span> 即可。</p>
<h3 id="代码">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> nx, ny;</span><br><span class="line">        <span class="built_in">read</span>(nx), <span class="built_in">read</span>(ny);</span><br><span class="line">        <span class="keyword">if</span> (nx &lt; x || ny &lt; y) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nx - x &lt; ny - y) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x = nx, y = ny;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="built_in">printStr</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printStr</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="b---middle-class">B - Middle Class</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1334/problem/B">题目传送门</a></p>
<h3 id="题解-1">题解</h3>
<p>假设我们已经知道了答案 <span class="math inline">\(s\)</span>，考虑如何判断是否合法。</p>
<p>我们需要让 <span class="math inline">\(s\)</span> 个人的钱数 <span class="math inline">\(\ge x\)</span>，那么我们的最优策略一定是选择最大的 <span class="math inline">\(s\)</span> 个人，然后对这 <span class="math inline">\(s\)</span> 个人进行一次操作，如果得到的平均值 <span class="math inline">\(\ge x\)</span> 则符合条件，否则一定不可以。</p>
<p>那么我们只要将所有数从大到小排序以后，枚举答案 <span class="math inline">\(s\)</span> 进行判断即可。</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, x, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    std::<span class="built_in">reverse</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">1ll</span> * x * i) &#123;</span><br><span class="line">            <span class="built_in">print</span>(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="c---circle-of-monsters">C - Circle of Monsters</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1334/problem/C">题目传送门</a></p>
<h3 id="题解-2">题解</h3>
<p>为方便描述，下文中 <span class="math inline">\(i+1\)</span> 表示环上 <span class="math inline">\(i\)</span> 的下一个怪物，<span class="math inline">\(i-1\)</span> 表示环上 <span class="math inline">\(i\)</span> 的上一个怪物。</p>
<p>首先我们将 <span class="math inline">\(b_i\)</span> 与 <span class="math inline">\(a_{i+1}\)</span> 取 <span class="math inline">\(\min\)</span>，这显然不会影响答案。</p>
<p>对于一个怪物 <span class="math inline">\(i\)</span>，打败他至少需要的操作次数为 <span class="math inline">\(a_i-b_{i-1}\)</span>，即打 <span class="math inline">\(a_i-b_{i-1}\)</span> 枪，剩下的血量用上一个怪物炸。</p>
<p>那么总的操作次数的下界即为 <span class="math inline">\(\sum\limits_{i=1}^{n} a_i-b_{i-1}\)</span>。</p>
<p>但是这是一个环形，我们不可能做到每个怪物都被上一个怪物炸，必须有一个怪物是手动打死的。</p>
<p>而在之前的操作次数下界的基础上，手动打死怪物 <span class="math inline">\(i\)</span> 需要花费额外的 <span class="math inline">\(b_i\)</span> 次操作，所以我们只要选择 <span class="math inline">\(b_i\)</span> 最小的那个怪物手动打死即可。</p>
<p>总花费即为 <span class="math inline">\(\min\limits_{1\le i\le n} b_i+\sum\limits_{i=1}^{n} a_i-b_{i-1}\)</span>。</p>
<h3 id="代码-2">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>, mn = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]), <span class="built_in">read</span>(b[i]);</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        b[i] = std::<span class="built_in">min</span>(b[i], a[i % n + <span class="number">1</span>]);</span><br><span class="line">        mn = std::<span class="built_in">min</span>(mn, b[i]);</span><br><span class="line">        sum -= b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(sum + mn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="d---minimum-euler-cycle">D - Minimum Euler Cycle</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1334/problem/D">题目传送门</a></p>
<h3 id="题解-3">题解</h3>
<p>看到完全图，欧拉回路，以及字典序最小，一个很自然的想法是从 <span class="math inline">\(1\)</span> 开始，每次走能走的最小的那个点。</p>
<p>模拟发现，这样走一定能恰好走出一条欧拉回路，顶点序列如下： <span class="math display">\[1,2,1,3,\cdots,1,n,2,3,2,4,\cdots,2,n,3,4,\cdots,n,n-1,n,1\]</span></p>
<p>我们可以将这个序列分成若干组，可以更直观的看出规律： <span class="math display">\[
\begin{aligned}
&amp; 1,2,1,3,\cdots,1,n \\
&amp; 2,3,2,4,\cdots,2,n \\
&amp; 3,4,3,5,\cdots,3,n \\
&amp; \vdots \\
&amp; n-2,n-1,n-2,n \\
&amp; n-1,n \\
&amp; 1
\end{aligned}
\]</span></p>
<p>于是我们求出 <span class="math inline">\(l,r\)</span> 在第几组中的第几个，直接模拟即可。</p>
<p>注意需要特判最后的 <span class="math inline">\(1\)</span>。</p>
<h3 id="代码-3">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l, r;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">get</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; n &amp;&amp; l &gt; <span class="number">2</span> * (n - p)) &#123;</span><br><span class="line">        l -= <span class="number">2</span> * (n - p);</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;p, l&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(l), <span class="built_in">read</span>(r);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">1ll</span> * n * (n - <span class="number">1</span>) + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">1</span>, --r;</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; L = <span class="built_in">get</span>(l), R = <span class="built_in">get</span>(r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = L.first; k &lt;= R.first; ++k) &#123;</span><br><span class="line">        <span class="keyword">int</span> lb = k == L.first ? L.second : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rb = k == R.first ? R.second : <span class="number">2</span> * (n - k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lb; i &lt;= rb; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">print</span>(k, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(k + i / <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="e---divisor-paths">E - Divisor Paths</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1334/problem/E">题目传送门</a></p>
<h3 id="题解-4">题解</h3>
<p>打 CF 只知道猜结论，一个 WA22 以为结论错了，没想到是没开 <code>long long</code>。当场去世。</p>
<p><del>好的我们开始猜结论。</del></p>
<p>首先，对于两个点 <span class="math inline">\(x,y\ (x \ge y)\)</span>，若 <span class="math inline">\(y|x\)</span>，那么 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的最短路长度一定是 <span class="math inline">\(d(x)-d(y)\)</span>（<span class="math inline">\(d(x)\)</span> 表示 <span class="math inline">\(x\)</span> 的因子数量）。所以，从 <span class="math inline">\(x\)</span> 开始不断除掉某个质因子直到等于 <span class="math inline">\(y\)</span> 的一条路径一定是一条最短路。</p>
<p>如果中途增大了会导致因子数量变多，所以反过来也是成立的。</p>
<p>上面的结论可以更加严谨的证明，这里不做详细证明。</p>
<p>那么最短路条数等于将 <span class="math inline">\(\frac{x}{y}\)</span> 分解质因数后的可重元素排列数量。可以直接预处理阶乘和阶乘逆元求出。</p>
<p>拓展到一般情况，<span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的最短路一定经过点 <span class="math inline">\(\gcd(x,y)\)</span>。大概理解一下，一定不会经过比 <span class="math inline">\(\gcd(x,y)\)</span> 更小的公因子，这样显然不优；也一定不会往 <span class="math inline">\(\operatorname{lcm}(x,y)\)</span> 的方向走，由于 <span class="math inline">\(\frac{a}{b}=\frac{b}{c}\)</span> 时，<span class="math inline">\(d(a)-d(b) &gt; d(b)-d(c)\)</span>，所以往 <span class="math inline">\(\operatorname{lcm}(x,y)\)</span> 方向走也是不优的。</p>
<p>那么只要分别求出 <span class="math inline">\(x\to \gcd(x,y)\)</span> 和 <span class="math inline">\(y\to \gcd(x,y)\)</span> 的最短路数量，相乘即可。</p>
<h3 id="代码-4">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="keyword">int</span> fac[<span class="number">105</span>], inv[<span class="number">105</span>];</span><br><span class="line">std::vector&lt;std::pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt;&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            s = <span class="number">1ll</span> * s * a % P;</span><br><span class="line">        &#125;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[n] = <span class="built_in">qpow</span>(fac[n], P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        inv[i - <span class="number">1</span>] = <span class="number">1ll</span> * inv[i] * i % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : p) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x % v.first == <span class="number">0</span>) &#123;</span><br><span class="line">            x /= v.first;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="number">1ll</span> * res * inv[k] % P;</span><br><span class="line">        sum += k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * res * fac[sum] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; <span class="number">1ll</span> * i * i &lt;= x; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            p.<span class="built_in">push_back</span>(&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                ++p.<span class="built_in">back</span>().second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        p.<span class="built_in">push_back</span>(&#123;x, <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x, y;</span><br><span class="line">        <span class="built_in">read</span>(x), <span class="built_in">read</span>(y);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> g = <span class="built_in">gcd</span>(x, y);</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1ll</span> * <span class="built_in">get</span>(x / g) * <span class="built_in">get</span>(y / g) % P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="f---strange-function">F - Strange Function</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1334/problem/F">题目传送门</a></p>
<h3 id="题解-5">题解</h3>
<p>首先考虑将删去最小的转化成保留最大的。</p>
<p>这种选一个子序列满足什么条件的问题，我们首先考虑一个经典的 DP。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示 <span class="math inline">\(a\)</span> 的前 <span class="math inline">\(i\)</span> 个数中选出一个子序列（强制 <span class="math inline">\(i\)</span> 选），进行题目中的操作后得到的序列与 <span class="math inline">\(b_{1\ldots j}\)</span> 相等时的最大权值。</p>
<p>由于我们强制 <span class="math inline">\(i\)</span> 选，所以合法的 <span class="math inline">\(j\)</span> 是唯一的，我们大可不必记录 <span class="math inline">\(j\)</span> 这一维状态。</p>
<p>考虑满足 <span class="math inline">\(a_i=b_j\)</span> 的唯一的 <span class="math inline">\(j\)</span>，令 <span class="math inline">\(a_0=b_0=0\)</span>，那么有转移 <span class="math display">\[f_i=\max_{0\le k &lt; i,a_k=b_{j-1}}\{f_k+\sum_{t=k+1}^{i-1}[a_t\le a_k][p_t &gt; 0]p_t\}+p_i\]</span></p>
<p>对于当前的 <span class="math inline">\(i\)</span>，设 <span class="math display">\[g_k=f_k+\sum_{t=k+1}^{i-1}[a_t\le a_k][p_t &gt; 0]p_t\]</span></p>
<p>考虑将 <span class="math inline">\(i\)</span> 加 <span class="math inline">\(1\)</span> 后 <span class="math inline">\(g_k\)</span> 的变化。对于满足 <span class="math inline">\(0\le k &lt; i\)</span> 的所有 <span class="math inline">\(k\)</span>，如果 <span class="math inline">\(p_i\le 0\)</span> 那么 <span class="math inline">\(g_k\)</span> 显然不会改变，否则所有满足 <span class="math inline">\(a_k\ge a_i\)</span> 的 <span class="math inline">\(g_k\)</span> 会加上 <span class="math inline">\(p_i\)</span>；对于 <span class="math inline">\(k=i\)</span> 的 <span class="math inline">\(g_k\)</span>，有 <span class="math inline">\(g_k=f_i\)</span>。</p>
<p>考虑一个以 <span class="math inline">\(a_k\)</span> 为下标的数组，位置 <span class="math inline">\(v\)</span> 的值即为 <span class="math display">\[\max_{0\le k &lt; i,a_k=v}\{g_k\}\]</span></p>
<p>根据上述分析，我们需要在这个数组上支持后缀加、单点取 <span class="math inline">\(\max\)</span>、单点查询操作即可。单点取 <span class="math inline">\(\max\)</span> 操作可以拆分为一个单点查询和两个后缀加操作。</p>
<p>后缀加、单点查询可以用树状数组简单地维护。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="代码-5">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], m, b[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> w[N], sum, f[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> c[N];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> v)</span> </span>&#123; <span class="comment">// 后缀加</span></span><br><span class="line">        <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) &#123;</span><br><span class="line">            c[x] += v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 单点查询</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x ^= x &amp; -x) &#123;</span><br><span class="line">            s += c[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(w[i]);</span><br><span class="line">        sum += w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    T.<span class="built_in">add</span>(<span class="number">1</span>, -INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = std::<span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + m, a[i]) - b;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= m &amp;&amp; a[i] == b[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">                f[i] = w[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i] = T.<span class="built_in">query</span>(b[j - <span class="number">1</span>]) + w[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f[i] = -INF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            T.<span class="built_in">add</span>(a[i], w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = T.<span class="built_in">query</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span> (f[i] &gt; tmp) &#123;</span><br><span class="line">            T.<span class="built_in">add</span>(a[i], f[i] - tmp);</span><br><span class="line">            T.<span class="built_in">add</span>(a[i] + <span class="number">1</span>, tmp - f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = T.<span class="built_in">query</span>(b[m]);</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; <span class="number">-1e15</span>) &#123;</span><br><span class="line">        <span class="built_in">printStr</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="built_in">print</span>(sum - ans); <span class="comment">// 用总和减去最大保留的权值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printStr</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="g---substring-search">G - Substring Search</h2><div class="story post-story">
<p><a href="https://codeforces.com/contest/1334/problem/G">题目传送门</a></p>
<p>也许会补的吧...</p>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>数论</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1214H」Tiles Placement</title>
    <url>/cf1214h-sol/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1214/problem/H">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，你需要给每个点染一个 <span class="math inline">\(1\sim k\)</span> 的颜色，使得树上所有长度为 <span class="math inline">\(k\)</span> 的路径都恰好包含 <span class="math inline">\(k\)</span> 种颜色。</p>
<p><span class="math inline">\(n\le 2\times 10^5\)</span></p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>根本不会构造.jpg</p>
<p><del>我来翻译官方题解了</del></p>
<p>显然如果一个点出去有三条路径（长度记为 <span class="math inline">\(a,b,c\)</span>）满足 <span class="math inline">\(a+b\ge k-1,a+c\ge k-1,b+c\ge k-1\)</span>，则一定不满足条件。否则，存在以下一个构造方案。</p>
<p>拉出一条直径，从左到右染 <span class="math inline">\(1,2,3,\cdots,k,1,2,3,\cdots\)</span> 。然后考虑直径外的部分，把直径分成两半，对于左边部分的某个染成 <span class="math inline">\(i\)</span> 的点，我们把这个点多出去的部分按深度从小到大染成 <span class="math inline">\(i,i-1,i-2,\cdots,1,k,k-1,k-2\cdots\)</span>；对于右边部分的某个染成 <span class="math inline">\(i\)</span> 的点，我们把这个点多出去的部分按深度从小到大染成 <span class="math inline">\(i,i+1,i+2,\cdots,k,1,2,3\cdots\)</span>。正确性可以参考官方题解。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = <span class="built_in">getchar</span>(), f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">int</span> k, n;</span><br><span class="line"><span class="keyword">int</span> mx[N], cmx[N];</span><br><span class="line"><span class="keyword">int</span> rt, ed, dep[N], fa[N], cnt, p[N], on[N], col[N];</span><br><span class="line"><span class="keyword">int</span> edge, to[N &lt;&lt; <span class="number">1</span>], pr[N &lt;&lt; <span class="number">1</span>], hd[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line">std :: <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    std :: <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">0</span>, u)</span>, tmp</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa) tmp = <span class="built_in">dfs1</span>(v, u), ++tmp.first, res = std :: <span class="built_in">max</span>(res, tmp);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dep[u] = dep[fa[u]] + <span class="number">1</span>, mx[u] = cmx[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa[u])&#123;</span><br><span class="line">            fa[v] = u, <span class="built_in">dfs2</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (mx[v] + <span class="number">1</span> &gt; mx[u]) cmx[u] = mx[u], mx[u] = mx[v] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mx[v] + <span class="number">1</span> &gt; cmx[u]) cmx[u] = mx[v] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    c = (c + d + k - <span class="number">1</span>) % k + <span class="number">1</span>, col[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa[u] &amp;&amp; !on[v]) <span class="built_in">dfs3</span>(v, c, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">        u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(), <span class="built_in">addedge</span>(u, v), <span class="built_in">addedge</span>(v, u);</span><br><span class="line">    <span class="built_in">dfs2</span>(rt = <span class="built_in">dfs1</span>(<span class="number">1</span>).second);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cmx[i])</span><br><span class="line">            <span class="keyword">if</span> (mx[i] + <span class="number">1</span> &gt; dep[i]) <span class="keyword">if</span> (dep[i] + cmx[i] &gt;= k &amp;&amp; k &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>), <span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mx[i] + cmx[i] + <span class="number">1</span> &gt;= k &amp;&amp; k &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>), <span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!ed || dep[i] &gt; dep[ed]) ed = i;</span><br><span class="line">    cnt = dep[ed];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = ed; i; i = fa[i]) p[dep[i]] = i, on[i] = <span class="number">1</span>, col[i] = (dep[i] - <span class="number">1</span>) % k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = hd[p[i]]; j; j = pr[j])</span><br><span class="line">            <span class="keyword">if</span> (!on[to[j]]) <span class="built_in">dfs3</span>(to[j], col[p[i]], i &lt;= cnt / <span class="number">2</span> ? <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, col[i]); <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 295D」Greg and Caves</title>
    <url>/cf295d-sol/</url>
    <content><![CDATA[<blockquote>
<p>标签：DP</p>
</blockquote>
<p><a href="http://codeforces.com/problemset/problem/295/D">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定<span class="math inline">\(n,m\)</span>，你需要对一个<span class="math inline">\(n\times m\)</span>的矩阵黑白染色，满足：</p>
<ol type="1">
<li>存在一个区间<span class="math inline">\([l,r]\)</span>，满足<span class="math inline">\(l\sim r\)</span>这些行有且仅有两个黑色格子，其他行不存在黑色格子。</li>
<li>存在一个<span class="math inline">\(t\ (l\le t\le r)\)</span>，使得对于所有的<span class="math inline">\(i,j\ (l\le i\le j\le t)\)</span>，满足第<span class="math inline">\(i\)</span>行以两个黑色格子为端点的区间（以下简称“区间”）被<span class="math inline">\(j\)</span>行的区间包含；同样地，对于所有的<span class="math inline">\(i,j\ (t\le i\le j\le r)\)</span>，第<span class="math inline">\(j\)</span>行的区间被第<span class="math inline">\(i\)</span>行的区间包含。</li>
</ol>
<p>求染色方案数<span class="math inline">\(\bmod (10^9+7)\)</span>的值。</p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>比较简单的<span class="math inline">\(\mathrm{DP}\)</span>，设<span class="math inline">\(dp_{i,j}\)</span>表示上半部分（即<span class="math inline">\(l\)</span>到<span class="math inline">\(t\)</span>部分）的高度<strong>至多</strong>为<span class="math inline">\(i\)</span>，底边宽度（包含两个黑色格子）为<span class="math inline">\(j\)</span>且底边位置固定时的方案数。</p>
<h3 id="转移方程">转移方程</h3>
<p><span class="math display">\[dp_{i,j}=dp_{i,j-1}+\sum\limits_{k=2}^j dp_{i-1,k}\]</span></p>
<p>应该还是比较好理解的。初始值<span class="math inline">\(dp_{1,i}=dp_{i,1}=1\)</span>。</p>
<p>直接转移是<span class="math inline">\(O(n^3)\)</span>的，但是<span class="math inline">\(\sum\limits_{k=2}^j dp_{i-1,k}\)</span>可以在枚举<span class="math inline">\(j\)</span>的同时计算（即前缀和优化），时间复杂度可以做到<span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="答案">答案</h3>
<p>下半部分的方案与上半部分同理。</p>
<p>注意如果下半部分的底边长度和上半部分的底边长度相等，会有重复，所以应该减去。</p>
<p><span class="math display">\[ans=\sum\limits_{i=1}^n \sum\limits_{j=2}^m (dp_{i,j}-dp_{i-1,j})\times dp_{n-i+1,j}\times (m-j+1)\bmod 1000000007\]</span></p>
<p><span class="math inline">\(i\)</span>枚举的是下半部分的起始位置，<span class="math inline">\(j\)</span>枚举的是下半部分的底边宽度，第一项是上半部分减去长度相等的方案，第二项是下半部分的方案，第三项是计算底边在矩阵中的位移。</p>
<p>注意需要随时取模。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<p><a href="http://codeforces.com/contest/295/submission/45051328">Code</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n, m, dp[<span class="number">2005</span>][<span class="number">2005</span>], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= m; ++j)</span><br><span class="line">            (s += dp[i - <span class="number">1</span>][j]) %= P, dp[i][j] = (dp[i][j - <span class="number">1</span>] + s) % P; <span class="comment">// 前缀和优化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= m; ++j)</span><br><span class="line">            (ans += <span class="number">1ll</span> * (dp[i][j] - dp[i - <span class="number">1</span>][j] + P) * dp[n - i + <span class="number">1</span>][j] % P * (m - j + <span class="number">1</span>) % P) %= P; <span class="comment">// 计算答案，随时取模</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 505E」Mr. Kitayuta vs. Bamboos</title>
    <url>/cf505e-sol/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/problemset/problem/505/E">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>有<span class="math inline">\(n\)</span>根竹子，竹子<span class="math inline">\(i\)</span>初始高度为<span class="math inline">\(h_i\)</span>，每天<strong>晚上</strong>会长高<span class="math inline">\(a_i\)</span>。</p>
<p>每天<strong>白天</strong>，你可以选择<span class="math inline">\(k\)</span>根竹子（同一根竹子在同一个白天可以多次选择），把他们的高度减少<span class="math inline">\(p\)</span>，若竹子当前高度<span class="math inline">\(-p\)</span>后<span class="math inline">\(&lt;0\)</span>，则竹子高度变为<span class="math inline">\(0\)</span>。</p>
<p>最小化<span class="math inline">\(m\)</span>天后最高的竹子的高度。</p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>首先<code>最小化最大的...</code>这种问题，显然可以用二分答案。</p>
<p>二分<span class="math inline">\(m\)</span>天后最高的竹子的高度<span class="math inline">\(H\)</span>，然后问题就变成了判定性问题：是否存在一种方案，使得<span class="math inline">\(m\)</span>天后竹子高度都<span class="math inline">\(\le H\)</span>。</p>
<p>考虑怎么解决这个判定性问题。</p>
<p>如果按照题意一天一天模拟，就需要考虑把竹子高度减<span class="math inline">\(p\)</span>后<span class="math inline">\(&lt;0\)</span>的情况，会比较麻烦。</p>
<p>所以我们尝试倒着模拟这一过程。</p>
<p>即：竹子初始高度都设为<span class="math inline">\(H\)</span>，每根竹子每天会<strong>减少</strong><span class="math inline">\(a_i\)</span>的高度，然后你可以选择<span class="math inline">\(k\)</span>根竹子，把它们“拔高”<span class="math inline">\(p\)</span>。问<span class="math inline">\(m\)</span>天后竹子高度是否都<span class="math inline">\(\ge h_i\)</span>。</p>
<p>此时你<strong>必须保证</strong>竹子减少<span class="math inline">\(a_i\)</span>的高度后不会<span class="math inline">\(&lt;0\)</span>。</p>
<p>这样就好做了。我们用一个堆维护 当前状态下继续减少高度而不“拔高”，第<span class="math inline">\(m\)</span>天结束后竹子高度会<span class="math inline">\(&lt;h_i\)</span>的竹子 一直减少高度 多少天后的高度会<span class="math inline">\(&lt;0\)</span>。</p>
<p>（不理解这句话可以尝试看代码理解）</p>
<p>每次取出最快<span class="math inline">\(&lt;0\)</span>的竹子，对它“拔高”即可。注意中间可能会出现无论怎么“拔高”还是会<span class="math inline">\(&lt;0\)</span>的竹子，此时直接返回错误即可。</p>
<p>最后判断堆是否为空即可，因为堆中维护的是<span class="math inline">\(m\)</span>天后竹子高度会<span class="math inline">\(&lt;h_i\)</span>的竹子，所以堆空即代表所有竹子高度都<span class="math inline">\(\ge h_i\)</span>。</p>
<p>时间复杂度<span class="math inline">\(O((n+mk)\log n\log mx)\)</span>，其中<span class="math inline">\(mx\)</span>表示<span class="math inline">\(\max\limits_{1\le i\le n} h_i+a_im\)</span>（二分的上界）。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<p><a href="http://codeforces.com/contest/505/submission/45262032">Code</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, c[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p, a[<span class="number">100005</span>], h[<span class="number">100005</span>], l = <span class="number">0</span>, r, mid, ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> day, id;  <span class="comment">// 表示当前状态下（二分的高度+c[id]*p）day+1天后竹子id的高度会&lt;0</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;b) <span class="keyword">const</span> &#123;  <span class="comment">// 默认大根堆，所以重载&lt;时写的是&gt;</span></span><br><span class="line">        <span class="keyword">return</span> day &gt; b.day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Heap</span>&#123;</span>  <span class="comment">// 用algorithm中的堆相关的算法封装实现。</span></span><br><span class="line">    node h[<span class="number">200005</span>];</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; sz = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> !sz; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(node x)</span></span>&#123; h[++sz] = x, std :: <span class="built_in">push_heap</span>(h + <span class="number">1</span>, h + <span class="number">1</span> + sz); &#125;</span><br><span class="line">    <span class="function">node <span class="title">pop</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> std :: <span class="built_in">pop_heap</span>(h + <span class="number">1</span>, h + <span class="number">1</span> + sz), h[sz--]; &#125;</span><br><span class="line">    <span class="function">node <span class="title">top</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> h[<span class="number">1</span>]; &#125;</span><br><span class="line">&#125;H;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    H.<span class="built_in">clear</span>(), <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c); <span class="comment">// c[i]表示竹子i被“拔高”了几次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (x - a[i] * m &lt; h[i]) H.<span class="built_in">push</span>((node)&#123;x / a[i], i&#125;);  <span class="comment">// 初始堆的状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; !H.<span class="built_in">empty</span>() &amp;&amp; i &lt;= m; ++i)  <span class="comment">// i表示倒着的第几天</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; !H.<span class="built_in">empty</span>() &amp;&amp; j &lt;= k; ++j)&#123; <span class="comment">// 拔高k根竹子</span></span><br><span class="line">            node u = H.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (u.day &lt; i) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 无论怎么“拔高”都不能满足条件</span></span><br><span class="line">            ++c[u.id];  <span class="comment">// “拔高”</span></span><br><span class="line">            <span class="keyword">if</span> (x + c[u.id] * p - a[u.id] * m &lt; h[u.id])  <span class="comment">// 还是不满足条件，就插入堆中</span></span><br><span class="line">                H.<span class="built_in">push</span>((node)&#123;(x + c[u.id] * p) / a[u.id], u.id&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> H.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), k = <span class="built_in">read</span>(), p = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        h[i] = <span class="built_in">read</span>(), a[i] = <span class="built_in">read</span>(), r = std :: <span class="built_in">max</span>(r, h[i] + a[i] * m);  <span class="comment">// 二分上界</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) <span class="built_in">check</span>(mid = l + r &gt;&gt; <span class="number">1</span>) ? ans = mid, r = mid - <span class="number">1</span> : l = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 815D」Karen and Cards</title>
    <url>/cf815d-sol/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/problemset/problem/815/D">题目传送门</a></p>
<h2 id="karen-and-cards">Karen and Cards</h2><div class="story post-story">
<p>Karen just got home from the supermarket, and is getting ready to go to sleep.</p>
<span id="more"></span>
<figure>
<img src="http://codeforces.com/predownloaded/2b/98/2b98bfcf516f93477a5a209118c7c4582fc9db2d.png" class="lazyload" data-srcset="http://codeforces.com/predownloaded/2b/98/2b98bfcf516f93477a5a209118c7c4582fc9db2d.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" /><figcaption>img</figcaption>
</figure>
<p>After taking a shower and changing into her pajamas, she looked at her shelf and saw an album. Curious, she opened it and saw a trading card collection.</p>
<p>She recalled that she used to play with those cards as a child, and, although she is now grown-up, she still wonders a few things about it.</p>
<p>Each card has three characteristics: strength, defense and speed. The values of all characteristics of all cards are positive integers. The maximum possible strength any card can have is <span class="math inline">\(p\)</span>, the maximum possible defense is <span class="math inline">\(q\)</span> and the maximum possible speed is <span class="math inline">\(r\)</span>.</p>
<p>There are <span class="math inline">\(n\)</span> cards in her collection. The <span class="math inline">\(i\)</span>-th card has a strength <span class="math inline">\(a_i\)</span>, defense <span class="math inline">\(b_i\)</span> and speed <span class="math inline">\(c_i\)</span>, respectively.</p>
<p>A card beats another card if at least two of its characteristics are strictly greater than the corresponding characteristics of the other card.</p>
<p>She now wonders how many different cards can beat all the cards in her collection. Two cards are considered different if at least one of their characteristics have different values.</p>
<h3 id="input">Input</h3>
<p>The first line of input contains four integers, <span class="math inline">\(n,p,q\)</span> and <span class="math inline">\(r\)</span> (<span class="math inline">\(1 \le n,p,q,r \le 500000\)</span>), the number of cards in the collection, the maximum possible strength, the maximum possible defense, and the maximum possible speed, respectively.</p>
<p>The next <span class="math inline">\(n\)</span> lines each contain three integers. In particular, the <span class="math inline">\(i\)</span>-th line contains <span class="math inline">\(a_i,b_i\)</span> and <span class="math inline">\(c_i\)</span> (<span class="math inline">\(1\le a_i\le p,1\le b_i\le q,1\le c_i\le r\)</span>), the strength, defense and speed of the <span class="math inline">\(i\)</span>-th collection card, respectively.</p>
<h3 id="output">Output</h3>
<p>Output a single integer on a line by itself, the number of different cards that can beat all the cards in her collection.</p>
<h3 id="examples">Examples</h3>
<h4 id="input-1">Input</h4>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">4</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="output-1">Output</h4>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h4 id="input-2">Input</h4>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">10</span> <span class="number">10</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="output-2">Output</h4>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">972</span><br></pre></td></tr></table></figure>
<h3 id="note">Note</h3>
<p>In the first test case, the maximum possible strength is 4, the maximum possible defense is 4 and the maximum possible speed is 5. Karen has three cards:</p>
<ul>
<li>The first card has strength 2, defense 2 and speed 5.</li>
<li>The second card has strength 1, defense 3 and speed 4.</li>
<li>The third card has strength 4, defense 1 and speed 1.</li>
</ul>
<p>There are 10 cards that beat all the cards here:</p>
<ol type="1">
<li>The card with strength 3, defense 3 and speed 5.</li>
<li>The card with strength 3, defense 4 and speed 2.</li>
<li>The card with strength 3, defense 4 and speed 3.</li>
<li>The card with strength 3, defense 4 and speed 4.</li>
<li>The card with strength 3, defense 4 and speed 5.</li>
<li>The card with strength 4, defense 3 and speed 5.</li>
<li>The card with strength 4, defense 4 and speed 2.</li>
<li>The card with strength 4, defense 4 and speed 3.</li>
<li>The card with strength 4, defense 4 and speed 4.</li>
<li>The card with strength 4, defense 4 and speed 5.</li>
</ol>
<p>In the second test case, the maximum possible strength is 10, the maximum possible defense is 10 and the maximum possible speed is 10. Karen has five cards, all with strength 1, defense 1 and speed 1.</p>
<p>Any of the 972 cards which have at least two characteristics greater than 1 can beat all of the cards in her collection.</p>
</div><h2 id="problem">Problem</h2><div class="story post-story">
<p>给定<span class="math inline">\(n\)</span>个三元组<span class="math inline">\((a_i,b_i,c_i)\)</span>，以及三元组中每个数的上限<span class="math inline">\(p,q,r\)</span>，定义一个三元组能击败另一个三元组当且仅当这个三元组中有任意两个数<strong>严格大于</strong>另一个三元组<strong>对应</strong>的两个数。求有多少三元组能击败所有<span class="math inline">\(n\)</span>个三元组。</p>
</div><h2 id="solution">Solution</h2><div class="story post-story">
<p>记满足条件的三元组为<span class="math inline">\((x,y,z)\)</span>。显然如果枚举<span class="math inline">\(x\)</span>，则三元组可以分为两类：<span class="math inline">\(a_i&lt;x\)</span>与<span class="math inline">\(a_i\ge x\)</span>。对于<span class="math inline">\(a_i&lt;x\)</span>的三元组，只需要满足<span class="math inline">\(y&gt;b_i\)</span><strong>或者</strong><span class="math inline">\(z&gt;c_i\)</span>。而对于<span class="math inline">\(a_i\ge x\)</span>的三元组，需要满足<span class="math inline">\(y&gt;b_i\)</span><strong>并且</strong><span class="math inline">\(z&gt;c_i\)</span>。</p>
<p>记<span class="math inline">\(smx_j(j\in [1,q])\)</span>表示<span class="math inline">\(b_i\ge j\)</span>的三元组中最大的<span class="math inline">\(c_i\)</span>，<span class="math inline">\(mx3\)</span>表示<span class="math inline">\(a_i\ge x\)</span>的三元组中最大的<span class="math inline">\(c_i\)</span>。那么<span class="math inline">\(z\)</span>的方案数就是<span class="math inline">\(r-max(smx_y,mx3)\)</span>，即<span class="math inline">\(z\)</span>需要满足<span class="math inline">\(z&gt;smx_y,z&gt;mx3\)</span>，因为对于<span class="math inline">\(a_i\ge x\)</span>的三元组，<span class="math inline">\(z\)</span>一定大于<span class="math inline">\(c_i\)</span>，且对于<span class="math inline">\(b_i\ge y\)</span>的三元组，<span class="math inline">\(z\)</span>也一定大于<span class="math inline">\(c_i\)</span>。</p>
<p>记<span class="math inline">\(mx2\)</span>表示<span class="math inline">\(a_i\ge x\)</span>的三元组中最大的<span class="math inline">\(b_i\)</span>，那么当<span class="math inline">\(x\)</span>固定时，总方案可以用<code>for (int i=mx2+1;i&lt;=q;i++) ans+=r-max(smx[i],mx3);</code>进行统计。</p>
<p>这样的话，因为我们要统计<span class="math inline">\(a_i\ge x\)</span>的三元组中最大的<span class="math inline">\(b_i\)</span>（<span class="math inline">\(mx2\)</span>），最大的<span class="math inline">\(c_i\)</span>（<span class="math inline">\(mx3\)</span>），所以我们应该倒着枚举<span class="math inline">\(x\)</span>。</p>
<p>时间复杂度？<span class="math inline">\(\mathcal O(n^2)\)</span>。显然不能过。</p>
<p>考虑优化<code>for (int i=mx2+1;i&lt;=q;i++) ans+=r-max(smx[i],mx3);</code>这段代码。</p>
<p><span class="math inline">\(max\)</span>很不好处理，我们考虑把它拆开分别计算。由<span class="math inline">\(smx_i\)</span>的定义可得，<span class="math inline">\(\{smx_i\}\)</span>单调不升，也就是<span class="math inline">\(i\)</span>越小，<span class="math inline">\(smx_i\)</span>越大。那么我们找到一个<span class="math inline">\(max\)</span>分界线，记为<span class="math inline">\(k\)</span>，使得<span class="math inline">\(i\ge k\)</span>时，<span class="math inline">\(smx_i\le mx3\)</span>，<span class="math inline">\(i&lt;k\)</span>时，<span class="math inline">\(smx_i&gt;mx3\)</span>。于是就可以<span class="math inline">\(\mathcal O(1)\)</span>计算答案了，用前缀和维护<span class="math inline">\(\{smx_i\}\)</span>的区间和即可。</p>
<p>显然，<span class="math inline">\(\{smx_i\},mx2,mx3\)</span>很容易维护。那么<span class="math inline">\(k\)</span>怎么办呢？因为<span class="math inline">\(x\)</span>从大到小枚举，<span class="math inline">\(mx3\)</span>会逐渐变大，而<span class="math inline">\(\{smx_i\}\)</span>单调不升，所以<span class="math inline">\(k\)</span>慢慢变小（向前），一直维护即可。</p>
<p>一些细节具体见代码。</p>
</div><h2 id="source">Source</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(ch)&amp;&amp;ch!=EOF;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(ch);ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500005</span>;</span><br><span class="line"><span class="keyword">int</span> n,La,Lb,Lc,smx[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">card</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> b,c;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;card&gt; d[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,sum[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),La=<span class="built_in">read</span>(),Lb=<span class="built_in">read</span>(),Lc=<span class="built_in">read</span>(); <span class="comment">//La,Lb,Lc分别代表p,q,r</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">min</span>(La,<span class="built_in">read</span>()),b=<span class="built_in">min</span>(Lb,<span class="built_in">read</span>()),c=<span class="built_in">min</span>(Lc,<span class="built_in">read</span>());</span><br><span class="line">        d[a].<span class="built_in">push_back</span>((card)&#123;b,c&#125;);</span><br><span class="line">        smx[b]=<span class="built_in">max</span>(smx[b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=Lb<span class="number">-1</span>;i;--i) smx[i]=<span class="built_in">max</span>(smx[i],smx[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Lb;++i) sum[i]=sum[i<span class="number">-1</span>]+smx[i]; <span class="comment">//smx[i]的前缀和</span></span><br><span class="line">    <span class="keyword">int</span> mxb=<span class="number">0</span>,mxc=<span class="number">0</span>,k=Lb+<span class="number">1</span>; <span class="comment">//初始值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> x=La;x;--x)&#123; <span class="comment">//从大到小枚举</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d[x].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=d[x][i].b,z=d[x][i].c;</span><br><span class="line">            mxb=<span class="built_in">max</span>(mxb,y),mxc=<span class="built_in">max</span>(mxc,z); <span class="comment">//维护mx2和mx3</span></span><br><span class="line">            <span class="keyword">while</span> (k&gt;mxb+<span class="number">1</span>&amp;&amp;smx[k<span class="number">-1</span>]&lt;mxc) --k; <span class="comment">//维护k</span></span><br><span class="line">        &#125;</span><br><span class="line">        k=<span class="built_in">max</span>(k,mxb+<span class="number">1</span>); <span class="comment">//防止越界</span></span><br><span class="line">        ans+=<span class="number">1ll</span>*(Lc-mxc)*(Lb-k+<span class="number">1</span>)+<span class="number">1ll</span>*Lc*(k-mxb<span class="number">-1</span>)-sum[k<span class="number">-1</span>]+sum[mxb]; <span class="comment">//利用前缀和O(1)统计答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>三维数点</tag>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 599E」Sandy and Nuts</title>
    <url>/cf599e-sol/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/problemset/problem/599/E">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>有一棵<span class="math inline">\(n\)</span>个节点的以1为根的树，有<span class="math inline">\(m\)</span>条边已知，并且有<span class="math inline">\(q\)</span>个限制<span class="math inline">\(a_i,b_i,c_i\)</span>，需要满足<span class="math inline">\(\mathrm{LCA}(a_i,b_i)=c_i\)</span>。求满足条件的树的数量。</p>
<p><span class="math inline">\(m&lt; n\le 13,q\le 100\)</span>。</p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>树形状压DP。DP状态很显然，<span class="math inline">\(dp_{u,mask}\)</span>表示以<span class="math inline">\(u\)</span>为根，由<span class="math inline">\(mask\)</span>这些点组成的子树的方案数。<span class="math inline">\(mask\)</span>是一个二进制状态。</p>
<p>为方便讨论，以下题解和代码节点编号从<span class="math inline">\(0\)</span>开始。</p>
<h3 id="转移方程">转移方程</h3>
<p><span class="math display">\[dp_{u,mask}=\sum dp_{v,submask}\times dp_{u,mask\oplus submask}\]</span></p>
<p><span class="math inline">\(\oplus\)</span>表示的是异或(<span class="math inline">\(xor\)</span>)运算。</p>
<p>但是，我们直接枚举<span class="math inline">\(v,submask\)</span>会有重复，例如一棵二叉树，根为<span class="math inline">\(root\)</span>，左右儿子分别为<span class="math inline">\(leftson,rightson\)</span>。当枚举<span class="math inline">\(v=leftson\)</span>时会计算这棵树，<span class="math inline">\(v=rightson\)</span>时又会计算这棵树，就会出现重复。</p>
<p>所以，我们规定一个点<span class="math inline">\(pos\in mask\ (pos\ne u)\)</span>，强制<span class="math inline">\(pos\)</span>在<span class="math inline">\(submask\)</span>中才能转移。</p>
<h3 id="转移条件">转移条件</h3>
<p>题目中有两种限制条件，分别为边和<span class="math inline">\(\mathrm{LCA}\)</span>。</p>
<ol type="1">
<li>对于<span class="math inline">\(\mathrm{LCA}\)</span>的限制： 1.1. 对于限制<span class="math inline">\((a,b,c)\)</span>，如果<span class="math inline">\(c=u\)</span>，但是<span class="math inline">\(a,b\in submask\)</span>，那么<span class="math inline">\(\mathrm{LCA}\)</span>一定不为<span class="math inline">\(c\)</span>，不满足条件。 1.2. 对于限制<span class="math inline">\((a,b,c)\)</span>， 如果<span class="math inline">\(c\in submask\)</span>，但<span class="math inline">\(a,b\)</span>中有<strong>至少</strong>一个不在<span class="math inline">\(submask\)</span>中，则<span class="math inline">\(\mathrm{LCA}\)</span>一定不为<span class="math inline">\(c\)</span>，不满足条件。</li>
<li>对于边的限制： 2.1. 对于边<span class="math inline">\((x,y)\)</span>，如果<span class="math inline">\(x,y\ne u\)</span>，但是<span class="math inline">\(x,y\)</span>其中一个在<span class="math inline">\(submask\)</span>中，另一个不在，则这条边不可能在树上，不满足条件。 2.2. 如果<span class="math inline">\(u\)</span>与<span class="math inline">\(i\)</span>有边且<span class="math inline">\(i\in submask\)</span>的<span class="math inline">\(i\)</span>的数量大于1，则不可能有满足条件的树，不满足条件。</li>
</ol>
<p>在2.2中，如果这样的<span class="math inline">\(i\)</span>的数量等于1，则转移时<span class="math inline">\(v\)</span>不用枚举，<span class="math inline">\(v\)</span>只能是那个<span class="math inline">\(i\)</span>。否则<span class="math inline">\(v\)</span>需要在<span class="math inline">\(submask\)</span>中枚举。</p>
<h3 id="关于复杂度">关于复杂度</h3>
<p>子集枚举可以用<code>for (register int submask = mask; submask; submask = (submask - 1) &amp; mask)</code>。</p>
<p>此时复杂度并不是<span class="math inline">\(O(4^n)\)</span>，而是<span class="math inline">\(O(3^n)\)</span>，因为每次枚举到的<span class="math inline">\(submask\)</span>一定是<span class="math inline">\(mask\)</span>的子集。状态数为<span class="math inline">\(3^n\)</span>。</p>
<p>因为此时<span class="math inline">\(n\)</span>个数有三种状态：不在<span class="math inline">\(mask\)</span>中，在<span class="math inline">\(mask\)</span>但不在<span class="math inline">\(submask\)</span>中，在<span class="math inline">\(submask\)</span>中。所以是<span class="math inline">\(3^n\)</span>。</p>
<p>所以复杂度为<span class="math inline">\(O(3^nn(n+q+m))\)</span>。</p>
<p>观察代码可以发现这个复杂度非常不满，很多状态和子集是没用的。加上CF的评测机速度，还是可以过的。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<p><a href="http://codeforces.com/problemset/submission/599/45029702">Code</a> 实测93ms</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m, q, edge[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> x, y; &#125; E[<span class="number">15</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> <span class="keyword">int</span> x, y, z; &#125; a[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">15</span>][<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span></span>&#123; <span class="keyword">return</span> s &amp; (<span class="number">1</span> &lt;&lt; x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> mask)</span></span>&#123; <span class="comment">// 用记搜实现</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> &amp;res = dp[u][mask];</span><br><span class="line">    <span class="keyword">if</span> (~res) <span class="keyword">return</span> res;</span><br><span class="line">    res = <span class="number">0</span>, mask -= <span class="number">1</span> &lt;&lt; u;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span> (pos = <span class="number">0</span>; pos &lt; n; ++pos) <span class="keyword">if</span> (<span class="built_in">in</span>(pos, mask)) <span class="keyword">break</span>; <span class="comment">// 强制pos在submask中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> submask = mask; submask; submask = (submask - <span class="number">1</span>) &amp; mask) <span class="comment">// 枚举子集</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">in</span>(pos, submask))&#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">1</span>, v, cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 条件1.1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">                <span class="keyword">if</span> (a[i].z == u &amp;&amp; <span class="built_in">in</span>(a[i].x, submask) &amp;&amp; <span class="built_in">in</span>(a[i].y, submask))</span><br><span class="line">                    &#123; flag = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 条件1.2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">in</span>(a[i].z, submask) &amp;&amp; (!<span class="built_in">in</span>(a[i].x, submask) || !<span class="built_in">in</span>(a[i].y, submask)))</span><br><span class="line">                    &#123; flag = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 条件2.1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">                    <span class="keyword">if</span> (E[i].x != u &amp;&amp; E[i].y != u &amp;&amp; (<span class="built_in">in</span>(E[i].x, submask) ^ <span class="built_in">in</span>(E[i].y, submask)))</span><br><span class="line">                        &#123; flag = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 条件2.2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                <span class="keyword">if</span> (edge[u][i] &amp;&amp; <span class="built_in">in</span>(i, submask))&#123; ++cnt; v = i; &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">1</span>) res += <span class="built_in">dfs</span>(v, submask) * <span class="built_in">dfs</span>(u, mask ^ submask ^ (<span class="number">1</span> &lt;&lt; u));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; n; ++v)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">in</span>(v, submask)) res += <span class="built_in">dfs</span>(v, submask) * <span class="built_in">dfs</span>(u, mask ^ submask ^ (<span class="number">1</span> &lt;&lt; u)); <span class="comment">// 转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;E[i].x, &amp;E[i].y), --E[i].x, --E[i].y, <span class="comment">// 编号从0开始</span></span><br><span class="line">        edge[E[i].x][E[i].y] = edge[E[i].y][E[i].x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z), --a[i].x, --a[i].y, --a[i].z; <span class="comment">// 同上</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) dp[i][<span class="number">1</span> &lt;&lt; i] = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, <span class="built_in">dfs</span>(<span class="number">0</span>, (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状压DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展欧几里得 学习笔记</title>
    <url>/exgcd-notes/</url>
    <content><![CDATA[<h2 id="问题">问题</h2><div class="story post-story">
<p>形式1：求方程<span class="math inline">\(ax+by=c\)</span>的任意一组整数解。</p>
<p>形式2：求同余方程<span class="math inline">\(ax\equiv c\pmod b\)</span>的最小整数解。</p>
<span id="more"></span>
<p>可以发现两种形式的问题可以互相转化。</p>
</div><h2 id="前置技能">前置技能</h2><div class="story post-story">
<p>辗转相除法求gcd</p>
</div><h2 id="求解">求解</h2><div class="story post-story">
<p>根据裴蜀定理，当且仅当<span class="math inline">\(gcd(a,b)|c\)</span>时，原方程有整数解。</p>
<p>所以我们考虑解决方程<span class="math inline">\(ax+by=gcd(a,b)\)</span>，最后同乘<span class="math inline">\(\frac{c}{gcd(a,b)}\)</span>即可。</p>
<p>为方便描述，我们用<span class="math inline">\(\%\)</span>代替<span class="math inline">\(\bmod\)</span>。</p>
<p>有性质<span class="math inline">\(gcd(a,b)=gcd(b,a\%b)\)</span></p>
<p>我们假设已经解出方程<span class="math inline">\(bx&#39;+(a\%b)y&#39;=gcd(b,a\%b)\)</span>，即<span class="math inline">\(bx&#39;+(a\%b)y&#39;=gcd(a,b)\)</span>。</p>
<p>将<span class="math inline">\(a\%b\)</span>展开，得<span class="math inline">\(bx&#39;+(a-\lfloor \frac{a}{b}\rfloor\times b)y&#39;=gcd(a,b)\)</span>。</p>
<p>即<span class="math inline">\(ay&#39;+b(x&#39;-\lfloor \frac{a}{b}\rfloor y&#39;)=gcd(a,b)\)</span>。</p>
<p>令<span class="math inline">\(x=y&#39;,y=x&#39;-\lfloor \frac{a}{b}\rfloor y&#39;\)</span>，我们得到了原方程得一组解。</p>
<p>所以可以递归求解，终止条件是<span class="math inline">\(b=0\)</span>，此时<span class="math inline">\(gcd(a,b)=a\)</span>，方程组的解是<span class="math inline">\(x=1,y=0\)</span>。</p>
<p>求<span class="math inline">\(x\)</span>最小的解：</p>
<p>因为如果<span class="math inline">\((x,y)\)</span>是一组解，则<span class="math inline">\((x+\frac{b}{gcd(a,b)},y-\frac{a}{gcd(a,b)})\)</span>也是一组解，可以根据这个求出最小解。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">    <span class="keyword">int</span> x0, y0, g = <span class="built_in">exgcd</span>(b, a % b, x0, y0);</span><br><span class="line">    <span class="keyword">return</span> x = y0, y = x0 - a / b * y0, g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="keyword">int</span> x, y, g = <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">    <span class="keyword">if</span> (c % g) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Impossible&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    x *= c / g, y *= c / g;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>中国剩余定理 学习笔记</title>
    <url>/crt-notes/</url>
    <content><![CDATA[<h2 id="问题">问题</h2><div class="story post-story">
<p>中国剩余定理用来解决如下问题：</p>
<p>求关于<span class="math inline">\(x\)</span>的方程组</p>
<p><span class="math display">\[\begin{cases} x \equiv a_1 \pmod{p_1} \\ x \equiv a_2 \pmod{p_2} \\ \cdots \\ x \equiv a_n\pmod{p_n}\end{cases}\]</span></p>
<p>的最小非负整数解。</p>
<p><strong>其中<span class="math inline">\(p_i\)</span>两两互质。</strong></p>
<span id="more"></span>
</div><h2 id="前置技能">前置技能</h2><div class="story post-story">
<p>扩展欧几里得求乘法逆元</p>
</div><h2 id="求解">求解</h2><div class="story post-story">
<p>设<span class="math inline">\(M=\prod_{i=1}^{n} p_i,d_i=\frac{M}{p_i}\)</span>，即<span class="math inline">\(d_i\)</span>表示除<span class="math inline">\(p_i\)</span>外所有<span class="math inline">\(p\)</span>的乘积。</p>
<p>记<span class="math inline">\(inv_i\)</span>表示<span class="math inline">\(d_i\)</span>在模<span class="math inline">\(p_i\)</span>域下的逆元（因为<span class="math inline">\(p\)</span>两两互质，所以<span class="math inline">\(d_i\)</span>一定与<span class="math inline">\(p_i\)</span>互质，所以一定存在逆元），即<span class="math inline">\(inv_i \times d_i \equiv 1 \pmod{p_i}\)</span>。记<span class="math inline">\(x_i=inv_i\times d_i\)</span>，则：</p>
<ol type="1">
<li>因为<span class="math inline">\(d_i\)</span>能被除<span class="math inline">\(p_i\)</span>外的所有<span class="math inline">\(p\)</span>整除，所以<span class="math inline">\(x_i\)</span>一定能被除<span class="math inline">\(p_i\)</span>外的所有<span class="math inline">\(p\)</span>整除，所以<span class="math inline">\(x_ia_i\)</span>一定能被除<span class="math inline">\(p_i\)</span>外的所有<span class="math inline">\(p\)</span>整除。</li>
<li><span class="math inline">\(x_i\equiv 1 \pmod{p_i}\)</span>，所以<span class="math inline">\(a_ix_i\equiv a_i \pmod{p_i}\)</span>。</li>
</ol>
<p>根据以上两条推论可得，答案为<span class="math inline">\(\left( \sum_{i=1}^{n} a_ix_i \right) \bmod M\)</span>。因为对于第<span class="math inline">\(i\)</span>个方程，根据推论1，对于所有的<span class="math inline">\(j\ne i\)</span>，<span class="math inline">\(a_jx_j\)</span>不会对该方程组产生贡献，即<span class="math inline">\(a_jx_j\equiv 0 \pmod{p_i} (j\ne i)\)</span>。只有<span class="math inline">\(a_ix_i\)</span>会对第<span class="math inline">\(i\)</span>个方程产生贡献，且根据推论2，恰好会产生<span class="math inline">\(a_i\)</span>的贡献。又因为对于所有<span class="math inline">\(i\)</span>，<span class="math inline">\(M\equiv 0\pmod{p_i}\)</span>，所以答案加上或减去若干个<span class="math inline">\(M\)</span>都满足方程组。求的是最小非负整数解，所以答案<span class="math inline">\(\bmod M\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<p>中国剩余定理模板题：<a href="https://www.luogu.org/problemnew/show/P3868">[TJOI2009]猜数字</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> &amp;x, <span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x0, y0, g = <span class="built_in">exgcd</span>(b, a % b, x0, y0);</span><br><span class="line">    <span class="keyword">return</span> x = y0, y = x0 - a / b * y0, g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">15</span>], p[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, y, g = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">    <span class="keyword">if</span> (g != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qmul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= p, b %= p; b; b &gt;&gt;= <span class="number">1</span>, a = (a + a) % p) b &amp; <span class="number">1</span> ? s = (s + a) % p : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = (a[i] % p[i] + p[i]) % p[i];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> m = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) m = m * p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> d = m / p[i], d_ = <span class="built_in">inv</span>(d, p[i]);</span><br><span class="line">        (ans += <span class="built_in">qmul</span>(<span class="built_in">qmul</span>(d, d_, m), a[i], m)) %= m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title>乘法逆元 学习笔记</title>
    <url>/inv-notes/</url>
    <content><![CDATA[<h2 id="问题">问题</h2><div class="story post-story">
<p>用来解决模域下的除法问题。</p>
</div><h2 id="求解">求解</h2><div class="story post-story">
<p>乘法逆元的定义：<span class="math inline">\(ab\equiv 1 \pmod p\)</span>，则<span class="math inline">\(b\)</span>称为<span class="math inline">\(a\)</span>在模<span class="math inline">\(p\)</span>域下的乘法逆元。乘法逆元不一定存在，存在条件请参见下文。</p>
<span id="more"></span>
<p>这样我们就可以轻松解决模域下的除法问题。即假设我们要求<span class="math inline">\(\frac{a}{b} \bmod p\)</span>的值，用<span class="math inline">\(inv(x)\)</span>表示<span class="math inline">\(x\)</span>在模<span class="math inline">\(p\)</span>域下的乘法逆元，则<span class="math inline">\(\frac{a}{b} \bmod p=\frac{a\cdot b\cdot inv(b)}{b}\bmod p=a\cdot inv(b) \bmod p\)</span>，所以我们把除法变成了乘法，就可以利用乘法在模域下的一些性质对原问题进行求解或转化。</p>
<p>问题在于如何求出<span class="math inline">\(inv(b)\)</span>。求乘法逆元有许多方法。</p>
<h3 id="扩展欧几里得">扩展欧几里得</h3>
<p>根据乘法逆元的定义，我们要求<span class="math inline">\(inv(a)\)</span>，就是求同余方程<span class="math inline">\(ax\equiv 1 \pmod p\)</span>的最小整数解。</p>
<p>考虑将该同余方程转化为一般形式，即<span class="math inline">\(ax+py=1\)</span>。</p>
<p>很容易就能求出<span class="math inline">\(x\)</span>的最小整数解。</p>
<p>根据裴蜀定理可知，方程<span class="math inline">\(ax+by=c\)</span>只有当<span class="math inline">\(gcd(a,b)|c\)</span>时才有整数解。所以<strong>只有当<span class="math inline">\(gcd(a,p)=1\)</span>时，逆元才唯一存在</strong>。</p>
<h3 id="费马小定理">费马小定理</h3>
<p>费马小定理：当<span class="math inline">\(p\)</span>是质数时，<span class="math inline">\(a^{p-1}\equiv 1 \pmod p\)</span>。即<span class="math inline">\(a\cdot a^{p-2}\equiv 1\pmod p\)</span>。所以<span class="math inline">\(inv(a)=a^{p-2}\)</span>。</p>
<h3 id="欧拉定理">欧拉定理</h3>
<p>欧拉定理：当<span class="math inline">\(a,p\)</span>互质时，<span class="math inline">\(a^{\varphi(p)}\equiv 1 \pmod p\)</span>。即<span class="math inline">\(a\cdot a^{\varphi(p)-1}\equiv 1\pmod p\)</span>。所以<span class="math inline">\(inv(a)=a^{\varphi(p)-1}\)</span>。</p>
<p><span class="math inline">\(\varphi(p)\)</span>即欧拉函数，表示小于等于<span class="math inline">\(p\)</span>的正整数中，与<span class="math inline">\(p\)</span>互质的数的个数。</p>
<p>因为当<span class="math inline">\(p\)</span>是质数时，<span class="math inline">\(\varphi(p)=p-1\)</span>，所以费马小定理是欧拉定理的特殊形式。</p>
<p><span class="math inline">\(\varphi(p)\)</span>的求法不详细介绍。</p>
<h3 id="特例">特例</h3>
<p>还有一些奇怪的特例，例如求<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>所有数在模<span class="math inline">\(p\)</span>域下的逆元，还有<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>所有数的阶乘在模<span class="math inline">\(p\)</span>域下的逆元，这些可以<span class="math inline">\(O(n)\)</span>求出。</p>
<p>不详细介绍。</p>

</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>线性递推求1~n的逆元 学习笔记</title>
    <url>/linear-inv-notes/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3811">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>求<span class="math inline">\(1\sim n\)</span>中所有整数在模<span class="math inline">\(p\)</span>意义下的乘法逆元。</p>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>设<span class="math inline">\(a=\left\lfloor\frac{P}{i}\right\rfloor,b=P\bmod i\)</span>，则<span class="math inline">\(ai+b=P\)</span></p>
<p>即<span class="math inline">\(ai+b\equiv 0 \pmod P\)</span></p>
<span id="more"></span>
<p><span class="math display">\[\begin{align*} &amp;\therefore \frac{ai+b}{ib}\equiv 0 \pmod P \\ &amp;\therefore ab^{-1}+i^{-1}\equiv 0 \pmod P \\ &amp;\therefore\ i^{-1}\equiv -ab^{-1} \pmod P  \end{align*}\]</span></p>
<p>即<span class="math display">\[inv(i)=\left(P-\left\lfloor\frac{P}{i}\right\rfloor\right)\cdot inv(P\bmod i)\bmod P\]</span></p>
<p>于是<span class="math inline">\(O(n)\)</span>递推求一下就可以了。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, P, inv[<span class="number">3000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">10</span>) <span class="built_in">putchar</span>(x + <span class="number">48</span>); <span class="keyword">else</span> <span class="built_in">print</span>(x / <span class="number">10</span>), <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;P);</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) inv[i] = <span class="number">1ll</span> * (P - P / i) * inv[P % i] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">print</span>(inv[i]), <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>「LOJ 6059」「2017 山东一轮集训 Day1」Sum</title>
    <url>/loj6059-sol/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/6059">LOJ 6059</a></p>
<span id="more"></span>
<h2 id="题解">题解</h2><div class="story post-story">
<p>一眼 DP。并且很显然可以倍增优化。<span class="math inline">\(dp_{i,j,k}\)</span> 表示 <span class="math inline">\(2^i\)</span> 位，数字之和<strong>恰好</strong>为 <span class="math inline">\(j\)</span>，模 <span class="math inline">\(p\)</span> 为 <span class="math inline">\(k\)</span> 时的方案数。有如下转移：</p>
<p><span class="math display">\[dp_{i,j,k}=\sum_{j_1+j_2=j}\sum_{k_1\times 10^{2^{i-1}}+k_2\equiv k\pmod p}dp_{i-1,j_1,k_1}\times dp_{i-1,j_2,k_2}\]</span></p>
<p>直接这样做是 <span class="math inline">\(O(p^2m^2\log n)\)</span> 的。</p>
<p>只考虑 <span class="math inline">\(j\)</span> 这一维，很显然可以用 FFT 优化，于是复杂度变为 <span class="math inline">\(O(p^2m\log m\log n)\)</span>，但是常数较大，比较难卡过。</p>
<p>如果我们记</p>
<p><span class="math display">\[tmp_{j,k}=\sum_{t\times 10^{2^{i-1}}\equiv k\pmod p} dp_{i-1,j,t}\]</span></p>
<p>则原式变成了</p>
<p><span class="math display">\[dp_{i,j,k}=\sum_{j_1+j_2=j}\sum_{(k_1+k_2)\bmod p=k}tmp_{j_1,k_1}\times dp_{i-1,j_2,k_2}\]</span></p>
<p>然而这个 <span class="math inline">\(\bmod\)</span> 还是不太舒服，我们考虑把第二维值域扩充到 <span class="math inline">\([0,2p)\)</span>，然后再把 <span class="math inline">\([p,2p)\)</span> 这部分加到 <span class="math inline">\([0,p)\)</span>。则式子变得十分美观：</p>
<p><span class="math display">\[dp_{i,j,k}=\sum_{j_1+j_2=j}\sum_{k_1+k_2=k}tmp_{j_1,k_1}\times dp_{i-1,j_2,k_2}\]</span></p>
<p>我们把 <span class="math inline">\(j,k\)</span> 两维拍到一起，发现这个式子仍然是个卷积的形式。于是直接用 FFT 优化。</p>
<p>时间复杂度 <span class="math inline">\(O(mp\log (mp)\log n)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 70005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 998244353</span></span><br><span class="line"><span class="keyword">int</span> n, p, m, pw[<span class="number">35</span>], dp[<span class="number">35</span>][N], s[N], tmp[N], len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    (x += y) &gt;= P ? x -= P : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x += y) &gt;= P ? x - P : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x -= y) &lt; <span class="number">0</span> ? x + P : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = P - <span class="number">2</span>, <span class="keyword">int</span> p = P)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1ll</span> * a * a % p) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1ll</span> * s * a % p;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number_Theory_Transform</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, rev[N], omega[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        n = m;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) &lt; n) ++k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) rev[i] = rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (i &amp; <span class="number">1</span>) &lt;&lt; k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) i &lt; rev[i] ? std :: <span class="built_in">swap</span>(a[i], a[rev[i]]), <span class="number">0</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> l = m &lt;&lt; <span class="number">1</span>, omega1 = <span class="built_in">qpow</span>(o == <span class="number">1</span> ? <span class="number">3</span> : <span class="number">332748118</span>, (P - <span class="number">1</span>) / l);</span><br><span class="line">            omega[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) omega[i] = <span class="number">1ll</span> * omega[i - <span class="number">1</span>] * omega1 % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span>* p = a; p &lt; a + n; p += l)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">                    <span class="keyword">register</span> <span class="keyword">int</span> t = <span class="number">1ll</span> * omega[i] * p[m + i] % P;</span><br><span class="line">                    p[m + i] = <span class="built_in">del</span>(p[i], t), <span class="built_in">upd</span>(p[i], t);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> _n = <span class="built_in">qpow</span>(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = <span class="number">1ll</span> * a[i] * _n % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> na, <span class="keyword">int</span> *A, <span class="keyword">int</span> nb, <span class="keyword">int</span> *B, <span class="keyword">int</span> *C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (na &lt;= <span class="number">20</span> &amp;&amp; nb &lt;= <span class="number">20</span>)&#123;</span><br><span class="line">        n = std :: <span class="built_in">max</span>(na, nb);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) C[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; na; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nb; ++j)</span><br><span class="line">                <span class="keyword">if</span> (i + j &lt; n) <span class="built_in">upd</span>(C[i + j], <span class="number">1ll</span> * A[i] * B[j] % P);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a[N], b[N];</span><br><span class="line">    n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; na + nb - <span class="number">1</span>) n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; na; ++i) a[i] = A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nb; ++i) b[i] = B[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = na; i &lt; n; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = nb; i &lt; n; ++i) b[i] = <span class="number">0</span>;</span><br><span class="line">    T.<span class="built_in">init</span>(n), T.<span class="built_in">NTT</span>(a, <span class="number">1</span>), T.<span class="built_in">NTT</span>(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = <span class="number">1ll</span> * a[i] * b[i] % P;</span><br><span class="line">    T.<span class="built_in">NTT</span>(a, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; std :: <span class="built_in">max</span>(na, nb); ++i) C[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;p, &amp;m);</span><br><span class="line">    len = (m + <span class="number">1</span>) * p * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span> &amp;&amp; i &lt;= m; ++i) ++dp[<span class="number">0</span>][i * p * <span class="number">2</span> + i % p];</span><br><span class="line">    pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i) pw[i] = pw[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++i) pw[i] = <span class="built_in">qpow</span>(<span class="number">10</span>, pw[i], p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) tmp[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p; ++k)</span><br><span class="line">                <span class="built_in">upd</span>(tmp[j * p * <span class="number">2</span> + <span class="number">1ll</span> * k * pw[i] % p], dp[i][j * p * <span class="number">2</span> + k]);</span><br><span class="line">        <span class="built_in">multiply</span>(len, tmp, len, dp[i], dp[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p; ++k)</span><br><span class="line">                <span class="built_in">upd</span>(dp[i + <span class="number">1</span>][j * p * <span class="number">2</span> + k], dp[i + <span class="number">1</span>][j * p * <span class="number">2</span> + k + p]), dp[i + <span class="number">1</span>][j * p * <span class="number">2</span> + k + p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">30</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) tmp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p; ++k)</span><br><span class="line">                    <span class="built_in">upd</span>(tmp[j * p * <span class="number">2</span> + <span class="number">1ll</span> * k * pw[i] % p], s[j * p * <span class="number">2</span> + k]), s[j * p * <span class="number">2</span> + k] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">multiply</span>(len, tmp, len, dp[i], s);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p; ++k)</span><br><span class="line">                    <span class="built_in">upd</span>(s[j * p * <span class="number">2</span> + k], s[j * p * <span class="number">2</span> + k + p]), s[j * p * <span class="number">2</span> + k + p] = <span class="number">0</span>;</span><br><span class="line">            n -= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) <span class="built_in">upd</span>(sum, s[i * p * <span class="number">2</span>]), <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>FFT</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>「LOJ 6060」「2017 山东一轮集训 Day1 / SDWC2018 Day1」Set</title>
    <url>/loj6060-sol/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/6060">LOJ 6060</a></p>
<span id="more"></span>
<h2 id="题解">题解</h2><div class="story post-story">
<p>我们发现，<span class="math inline">\(x_1\text{ xor }x_2\)</span> 的值是固定的，也就是整个集合的异或和，我们记为 <span class="math inline">\(s\)</span>。</p>
<p>很显然 <span class="math inline">\(x_1+x_2\ge s\)</span>，我们把 <span class="math inline">\(x_1+x_2-s\)</span> 的值叫做“差值”。显然我们需要使差值最大化。</p>
<p>考虑 <span class="math inline">\(s\)</span> 第 <span class="math inline">\(i\)</span> 位（从右往左，从 <span class="math inline">\(0\)</span> 开始标号，下同），若是 <span class="math inline">\(1\)</span>，则 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 的这一位上有且仅有一个 <span class="math inline">\(1\)</span>，那么显然对差值的贡献为 <span class="math inline">\(0\)</span>；否则，<span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 的这一位要么都是 <span class="math inline">\(0\)</span>，要么都是 <span class="math inline">\(1\)</span>，显然最好是两个都为 <span class="math inline">\(1\)</span>，那么会对差值产生 <span class="math inline">\(2^{i+1}\)</span> 的贡献。</p>
<p>题目同时又规定，需要在最大化 <span class="math inline">\(x_1+x_2\)</span> 的前提下，最小化 <span class="math inline">\(x_1\)</span>，也就是要最大化 <span class="math inline">\(x_2\)</span>。</p>
<p>自然想到线性基。通常我们在线性基中插入、查询时直接从最高位遍历到最低位，因为我们可以认为高位的优先级高于低位。</p>
<p>但是，在本题中，由于要优先最大化差值，所以我们需要先最大化 <span class="math inline">\(x_2\)</span> 的所有在 <span class="math inline">\(s\)</span> 中为 <span class="math inline">\(0\)</span> 的那些位置。</p>
<p>于是，我们在插入、查询时，强制这些位置的优先级高于其他位置，而内部仍然按照从高位到低位的顺序进行遍历。这样就能保证先最大化差值，在这个前提下最大化 <span class="math inline">\(x_2\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum, a[N], b[<span class="number">65</span>], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">60</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (!(sum &gt;&gt; i &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!b[i]) <span class="keyword">return</span> b[i] = x, <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">                x ^= b[i];</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">60</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!b[i]) <span class="keyword">return</span> b[i] = x, <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">                x ^= b[i];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">read</span>(), sum ^= a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">60</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (!(sum &gt;&gt; i &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> (!(ans &gt;&gt; i &amp; <span class="number">1</span>))</span><br><span class="line">                ans ^= b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">60</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!(ans &gt;&gt; i &amp; <span class="number">1</span>))</span><br><span class="line">                ans ^= b[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum ^ ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>「LOJ 6062」「2017 山东一轮集训 Day2」Pair</title>
    <url>/loj6062-sol/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/6062">LOJ 6062</a></p>
<span id="more"></span>
<h2 id="题解">题解</h2><div class="story post-story">
<p>我们令 <span class="math inline">\(c_i=h-b_i\)</span>，并将序列 <span class="math inline">\(c\)</span> 从小到大排序。我们遍历 <span class="math inline">\(a\)</span> 的所有长度为 <span class="math inline">\(m\)</span> 的区间，将这个区间中的数从小到大排序后的第 <span class="math inline">\(i\)</span> 个数记为 <span class="math inline">\(d_i\)</span>。一个区间满足题目中的条件当且仅当 <span class="math inline">\(d_i\ge c_i\)</span>。</p>
<p>考虑离散，然后用权值线段树维护。记最大值为 <span class="math inline">\(t\)</span>，对于所有 <span class="math inline">\(c_i\)</span>，把线段树上 <span class="math inline">\([c_i,t]\)</span> 这段区间加 <span class="math inline">\(1\)</span>；对于当前区间中的所有 <span class="math inline">\(a_i\)</span>，把线段树上 <span class="math inline">\([a_i,t]\)</span> 这段区间减 <span class="math inline">\(1\)</span>，判断是否满足条件只需要判断线段树上是否有 <span class="math inline">\(&lt; 0\)</span> 的位置即可，这个可以维护最小值判断。正确性显然。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300005</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val[N &lt;&lt; <span class="number">2</span>], lz[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        val[u] = std :: <span class="built_in">min</span>(val[u &lt;&lt; <span class="number">1</span>], val[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        lz[u] += x, val[u] += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lz[u]) <span class="built_in">add</span>(u &lt;&lt; <span class="number">1</span>, lz[u]), <span class="built_in">add</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, lz[u]), lz[u] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">add</span>(u, x), <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> md = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">down</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= md) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, md, L, R, x);</span><br><span class="line">        <span class="keyword">if</span> (R &gt; md) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, md + <span class="number">1</span>, r, L, R, x);</span><br><span class="line">        <span class="built_in">up</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> val[<span class="number">1</span>] &gt;= <span class="number">0</span>; &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="keyword">int</span> n, m, h, a[N], b[N], t, c[N], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), h = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) b[i] = h - <span class="built_in">read</span>(), c[++t] = b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">read</span>(), c[++t] = a[i];</span><br><span class="line">    std :: <span class="built_in">sort</span>(c + <span class="number">1</span>, c + <span class="number">1</span> + t);</span><br><span class="line">    t = std :: <span class="built_in">unique</span>(c + <span class="number">1</span>, c + <span class="number">1</span> + t) - c - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        b[i] = std :: <span class="built_in">lower_bound</span>(c + <span class="number">1</span>, c + <span class="number">1</span> + t, b[i]) - c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = std :: <span class="built_in">lower_bound</span>(c + <span class="number">1</span>, c + <span class="number">1</span> + t, a[i]) - c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        T.<span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, t, b[i], t, <span class="number">1</span>), T.<span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, t, a[i], t, <span class="number">-1</span>);</span><br><span class="line">    ans = T.<span class="built_in">query</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        T.<span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, t, a[i], t, <span class="number">-1</span>), T.<span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, t, a[i - m], t, <span class="number">1</span>), ans += T.<span class="built_in">query</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>离散</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>「LOJ 6065」「2017 山东一轮集训 Day3」第一题</title>
    <url>/loj6065-sol/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/6065">LOJ 6065</a></p>
<span id="more"></span>
<h2 id="题解">题解</h2><div class="story post-story">
<p>总的分为两种情况：<span class="math inline">\(1+1+2+2\)</span> 和 <span class="math inline">\(1+1+1+3\)</span>。</p>
<p>对于第一种情况，我们假设边长为 <span class="math inline">\(k\)</span>，<span class="math inline">\(6\)</span> 根棒子长度为 <span class="math inline">\(k,k,x_1,k-x_1,x_2,k-x_2\)</span>，并且强制 <span class="math inline">\(x_1\ge x_2\ge k-x_2\ge k-x_1\)</span>。</p>
<p>我们记 <span class="math inline">\(cnt_i\)</span> 表示长度为 <span class="math inline">\(i\)</span> 的棒子的数量，我们从小到大枚举 <span class="math inline">\(x_1\)</span>，同时维护 <span class="math inline">\(cntt_i\)</span> 表示在长度小于 <span class="math inline">\(x_1\)</span> 的棒子中选出两根拼成长度为 <span class="math inline">\(i\)</span> 的方案数。</p>
<p>具体计算的时候，为了避免算重，我们分三种情况进行计算：</p>
<ol type="1">
<li><span class="math inline">\(x_1 &gt; x_2 &gt; k-x_2 &gt; k-x_1\)</span>，枚举 <span class="math inline">\(k\)</span>，方案数为 <span class="math inline">\(cnt_{x_1}\times cnt_{k-x_1}\times cntt_{k}\times C_{cnt_k}^2\)</span>；</li>
<li><span class="math inline">\(x_1 = x_2 &gt; k-x_2 = k-x_1\)</span>，同样枚举 <span class="math inline">\(k\)</span>，方案数为 <span class="math inline">\(C_{cnt_{x_1}}^2\times C_{cnt_{k-x_1}}^2\times C_{cnt_k}^2\)</span>；</li>
<li><span class="math inline">\(x_1 = x_2 = k-x_2 = k-x_1\)</span>，此时 <span class="math inline">\(k=2x_1\)</span>，方案数为 <span class="math inline">\(C_{cnt_{x_1}}^4\times C_{cnt_{2x_1}}^2\)</span>。</li>
</ol>
<p>对于第二种情况，假设棒子长度为 <span class="math inline">\(k,k,k,x_1,x_2,k-x_1-x_2\)</span>，强制 <span class="math inline">\(x_1\ge x_2\ge k-x_1-x_2\)</span>。</p>
<p>同样记录 <span class="math inline">\(cnt_i\)</span>，然后从小到大枚举 <span class="math inline">\(x_1\)</span>，同时记录 <span class="math inline">\(cntt_i\)</span>。</p>
<p>也分为三种情况：</p>
<ol type="1">
<li><span class="math inline">\(x_1 &gt; x_2 &gt; k-x_1-x_2\)</span>，枚举 <span class="math inline">\(k\)</span>，方案数为 <span class="math inline">\(cnt_{x_1}\times cntt_{k-x_1}\times C_{cnt_k}^3\)</span>；</li>
<li><span class="math inline">\(x_1 = x_2 &gt; k-x_1-x_2\)</span>，枚举 <span class="math inline">\(k\)</span>，方案数为 <span class="math inline">\(C_{cnt_{x_1}}^2\times cnt_{k-2x_1}\times C_{cnt_k}^3\)</span>；</li>
<li><span class="math inline">\(x_1 = x_2 = k-x_1-x_2\)</span>，此时 <span class="math inline">\(k=3x_1\)</span>，方案数为 <span class="math inline">\(C_{cnt_{x_1}}^3\times C_{cnt_{3x_1}}^3\)</span>。</li>
</ol>
<p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = <span class="built_in">getchar</span>(), f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10000005</span></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], cnt[M], cntt[M];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123; <span class="keyword">return</span> x &lt; <span class="number">2</span> ? <span class="number">0</span> : x * (x - <span class="number">1</span>) / <span class="number">2</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C3</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123; <span class="keyword">return</span> x &lt; <span class="number">3</span> ? <span class="number">0</span> : x * (x - <span class="number">1</span>) * (x - <span class="number">2</span>) / <span class="number">6</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C4</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123; <span class="keyword">return</span> x &lt; <span class="number">4</span> ? <span class="number">0</span> : x * (x - <span class="number">1</span>) * (x - <span class="number">2</span>) * (x - <span class="number">3</span>) / <span class="number">24</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">read</span>(), ++cnt[a[i]];</span><br><span class="line">    std :: <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    m = a[n];</span><br><span class="line">    n = std :: <span class="built_in">unique</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n) - a - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n &amp;&amp; a[j] - a[i] &lt; a[i]; ++j)</span><br><span class="line">            ans += <span class="number">1ll</span> * cntt[a[j]] * cnt[a[i]] * cnt[a[j] - a[i]] * <span class="built_in">C2</span>(cnt[a[j]]),</span><br><span class="line">            ans += <span class="number">1ll</span> * <span class="built_in">C2</span>(cnt[a[i]]) * <span class="built_in">C2</span>(cnt[a[j] - a[i]]) * <span class="built_in">C2</span>(cnt[a[j]]);</span><br><span class="line">        <span class="keyword">if</span> (a[i] * <span class="number">2</span> &lt;= m) ans += <span class="number">1ll</span> * <span class="built_in">C4</span>(cnt[a[i]]) * <span class="built_in">C2</span>(cnt[a[i] * <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">            ans += <span class="number">1ll</span> * <span class="built_in">C3</span>(cnt[a[j]]) * cnt[a[i]] * cntt[a[j] - a[i]];</span><br><span class="line">            <span class="keyword">if</span> ((a[i] &lt;&lt; <span class="number">1</span>) &lt; a[j] &amp;&amp; a[j] &lt; a[i] * <span class="number">3</span>)</span><br><span class="line">                ans += <span class="number">1ll</span> * <span class="built_in">C3</span>(cnt[a[j]]) * <span class="built_in">C2</span>(cnt[a[i]]) * cnt[a[j] - (a[i] &lt;&lt; <span class="number">1</span>)];</span><br><span class="line">            <span class="keyword">if</span> (a[j] == a[i] * <span class="number">3</span>) ans += <span class="number">1ll</span> * <span class="built_in">C3</span>(cnt[a[j]]) * <span class="built_in">C3</span>(cnt[a[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[i] + a[j] &lt;= m) cntt[a[i] + a[j]] += cnt[a[i]] * cnt[a[j]];</span><br><span class="line">        <span class="keyword">if</span> ((a[i] &lt;&lt; <span class="number">1</span>) &lt;= m) cntt[a[i] &lt;&lt; <span class="number">1</span>] += <span class="built_in">C2</span>(cnt[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「LOJ 6066」「2017 山东一轮集训 Day3」第二题</title>
    <url>/loj6066-sol/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/6066">LOJ 6066</a></p>
<span id="more"></span>
<h2 id="题解">题解</h2><div class="story post-story">
<p>答案具有单调性，于是二分 <span class="math inline">\(k\)</span>，问题转化成：</p>
<blockquote>
<p>是否存在两个点 <span class="math inline">\(u,v\)</span> 满足 <span class="math inline">\(u\)</span> 的 <span class="math inline">\(k-\)</span> 子树与 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(k-\)</span> 子树形态相同。</p>
</blockquote>
<p>解决这样的问题可以使用哈希，那么我们需要找到一种哈希的方式使得“形态”相同的树的哈希值相同，“形态”不同的树的哈希值不同。</p>
<p>由于节点标号与树的形态无关，儿子的顺序与树的形态有关，容易想到括号序列。于是问题变成：</p>
<blockquote>
<p>在以 <span class="math inline">\(u\)</span> 为根的子树对应的括号序列中，删去所有与 <span class="math inline">\(u\)</span> 距离 <span class="math inline">\(k+1\)</span> 的点为根的子树对应的括号序列后，求哈希值。</p>
</blockquote>
<p>由于每个点只会在 <span class="math inline">\(k+1\)</span> 级祖先处被遍历，所以求所有 <span class="math inline">\(k-\)</span> 子树的哈希值是 <span class="math inline">\(O(n)\)</span> 的。</p>
<p>求每个点的 <span class="math inline">\(k+1\)</span> 级祖先可以使用倍增做到 <span class="math inline">\(O(n\log n)\)</span> 或用长链剖分做到 <span class="math inline">\(O(n)\)</span>。</p>
<p>总时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<p>我使用了双哈希 + set 的方式进行判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Double_Hash&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>, B1 = <span class="number">233</span>, P1 = <span class="number">382538579</span>, B2 = <span class="number">331</span>, P2 = <span class="number">952959323</span>;</span><br><span class="line">    <span class="keyword">int</span> pw1[N], pw2[N];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> H1, H2;</span><br><span class="line">        <span class="built_in">node</span>(<span class="keyword">int</span> _H1 = <span class="number">0</span>, <span class="keyword">int</span> _H2 = <span class="number">0</span>)&#123; H1 = _H1, H2 = _H2; &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> H1 == rhs.H1 &amp;&amp; H2 == rhs.H2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> H1 &lt; rhs.H1 || (H1 == rhs.H1 &amp;&amp; H2 &lt; rhs.H2);</span><br><span class="line">        &#125;</span><br><span class="line">        node <span class="keyword">operator</span> + (<span class="keyword">const</span> <span class="keyword">char</span> ch) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">node</span>((<span class="number">1ll</span> * H1 * B1 + ch) % P1, (<span class="number">1ll</span> * H2 * B2 + ch) % P2);</span><br><span class="line">        &#125;</span><br><span class="line">        node <span class="keyword">operator</span> + (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">node</span>((H1 + rhs.H1) % P1, (H2 + rhs.H2) % P2);</span><br><span class="line">        &#125;</span><br><span class="line">        node <span class="keyword">operator</span> - (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">node</span>((H1 - rhs.H1 + P1) % P1, (H2 - rhs.H2 + P2) % P2);</span><br><span class="line">        &#125;</span><br><span class="line">        node <span class="keyword">operator</span> &lt;&lt; (<span class="keyword">const</span> <span class="keyword">int</span> x) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">node</span>(<span class="number">1ll</span> * H1 * pw1[x] % P1, <span class="number">1ll</span> * H2 * pw2[x] % P2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;h[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n = N - <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        pw1[<span class="number">0</span>] = <span class="number">1</span>, pw2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            pw1[i] = <span class="number">1ll</span> * pw1[i - <span class="number">1</span>] * B1 % P1, pw2[i] = <span class="number">1ll</span> * pw2[i - <span class="number">1</span>] * B2 % P2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">node <span class="title">hash</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h[r] - (h[l - <span class="number">1</span>] &lt;&lt; (r - l + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) h[i] = h[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Double_Hash;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n, fa[N][<span class="number">20</span>], idx, l[N], r[N], dis[N];</span><br><span class="line"><span class="keyword">char</span> a[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">std :: vector&lt;<span class="keyword">int</span>&gt; son[N], po[N];</span><br><span class="line">std :: set&lt;node&gt; S;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dis[u] = <span class="number">0</span>, l[u] = ++idx, a[idx] = <span class="number">23</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; ++i)</span><br><span class="line">        fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; son[u].<span class="built_in">size</span>(); ++i)</span><br><span class="line">        v = son[u][i], fa[v][<span class="number">0</span>] = u, <span class="built_in">dfs</span>(v), dis[u] = std :: <span class="built_in">max</span>(dis[u], dis[v] + <span class="number">1</span>);</span><br><span class="line">    r[u] = ++idx, a[idx] = <span class="number">97</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth_fa</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">18</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (k &gt;&gt; i &amp; <span class="number">1</span>) u = fa[u][i];</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) po[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        po[i].<span class="built_in">push_back</span>(l[i]), po[i].<span class="built_in">push_back</span>(r[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">kth_fa</span>(i, k + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) po[p].<span class="built_in">push_back</span>(l[i]), po[p].<span class="built_in">push_back</span>(r[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        std :: <span class="built_in">sort</span>(po[i].<span class="built_in">begin</span>(), po[i].<span class="built_in">end</span>());</span><br><span class="line">    S.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (dis[i] &gt;= k)&#123;</span><br><span class="line">            node tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; po[i].<span class="built_in">size</span>(); j += <span class="number">2</span>)</span><br><span class="line">                tmp = (tmp &lt;&lt; (po[i][j + <span class="number">1</span>] - po[i][j])) + <span class="built_in">hash</span>(po[i][j], po[i][j + <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (S.<span class="built_in">count</span>(tmp)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            S.<span class="built_in">insert</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) son[i].<span class="built_in">push_back</span>(<span class="built_in">read</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pre</span>(n &lt;&lt; <span class="number">1</span>), <span class="built_in">build</span>(a, n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n, md, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) <span class="keyword">if</span> (<span class="built_in">check</span>(md = (l + r) &gt;&gt; <span class="number">1</span>)) l = md + <span class="number">1</span>, ans = md; <span class="keyword">else</span> r = md - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>括号序列</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>「LOJ 6073」「2017 山东一轮集训 Day5」距离</title>
    <url>/loj6073-sol/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/6073">LOJ 6073</a></p>
<span id="more"></span>
<h2 id="题解">题解</h2><div class="story post-story">
<p>建议先做下这题的弱弱弱弱弱化版：<a href="https://loj.ac/problem/2558">LOJ #2558. 「LNOI2014」LCA</a>。</p>
<p>设 <span class="math inline">\(dis_i\)</span> 表示根到 <span class="math inline">\(i\)</span> 的路径上的边权之和，<span class="math inline">\(dep_i\)</span> 表示根到 <span class="math inline">\(i\)</span> 的路径上的点数，答案可以表示成</p>
<p><span class="math display">\[\begin{aligned}\sum_{i\in \text{path}(u,v)}\text{dist}(p_i,k)&amp;=\sum_{i\in \text{path}(u,v)} \left(dis_{p_i}+dis_k-2dis_{\text{LCA}(p_i,k)}\right)\\&amp;=\left(dep_u+dep_v-2dep_{\text{LCA}(u,v)}+1\right)dis_k\\&amp;+\sum_{i\in \text{path}(u,v)} dis_{p_i}-2\sum_{i\in \text{path}(u,v)}dis_{\text{LCA}(p_i,k)}\end{aligned}\]</span></p>
<p>这个式子的第一项可以在预处理 <span class="math inline">\(dep_i,dis_i\)</span> 后快速计算，第二项可以预处理根到 <span class="math inline">\(i\)</span> 的路径上所有 <span class="math inline">\(dis_j\)</span> 之和（记为 <span class="math inline">\(sumd_i\)</span>）然后快速计算，关键是最后一项，即计算</p>
<p><span class="math display">\[\sum_{i\in \text{path}(u,v)}dis_{\text{LCA}(p_i,k)}\]</span></p>
<p>的值。</p>
<p>联系 <a href="https://loj.ac/problem/2558">LOJ #2558. 「LNOI2014」LCA</a> 的做法，我们有了一个初步的暴力做法：</p>
<p>我们设 <span class="math inline">\(w_i\)</span> 表示 <span class="math inline">\(i\)</span> 与它父亲的边的边权，对于 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 路径上的每个点 <span class="math inline">\(i\)</span>，我们把 <span class="math inline">\(p_i\)</span> 到根的路径上所有点 <span class="math inline">\(j\)</span> 的“点权”加 <span class="math inline">\(w_j\)</span>，某个点的“点权”初始为 <span class="math inline">\(0\)</span>。然后，我们查询根到 <span class="math inline">\(k\)</span> 路径上所有点的“点权和”，这个值即为上面式子的值。</p>
<p>考虑优化这个暴力。与 <a href="https://loj.ac/problem/2558">LOJ #2558. 「LNOI2014」LCA</a> 相似，我们可以差分。我们把 <span class="math inline">\(p_i\)</span> 到根的路径上所有点 <span class="math inline">\(j\)</span> 的“点权”加 <span class="math inline">\(w_j\)</span> 这样的一次操作叫做对点 <span class="math inline">\(i\)</span> 的一次操作。那么显然答案可以差分成对 <span class="math inline">\(u\)</span> 到根路径上每个点进行一次操作后的 <span class="math inline">\(k\)</span> 到根路径上的“点权”和，加上对 <span class="math inline">\(v\)</span> 到根路径上每个点进行一次操作后的 <span class="math inline">\(k\)</span> 到根路径上的“点权”和，减去对 <span class="math inline">\(\text{LCA}(u,v)\)</span> 到根路径上每个点进行一次操作后的 <span class="math inline">\(k\)</span> 到根路径上的“点权”和，减去对 <span class="math inline">\(\text{LCA}(u,v)\)</span> 的父亲到根路径上每个点进行一次操作后的 <span class="math inline">\(k\)</span> 到根路径上的“点权”和。注意上面四个操作都是在初始状态下进行的，并不是从上一个操作继承下来的。</p>
<p>四个操作我们可以对每个节点维护一棵线段树，第 <span class="math inline">\(i\)</span> 个点的线段树维护对 <span class="math inline">\(i\)</span> 到根路径上每个点进行一次操作后的区间的“点权”之和，注意这里的区间是指树剖后 DFS 序上的区间。求 <span class="math inline">\(k\)</span> 到根路径上的点权和可以树链剖分后在线段树上 <span class="math inline">\(O(\log^2n)\)</span> 得到。每个点的线段树可以从它父亲那里继承过来，即可持久化线段树，注意这里需要支持可持久化的区间修改、区间查询，线段树的写法与普通线段树有一些区别。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">int</span> type, n, q, p[N];</span><br><span class="line"><span class="keyword">int</span> edge, to[N &lt;&lt; <span class="number">1</span>], tw[N &lt;&lt; <span class="number">1</span>], pr[N &lt;&lt; <span class="number">1</span>], hd[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    to[++edge] = v, tw[edge] = w, pr[edge] = hd[u], hd[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[N], pre[N], sumd[N], ans;</span><br><span class="line"><span class="keyword">int</span> fa[N], sz[N], dep[N], son[N], top[N], idx, dfn[N], id[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dep[u] = dep[fa[u]] + <span class="number">1</span>, sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa[u])</span><br><span class="line">            fa[v] = u, dis[v] = dis[u] + tw[i], <span class="built_in">dfs</span>(v), sz[u] += sz[v], </span><br><span class="line">            !son[u] || sz[v] &gt; sz[son[u]] ? son[u] = v : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp, dfn[u] = ++idx, id[idx] = u, pre[idx] = dis[u] - dis[fa[u]];</span><br><span class="line">    <span class="keyword">if</span> (son[u]) <span class="built_in">dfs</span>(son[u], tp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa[u] &amp;&amp; v != son[u]) <span class="built_in">dfs</span>(v, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chairman_Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt, ls[N * <span class="number">150</span>], rs[N * <span class="number">150</span>], lz[N * <span class="number">150</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum[N * <span class="number">150</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> _u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        u = ++cnt, ls[u] = ls[_u], rs[u] = rs[_u], sum[u] = sum[_u], lz[u] = lz[_u];</span><br><span class="line">        <span class="keyword">if</span> (L == l &amp;&amp; r == R) <span class="keyword">return</span> ++lz[u], <span class="built_in"><span class="keyword">void</span></span>(<span class="number">0</span>);</span><br><span class="line">        sum[u] += pre[R] - pre[L - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> md = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (R &lt;= md) <span class="built_in">modify</span>(ls[u], ls[_u], l, md, L, R);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (L &gt; md) <span class="built_in">modify</span>(rs[u], rs[_u], md + <span class="number">1</span>, r, L, R);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(ls[u], ls[_u], l, md, L, md), <span class="built_in">modify</span>(rs[u], rs[_u], md + <span class="number">1</span>, r, md + <span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (L == l &amp;&amp; r == R) <span class="keyword">return</span> sum[u] + <span class="number">1ll</span> * lz[u] * (pre[R] - pre[L - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">1ll</span> * lz[u] * (pre[R] - pre[L - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> md = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (R &lt;= md) <span class="keyword">return</span> tmp + <span class="built_in">query</span>(ls[u], l, md, L, R);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (L &gt; md) <span class="keyword">return</span> tmp + <span class="built_in">query</span>(rs[u], md + <span class="number">1</span>, r, L, R);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> tmp + <span class="built_in">query</span>(ls[u], l, md, L, md) + <span class="built_in">query</span>(rs[u], md + <span class="number">1</span>, r, md + <span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="keyword">int</span> rt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _u = u;</span><br><span class="line">    u = p[u];</span><br><span class="line">    <span class="keyword">while</span> (top[u] != <span class="number">1</span>)&#123;</span><br><span class="line">        T.<span class="built_in">modify</span>(rt[_u], rt[_u], <span class="number">1</span>, n, dfn[top[u]], dfn[u]);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    T.<span class="built_in">modify</span>(rt[_u], rt[_u], <span class="number">1</span>, n, <span class="number">1</span>, dfn[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    rt[u] = rt[fa[u]], <span class="built_in">update</span>(u), sumd[u] = sumd[fa[u]] + dis[p[u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa[u]) <span class="built_in">build</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) std :: <span class="built_in">swap</span>(u, v);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != <span class="number">1</span>)&#123;</span><br><span class="line">        res += T.<span class="built_in">query</span>(rt, <span class="number">1</span>, n, dfn[top[u]], dfn[u]);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    res += T.<span class="built_in">query</span>(rt, <span class="number">1</span>, n, <span class="number">1</span>, dfn[u]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    type = <span class="built_in">read</span>();</span><br><span class="line">    n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">        u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(), w = <span class="built_in">read</span>(), <span class="built_in">addedge</span>(u, v, w), <span class="built_in">addedge</span>(v, u, w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) p[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>), <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pre[i] += pre[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">read</span>() ^ (type * ans), v = <span class="built_in">read</span>() ^ (type * ans), k = <span class="built_in">read</span>() ^ (type * ans);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">lca</span>(u, v);</span><br><span class="line">        ans = sumd[u] + sumd[v] - sumd[l] - sumd[fa[l]];</span><br><span class="line">        ans += <span class="number">1ll</span> * (dep[u] + dep[v] - dep[l] - dep[fa[l]]) * dis[k];</span><br><span class="line">        ans -= <span class="number">2</span> * (<span class="built_in">query</span>(rt[u], k) + <span class="built_in">query</span>(rt[v], k) - <span class="built_in">query</span>(rt[l], k) - <span class="built_in">query</span>(rt[fa[l]], k));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>可持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>「LOJ 6068」「2017 山东一轮集训 Day4」棋盘</title>
    <url>/loj6068-sol/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/6068">LOJ 6068</a></p>
<span id="more"></span>
<h2 id="题解">题解</h2><div class="story post-story">
<p>这类棋盘上放棋子的问题，且根据这个数据范围，很容易想到网络流。</p>
<p>棋子的攻击方式有两种，我们先考虑同一行。我们把一行中极大的连续的 <code>.</code> 组成的区间叫做行连通块。显然不同的行连通块之间是互不影响的。对于同一个行连通块，假设当前已经有 <span class="math inline">\(x\)</span> 个棋子，那么再放入一个棋子后就会对答案产生 <span class="math inline">\(x\)</span> 的贡献。同理我们可以定义列连通块，也同样具有行连通块的性质。显然，每个 <code>.</code> 唯一地属于一个行连通块和列连通块。</p>
<p>那么就有一个初步的建模思路：建立两排点，左边是所有行连通块，右边是所有列连通块，源点 <span class="math inline">\(S\)</span> 向行连通块连边，列连通块向汇点 <span class="math inline">\(T\)</span> 连边，对于每个是 <code>.</code> 的位置，我们把包含它的行连通块向包含它的列连通块连边。</p>
<p>假设放入一个棋子对应 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 的一个单位的流量，那么这条路径上边上的费用之和应该是放入这个棋子对答案产生的贡献。对于一个行连通块 <span class="math inline">\(i\)</span>，假设它的大小为 <span class="math inline">\(sz_i\)</span>，那么应该从 <span class="math inline">\(S\)</span> 向 <span class="math inline">\(i\)</span> 连 <span class="math inline">\(sz_i\)</span> 条边，第 <span class="math inline">\(j\)</span> 条边的费用是 <span class="math inline">\(j-1\)</span>，流量上界是 <span class="math inline">\(1\)</span>，这样就能保证第 <span class="math inline">\(j\)</span> 次在这个行连通块放旗子时贡献是 <span class="math inline">\(j-1\)</span>。列连通块同理。行连通块向列连通块连的边费用为 <span class="math inline">\(0\)</span>，流量上界为 <span class="math inline">\(1\)</span>。</p>
<p>于是问题变成了求流量恰好为 <span class="math inline">\(k\)</span> 时的最小费用。可以发现，在跑费用流时，每次跑 SPFA 增广流量只会恰好增加 <span class="math inline">\(1\)</span>，于是在跑费用流时从小到大求出每个 <span class="math inline">\(k\)</span> 的答案即可。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">5005</span>, M = <span class="number">100005</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> S, T, edge, to[M], pr[M], cap[M], cost[M], hd[N];</span><br><span class="line">    <span class="built_in">Graph</span>()&#123; edge = <span class="number">0</span>, <span class="built_in">memset</span>(hd, <span class="number">-1</span>, <span class="keyword">sizeof</span> hd); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        to[edge] = v, cap[edge] = w, cost[edge] = c, pr[edge] = hd[u], hd[u] = edge++;</span><br><span class="line">        to[edge] = u, cap[edge] = <span class="number">0</span>, cost[edge] = -c, pr[edge] = hd[v], hd[v] = edge++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> h, t, Q[<span class="number">1000005</span>], dis[N], vis[N], mn[N], pre[N];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis), <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        h = <span class="number">0</span>, t = <span class="number">1</span>, Q[t] = S, dis[S] = <span class="number">0</span>, vis[S] = <span class="number">1</span>, pre[S] = <span class="number">0</span>, mn[S] = INF;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; t)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q[++h]; vis[u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; ~i; i = pr[i])</span><br><span class="line">                <span class="keyword">if</span> (cap[i] &amp;&amp; dis[u] + cost[i] &lt; dis[v = to[i]])&#123;</span><br><span class="line">                    dis[v] = dis[u] + cost[i], mn[v] = std :: <span class="built_in">min</span>(mn[u], cap[i]), pre[v] = i;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[v]) Q[++t] = v, vis[v] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[T] != INF;</span><br><span class="line">    &#125;</span><br><span class="line">    std :: <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">int</span> _S, <span class="keyword">int</span> _T)</span></span>&#123;</span><br><span class="line">        std :: vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="number">0</span>), S = _S, T = _T;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">SPFA</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(res[res.<span class="built_in">size</span>() - <span class="number">1</span>] + dis[T]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = T; i != S; i = to[pre[i] ^ <span class="number">1</span>])</span><br><span class="line">                cap[pre[i]] -= mn[T], cap[pre[i] ^ <span class="number">1</span>] += mn[T];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;G;</span><br><span class="line"><span class="keyword">int</span> n, q, cnt, cntr, cntc, rbel[<span class="number">55</span>][<span class="number">55</span>], cbel[<span class="number">55</span>][<span class="number">55</span>], sz[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line">std :: vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a[i] + <span class="number">1</span>);</span><br><span class="line">    cntr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sz[cntr]) ++cntr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == <span class="string">&#x27;.&#x27;</span>) rbel[i][j] = cntr, ++sz[cntr];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sz[cntr]) ++cntr;</span><br><span class="line">    &#125;</span><br><span class="line">    cntc = cntr + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sz[cntc]) ++cntc;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[j][i] == <span class="string">&#x27;.&#x27;</span>) cbel[j][i] = cntc, ++sz[cntc];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sz[cntc]) ++cntc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntr; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz[i]; ++j)</span><br><span class="line">            G.<span class="built_in">addedge</span>(<span class="number">0</span>, i, <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = cntr + <span class="number">1</span>; i &lt;= cntc; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz[i]; ++j)</span><br><span class="line">            G.<span class="built_in">addedge</span>(i, cntc + <span class="number">1</span>, <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == <span class="string">&#x27;.&#x27;</span>) G.<span class="built_in">addedge</span>(rbel[i][j], cbel[i][j], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    ans = G.<span class="built_in">MinCostMaxFlow</span>(<span class="number">0</span>, cntc + <span class="number">1</span>);</span><br><span class="line">    q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (q--) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[<span class="built_in">read</span>()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「LOJ 6074」「2017 山东一轮集训 Day6」子序列</title>
    <url>/loj6074-sol/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/6074">LOJ 6074</a></p>
<span id="more"></span>
<h2 id="题解">题解</h2><div class="story post-story">
<p>设字符集大小为 <span class="math inline">\(m\)</span>，这里 <span class="math inline">\(m=9\)</span>，假设字符从 <span class="math inline">\(0\)</span> 开始标号。</p>
<p>显然可以 DP，设 <span class="math inline">\(dp_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 个字符中，以字符 <span class="math inline">\(j\)</span> 结尾的本质不同的子序列个数。特殊地，<span class="math inline">\(j=m\)</span> 表示子序列为空。有方程：</p>
<p><span class="math display">\[dp_{i,j}=\begin{cases}dp_{i-1,j} &amp; \text{ if } j\ne S_i \\ \sum_{k=0}^{m} dp_{i-1,k} &amp; \text{ if }j=S_i\end{cases}\]</span></p>
<p>初始值是 <span class="math inline">\(dp_{0,m}=1\)</span>。</p>
<p>发现 <span class="math inline">\(dp\)</span> 数组可以写成行向量，记</p>
<p><span class="math display">\[F_i=\begin{pmatrix}dp_{i,0} &amp; dp_{i,1} &amp; dp_{i,2} &amp; \cdots &amp; dp_{i,m}\end{pmatrix}\]</span></p>
<p>而转移可以表示为一个行向量乘上转移矩阵 <span class="math inline">\(M_i\)</span> 的形式：</p>
<p><span class="math display">\[\begin{aligned}M_i &amp;= \begin{pmatrix}1 &amp; &amp; 1 &amp; &amp; \\ &amp; 1 &amp; 1 &amp; &amp; \\ &amp; &amp; 1 &amp; &amp; \\ &amp; &amp; \vdots &amp; \ddots &amp; \\ &amp; &amp; 1 &amp; &amp; 1 \end{pmatrix} \\ F_i &amp;= F_{i-1}M_i\end{aligned}\]</span></p>
<p><span class="math inline">\(M_i\)</span> 是一个主对角线为 <span class="math inline">\(1\)</span>，<span class="math inline">\(S_i\)</span> 这一列为 <span class="math inline">\(1\)</span>，其余为 <span class="math inline">\(0\)</span> 的矩阵。</p>
<p>初始的行向量为</p>
<p><span class="math display">\[A=\begin{pmatrix}0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 1\end{pmatrix}\]</span></p>
<p>最后由于是求</p>
<p><span class="math display">\[\left(\sum_{i=0}^m dp_{n,i}\right)-1\]</span></p>
<p>所以最后需要乘上列向量</p>
<p><span class="math display">\[B=\begin{pmatrix}1 \\ 1 \\ 1 \\ \vdots \\ 1\end{pmatrix}\]</span></p>
<p>于是对于每个询问，答案可以表示成</p>
<p><span class="math display">\[\begin{aligned}ans&amp;=AM_lM_{l+1}M_{l+2}\cdots M_{r}B\\&amp;=AM_{l-1}^{-1}M_{l-2}^{-1}\cdots M_1^{-1}M_1M_2\cdots M_{r}B\end{aligned}\]</span></p>
<p>直接维护 <span class="math inline">\(M_i\)</span> 和 <span class="math inline">\(M_i^{-1}\)</span> 的前缀积（注意顺序），时间复杂度 <span class="math inline">\(O(nm^3+qm^3)\)</span>。</p>
<p>在维护完 <span class="math inline">\(M_i\)</span> 和 <span class="math inline">\(M_i^{-1}\)</span> 后，分别右乘一个 <span class="math inline">\(B\)</span> 和左乘一个 <span class="math inline">\(A\)</span>，这样询问部分的复杂度可以降到 <span class="math inline">\(O(qm)\)</span>。</p>
<p>预处理部分，我们来观察一些特殊性质。对于 <span class="math inline">\(M_i\)</span> 的前缀积，我们发现每次要算</p>
<p><span class="math display">\[\begin{aligned}CM_i&amp;=\begin{pmatrix}C_{0,0} &amp; C_{0,1} &amp; C_{0,2} &amp; \cdots &amp; C_{0,m} \\ C_{1,0} &amp; C_{1,1} &amp; C_{1,2} &amp; \cdots &amp; C_{1,m} \\ C_{2,0} &amp; C_{2,1} &amp; C_{2,2} &amp; \cdots &amp; C_{2,m} \\ &amp; &amp; &amp; \ddots &amp; \\ C_{m,0} &amp; C_{m,1} &amp; C_{m,2} &amp; \cdots &amp; C_{m,m} \end{pmatrix}\begin{pmatrix}1 &amp; &amp; 1 &amp; &amp; \\ &amp; 1 &amp; 1 &amp; &amp; \\ &amp; &amp; 1 &amp; &amp; \\ &amp; &amp; \vdots &amp; \ddots &amp; \\ &amp; &amp; 1 &amp; &amp; 1 \end{pmatrix} \\ &amp;= \begin{pmatrix}C_{0,0} &amp; C_{0,1} &amp; \sum_{j=0}^m C_{0,j} &amp; \cdots &amp; C_{0,m} \\ C_{1,0} &amp; C_{1,1} &amp; \sum_{j=0}^m C_{1,j} &amp; \cdots &amp; C_{1,m} \\ C_{2,0} &amp; C_{2,1} &amp; \sum_{j=0}^m C_{2,j} &amp; \cdots &amp; C_{2,m} \\ &amp; &amp; &amp; \ddots &amp; \\ C_{m,0} &amp; C_{m,1} &amp; \sum_{j=0}^m C_{m,j} &amp; \cdots &amp; C_{m,m} \end{pmatrix}\end{aligned}\]</span></p>
<p>相当于把 <span class="math inline">\(C\)</span> 的第 <span class="math inline">\(S_i\)</span> 列改成对应行的 <span class="math inline">\(C_{k,j}\)</span> 之和。且最后乘上 <span class="math inline">\(B\)</span> 相当于求每行的和。那么只要维护 <span class="math inline">\(C\)</span> 的每一行之和即可。于是维护 <span class="math inline">\(M_i\)</span> 的前缀积乘上 <span class="math inline">\(B\)</span> 的复杂度变成了 <span class="math inline">\(O(nm)\)</span>。</p>
<p>对于 <span class="math inline">\(M_i^{-1}\)</span> 的前缀积，我们先根据矩阵求逆的过程手动求出 <span class="math inline">\(M_i^{-1}\)</span>，发现</p>
<p><span class="math display">\[M_i^{-1}=\begin{pmatrix}1 &amp; &amp; -1 &amp; &amp; \\ &amp; 1 &amp; -1 &amp; &amp; \\ &amp; &amp; 1 &amp; &amp; \\ &amp; &amp; \vdots &amp; \ddots &amp; \\ &amp; &amp; -1 &amp; &amp; 1 \end{pmatrix}\]</span></p>
<p>即 <span class="math inline">\(M_i^{-1}\)</span> 是主对角线为 <span class="math inline">\(1\)</span>，第 <span class="math inline">\(S_i\)</span> 列除了第 <span class="math inline">\(S_i\)</span> 行外是 <span class="math inline">\(-1\)</span> 的矩阵。</p>
<p>维护 <span class="math inline">\(M_i^{-1}\)</span> 的前缀积时，我们要算</p>
<p><span class="math display">\[\begin{aligned}M_i^{-1}C&amp;=\begin{pmatrix}1 &amp; &amp; -1 &amp; &amp; \\ &amp; 1 &amp; -1 &amp; &amp; \\ &amp; &amp; 1 &amp; &amp; \\ &amp; &amp; \vdots &amp; \ddots &amp; \\ &amp; &amp; -1 &amp; &amp; 1 \end{pmatrix}\begin{pmatrix}C_{0,0} &amp; C_{0,1} &amp; C_{0,2} &amp; \cdots &amp; C_{0,m} \\ C_{1,0} &amp; C_{1,1} &amp; C_{1,2} &amp; \cdots &amp; C_{1,m} \\ C_{2,0} &amp; C_{2,1} &amp; C_{2,2} &amp; \cdots &amp; C_{2,m} \\ &amp; &amp; &amp; \ddots &amp; \\ C_{m,0} &amp; C_{m,1} &amp; C_{m,2} &amp; \cdots &amp; C_{m,m} \end{pmatrix} \\ &amp;= \begin{pmatrix}C_{0,0}-C_{2,0} &amp; C_{0,1}-C_{2,1} &amp; C_{0,2}-C_{2,2} &amp; \cdots &amp; C_{0,m}-C_{2,m} \\ C_{1,0}-C_{2,0} &amp; C_{1,1}-C_{2,1} &amp; C_{1,2}-C_{2,2} &amp; \cdots &amp; C_{1,m}-C_{2,m} \\ C_{2,0} &amp; C_{2,1} &amp; C_{2,2} &amp; \cdots &amp; C_{2,m} \\ &amp; &amp; &amp; \ddots &amp; \\ C_{m,0}-C_{2,0} &amp; C_{m,1}-C_{2,1} &amp; C_{m,2}-C_{2,2} &amp; \cdots &amp; C_{m,m}-C_{2,m} \end{pmatrix}\end{aligned}\]</span></p>
<p>可以发现，每一列除了 <span class="math inline">\(S_i\)</span> 这一行以外都减去的是同一个数，于是我们维护每一列减去的数，例如对于某一列</p>
<p><span class="math display">\[\begin{pmatrix}x_0-v \\ x_1-v \\ x_2-v \\ \vdots \\ x_m-v \end{pmatrix}\]</span></p>
<p>要变成</p>
<p><span class="math display">\[\begin{pmatrix}x_0-v-(x_2-v) \\ x_1-v-(x_2-v) \\ x_2-v \\ \vdots \\ x_m-v-(x_2-v) \end{pmatrix}==\begin{pmatrix}x_0-x_2 \\ x_1-x_2 \\ (2x_2-v)-x_2 \\ \vdots \\ x_m-x_2 \end{pmatrix}\]</span></p>
<p>于是只需要修改第 <span class="math inline">\(S_i\)</span> 那一行的值，并且更新每一列减去的值即可。</p>
<p>最后左乘 <span class="math inline">\(A\)</span> 相当于求最后一行的值。由于最后一行不会修改，始终是</p>
<p><span class="math display">\[\begin{pmatrix}0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 1\end{pmatrix}\]</span></p>
<p>所以直接减去对应列需要减的数即可。这一部分的时间复杂度也变成了 <span class="math inline">\(O(nm)\)</span>。</p>
<p>总时间复杂度 <span class="math inline">\(O(nm+qm)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n, q, a[<span class="number">10</span>][<span class="number">10</span>], av[<span class="number">10</span>][<span class="number">10</span>], f[N][<span class="number">10</span>], fv[N][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a += b) &gt;= P ? a - P : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a -= b) &lt; <span class="number">0</span> ? a + P : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">        a[i][i] = av[i][i] = f[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++j)&#123;</span><br><span class="line">            f[i][j] = <span class="built_in">plus</span>(<span class="built_in">minus</span>(f[i - <span class="number">1</span>][j], a[j][t]), f[i - <span class="number">1</span>][j]);</span><br><span class="line">            a[j][t] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            fv[i][j] = av[t][j];</span><br><span class="line">            av[t][j] = <span class="built_in">minus</span>(<span class="built_in">plus</span>(av[t][j], av[t][j]), fv[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++j)</span><br><span class="line">            fv[i][j] = <span class="built_in">minus</span>(j == <span class="number">9</span>, fv[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">islower</span>(s[++n] = <span class="built_in">getchar</span>())) ;</span><br><span class="line">    --n;</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">            ans = <span class="built_in">plus</span>(ans, <span class="number">1ll</span> * fv[l - <span class="number">1</span>][i] * f[r][i] % P);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">minus</span>(ans, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>矩阵乘法</tag>
        <tag>矩阵求逆</tag>
      </tags>
  </entry>
  <entry>
    <title>「LOJ 6077」「2017 山东一轮集训 Day7」逆序对</title>
    <url>/loj6077-sol/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/6077">LOJ 6077</a></p>
<span id="more"></span>
<h2 id="题解">题解</h2><div class="story post-story">
<p>考虑已经有一个 <span class="math inline">\([1,i-1]\)</span> 的排列，我们把 <span class="math inline">\(i\)</span> 这个数插进去，会使得逆序对数量加 <span class="math inline">\(x_i\)</span>，其中 <span class="math inline">\(x_i\in [0,i)\)</span>。那么问题转化成求 <span class="math inline">\(\sum_{i=1}^n x_i=k\)</span> 的解的数量，满足 <span class="math inline">\(\forall i\in [1,n]:0\le x_i &lt; i\)</span>。</p>
<p>考虑容斥，枚举不满足条件的位置个数 <span class="math inline">\(i\)</span> 和位置 <span class="math inline">\(p_1,p_2,p_3,\cdots,p_i\)</span>，那么问题变成了有若干个有 <span class="math inline">\(n\)</span> 个条件，其中有 <span class="math inline">\(i\)</span> 个条件是 <span class="math inline">\(x_{p_j}\ge p_j\)</span>，其他条件是 <span class="math inline">\(x_j\ge 0\)</span>。我们让 <span class="math inline">\(k\)</span> 减去 <span class="math inline">\(p_1+p_2+p_3+\cdots+p_i\)</span> 的值，就变成了一个经典的隔板法求不定方程非负整数解的数量的问题。即答案是</p>
<p><span class="math display">\[ans=\sum_{i=0}^{n}(-1)^i\sum_{p_1 &lt; p_2 &lt; p_3 &lt; \cdots &lt; p_i} C_{n-1+k-\sum_{j=1}^i p_j}^{n-1}\]</span></p>
<p>我们发现后面的组合数式子不需要关心 <span class="math inline">\(p_j\)</span> 具体的值，只需要知道 <span class="math inline">\(\sum_{j=1}^i p_j\)</span> 即可。于是我们枚举这个值，式子变成了</p>
<p><span class="math display">\[ans=\sum_{i=0}^n(-1)^i\sum_{j=0}^{k}F_{i,j}C_{k-j+n-1}^{n-1}\]</span></p>
<p>其中 <span class="math inline">\(F_{i,j}\)</span> 表示选 <span class="math inline">\(i\)</span> 个互不相同的数，且这些数在 <span class="math inline">\([1,n]\)</span> 的范围内，使得这 <span class="math inline">\(i\)</span> 个数和为 <span class="math inline">\(j\)</span> 的方案数。又可以注意到，因为 <span class="math inline">\(i\)</span> 个数要互不相同，所以当 <span class="math inline">\(j &lt; \frac{i(i+1)}{2}\)</span> 时，<span class="math inline">\(F_{i,j}=0\)</span>。又因为 <span class="math inline">\(j\)</span> 不能超过 <span class="math inline">\(k\)</span>，所以 <span class="math inline">\(i\)</span> 只需要枚举到 <span class="math inline">\(\lfloor\sqrt{2k}\rfloor\)</span> 即可。而组合数可以 <span class="math inline">\(O(n+k)\)</span> 预处理阶乘及阶乘的逆元，然后 <span class="math inline">\(O(1)\)</span> 计算。那么关键问题是如何求 <span class="math inline">\(F_{i,j}\)</span>。</p>
<p>这是经典的整数划分问题。假设当前有 <span class="math inline">\(i\)</span> 个数，和为 <span class="math inline">\(j\)</span>，那么有两种决策：</p>
<ol type="1">
<li>把所有数加 <span class="math inline">\(1\)</span>，和变成了 <span class="math inline">\(i+j\)</span>；</li>
<li>在最前面加上一个数 <span class="math inline">\(1\)</span>，并把其他所有数加 <span class="math inline">\(1\)</span>，个数变成 <span class="math inline">\(i+1\)</span>，和变成 <span class="math inline">\(i+j+1\)</span>。</li>
</ol>
<p>可以证明所有方案都可以通过这两种变换唯一的遍历到。但是有些方案中会存在某个数大于 <span class="math inline">\(n\)</span> 的情况，需要减去。又因为所有数互不相同，且变换之前的方案是合法的，所以这个不合法的方案一定只会存在一个大于 <span class="math inline">\(n\)</span> 的数且这个数是 <span class="math inline">\(n+1\)</span>。那么这种不合法的方案数一定与去掉 <span class="math inline">\(n+1\)</span> 这个数后序列的方案数相等，直接减去即可。DP 的转移方程是</p>
<p><span class="math display">\[F_{i,j}=F_{i,j-i}+F_{i-1,j-i}-F_{i-1,j-n-1}\]</span></p>
<p>可以直接带上容斥系数，变成</p>
<p><span class="math display">\[F_{i,j}=F_{i,j-i}-F_{i-1,j-i}+F_{i-1,j-n-1}\]</span></p>
<p>处理完后直接计算即可。时间复杂度 <span class="math inline">\(O(n\sqrt{n})\)</span>。</p>
<p>还有一种用生成函数推导答案式子的方法，可以参考 <a href="https://blog.trisolaris.top/%E3%80%8Csdtt2017%E3%80%8Dinverse/">Trisolaris's Blog</a>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n, k, fac[N &lt;&lt; <span class="number">1</span>], inv[N &lt;&lt; <span class="number">1</span>], t, F[<span class="number">455</span>][N], f[N], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    (a += b) &gt;= P ? a -= P : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    (a -= b) &lt; <span class="number">0</span> ? a += P : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = P - <span class="number">2</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1ll</span> * a * a % P) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1ll</span> * s * a % P;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + k; ++i) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    inv[n + k] = <span class="built_in">qpow</span>(fac[n + k]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n + k; i; --i) inv[i - <span class="number">1</span>] = <span class="number">1ll</span> * inv[i] * i % P;</span><br><span class="line">    t = std :: <span class="built_in">min</span>(n, <span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">sqrt</span>(<span class="number">2</span> * k)) + <span class="number">1</span>);</span><br><span class="line">    F[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i * (i + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; j &lt;= k; ++j)&#123;</span><br><span class="line">            <span class="built_in">dec</span>(F[i][j], F[i - <span class="number">1</span>][j - i]), <span class="built_in">inc</span>(F[i][j], F[i][j - i]);</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= n + <span class="number">1</span>) <span class="built_in">inc</span>(F[i][j], F[i - <span class="number">1</span>][j - n - <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">inc</span>(f[j], F[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[n] * inv[m] % P * inv[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">init</span>(n, k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) <span class="built_in">inc</span>(ans, <span class="number">1ll</span> * f[i] * <span class="built_in">C</span>(k - i + n - <span class="number">1</span>, n - <span class="number">1</span>) % P);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>「LOJ 6079」「2017 山东一轮集训 Day7」养猫</title>
    <url>/loj6079-sol/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/6079">LOJ 6079</a></p>
<span id="more"></span>
<h2 id="题解">题解</h2><div class="story post-story">
<p><span class="math inline">\(n\le 1000\)</span>，还要输出方案，容易想到网络流。首先我们假设每个时刻都选 <code>S</code>，记 <span class="math inline">\(a_i=s_i-e_i\)</span>，那么问题变成了调整若干个时刻 <span class="math inline">\(j\)</span>，对于每个长度为 <span class="math inline">\(k\)</span> 的区间，调整的时刻数量 <span class="math inline">\(x\)</span> 应该满足 <span class="math inline">\(me\le x\le k-ms\)</span>，在这个前提下，使得 <span class="math inline">\(a_j\)</span> 之和尽量小。</p>
<p>考虑这样一个建模方法：源点 <span class="math inline">\(S\)</span> 向某个点 <span class="math inline">\(P\)</span> 连 <span class="math inline">\((k-ms,0)\)</span> 的边（<span class="math inline">\((x,y)\)</span> 表示流量上界为 <span class="math inline">\(x\)</span>，费用为 <span class="math inline">\(y\)</span> 的边，下同），点 <span class="math inline">\(P\)</span> 向 <span class="math inline">\([1,k]\)</span> 的点连 <span class="math inline">\((\infty,0)\)</span> 的边，点 <span class="math inline">\(i\)</span> 向 <span class="math inline">\(i+1\)</span> 连 <span class="math inline">\((k-ms-me,0)\)</span> 的边，<span class="math inline">\(i\)</span> 向 <span class="math inline">\(i+k\)</span> 连 <span class="math inline">\((1,a_i)\)</span> 的边（<span class="math inline">\(i+1,i+k&gt;n\)</span> 时则向汇点 <span class="math inline">\(T\)</span> 连边）。然后跑最小费用最大流的结果就是答案。</p>
<p>考虑这样建模为什么是对的。显然流只会从编号小的点流向编号大的点。我们假设从小到大处理每一个点 <span class="math inline">\(i\)</span>，处理过的点已经满足流量平衡，未处理的点则把入流先“屯”着。有入流的点说明这个点需要调整。对于当前要处理的点 <span class="math inline">\(i\)</span>，我们发现这个点“屯”着的流量就是 <span class="math inline">\([i,i+k-1]\)</span> 这个区间中还能放的点数，已经有入流的点属于已经确定的点。由于总流量是 <span class="math inline">\(k-ms\)</span>，而每个长度为 <span class="math inline">\(k\)</span> 的区间只考虑 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(i+1\)</span> 的边只能流出 <span class="math inline">\(k-ms-me\)</span> 的流量，所以一定会有至少 <span class="math inline">\(me\)</span> 个点被调整。（这一段是我自己yy的）</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">2005</span>, M = <span class="number">10005</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> S, T, edge, to[M], pr[M], cap[M], cost[M], hd[N];</span><br><span class="line">    <span class="built_in">Graph</span>()&#123; edge = <span class="number">0</span>, <span class="built_in">memset</span>(hd, <span class="number">-1</span>, <span class="keyword">sizeof</span> hd); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        to[edge] = v, cap[edge] = w, cost[edge] = c, pr[edge] = hd[u], hd[u] = edge++;</span><br><span class="line">        to[edge] = u, cap[edge] = <span class="number">0</span>, cost[edge] = -c, pr[edge] = hd[v], hd[v] = edge++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> h, t, Q[<span class="number">1000005</span>], vis[N], mn[N], pre[N];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dis[N];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis), <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        h = <span class="number">0</span>, t = <span class="number">1</span>, Q[t] = S, dis[S] = <span class="number">0</span>, vis[S] = <span class="number">1</span>, pre[S] = <span class="number">0</span>, mn[S] = INF;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; t)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q[++h]; vis[u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; ~i; i = pr[i])</span><br><span class="line">                <span class="keyword">if</span> (cap[i] &amp;&amp; dis[u] + cost[i] &lt; dis[v = to[i]])&#123;</span><br><span class="line">                    dis[v] = dis[u] + cost[i], mn[v] = std :: <span class="built_in">min</span>(mn[u], cap[i]), pre[v] = i;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[v]) Q[++t] = v, vis[v] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[T] != dis[N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">int</span> _S, <span class="keyword">int</span> _T)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        S = _S, T = _T;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">SPFA</span>())&#123;</span><br><span class="line">            res += mn[T] * dis[T];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = T; i != S; i = to[pre[i] ^ <span class="number">1</span>])</span><br><span class="line">                cap[pre[i]] -= mn[T], cap[pre[i] ^ <span class="number">1</span>] += mn[T];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;G;</span><br><span class="line"><span class="keyword">int</span> n, k, ms, me, a[<span class="number">1005</span>], E[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>(), ms = <span class="built_in">read</span>(), me = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">read</span>(), sum += a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] -= <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        G.<span class="built_in">addedge</span>(i, i + <span class="number">1</span>, k - ms - me, <span class="number">0</span>);</span><br><span class="line">        E[i] = G.edge;</span><br><span class="line">        G.<span class="built_in">addedge</span>(i, std :: <span class="built_in">min</span>(i + k, n + <span class="number">1</span>), <span class="number">1</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) G.<span class="built_in">addedge</span>(<span class="number">0</span>, i, Graph :: INF, <span class="number">0</span>);</span><br><span class="line">    G.<span class="built_in">addedge</span>(n + <span class="number">2</span>, <span class="number">0</span>, k - ms, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum - G.<span class="built_in">MinCostMaxFlow</span>(n + <span class="number">2</span>, n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (G.cap[E[i]]) <span class="built_in">putchar</span>(<span class="string">&#x27;S&#x27;</span>); <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher 学习笔记</title>
    <url>/manacher-notes/</url>
    <content><![CDATA[<h2 id="问题形式">问题形式</h2><div class="story post-story">
<p>给定一个字符串，求该字符串的最长回文子串。</p>
<p><a href="https://www.luogu.org/problemnew/show/P3805">洛谷传送门</a></p>
</div><h2 id="一个简单的暴力实现">一个简单的暴力实现</h2><div class="story post-story">
<p>由于回文串是对称的，我们枚举对称轴（注意奇偶分类讨论）。然后从该对称轴向左向右扩展，直到两字母不相等。此时的字符串长度一定是以当前对称轴作为中心的最长回文子串。</p>
<p>时间复杂度<span class="math inline">\(\mathcal O(n^2)\)</span>。</p>
<span id="more"></span>
</div><h2 id="manacher---暴力的优化">Manacher - 暴力的优化</h2><div class="story post-story">
<p>为了避免奇偶分类讨论，我们现在字符之间以及字符串两端插入一个特殊字符（与字符串中所有字符都不相等）。</p>
<p>例如：<code>ababaab -&gt; #a#b#a#b#a#a#b#</code>，显然，原来是回文串的还是回文串，原来不是回文串的仍然不是回文串，长度稍做处理即可。</p>
<p>通过观察发现，暴力主要慢在相同的状态被重复枚举，没有利用回文串的性质。</p>
<p>记<span class="math inline">\(hw_i\)</span>表示以<span class="math inline">\(i\)</span>为对称轴时，最长的回文串的右端距离<span class="math inline">\(i\)</span>（包括最右端的字符和<span class="math inline">\(i\)</span>）的长度为<span class="math inline">\(hw_i\)</span>。栗子：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">char</span>:    # a # b # a #</span><br><span class="line"> <span class="attribute">hw</span> :    <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">char</span>:    # a # b # b # a #</span><br><span class="line"> <span class="attribute">hw</span> :    <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如何快速求出<span class="math inline">\(hw_i\)</span>？</p>
<p>考虑根据回文串的性质，利用已经求出的<span class="math inline">\(hw\)</span>值来求出当前的<span class="math inline">\(hw_i\)</span>。</p>
<p>引入两个辅助变量<span class="math inline">\(MaxRight,Mid\)</span>。<span class="math inline">\(MaxRight\)</span>表示当前访问到的所有回文子串，所能触及的最右一个字符的位置，<span class="math inline">\(Mid\)</span>表示对应的对称轴。</p>
<p>为方便观察，下面的图示中记<span class="math inline">\(x\)</span>为<span class="math inline">\(MaxRight\)</span>关于<span class="math inline">\(Mid\)</span>对称的位置，<span class="math inline">\(r\)</span>表示<span class="math inline">\(MaxRight\)</span>，<span class="math inline">\(m\)</span>表示<span class="math inline">\(Mid\)</span>，<span class="math inline">\(*\)</span>表示未触及的位置。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">x</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">m</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">r</span>|<span class="string">*</span>|<span class="string">*</span>|<span class="string">*</span>|</span><br></pre></td></tr></table></figure>
<p>当前要求<span class="math inline">\(hw_i\)</span>的位置<span class="math inline">\(i\)</span>一定在<span class="math inline">\(Mid\)</span>右边。那么我们根据<span class="math inline">\(i\le MaxRight\)</span>和<span class="math inline">\(i&gt;MaxRight\)</span>讨论：</p>
<h3 id="当ile-maxright时">当<span class="math inline">\(i\le MaxRight\)</span>时</h3>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">x</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">j</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">m</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">i</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">r</span>|<span class="string">*</span>|<span class="string">*</span>|<span class="string">*</span>|</span><br></pre></td></tr></table></figure>
<p>记<span class="math inline">\(j\)</span>为<span class="math inline">\(i\)</span>关于<span class="math inline">\(m\)</span>的对称点。由于<span class="math inline">\(hw_j\)</span>已知，我们尝试利用<span class="math inline">\(hw_j\)</span>得出<span class="math inline">\(hw_i\)</span>的下界。</p>
<p>又分成两种小情况：</p>
<h4 id="hw_j比较小向左没有超过x"><span class="math inline">\(hw_j\)</span>比较小，向左没有超过<span class="math inline">\(x\)</span></h4>
<p>大概情况如图所示：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">x</span>|<span class="string"> </span>|<span class="string">-</span>|<span class="string">j</span>|<span class="string">-</span>|<span class="string"> </span>|<span class="string">m</span>|<span class="string"> </span>|<span class="string">-</span>|<span class="string">i</span>|<span class="string">-</span>|<span class="string"> </span>|<span class="string">r</span>|<span class="string">*</span>|<span class="string">*</span>|<span class="string">*</span>|</span><br></pre></td></tr></table></figure>
<p>此时显然<span class="math inline">\(hw_i\)</span>的下界为<span class="math inline">\(hw_j\)</span>。如图所示的情况一定也是上界，但如果<span class="math inline">\(i+hw_i-1\)</span>刚好等于<span class="math inline">\(MaxRight\)</span>，那么有可能可以继续扩展。由于不影响复杂度，为方便起见，无论哪一种情况都尝试扩展。</p>
<h4 id="hw_j比较大向左超过x"><span class="math inline">\(hw_j\)</span>比较大，向左超过<span class="math inline">\(x\)</span></h4>
<p>大概情况如图所示：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">                    |<span class="string">             </span>|</span><br><span class="line">       /-------j----|<span class="string">--\          </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">x</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">j</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">m</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">i</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">r</span>|<span class="string">*</span>|<span class="string">*</span>|<span class="string">*</span>|</span><br><span class="line">                   \|<span class="string">------i------</span>|<span class="string">/</span></span><br><span class="line"><span class="string">                    </span>|<span class="string">             </span>|</span><br></pre></td></tr></table></figure>
<p>此时暂时只能确定两根较长的线之间的部分时回文的，所以<span class="math inline">\(hw_i\)</span>的下界是<span class="math inline">\(MaxRight-i+1\)</span>。然后同样地直接继续扩展即可。</p>
<p>实际实现中，这两种情况不需要特殊判断，只要在<span class="math inline">\(hw_j\)</span>和<span class="math inline">\(MaxRight-i+1\)</span>中取<span class="math inline">\(min\)</span>即可。</p>
<h3 id="当imaxright时">当<span class="math inline">\(i&gt;MaxRight\)</span>时</h3>
<p>此时显然<span class="math inline">\(hw_i\)</span>的求值不能利用之前的任意值，所以定下界为<span class="math inline">\(1\)</span>，也直接扩展即可。</p>
<h3 id="总结">总结</h3>
<h4 id="步骤">步骤</h4>
<p>综上所述，从左到右枚举<span class="math inline">\(i\)</span>的过程中，对于每个<span class="math inline">\(i\)</span>，算法步骤如下：</p>
<ol type="1">
<li>若<span class="math inline">\(i\le MaxRight\)</span>，则令<span class="math inline">\(hw_i=min(hw_{2*Mid-i}, MaxRight-i+1)\)</span>，否则令<span class="math inline">\(hw_i=1\)</span>（显然，<span class="math inline">\(i\)</span>关于<span class="math inline">\(Mid\)</span>的对称点<span class="math inline">\(j\)</span>为<span class="math inline">\(2*Mid-i\)</span>）。</li>
<li>以<span class="math inline">\(i\)</span>为中心扩展回文串，直到左右两边字符不同，或者到达边界。</li>
<li>更新<span class="math inline">\(MaxRight\)</span>和<span class="math inline">\(Mid\)</span>。</li>
<li>更新答案。扩展出来的子串在原串中的长度一定为<span class="math inline">\(hw_i-1\)</span>。因为在添加字符后的串中该子串长度为<span class="math inline">\(2hw_i-1\)</span>，由于首尾一定是特殊字符，所以特殊字符数量比其他字符多<span class="math inline">\(1\)</span>，所以特殊字符数量为<span class="math inline">\(hw_i\)</span>，其他字符为<span class="math inline">\(hw_i-1\)</span>。</li>
</ol>
<h4 id="一个小技巧">一个小技巧</h4>
<p>如果你的字符串下标从<span class="math inline">\(1\)</span>开始，你可以令<span class="math inline">\(s_0\)</span>为那个特殊字符，这样就省去了判断边界的问题。</p>
<h4 id="复杂度分析">复杂度分析</h4>
<p>根据上面三种情况的分析，在继续扩展<span class="math inline">\(hw_i\)</span>时，每一次的扩展都可以更新<span class="math inline">\(MaxRight\)</span>，而<span class="math inline">\(MaxRight\)</span>最多变化<span class="math inline">\(n\)</span>次，所以总的时间复杂度为<span class="math inline">\(\mathcal O(n)\)</span>的。</p>
</div><h2 id="代码实现">代码实现</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">11000005</span>], *ps = buf;</span><br><span class="line"><span class="keyword">int</span> n, hw[<span class="number">22000005</span>], mr = <span class="number">0</span>, mid = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">22000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    buf[<span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">11000005</span>, stdin)] = <span class="string">&#x27;\0&#x27;</span>, s[<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>; <span class="comment">// 小技巧</span></span><br><span class="line">    <span class="keyword">while</span> (*ps &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; *ps &lt;= <span class="string">&#x27;z&#x27;</span>) s[++n] = <span class="string">&#x27;#&#x27;</span>, s[++n] = *ps, ++ps;</span><br><span class="line">    s[++n] = <span class="string">&#x27;#&#x27;</span>; <span class="comment">// 插入特殊字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        hw[i] = i &lt;= mr ? std :: <span class="built_in">min</span>(hw[(mid &lt;&lt; <span class="number">1</span>) - i], mr - i + <span class="number">1</span>) : <span class="number">1</span>;  <span class="comment">// 得出下界</span></span><br><span class="line">        <span class="keyword">while</span> (s[i - hw[i]] == s[i + hw[i]]) ++hw[i]; <span class="comment">// 继续扩展</span></span><br><span class="line">        <span class="keyword">if</span> (i + hw[i] - <span class="number">1</span> &gt; mr) mid = i, mr = i + hw[i] - <span class="number">1</span>; <span class="comment">// 更新mr,mid</span></span><br><span class="line">        ans = std :: <span class="built_in">max</span>(ans, hw[i] - <span class="number">1</span>); <span class="comment">// 更新答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="参考资料">参考资料</h2><div class="story post-story">
<p><a href="https://segmentfault.com/a/1190000003914228">最长回文子串——Manacher 算法</a></p>

</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>「LuoguP2042」「NOI2005」维护数列</title>
    <url>/luogu2042-sol/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2042">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>维护一个序列，支持插入序列、区间删除、区间覆盖、区间翻转、区间求和、求序列最大子段和（至少包含一个元素）。</p>
<p>插入总数<span class="math inline">\(\le 4\times 10^6\)</span>，任意时刻序列长度<span class="math inline">\(\le 5\times 10^5\)</span>。</p>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p><span class="math inline">\(Splay\)</span>板子题。</p>
<span id="more"></span>
<p>不会<span class="math inline">\(Splay\)</span>的同学出门左转<a href="https://www.luogu.org/problemnew/show/P3391">文艺平衡树</a>。</p>
<p>由于插入数量太大，直接开4000000的数组显得不现实，我们考虑建立回收栈（雾），删除时遍历子树，回收被删除的节点，新建节点时优先从回收栈里取点，但是要注意各个数组都要初始化。</p>
<p>总体思路是，对每个节点维护：<span class="math inline">\(val,sz,sum,la,ra,ma\)</span>，分别表示这个点本身的值、子树大小、子树的<span class="math inline">\(val\)</span>之和、该区间（以这个点为根的子树所表示的区间，下同）中包含最左边元素的最长子段和（<strong>可以不包含元素</strong>）、包含最右边元素的最长子段和（<strong>可以不包含元素</strong>）、整个区间的最大子段和（<strong>至少包含一个元素</strong>，即答案）；懒标记<span class="math inline">\(cov=0/1,rev=0/1\)</span>，分别表示该区间是否被覆盖、是否被翻转。</p>
<p>接下来我们仔细分析每一步操作。</p>
<h3 id="新建节点">新建节点</h3>
<p>已经讲过，若回收栈里有点，则优先拿来用，否则新建节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> _val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = top ? rb[top--] : ++cnt; <span class="comment">// rb即回收栈</span></span><br><span class="line">    son[x][<span class="number">0</span>] = son[x][<span class="number">1</span>] = fa[x] = rev[x] = cov[x] = <span class="number">0</span>, sz[x] = <span class="number">1</span>; <span class="comment">// 注意别忘记初始化</span></span><br><span class="line">    val[x] = ma[x] = sum[x] = _val, la[x] = ra[x] = std :: <span class="built_in">max</span>(_val, <span class="number">0</span>); <span class="comment">// la,ra可以不包含元素</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上传">上传</h3>
<p>主要是<span class="math inline">\(la,ra,ma\)</span>的更新。<span class="math inline">\(la\)</span>和<span class="math inline">\(ra\)</span>同理，以<span class="math inline">\(la\)</span>为例，当前节点的<span class="math inline">\(la\)</span>值就是<code>max(左子树的la,左子树的sum+当前节点的val+右子树的la)</code>，分别表示跨过当前节点和不跨过当前节点两种情况。对于<span class="math inline">\(ma\)</span>，也差不多，不跨过的情况是<code>max(左子树的ma,右子树的ma)</code>，跨过的情况是<code>左子树的ra+当前节点的val+右子树的la</code>，在这两种情况中再取个<span class="math inline">\(max\)</span>即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">    sz[u] = sz[ls] + sz[rs] + <span class="number">1</span>, sum[u] = sum[ls] + sum[rs] + val[u];</span><br><span class="line">    la[u] = std :: <span class="built_in">max</span>(la[ls], sum[ls] + val[u] + la[rs]);</span><br><span class="line">    ra[u] = std :: <span class="built_in">max</span>(ra[rs], sum[rs] + val[u] + ra[ls]);</span><br><span class="line">    ma[u] = std :: <span class="built_in">max</span>(std :: <span class="built_in">max</span>(ma[ls], ma[rs]), ra[ls] + val[u] + la[rs]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="下传懒标记">下传懒标记</h3>
<p>比较简单，不需要考虑标记下传的顺序。</p>
<p>对于<span class="math inline">\(cov\)</span>标记，直接把左右儿子的<span class="math inline">\(val\)</span>设为当前节点的<span class="math inline">\(val\)</span>，<span class="math inline">\(sum\)</span>设为<span class="math inline">\(val\times sz\)</span>。而<span class="math inline">\(la,ra,ma\)</span>则需要分类讨论，若<span class="math inline">\(val&gt;0\)</span>，显然直接把整个区间选上更优，否则<span class="math inline">\(la,ra\)</span>不选，<span class="math inline">\(ma\)</span>只选一个点。</p>
<p>对于<span class="math inline">\(rev\)</span>标记，直接交换<strong>左右儿子</strong>的左右子树、<strong>左右儿子</strong>的<span class="math inline">\(la,ra\)</span>（注意不是交换当前节点的左右子树、<span class="math inline">\(la,ra\)</span>，这种写法在<a href="https://www.luogu.org/problemnew/show/P3391">文艺平衡树</a>可以过，但是在本题中会出错）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (cov[u])&#123;</span><br><span class="line">        <span class="keyword">if</span> (ls) val[ls] = val[u], cov[ls] = <span class="number">1</span>, sum[ls] = sz[ls] * val[u];</span><br><span class="line">        <span class="keyword">if</span> (rs) val[rs] = val[u], cov[rs] = <span class="number">1</span>, sum[rs] = sz[rs] * val[u];</span><br><span class="line">        <span class="keyword">if</span> (val[u] &gt; <span class="number">0</span>)&#123; <span class="comment">// 分类讨论</span></span><br><span class="line">            <span class="keyword">if</span> (ls) la[ls] = ra[ls] = ma[ls] = sum[ls];</span><br><span class="line">            <span class="keyword">if</span> (rs) la[rs] = ra[rs] = ma[rs] = sum[rs];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ls) la[ls] = ra[ls] = <span class="number">0</span>, ma[ls] = val[u];</span><br><span class="line">            <span class="keyword">if</span> (rs) la[rs] = ra[rs] = <span class="number">0</span>, ma[rs] = val[u];</span><br><span class="line">        &#125;</span><br><span class="line">        cov[u] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rev[u])&#123;</span><br><span class="line">        <span class="keyword">if</span> (ls) rev[ls] ^= <span class="number">1</span>, std :: <span class="built_in">swap</span>(son[ls][<span class="number">0</span>], son[ls][<span class="number">1</span>]), std :: <span class="built_in">swap</span>(la[ls], ra[ls]);</span><br><span class="line">        <span class="keyword">if</span> (rs) rev[rs] ^= <span class="number">1</span>, std :: <span class="built_in">swap</span>(son[rs][<span class="number">0</span>], son[rs][<span class="number">1</span>]), std :: <span class="built_in">swap</span>(la[rs], ra[rs]);</span><br><span class="line">        <span class="comment">// 交换左右儿子的左右子树和la,ra</span></span><br><span class="line">        rev[u] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建树">建树</h3>
<p>直接按照原序列的顺序建树（注意不是按数的大小建树）。</p>
<p>可是直接插入是<span class="math inline">\(\mathcal O(n\log n)\)</span>的，且常数较大。我们直接取序列中点作为根，然后递归调用左边和右边，分别作为根的左儿子和右儿子。</p>
<p>这样我们可以做到<span class="math inline">\(\mathcal O(n)\)</span>建树，<span class="math inline">\(n\)</span>是序列长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">new_node</span>(a[l]);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, u = <span class="built_in">new_node</span>(a[mid]);</span><br><span class="line">    <span class="comment">// 以mid为该子树的根，递归处理左右两边</span></span><br><span class="line">    son[u][<span class="number">0</span>] = <span class="built_in">build</span>(l, mid - <span class="number">1</span>, a), son[u][<span class="number">1</span>] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r, a);</span><br><span class="line">    fa[son[u][<span class="number">0</span>]] = fa[son[u][<span class="number">1</span>]] = u;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">up</span>(u), u; <span class="comment">// 注意更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="splay的基本操作rotatex和splayxg">Splay的基本操作：<span class="math inline">\(rotate(x)\)</span>和<span class="math inline">\(splay(x,g)\)</span></h3>
<p><span class="math inline">\(rotate(x)\)</span>表示将<span class="math inline">\(x\)</span>向上旋转，<span class="math inline">\(splay(x,g)\)</span>表示将<span class="math inline">\(x\)</span>旋转到<span class="math inline">\(g\)</span>的儿子。</p>
<p>注意<span class="math inline">\(rotate(x)\)</span>时需要上传操作，且要注意操作顺序。<span class="math inline">\(splay(x,g)\)</span>需要双旋。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> son[fa[x]][<span class="number">1</span>] == x; &#125; <span class="comment">// 返回x是他父亲的哪个儿子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k, <span class="keyword">int</span> y)</span></span>&#123; son[x][k] = y, fa[y] = x; &#125; <span class="comment">// 将x的k儿子变成y</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], d = <span class="built_in">dir</span>(x);</span><br><span class="line">    <span class="built_in">set</span>(fa[y], <span class="built_in">dir</span>(y), x), <span class="built_in">set</span>(y, d, son[x][!d]), <span class="built_in">set</span>(x, !d, y);</span><br><span class="line">    <span class="built_in">up</span>(y), <span class="built_in">up</span>(x); <span class="comment">// 注意上传以及上传的顺序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> g = <span class="number">0</span>)</span></span>&#123; <span class="comment">// g=0相当于旋转到根上</span></span><br><span class="line">    <span class="keyword">while</span> (fa[x] != g)&#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x];</span><br><span class="line">        <span class="keyword">if</span> (fa[y] != g) <span class="built_in">dir</span>(y) == <span class="built_in">dir</span>(x) ? <span class="built_in">rotate</span>(y) : <span class="built_in">rotate</span>(x);</span><br><span class="line">        <span class="built_in">rotate</span>(x); <span class="comment">// 双旋</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!g) rt = x; <span class="comment">// 更新rt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求当前序列中第k个位置在splay中对应的节点">求当前序列中第<span class="math inline">\(k\)</span>个位置在Splay中对应的节点</h3>
<p>这是下面前五个操作中必需的一个操作，即把序列中的位置转化为树上的节点编号。</p>
<p>这是一个经典的求第<span class="math inline">\(k\)</span>小的问题，直接按照左子树的<span class="math inline">\(sz\)</span>和当前的<span class="math inline">\(k\)</span>的大小关系决定往左、往右还是直接返回当前节点。</p>
<p>注意，此时由于需要用到儿子的信息，我们必须把<span class="math inline">\(u\)</span>的标记下传。</p>
<p>且因为这样做会把根到要求的那个节点的路径上的所有节点都<span class="math inline">\(down\)</span>一遍，所以在其余操作中不需要再进行<span class="math inline">\(down\)</span>操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(u); <span class="comment">// 下传标记</span></span><br><span class="line">    <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == sz[ls] + <span class="number">1</span>) <span class="keyword">return</span> u; <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= sz[ls]) <span class="keyword">return</span> <span class="built_in">kth</span>(ls, k); <span class="comment">// 向左走</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(rs, k - sz[ls] - <span class="number">1</span>); <span class="comment">// 向右走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入操作">插入操作</h3>
<p>对于插入操作，我们直接把<span class="math inline">\(pos\)</span>对应的节点<span class="math inline">\(splay\)</span>到根上（记为<span class="math inline">\(u\)</span>），把<span class="math inline">\(pos+1\)</span>的位置旋转到根下面（记为<span class="math inline">\(v\)</span>，即此时<span class="math inline">\(fa[v]=u\)</span>）。此时<span class="math inline">\(v\)</span>的左子树一定为空（不存在一个整数<span class="math inline">\(x\)</span>满足<span class="math inline">\(pos&lt;x&lt;pos+1\)</span>）。那么直接把需要插入的序列<span class="math inline">\(\mathcal O(n)\)</span>建树，把根节点连到<span class="math inline">\(v\)</span>上，作为<span class="math inline">\(v\)</span>的左子树即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> tot, <span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">build</span>(<span class="number">1</span>, tot, a);</span><br><span class="line">    <span class="keyword">int</span> u = <span class="built_in">kth</span>(rt, x); <span class="built_in">splay</span>(u);</span><br><span class="line">    <span class="keyword">int</span> v = <span class="built_in">kth</span>(rt, x + <span class="number">1</span>); <span class="built_in">splay</span>(v, u);</span><br><span class="line">    son[v][<span class="number">0</span>] = t, fa[t] = v, <span class="built_in">up</span>(v), <span class="built_in">up</span>(u);</span><br><span class="line">    <span class="comment">// 注意别忘记fa[t]=v和上传标记，不要习惯性打成up(u),up(v)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除操作">删除操作</h3>
<p>假设我们要删除的是区间<span class="math inline">\([l,r]\)</span>，那么同理，我们把<span class="math inline">\(l-1\)</span>对应的节点旋转到根上（记为<span class="math inline">\(u\)</span>），把<span class="math inline">\(r+1\)</span>的位置旋转到根下面（记为<span class="math inline">\(v\)</span>，即此时<span class="math inline">\(fa[v]=u\)</span>）。</p>
<p>此时<span class="math inline">\(v\)</span>的左子树所表示的区间即为<span class="math inline">\([l,r]\)</span>，那么我们直接把<span class="math inline">\(v\)</span>的左子树删除即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="comment">// 回收以u为根的子树</span></span><br><span class="line">    <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (ls) <span class="built_in">recycle</span>(ls);</span><br><span class="line">    <span class="keyword">if</span> (rs) <span class="built_in">recycle</span>(rs);</span><br><span class="line">    rb[++top] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="built_in">kth</span>(rt, l - <span class="number">1</span>); <span class="built_in">splay</span>(u);</span><br><span class="line">    <span class="keyword">int</span> v = <span class="built_in">kth</span>(rt, r + <span class="number">1</span>); <span class="built_in">splay</span>(v, u); <span class="comment">// 提区间操作</span></span><br><span class="line">    <span class="built_in">recycle</span>(son[v][<span class="number">0</span>]), son[v][<span class="number">0</span>] = <span class="number">0</span>, <span class="built_in">up</span>(v), <span class="built_in">up</span>(u); <span class="comment">// 更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="覆盖操作">覆盖操作</h3>
<p>与删除同理，提取区间<span class="math inline">\([l,r]\)</span>，打上<span class="math inline">\(cov\)</span>标记，更新即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="built_in">kth</span>(rt, l - <span class="number">1</span>); <span class="built_in">splay</span>(u);</span><br><span class="line">    <span class="keyword">int</span> v = <span class="built_in">kth</span>(rt, r + <span class="number">1</span>); <span class="built_in">splay</span>(v, u);</span><br><span class="line">    <span class="keyword">int</span> t = son[v][<span class="number">0</span>]; <span class="comment">// 提区间</span></span><br><span class="line">    val[t] = c, cov[t] = <span class="number">1</span>, sum[t] = sz[t] * c;</span><br><span class="line">    <span class="keyword">if</span> (c &gt; <span class="number">0</span>) la[t] = ra[t] = ma[t] = sum[t];</span><br><span class="line">    <span class="keyword">else</span> la[t] = ra[t] = <span class="number">0</span>, ma[t] = c; <span class="comment">// 打标记，与down中同理</span></span><br><span class="line">    <span class="built_in">up</span>(v), <span class="built_in">up</span>(u); <span class="comment">// 更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="翻转操作">翻转操作</h3>
<p>同理，提取区间后，打上<span class="math inline">\(rev\)</span>标记并更新。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="built_in">kth</span>(rt, l - <span class="number">1</span>); <span class="built_in">splay</span>(u);</span><br><span class="line">    <span class="keyword">int</span> v = <span class="built_in">kth</span>(rt, r + <span class="number">1</span>); <span class="built_in">splay</span>(v, u);</span><br><span class="line">    <span class="keyword">int</span> t = son[v][<span class="number">0</span>]; <span class="comment">// 提区间</span></span><br><span class="line">    rev[t] ^= <span class="number">1</span>, std :: <span class="built_in">swap</span>(son[t][<span class="number">0</span>], son[t][<span class="number">1</span>]), std :: <span class="built_in">swap</span>(la[t], ra[t]);</span><br><span class="line">    <span class="comment">// 打标记，与down中同理</span></span><br><span class="line">    <span class="built_in">up</span>(v), <span class="built_in">up</span>(u); <span class="comment">// 更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求和操作">求和操作</h3>
<p>提取区间后直接输出<span class="math inline">\(sum\)</span>值即可，不需要更新。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="built_in">kth</span>(rt, l - <span class="number">1</span>); <span class="built_in">splay</span>(u);</span><br><span class="line">    <span class="keyword">int</span> v = <span class="built_in">kth</span>(rt, r + <span class="number">1</span>); <span class="built_in">splay</span>(v, u);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum[son[v][<span class="number">0</span>]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大子段和">最大子段和</h3>
<p>直接输出<span class="math inline">\(ma[rt]\)</span>即可。</p>
<h3 id="一些细节">一些细节</h3>
<ol type="1">
<li>由于<span class="math inline">\(pos,l-1\)</span>可能会<span class="math inline">\(&lt;1\)</span>，<span class="math inline">\(pos+1,r\)</span>可能会<span class="math inline">\(&gt;n\)</span>，所以要考虑边界问题。我的代码中是直接把整个数组向右移动一位，并且使<span class="math inline">\(a[1]=a[n+2]=-\text{INF}\)</span>。个人觉得这个方法比较简单，只要在主程序中做一些简单的处理即可。</li>
<li>由于<span class="math inline">\(up\)</span>中没有判断左儿子或右儿子为空的情况（判起来会变得很鬼畜），所以我们令<span class="math inline">\(ma[0]=-\text{INF}\)</span>。</li>
</ol>
</div><h2 id="代码实现">代码实现</h2><div class="story post-story">
<p>总的再发一次吧。吸氧后<del>最快的一次</del>共1111ms。<a href="https://www.luogu.org/recordnew/show/15406481">评测记录</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 500000000</span></span><br><span class="line"><span class="keyword">int</span> n, m, a[N];</span><br><span class="line"><span class="keyword">char</span> opt[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> k, x, tot, c[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> rt, cnt, son[N][<span class="number">2</span>], fa[N], sz[N], val[N];</span><br><span class="line">    <span class="keyword">int</span> rev[N], cov[N], sum[N], la[N], ra[N], ma[N];</span><br><span class="line">    <span class="keyword">int</span> top, rb[<span class="number">5000005</span>];</span><br><span class="line">    <span class="built_in">Splay</span>()&#123;</span><br><span class="line">        rt = <span class="number">0</span>, cnt = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">        fa[<span class="number">0</span>] = son[<span class="number">0</span>][<span class="number">0</span>] = son[<span class="number">0</span>][<span class="number">1</span>] = sz[<span class="number">0</span>] = rev[<span class="number">0</span>] = cov[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        val[<span class="number">0</span>] = sum[<span class="number">0</span>] = la[<span class="number">0</span>] = ra[<span class="number">0</span>] = <span class="number">0</span>, ma[<span class="number">0</span>] = -INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> _val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = top ? rb[top--] : ++cnt;</span><br><span class="line">        son[x][<span class="number">0</span>] = son[x][<span class="number">1</span>] = fa[x] = rev[x] = cov[x] = <span class="number">0</span>, sz[x] = <span class="number">1</span>;</span><br><span class="line">        val[x] = ma[x] = sum[x] = _val, la[x] = ra[x] = std :: <span class="built_in">max</span>(_val, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (ls) <span class="built_in">recycle</span>(ls);</span><br><span class="line">        <span class="keyword">if</span> (rs) <span class="built_in">recycle</span>(rs);</span><br><span class="line">        rb[++top] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">        sz[u] = sz[ls] + sz[rs] + <span class="number">1</span>, sum[u] = sum[ls] + sum[rs] + val[u];</span><br><span class="line">        la[u] = std :: <span class="built_in">max</span>(la[ls], sum[ls] + val[u] + la[rs]);</span><br><span class="line">        ra[u] = std :: <span class="built_in">max</span>(ra[rs], sum[rs] + val[u] + ra[ls]);</span><br><span class="line">        ma[u] = std :: <span class="built_in">max</span>(std :: <span class="built_in">max</span>(ma[ls], ma[rs]), ra[ls] + val[u] + la[rs]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (cov[u])&#123;</span><br><span class="line">            <span class="keyword">if</span> (ls) val[ls] = val[u], cov[ls] = <span class="number">1</span>, sum[ls] = sz[ls] * val[u];</span><br><span class="line">            <span class="keyword">if</span> (rs) val[rs] = val[u], cov[rs] = <span class="number">1</span>, sum[rs] = sz[rs] * val[u];</span><br><span class="line">            <span class="keyword">if</span> (val[u] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ls) la[ls] = ra[ls] = ma[ls] = sum[ls];</span><br><span class="line">                <span class="keyword">if</span> (rs) la[rs] = ra[rs] = ma[rs] = sum[rs];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (ls) la[ls] = ra[ls] = <span class="number">0</span>, ma[ls] = val[u];</span><br><span class="line">                <span class="keyword">if</span> (rs) la[rs] = ra[rs] = <span class="number">0</span>, ma[rs] = val[u];</span><br><span class="line">            &#125;</span><br><span class="line">            cov[u] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rev[u])&#123;</span><br><span class="line">            <span class="keyword">if</span> (ls) rev[ls] ^= <span class="number">1</span>, std :: <span class="built_in">swap</span>(son[ls][<span class="number">0</span>], son[ls][<span class="number">1</span>]), std :: <span class="built_in">swap</span>(la[ls], ra[ls]);</span><br><span class="line">            <span class="keyword">if</span> (rs) rev[rs] ^= <span class="number">1</span>, std :: <span class="built_in">swap</span>(son[rs][<span class="number">0</span>], son[rs][<span class="number">1</span>]), std :: <span class="built_in">swap</span>(la[rs], ra[rs]);</span><br><span class="line">            rev[u] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dir</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> son[fa[x]][<span class="number">1</span>] == x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k, <span class="keyword">int</span> y)</span></span>&#123; son[x][k] = y, fa[y] = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x], d = <span class="built_in">dir</span>(x);</span><br><span class="line">        <span class="built_in">set</span>(fa[y], <span class="built_in">dir</span>(y), x), <span class="built_in">set</span>(y, d, son[x][!d]), <span class="built_in">set</span>(x, !d, y);</span><br><span class="line">        <span class="built_in">up</span>(y), <span class="built_in">up</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> g = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (fa[x] != g)&#123;</span><br><span class="line">            <span class="keyword">int</span> y = fa[x];</span><br><span class="line">            <span class="keyword">if</span> (fa[y] != g) <span class="built_in">dir</span>(y) == <span class="built_in">dir</span>(x) ? <span class="built_in">rotate</span>(y) : <span class="built_in">rotate</span>(x);</span><br><span class="line">            <span class="built_in">rotate</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!g) rt = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">new_node</span>(a[l]);</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, u = <span class="built_in">new_node</span>(a[mid]);</span><br><span class="line">        son[u][<span class="number">0</span>] = <span class="built_in">build</span>(l, mid - <span class="number">1</span>, a), son[u][<span class="number">1</span>] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r, a);</span><br><span class="line">        fa[son[u][<span class="number">0</span>]] = fa[son[u][<span class="number">1</span>]] = u;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">up</span>(u), u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="built_in">down</span>(u);</span><br><span class="line">        <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == sz[ls] + <span class="number">1</span>) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= sz[ls]) <span class="keyword">return</span> <span class="built_in">kth</span>(ls, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(rs, k - sz[ls] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> tot, <span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">build</span>(<span class="number">1</span>, tot, a);</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">kth</span>(rt, x); <span class="built_in">splay</span>(u);</span><br><span class="line">        <span class="keyword">int</span> v = <span class="built_in">kth</span>(rt, x + <span class="number">1</span>); <span class="built_in">splay</span>(v, u);</span><br><span class="line">        son[v][<span class="number">0</span>] = t, fa[t] = v, <span class="built_in">up</span>(v), <span class="built_in">up</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">kth</span>(rt, l - <span class="number">1</span>); <span class="built_in">splay</span>(u);</span><br><span class="line">        <span class="keyword">int</span> v = <span class="built_in">kth</span>(rt, r + <span class="number">1</span>); <span class="built_in">splay</span>(v, u);</span><br><span class="line">        <span class="built_in">recycle</span>(son[v][<span class="number">0</span>]), son[v][<span class="number">0</span>] = <span class="number">0</span>, <span class="built_in">up</span>(v), <span class="built_in">up</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">kth</span>(rt, l - <span class="number">1</span>); <span class="built_in">splay</span>(u);</span><br><span class="line">        <span class="keyword">int</span> v = <span class="built_in">kth</span>(rt, r + <span class="number">1</span>); <span class="built_in">splay</span>(v, u);</span><br><span class="line">        <span class="keyword">int</span> t = son[v][<span class="number">0</span>];</span><br><span class="line">        val[t] = c, cov[t] = <span class="number">1</span>, sum[t] = sz[t] * c;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) la[t] = ra[t] = ma[t] = sum[t];</span><br><span class="line">        <span class="keyword">else</span> la[t] = ra[t] = <span class="number">0</span>, ma[t] = c;</span><br><span class="line">        <span class="built_in">up</span>(v), <span class="built_in">up</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">kth</span>(rt, l - <span class="number">1</span>); <span class="built_in">splay</span>(u);</span><br><span class="line">        <span class="keyword">int</span> v = <span class="built_in">kth</span>(rt, r + <span class="number">1</span>); <span class="built_in">splay</span>(v, u);</span><br><span class="line">        <span class="keyword">int</span> t = son[v][<span class="number">0</span>];</span><br><span class="line">        rev[t] ^= <span class="number">1</span>, std :: <span class="built_in">swap</span>(son[t][<span class="number">0</span>], son[t][<span class="number">1</span>]), std :: <span class="built_in">swap</span>(la[t], ra[t]);</span><br><span class="line">        <span class="built_in">up</span>(v), <span class="built_in">up</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query_sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">kth</span>(rt, l - <span class="number">1</span>); <span class="built_in">splay</span>(u);</span><br><span class="line">        <span class="keyword">int</span> v = <span class="built_in">kth</span>(rt, r + <span class="number">1</span>); <span class="built_in">splay</span>(v, u);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum[son[v][<span class="number">0</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query_max_sum</span><span class="params">()</span></span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ma[rt]); &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), n += <span class="number">2</span>, a[<span class="number">1</span>] = a[n] = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) a[i] = <span class="built_in">read</span>(); <span class="comment">// 整体右移</span></span><br><span class="line">    T.rt = T.<span class="built_in">build</span>(<span class="number">1</span>, n, a);</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span> &amp;&amp; opt[<span class="number">2</span>] == <span class="string">&#x27;X&#x27;</span>) T.<span class="built_in">query_max_sum</span>();</span><br><span class="line">        <span class="keyword">else</span> x = <span class="built_in">read</span>() + <span class="number">1</span>, tot = <span class="built_in">read</span>(); <span class="comment">// +1是因为数组整体右移</span></span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) c[i] = <span class="built_in">read</span>();</span><br><span class="line">            T.<span class="built_in">insert</span>(x, tot, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>) T.<span class="built_in">erase</span>(x, x + tot - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span> &amp;&amp; opt[<span class="number">2</span>] == <span class="string">&#x27;K&#x27;</span>) T.<span class="built_in">cover</span>(x, x + tot - <span class="number">1</span>, <span class="built_in">read</span>());</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;R&#x27;</span>) T.<span class="built_in">reverse</span>(x, x + tot - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;G&#x27;</span>) T.<span class="built_in">query_sum</span>(x, x + tot - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如发现代码有问题请在评论中指出，谢谢！</p>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>NOI</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title>「LuoguP3846」「TJOI2007」可爱的质数 / BSGS 学习笔记</title>
    <url>/luogu3846-sol-bsgs-notes/</url>
    <content><![CDATA[<p>大步小步法（Baby Step Giant Step, BSGS），用于解决求形如 <span class="math inline">\(a^x\equiv b \pmod P\)</span> 的最小非负整数解，其中<span class="math inline">\((a,P)=1\)</span>。</p>
<span id="more"></span>
<h2 id="求解">求解</h2><div class="story post-story">
<p>显然 <span class="math inline">\(x\)</span> 可以表示为 <span class="math inline">\(i\cdot t-j\)</span> 的形式，其中 <span class="math inline">\(t\)</span> 是常数。那么原方程化为 <span class="math display">\[\begin{aligned}  a^{it-j} &amp;\equiv b &amp;\pmod P \\ \frac{a^{it}}{a^j} &amp;\equiv b &amp;\pmod P \\ a^{it}&amp;\equiv ba^j &amp;\pmod P \end{aligned}\]</span></p>
<p>又根据欧拉定理可得，<span class="math inline">\(a^b\equiv a^{b\bmod \varphi(P)}\pmod P\)</span>，所以最小非负整数解一定满足 <span class="math inline">\(0\le x &lt; \varphi(P)\)</span>。</p>
<p>那么 <span class="math inline">\(t\)</span> 取 <span class="math inline">\(\lfloor \sqrt{\varphi(P)}\rfloor\)</span> 时，<span class="math inline">\(i,j\)</span> 的数量都是 <span class="math inline">\(\mathcal O(\sqrt{P})\)</span> 的。所以我们只要对于所有的 <span class="math inline">\(i\)</span> 求出 <span class="math inline">\(a^{it}\)</span>，对于所有的 <span class="math inline">\(j\)</span> 求出 <span class="math inline">\(ba^j\)</span>，然后匹配即可。</p>
<p>具体实现时，可以用 <code>map</code> 或 <code>hashmap</code> 实现快速查找。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<p><a href="https://www.luogu.org/problemnew/show/P3846">「TJOI2007」可爱的质数</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> P, a, b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    a %= P, b %= P;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    std :: map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">sqrt</span>(P) + <span class="number">1</span>, x = <span class="number">1</span>, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i, x = <span class="number">1ll</span> * x * a % P)</span><br><span class="line">        M[<span class="number">1ll</span> * x * b % P] = i;</span><br><span class="line">    y = x;</span><br><span class="line">    <span class="keyword">if</span> (M.<span class="built_in">count</span>(<span class="number">1</span>) &amp;&amp; M[<span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i, x = <span class="number">1ll</span> * x * y % P)</span><br><span class="line">        <span class="keyword">if</span> (M.<span class="built_in">count</span>(x)) <span class="keyword">return</span> i * t - M[x];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_ans</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;no solution\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;P, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">write_ans</span>(<span class="built_in">BSGS</span>(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>TJOI</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title>「LuoguP3723」「AHOI / HNOI2017」礼物</title>
    <url>/luogu3723-sol/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3723">题目传送门</a></p>
<h2 id="题意">题意</h2><div class="story post-story">
<p>给定两个长度为<span class="math inline">\(n\)</span>的正整数序列<span class="math inline">\(a_0,a_1,a_2,\cdots,a_{n-1}\)</span>和<span class="math inline">\(b_0,b_1,b_2,\cdots,b_{n-1}\)</span>，满足<span class="math inline">\(a_i,b_i\le m\)</span>。</p>
<p>求<span class="math display">\[\sum_{i=0}^{n-1} ((a_i+c_0)-(b_{(i+k)\bmod n}+c_1))^2\]</span>的最小值，其中<span class="math inline">\(k,c_0,c_1\)</span>是非负整数。</p>
<p><span class="math inline">\(n\le 5\times 10^4,m\le 100\)</span>。</p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>观察上式，可以发现我们并不关心<span class="math inline">\(c_0,c_1\)</span>具体的值，只关心<span class="math inline">\(c_0-c_1\)</span>的值。记<span class="math inline">\(c=c_0-c_1\)</span>，显然有<span class="math inline">\(-m\le c\le m\)</span>。于是变成了求<span class="math display">\[\sum_{i=0}^{n-1} (a_i-b_{(i+k)\bmod n}+c)^2\]</span>的最小值，其中<span class="math inline">\(0\le k\le n-1,-m\le c\le m\)</span>。</p>
<p>最朴素的做法是直接枚举<span class="math inline">\(k,c\)</span>计算答案，时间复杂度<span class="math inline">\(O(n^2m)\)</span>。</p>
<p>这个和的平方的形式很难优化，考虑把它展开：</p>
<p><span class="math display">\[\begin{aligned} &amp;\quad \sum_{i=0}^{n-1}(a_i-b_{(i+k)\bmod n}+c)^2 \\ &amp;=\sum_{i=0}^{n-1}(a_i^2+b_{(i+k)\bmod n}^2+c^2-2a_ib_{(i+k)\bmod n}+2a_ic-2b_{(i+k)\bmod n}c) \\ &amp;=-2\sum a_ib_{(i+k)\bmod n}+\sum a_i^2+\sum b_i^2+2c\sum (a_i-b_i)+nc^2 \end{aligned}\]</span></p>
<p>然后我们发现，<span class="math inline">\(k,c\)</span>并没有同时影响答案中的某一项。第一项为与<span class="math inline">\(k\)</span>有关的式子，显然后面部分为关于<span class="math inline">\(c\)</span>的一个二次函数。后面部分可以直接用二次函数的顶点公式计算（注意<span class="math inline">\(c\)</span>是整数，需要讨论两种情况），也可以直接枚举<span class="math inline">\(c\)</span>进行计算。</p>
<p>如果前面部分也直接枚举<span class="math inline">\(k\)</span>进行计算的话，时间复杂度为<span class="math inline">\(\mathcal O(n^2)\)</span>，仍不能通过。</p>
<p>先不考虑系数。<span class="math inline">\(\bmod\)</span>很难处理，考虑把<span class="math inline">\(b\)</span>倍长，原式变成了<span class="math inline">\(\sum a_ib_{i+k}\)</span>。联系卷积的基本形式<span class="math inline">\(c_i=\sum_{j=0}^{i} a_jb_{i-j}\)</span>，可以发现需要满足<span class="math inline">\(a,b\)</span>的下标之和为<span class="math inline">\(c\)</span>的下标，即一个与<span class="math inline">\(j\)</span>无关的值。那么我们考虑把<span class="math inline">\(a\)</span>翻转，原式变成了<span class="math inline">\(\sum a_{n-i-1}b_{i+k}\)</span>，此时<span class="math inline">\(n-i-1+i+k=n+k-1\)</span>，是一个与<span class="math inline">\(i\)</span>无关的值。于是就可以FFT了。由于<span class="math inline">\(0\le k\le n-1\)</span>，所以对应的答案（假设<span class="math inline">\(c=a*b\)</span>）就是<span class="math inline">\(c_{n-1},c_{n},c_{n+1},\cdots,c_{2n-2}\)</span>。</p>
<p>啥？FFT精度爆了？因为<span class="math inline">\(m\le 100\)</span>，所以<span class="math inline">\(0\le c_i\le nm^2\le 5\times 10^8&lt; 998244353\)</span>，直接用NTT即可。</p>
<p>时间复杂度<span class="math inline">\(O(n\log n)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<p><a href="https://www.luogu.org/recordnew/show/15492151">评测记录</a>，开O2，总时间170ms，目前在第一页。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], b[N], c[N];</span><br><span class="line"><span class="keyword">namespace</span> Polynomial&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> P 998244353</span></span><br><span class="line">    <span class="keyword">int</span> omega[N], rev[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1ll</span> * a * a % P) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1ll</span> * s * a % P;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) &lt; n) ++k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) rev[i] = rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (i &amp; <span class="number">1</span>) &lt;&lt; k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123; (x += y) &gt;= P ? x -= P : <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> (x -= y) &lt; <span class="number">0</span> ? x + P : x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a, <span class="keyword">int</span> o = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (i &lt; rev[i]) std :: <span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> m = <span class="number">1</span>, l; m &lt; n; m = l)&#123;</span><br><span class="line">            l = m &lt;&lt; <span class="number">1</span>, omega[<span class="number">0</span>] = <span class="number">1</span>, omega[<span class="number">1</span>] = <span class="built_in">qpow</span>(~o ? <span class="number">3</span> : <span class="number">332748118</span>, (P - <span class="number">1</span>) / l);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i) omega[i] = <span class="number">1ll</span> * omega[i - <span class="number">1</span>] * omega[<span class="number">1</span>] % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> *p = a, t; p &lt; a + n; p += l)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)</span><br><span class="line">                    t = <span class="number">1ll</span> * p[k + m] * omega[k] % P, p[k + m] = <span class="built_in">sub</span>(p[k], t), <span class="built_in">add</span>(p[k], t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> _n = <span class="built_in">qpow</span>(n, P - <span class="number">2</span>), i = <span class="number">0</span>; i &lt; n; ++i) a[i] = <span class="number">1ll</span> * a[i] * _n % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Multiply</span><span class="params">(<span class="keyword">int</span> na, <span class="keyword">int</span> *a, <span class="keyword">int</span> nb, <span class="keyword">int</span> *b, <span class="keyword">int</span> nc, <span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; nc) n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">init</span>(n), <span class="built_in">NTT</span>(n, a), <span class="built_in">NTT</span>(n, b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) c[i] = <span class="number">1ll</span> * a[i] * b[i] % P;</span><br><span class="line">        <span class="built_in">NTT</span>(n, c, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s = INF, ans = INF;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[n - i - <span class="number">1</span>] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) b[i + n] = b[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        s1 += <span class="number">1ll</span> * a[i] * a[i] + <span class="number">1ll</span> * b[i] * b[i], s2 += (a[i] &lt;&lt; <span class="number">1</span>) - (b[i] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    Polynomial :: <span class="built_in">Multiply</span>(n, a, n &lt;&lt; <span class="number">1</span>, b, n &lt;&lt; <span class="number">1</span>, c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - <span class="number">1</span>; i &lt; (n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>; ++i) s = std :: <span class="built_in">min</span>(s, <span class="number">-2ll</span> * c[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = -m; i &lt;= m; ++i)</span><br><span class="line">        ans = std :: <span class="built_in">min</span>(ans, <span class="number">1ll</span> * n * i * i + s2 * i + s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>AHOI</tag>
        <tag>HNOI</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI2021 RP 爆棚记</title>
    <url>/noi2021/</url>
    <content><![CDATA[<p><del>咕咕咕</del></p>
<h2 id="day--n">Day -n</h2><div class="story post-story">
<p>PKUSC 考炸了，zyy 布置作业：两个月在 CF 上做 500 道 2300+。</p>
<p>于是开始了卷题生活。</p>
</div><h2 id="day--10">Day -10</h2><div class="story post-story">
<p>zyy 和 wzp 来讲课了。</p>
<p>zyy 的作业没做完，裂了。</p>
<p>wzp 的例题都不会，他说不会做的可以弃考了。我是不是该退役了 /kk</p>
</div><h2 id="day--2">Day -2</h2><div class="story post-story">
<p>貌似晚上开着空调被子没盖感冒了。</p>
<p>有亿点危 /fad</p>
<p>打算第二天休息一天的，结果突然说报到提前了一天，我 ****</p>
</div><h2 id="day--1">Day -1</h2><div class="story post-story">
<p>上午在家里休息了半天，下午因为感冒了，就没有坐大巴，自己去了余姚。</p>
<p>和 Froggy 一起换了下寝室，于是就开心地和 Froggy、wcr 一起住了 /cy</p>
<p>看了一下笔试，颓了一晚上。</p>
<p>食堂貌似不太行（？）</p>
</div><h2 id="day-0">Day 0</h2><div class="story post-story">
<p>听说烟花要提前登陆了，有点慌 /fad</p>
<p>中饭变成自助餐了，貌似不错（</p>
<span id="more"></span>
<p>教练突然通知下午可能要笔试，赶紧再去看了看笔试。</p>
<p>笔试从三点变成了两点半，结果又鸽到了三点...</p>
<p>为啥笔试会出不在笔试题库里的题啊 /jk</p>
<p>不过还好拿了 100 /cy</p>
</div><h2 id="day-0.5">Day 0.5</h2><div class="story post-story">
<p>没啥安排，在寝室颓废+睡觉。</p>
<p>做了一道题，发现因为感冒几天不敲代码码力有点不太行了 /kk</p>
<p>晚上突然通知明天八点半集合待命...这又是啥奇怪的操作...</p>
<p>晚上感冒竟然好了（</p>
</div><h2 id="day-1">Day 1</h2><div class="story post-story">
<p>八点半集合进场，八点四十说十点之前开始考，八点五十说九点开始考试。这 NOI 也太阴间了...</p>
<p>有亿点紧张。</p>
<p>开场一个小时看 T1 屁都不会，各种想法都想不通，有点自闭。</p>
<p>上了个厕所有了个比较复杂的想法，写写写。</p>
<p>到十一点半，终于把大样例调过了，结果第四个样例就跑了 3s /jk</p>
<p>自闭了，上了个（女）厕所冷静一下，看了看 T2，秒杀了 A 性质，再猜了猜结论大概半个小时把大样例过了。结果又跑了 3s /tuu</p>
<p>卡了 15min 常，变成了 0.3s，又开始卡 T1...</p>
<p>先把两棵线段树合并成了一棵，稍微快了一点，这时候已经一点了。想了一下 T3，看出来了题目里条件本质上是有用的边是一棵树，但是貌似不是很会建这棵树，就还是先去卡 T1 的常。</p>
<p>把线段树改成了 zkw 线段树，还 WA 掉了调了很久，一直在调 T1 和写 T3 暴力之间来回横跳。最后 T1 第四个样例跑了 1.5s，第五个样例跑了 0.8s，放弃了...</p>
<p>估分 60+100+24=184，问了一圈都是 250+ 还一车 AK，不过绍一的几个正式选手貌似都只有 200 出头？</p>
<p>紧张刺激的查分时刻！我 T1 竟然过了，T3 的第二档竟然也过了，竟然有 100+100+36=236，虽然还是有点低，但是已经比我预期高了好多了。</p>
<p>绍一的其他几个正式选手竟然都比我还低，感觉绍一今年要 wei。Froggy 260，不是正式选手可惜了（</p>
</div><h2 id="day-1.5">Day 1.5</h2><div class="story post-story">
<p>上午颓废+睡觉，下午去参加了 NOI 嘉年华。掷骰子 16 分算是拿了个中规中矩的分，保龄球第一次歪了从背后弹回来倒了 7 个，第二次歪了直接一个都没有（暗示 Day2 要爆蛋），拿了 8 分。听说二等奖要 85 分，直接死透了。</p>
<p>后来好像又降到了 80 分，但是那个投壶太难了，只投中 1 个拿了 12 分，彻底没救了。</p>
<p>不过看飞镖还挺好玩的就去玩了一下，第一发只想着要用力没管方向飞到了墙上还弹回来插在了地上。第二发直接飞到了 16*3，貌似直接满分了。</p>
<p>还有一个乒乓但是时间差不多到了，就拿了盒榨菜回去了（</p>
<p>晚上早点洗洗睡了。</p>
</div><h2 id="day-2">Day 2</h2><div class="story post-story">
<p>晚上貌似没睡好，早上还很早就醒了，有亿点困...</p>
<p>开场 1h 三道题都看了一遍想了想。T1 没啥思路；T2 那个分数没见过完全观察不出性质，还有 gcd 等于 1 也不知道咋保证，就先丢了；T3 样例解释里很好心地提示了容斥，不过好像复杂度有点高，只能拿一点点分。</p>
<p>上了个厕所，想到 T1 可以随机若干位置相等，离线下来好像可以做的样子。写了一发，样例都过了，但是随了一组极限数据大概 30 组询问就会错一个，有点裂开。输出了一下随机的轮数发现只跑了 7 次，要保证正确性大概要跑 30+ 次，泪目了。</p>
<p>T2 还是没什么想法，就跑去做 T3 了。</p>
<p>想着可以先写一下暴力一点的 DP 再优化。大概写了个 2^(max R 的个数)*n*m 的做法，过了前三个样例结果第四个样例跑了 7s 还 WA 了 /jk</p>
<p>自闭了，差不多只剩 1h 了，于是放弃了 T1T3，滚回去看 T2 了。</p>
<p>稍微分析了一下发现之前我在白给，分子分母一定互质，而且分子分母的规律还是挺好找的...但是时间来不及了，我还没分析出操作序列对应序列的性质，就算分析出来也不可能来得及写平衡树了，所以就冲了一发 50 分暴力。</p>
<p>泪目，估分 (50~80)+50+(0~20)，差不多 100 多一点。</p>
<p>没啥心情吃饭了，迫于教练压力随便吃了点，回寝室等查分。</p>
<p>查分查出来 T1 竟然过了，T3 也超出了我的预期！不过 T2 挂了点，最后得分 100+40+32=172。</p>
<p>不过 Froggy、zyk 都被卡常了，貌似有点泪目 /fad</p>
<p>这样总分就有 508 了，感觉按照以往的队线好像大概率能上了！</p>
<p>感觉我 RP 爆棚了，这都能翻到 500+</p>
<p>结果 QQ 群里一堆人说分数线 500+，还有说 510+、520 的，慌起来了 /kk</p>
<p>讲题一直没心思听，高校宣讲是线上的就鸽了，吃完晚饭就拉着 kmd 一直在贴成绩的地方晃，听两个教练说分数线 498，还当了两回工具人（给别人拍照）。</p>
<p>逛了一圈回来发现有一群人在贴成绩，赶紧跑过去看。结果还没看到自己人在哪里就有人说了分数线 498，算是安心了。不过也不知道为啥我好像心情挺平静的，貌似也没有太激动（</p>
<p>晚上和 Froggy、kmd、zz、wcr 打了好久的牌，还吃了桶方便面（</p>
</div><h2 id="day-3">Day 3</h2><div class="story post-story">
<p>和 sys 一起上台领奖了（</p>
<p>身高差有点小大（</p>
<p>下午就回家了。</p>
<p>NOI 就这样结束了。</p>
<p>新的征程开始了。</p>
<p>祝我好运！</p>
<hr />
<p>不过我到现在还没搞清楚为啥我代码在最终测评的时候会快这么多，有点懵 /fad</p>

</div>]]></content>
      <categories>
        <category>游记</category>
        <category>NOI</category>
      </categories>
  </entry>
  <entry>
    <title>一个镜像</title>
    <url>/mirror/</url>
    <content><![CDATA[<p>由于最近 GitHub 遭到多次攻击，国内经常上不去 GitHub Pages，且 GitHub 加载较慢，所以在 Gitee 上搭了一个镜像站，尽量做到实时同步（因为 Gitee Pages 需要手动部署）。</p>
<ul>
<li><a href="https://autumnkite.github.io/">GitHub Pages 链接</a></li>
<li><a href="https://autumnkite.gitee.io/">Gitee Pages 链接</a></li>
</ul>

]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2018 题解</title>
    <url>/noip2018-sol/</url>
    <content><![CDATA[<p>蒟蒻写的 NOIP2018 题解，欢迎吐槽。</p>
<span id="more"></span>


	<div class="row">
    <embed src="/files/NOIP2018_Solution.pdf" width="100%" height="550" type="application/pdf">
	</div>




]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NOIP2018</tag>
      </tags>
  </entry>
  <entry>
    <title>PKUWC2019 自闭记</title>
    <url>/pkuwc2019/</url>
    <content><![CDATA[<p>评（tu）价（cao）：<a href="https://www.zhihu.com/question/309834123">如何评价PKUWC 2019？ - 知乎</a></p>
<h2 id="day--n">Day -N</h2><div class="story post-story">
<p>联赛没考好。不过最后还是能去PKUWC。于是就又去某强者聚集的高中被吊锤了。</p>
<span id="more"></span>
</div><h2 id="day--1">Day -1</h2><div class="story post-story">
<p>晚上。吃完晚饭以后就到了火车站，大概7点左右到的吧。然后就是等人、取票、进站……</p>
<p>先乘高铁到杭州，然后在杭州转车（动卧）。在杭州也等了好一会吧，20:55，动车开了……</p>
<p>基本就是整理行李、玩手机以及各种探索（大雾。</p>
</div><h2 id="day-0">Day 0</h2><div class="story post-story">
<p>凌晨2点醒了一次，好像是被冷醒的，因为房间里吹出来的风是冷的。盖好被子以后就又睡着了，早上5:10就被fy吵醒了……总的来说睡眠质量极差。</p>
<p>8点就到中山了，有专车来接，直接到中山纪念中学报到了。纪中占地面积是真的大，850亩，风景挺好的。</p>
<p>没事干，就去旁边的孙中山故居逛了一圈，fy和ykl都去参加了那个答题，得到了一个胸章。</p>
<p>天气很好，气温很高，穿着棉袄、线衫、加绒裤，热到不行。</p>
<p>回酒店，在旁边的餐馆吃中饭，可惜的是烧鹅没了，只能吃烧鸭。4点回学校，试机，吃晚饭。这里的食堂不是很好，饭没有浙江的好吃。试机T2都不会做。</p>
<p>晚上逛学校，还好袋子里有地图，差点迷路……</p>
</div><h2 id="day-1">Day 1</h2><div class="story post-story">
<p>上午开营仪式，看了一下宣传片，听了纪中的校长、北大的两个教授的讲话。门开得正可海星。然后是营员合影。</p>
<p>下午的上机爆炸。T1就是个状压，我想到正解感觉好麻烦就放弃了……最后还是只有35的暴力。</p>
<p>T2想了好一会<span class="math inline">\(m=2\)</span>和链的做法，想了没多久也放弃了。</p>
<p>T3地主斗，写了2.5h一分未得。考后和同学的方法比较，感觉细节应该都判了啊。</p>
<p>最后35+0+0=35……自闭了，还是策略不对吧。</p>
</div><h2 id="day-2">Day 2</h2><div class="story post-story">
<p>早上突然想到地主斗那题，排的顺序是无关的，搜索的时候要判一下……</p>
<p>上午数学考试，实质是提答十合一，貌似是py优势场。我这种菜鸡只会写暴力，大概只对了两道？</p>
<p>下午的上机仍然爆炸，T1第一个包一眼，第二个包想了好久，不过还好搞出来了。</p>
<p>T2当时好像<span class="math inline">\(n,m\le 10\)</span>都不会，最后40分钟感觉没事干就写了个很fake的dfs，竟然过了。</p>
<p>T3不说了，计算几何告辞（知道前两个包怎么做，不会实现）。</p>
<p>当场自闭，T1满分想不出来，T2根本不会，为了防止跟昨天一样，我<del>果断</del>（其实还是很犹豫地）放弃了T3。</p>
<p>最后得分48+21+0=69。自闭了。</p>
</div><h2 id="day-3">Day 3</h2><div class="story post-story">
<p>这种分数显然进不了面试，滚粗。还是太菜了啊。</p>
<p>于是我和zyk就在ll的带领下去珠海<del>旅游</del>了（另外两人比较颓，没来）。</p>
<p>ll说我们主要是因为数学考太差，然而我觉得我都考太差……</p>
<p>先到海滨公园，看了珠海渔女。海岸线确实挺曲折的。然后就差不多要吃饭了，沿海岸线走到了一家海鲜餐厅，点了大概6碗菜吧，味道还不错。</p>
<p>饭吃完我们骑共享单车沿海岸线骑，一直骑到边防管理区（通往澳门的桥的桥头），大概骑了7km。发现那里离珠海站很近，就直接乘轻轨回到南朗，买了六点半的票。发现还早，于是提议去圆明新园逛一圈。</p>
<p>又骑了5km，在圆明新园里面逛了一圈，感觉就是个横店影视城的弱化版？去坐了一下缆车，但是观景体验极差，感觉浪费了150块钱。</p>
<p>差不多时间了就去珠海站附近，逛了一圈决定吃煲仔饭，吃完就去进站候车了。</p>
<p>基本一下午都在骑车、走路，心态崩。</p>
</div><h2 id="day-4">Day 4</h2><div class="story post-story">
<p>打算8点起床的，结果9点才醒，还是因为窗帘没拉好透出了光被亮醒的……起床之后去吃了早饭，然后洗了个澡，等ykl也完了以后就下去了。</p>
<p>退房，上大巴。大部分人都是去机场的，就我们四个人，变成包车了。一路上qq和司机聊得挺欢。</p>
<p>中饭吃车站里的麦当劳，高铁15:38开，就在车站里找了个位置玩手机。车站人很多，大概是因为春运？好不容易才找到位置。</p>
<p>晚饭在高铁上吃盒饭，拿了个鸡翅和鱼，竟然要￥60……而且不是很好吃……</p>
<p>到义乌，fy爸爸来接，到家23:00，等睡着就00:00了。</p>
<p>还是太菜了，省选根本没戏，正月要恶补文化课了。班主任还强迫我把期末考试补起来，啥都没复习，还没有状态……凉凉。</p>

</div>]]></content>
      <categories>
        <category>游记</category>
        <category>PKUWC</category>
      </categories>
  </entry>
  <entry>
    <title>后缀数组 学习笔记</title>
    <url>/suffix-array-notes/</url>
    <content><![CDATA[<p>后缀数组（Suffix Array, SA）是处理字符串的有力工具。它可以解决一些与字符串后缀LCP有关的问题。</p>
<span id="more"></span>
<h2 id="一些记号和约定">一些记号和约定</h2><div class="story post-story">
<ol type="1">
<li>在字符串<span class="math inline">\(S\)</span>中，第<span class="math inline">\(i\)</span>个字符到第<span class="math inline">\(j\)</span>个字符（包括<span class="math inline">\(i,j\)</span>）组成的子串记作<span class="math inline">\(S[i,j]\)</span>。</li>
<li>在字符串<span class="math inline">\(S\)</span>中，第<span class="math inline">\(i\)</span>个字符开始的后缀记作<span class="math inline">\(\text{Suffix}(i)\)</span>。</li>
<li>记<span class="math inline">\(SA[i]\)</span>表示字符串<span class="math inline">\(S\)</span>的所有后缀从小到大排序后，第<span class="math inline">\(i\)</span>个后缀的开始位置。<span class="math inline">\(SA\)</span>即后缀数组。</li>
<li>记<span class="math inline">\(rank[i]\)</span>表示字符串<span class="math inline">\(S\)</span>的第<span class="math inline">\(i\)</span>个后缀从小到大的排名，即<span class="math inline">\(SA\)</span>的逆数组。</li>
</ol>
<p>下面给出一个例子（字符串下标从<span class="math inline">\(1\)</span>开始）：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">String S:  <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line">    Rank:  <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line">--------------------------</span><br><span class="line">SA<span class="selector-attr">[1]</span>=<span class="number">4</span> -&gt; <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line">SA<span class="selector-attr">[2]</span>=<span class="number">5</span> -&gt; <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line">SA<span class="selector-attr">[3]</span>=<span class="number">6</span> -&gt; <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line">SA<span class="selector-attr">[4]</span>=<span class="number">1</span> -&gt; <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line">SA<span class="selector-attr">[5]</span>=<span class="number">7</span> -&gt; <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line">SA<span class="selector-attr">[6]</span>=<span class="number">2</span> -&gt; <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line">SA<span class="selector-attr">[7]</span>=<span class="number">8</span> -&gt; <span class="selector-tag">b</span></span><br><span class="line">SA<span class="selector-attr">[8]</span>=<span class="number">3</span> -&gt; <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> b</span><br></pre></td></tr></table></figure>
<p>由于<span class="math inline">\(rank\)</span>是<span class="math inline">\(SA\)</span>的逆数组，在求出<span class="math inline">\(SA\)</span>数组后，我们可以<span class="math inline">\(\mathcal O(|S|)\)</span>求出<span class="math inline">\(rank\)</span>数组，即<code>rank[sa[i]]=i</code>。</p>
</div><h2 id="一个简单的实现">一个简单的实现</h2><div class="story post-story">
<p>设字符串长度为<span class="math inline">\(n\)</span>且下标从<span class="math inline">\(1\)</span>开始。</p>
<p>我们直接把<span class="math inline">\(S\)</span>的每个后缀求出，然后用任意一种排序方法，在比较时暴力<span class="math inline">\(\mathcal O(n)\)</span>比较两个后缀的大小即可。</p>
<p>这种方法的复杂度太劣，我们尝试优化。</p>
</div><h2 id="倍增算法">倍增算法</h2><div class="story post-story">
<h3 id="前置知识">前置知识</h3>
<p>倍增，基数排序。</p>
<p>由于基数排序较为简单，这里不详细讲。</p>
<h3 id="算法思想">算法思想</h3>
<p>倍增算法的主要思想是：用倍增的方法对每个字符开始长度为<span class="math inline">\(2^k\)</span>的子串进行排序，求出排名。<span class="math inline">\(k\)</span>从<span class="math inline">\(0\)</span>开始，直到<span class="math inline">\(2^k&gt;n\)</span>时，这些子串就是<span class="math inline">\(S\)</span>的所有后缀。</p>
<p>可以发现，如果我们能<span class="math inline">\(\mathcal O(n)\)</span>求出每个字符开始长度为<span class="math inline">\(2^k\)</span>的子串排序后的结果，那么此算法的复杂度就是<span class="math inline">\(\mathcal O(n\log n)\)</span>的。</p>
<p>考虑利用<span class="math inline">\(k-1\)</span>时的排序结果快速求出当前结果。</p>
<p>由于我们已经求出每个字符开始长度为<span class="math inline">\(2^{k-1}\)</span>的子串的排名，那么字符串的比较变成了排名的比较。</p>
<p>这是一个双关键字排序，设当前字符为<span class="math inline">\(i\)</span>，则第一关键字为<span class="math inline">\(i\)</span>开始长度为<span class="math inline">\(2^{k-1}\)</span>的子串的排名，第二关键字为<span class="math inline">\(i+2^k\)</span>开始长度为<span class="math inline">\(2^{k-1}\)</span>的子串的排名。</p>
<p>如果用快速排序，则总复杂度为<span class="math inline">\(\mathcal O(n\log^2 n)\)</span>。</p>
<p>由于排名的值不会超过<span class="math inline">\(n\)</span>，我们考虑用基数排序做到总复杂度为<span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<p>双关键字的基数排序只要先按照<strong>第二关键字</strong>从小到大排序，再按照<strong>第一关键字</strong>从小到大排序即可，都可以做到<span class="math inline">\(\mathcal O(n)\)</span>的复杂度。</p>
<h3 id="算法实现">算法实现</h3>
<h4 id="技巧">技巧</h4>
<p>直接基数排序的常数较大，我们考虑每次把排序后的结果暂存在<span class="math inline">\(SA\)</span>数组中，即当前的<span class="math inline">\(SA[i]\)</span>表示每个字符开始长度为<span class="math inline">\(2^k\)</span>的子串进行排序后，排名为<span class="math inline">\(i\)</span>的子串的起始位置。</p>
<p>这样一来，我们可以利用<span class="math inline">\(k-1\)</span>时求出来的<span class="math inline">\(SA\)</span>数组，直接按第二关键字排好序，再按第一关键字排序。</p>
<h4 id="代码">代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sa[N], tx[N], ty[N], cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Radix_Sort</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> *x, <span class="keyword">int</span> *y, <span class="keyword">int</span> *sa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) cnt[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[x[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i) sa[cnt[x[y[i]]]--] = y[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[x] == a[y] &amp;&amp; a[x + l] == a[y + l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_SA</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> *a, <span class="keyword">int</span> *sa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x = tx, *y = ty;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) x[i] = a[i], y[i] = i;</span><br><span class="line">    <span class="built_in">Radix_Sort</span>(n, m, x, y, sa);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; j &lt;&lt;= <span class="number">1</span>, m = p)&#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - j + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (sa[i] &gt; j) y[++p] = sa[i] - j;</span><br><span class="line">        <span class="built_in">Radix_Sort</span>(n, m, x, y, sa);</span><br><span class="line">        std :: <span class="built_in">swap</span>(x, y), p = <span class="number">1</span>, x[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            x[sa[i]] = <span class="built_in">cmp</span>(y, sa[i - <span class="number">1</span>], sa[i], j) ? p : ++p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码解释">代码解释</h4>
<p>代码中的<span class="math inline">\(x[i]\)</span>表示<span class="math inline">\(i\)</span>开始长度为<span class="math inline">\(j=2^k\)</span>的子串排序后的排名，<span class="math inline">\(y[i]\)</span>在前半部分表示按<strong>第二关键字</strong>排序后，排名为<span class="math inline">\(i\)</span>的子串的起始位置。</p>
<p><code>Radix_Sort</code>函数即基数排序，不详细阐述。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *x = tx, *y = ty;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) x[i] = a[i], y[i] = i;</span><br><span class="line"><span class="built_in">Radix_Sort</span>(n, m, x, y, sa);</span><br></pre></td></tr></table></figure>
<p>这三行是初始化，由于长度为<span class="math inline">\(1\)</span>，直接按照字符本身为第一关键字进行排序，<span class="math inline">\(y[i]=i\)</span>时表示没有第二关键字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; j &lt;&lt;= <span class="number">1</span>, m = p)&#123;</span><br><span class="line">    p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - j + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (sa[i] &gt; j) y[++p] = sa[i] - j;</span><br><span class="line">    <span class="built_in">Radix_Sort</span>(n, m, x, y, sa);</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(j\)</span>枚举的是<span class="math inline">\(\frac{2^k}{2}\)</span>的值，即当前需要排序的子串长度的一半。首先把第二关键字为<span class="math inline">\(0\)</span>的位置加入<span class="math inline">\(y\)</span>。然后按第二关键字从小到大的加入<span class="math inline">\(y\)</span>。为什么可以这样写？因为<span class="math inline">\(sa[i]\)</span>表示排名为<span class="math inline">\(i\)</span>的子串的初始位置，即<span class="math inline">\(sa[i]\)</span>的排名一定是除<span class="math inline">\(0\)</span>外第<span class="math inline">\(i\)</span>小的，而以<span class="math inline">\(sa[i]\)</span>的排名作为第二关键字的位置就是<span class="math inline">\(sa[i]-j\)</span>，所以这样做就是把位置按第二关键字从小到大的加入<span class="math inline">\(y\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    std :: <span class="built_in">swap</span>(x, y), p = <span class="number">1</span>, x[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        x[sa[i]] = <span class="built_in">cmp</span>(y, sa[i - <span class="number">1</span>], sa[i], j) ? p : ++p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码中，由于前面的<span class="math inline">\(y\)</span>数组毫无用处了，就交换<span class="math inline">\(x,y\)</span>，使得<span class="math inline">\(y\)</span>表示上一个<span class="math inline">\(j\)</span>时的排名，把<span class="math inline">\(x\)</span>更新为当前<span class="math inline">\(j\)</span>时的排名。这里不能直接写<code>x[sa[i]]=i</code>的原因是有些子串可能会相等，那么它们的排名也应该相等。<span class="math inline">\(p\)</span>记录的是排名不同的子串数量，如果<span class="math inline">\(p=n\)</span>则直接退出循环。</p>
</div><h2 id="另一种算法">另一种算法</h2><div class="story post-story">
<p>还有一种求后缀数组的算法，叫做<span class="math inline">\(\text{DC3}\)</span>。该算法可以做到复杂度<span class="math inline">\(\mathcal O(n)\)</span>建立后缀数组，但由于常数较大且代码复杂度较高，不推荐使用。</p>
<p>有兴趣的同学可以查阅参考资料<span class="math inline">\([1]\)</span>。</p>
</div><h2 id="height数组"><span class="math inline">\(height\)</span>数组</h2><div class="story post-story">
<p>在具体应用中，<span class="math inline">\(SA\)</span>数组的应用并不多，更多的是另一个可以利用<span class="math inline">\(SA,rank\)</span>数组求出的数组——<span class="math inline">\(height\)</span>数组。</p>
<h3 id="定义">定义</h3>
<p><span class="math inline">\(height[i]\)</span>表示<span class="math inline">\(\text{Suffix}(SA[i])\)</span>和<span class="math inline">\(\text{Suffix}(SA[i-1])\)</span>的最长公共前缀（Longest Common Prefix, LCP）。即排名相邻的两个后缀的<span class="math inline">\(\text{LCP}\)</span>。</p>
<h3 id="性质">性质</h3>
<h4 id="性质一">性质一</h4>
<p>对于任意<span class="math inline">\(i,j(rank[i]&lt;rank[j])\)</span>，<span class="math inline">\(\text{Suffix}(i)\)</span>与<span class="math inline">\(\text{Suffix}(j)\)</span>的<span class="math inline">\(\text{LCP}\)</span>为<span class="math inline">\(\min\limits_{rank[i]&lt;k\le rank[j]} height[k]\)</span>。</p>
<p>这个性质比较显然，证明略。</p>
<h4 id="性质二">性质二</h4>
<p>记<span class="math inline">\(H[i]=height[rank[i]]\)</span>。对于任意<span class="math inline">\(i&gt;1\)</span>，有<span class="math inline">\(H[i]\ge H[i-1]-1\)</span>。</p>
<p>证明：当<span class="math inline">\(H[i-1]\le 1\)</span>时显然。当<span class="math inline">\(H[i]&gt;1\)</span>时，假设排<span class="math inline">\(\text{Suffix}(i-1)\)</span>前一名的后缀是<span class="math inline">\(\text{Suffix}(k)\)</span>，则<span class="math inline">\(\text{Suffix}(i)\)</span>与<span class="math inline">\(\text{Suffix}(k+1)\)</span>的<span class="math inline">\(\text{LCP}\)</span>为<span class="math inline">\(H[i-1]-1\)</span>（相当于都去掉了第一位），且<span class="math inline">\(\text{Suffix}(k+1)\)</span>也排<span class="math inline">\(\text{Suffix}(i)\)</span>前面，则根据性质一，<span class="math inline">\(H[i]\)</span>不会小于这个值，得证。</p>
<h3 id="求法及代码实现">求法及代码实现</h3>
<p>根据性质二，直接按照<span class="math inline">\(height[rank[1]],height[rank[2]],\cdots,height[rank[n]]\)</span>的顺序求即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Height</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a, <span class="keyword">int</span> *sa, <span class="keyword">int</span> *rank, <span class="keyword">int</span> *height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rank[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>, j; i &lt;= n; height[rank[i]] = k, ++i)</span><br><span class="line">        <span class="keyword">if</span> (rank[i] &gt; <span class="number">1</span>) <span class="keyword">for</span> (k ? --k : <span class="number">0</span>, j = sa[rank[i] - <span class="number">1</span>]; a[i + k] == a[j + k]; ++k)</span><br><span class="line">    height[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<span class="math inline">\(k\)</span>最多减少<span class="math inline">\(n\)</span>次，且不会超过<span class="math inline">\(n\)</span>，所以时间复杂度为<span class="math inline">\(\mathcal O(n)\)</span>。</p>
</div><h2 id="例题">例题</h2><div class="story post-story">
<p>给定一个字符串，<span class="math inline">\(q\)</span>次询问某两后缀的最长公共前缀的长度。</p>
<h3 id="解法">解法</h3>
<p>建出<span class="math inline">\(height\)</span>数组后，根据<span class="math inline">\(height\)</span>数组的性质一，原问题可以转化为区间最小值问题，直接用<span class="math inline">\(\text{ST}\)</span>表维护即可。</p>
<p>时间复杂度<span class="math inline">\(\mathcal O(n\log n+q)\)</span>。</p>
<p>若使用<span class="math inline">\(\text{DC3}\)</span>算法求<span class="math inline">\(\text{SA}\)</span>，<span class="math inline">\(\text{RMQ}\)</span>问题<span class="math inline">\(\mathcal O(n)\)</span>预处理，则时间复杂度为<span class="math inline">\(\mathcal O(n+q)\)</span>。</p>
<p>更多的例题可以查阅参考资料<span class="math inline">\([1]\)</span>。</p>
</div><h2 id="参考资料">参考资料</h2><div class="story post-story">
<ol type="1">
<li>IOI2009国家集训队论文《后缀数组——处理字符串的有力工具》，罗穗骞</li>
</ol>

</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>「模拟赛20190105 T1」松</title>
    <url>/vc190105A-sol/</url>
    <content><![CDATA[<h2 id="题意">题意</h2><div class="story post-story">
<p>给定两个长度为<span class="math inline">\(n\)</span>的<strong>数组</strong><span class="math inline">\(A,B\)</span>，下标范围<span class="math inline">\([0,n-1]\)</span>。</p>
<p>求所有整数<span class="math inline">\(k\in [0,n-1]\)</span>，满足存在一个<span class="math inline">\(m\)</span>次多项式<span class="math inline">\(C\)</span>，使得对于所有<span class="math inline">\(i\in [0,n-1]\)</span>，都有<span class="math inline">\(C(i)\equiv A_i-B_{(i+k)\bmod n} \pmod{998244353}\)</span>。</p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>先附上PPT：</p>
<p><img src="https://i.loli.net/2019/01/08/5c343b9332fed.png" class="lazyload" data-srcset="https://i.loli.net/2019/01/08/5c343b9332fed.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p><img src="https://i.loli.net/2019/01/08/5c344bd1d2530.png" class="lazyload" data-srcset="https://i.loli.net/2019/01/08/5c344bd1d2530.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
<p><del>这完全看不懂啊</del></p>
<p>首先，<span class="math inline">\(B\)</span>数组可以看成一个环，每次选环上的长度为<span class="math inline">\(n\)</span>的一段。所以我们直接把B数组复制接在末尾，变为原来的两倍长度。</p>
<p>然后，我们来理解这个差分。</p>
<p>对于任意一个<span class="math inline">\(m\)</span>次多项式<span class="math inline">\(f(x)\)</span>，当<span class="math inline">\(x\)</span>分别取<span class="math inline">\(0,1,2,\cdots,n(n\ge m+1)\)</span>时，将会得到<span class="math inline">\(n+1\)</span>个点值。将这<span class="math inline">\(n+1\)</span>个点值不断差分，<span class="math inline">\(m+1\)</span>次后会都变成<span class="math inline">\(0\)</span>。</p>
<p>例如，当<span class="math inline">\(f(x)=x^3+x^2-2x+1\)</span>时，分别取<span class="math inline">\(0,1,2,3,4,5\)</span>代入，得到<span class="math inline">\(6\)</span>个点值（第<span class="math inline">\(0\)</span>行）。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">x</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"><span class="attribute">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">9</span>   <span class="number">31</span>  <span class="number">73</span>  <span class="number">141</span></span><br><span class="line"><span class="attribute">1</span>       <span class="number">0</span>   <span class="number">8</span>   <span class="number">22</span>  <span class="number">42</span>  <span class="number">68</span></span><br><span class="line"><span class="attribute">2</span>           <span class="number">8</span>   <span class="number">14</span>  <span class="number">20</span>  <span class="number">26</span></span><br><span class="line"><span class="attribute">3</span>               <span class="number">6</span>   <span class="number">6</span>   <span class="number">6</span></span><br><span class="line"><span class="attribute">4</span>                   <span class="number">0</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后可以发现，按表格中的排列，<span class="math inline">\(t\)</span>次差分以后（第<span class="math inline">\(k\)</span>行第<span class="math inline">\(i\)</span>列）<span class="math inline">\(c_i=\sum\limits_{j=0}^i (-1)^j C_k^j f(i-j)\)</span></p>
<p>例如，表中第二行第四个数<span class="math inline">\(20=(73-31)-(31-9)=73-2\times 31+9=C_2^0\times 73-C_2^1\times 31+C_2^2\times 9\)</span>。</p>
<p>又可以发现，<span class="math inline">\(c_i=\sum\limits_{j=0}^i (-1)^j C_k^j f(i-j)\)</span>是卷积的形式，所以直接用FFT/NTT优化。</p>
<p>这样，我们对<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>分别做一遍卷积，然后把<span class="math inline">\(A[m+1,n-1]\)</span>与<span class="math inline">\(B[m+1,2n-1]\)</span>做一次<span class="math inline">\(KMP\)</span>即可。</p>
<p>由于数据较水，直接<span class="math inline">\(hash\)</span>也能过。</p>
<p>注意特判<span class="math inline">\(m\ge n-1\)</span>的情况，此时任意<span class="math inline">\(k\)</span>都满足条件。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) ;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 998244353</span></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], b[N], c[N], fac[N], inv[N], cnt, ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1ll</span> * a * a % P) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1ll</span> * s * a % P;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    inv[n] = <span class="built_in">qpow</span>(fac[n], P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i) inv[i - <span class="number">1</span>] = <span class="number">1ll</span> * inv[i] * i % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt; m ? <span class="number">0</span> : <span class="number">1ll</span> * fac[n] * inv[m] % P * inv[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Polynomial&#123;</span><br><span class="line">    <span class="keyword">int</span> omega[N], rev[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) &lt; n) ++k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) rev[i] = rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (i &amp; <span class="number">1</span>) &lt;&lt; k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a, <span class="keyword">int</span> o = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (i &lt; rev[i]) std :: <span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> m = <span class="number">1</span>, l; m &lt; n; m = l)&#123;</span><br><span class="line">            l = m &lt;&lt; <span class="number">1</span>, omega[<span class="number">0</span>] = <span class="number">1</span>, omega[<span class="number">1</span>] = <span class="built_in">qpow</span>(~o ? <span class="number">3</span> : <span class="number">332748118</span>, (P - <span class="number">1</span>) / l);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i) omega[i] = <span class="number">1ll</span> * omega[i - <span class="number">1</span>] * omega[<span class="number">1</span>] % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> *p = a, t; p &lt; a + n; p += l)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)</span><br><span class="line">                    t = <span class="number">1ll</span> * omega[k] * p[m + k] % P, (p[m + k] = p[k] - t) &lt; <span class="number">0</span> ? p[m + k] += P : <span class="number">0</span>,</span><br><span class="line">                    (p[k] += t) &gt;= P ? p[k] -= P : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>, _n = <span class="built_in">qpow</span>(n, P - <span class="number">2</span>); i &lt; n; ++i) a[i] = <span class="number">1ll</span> * a[i] * _n % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Trans</span><span class="params">(<span class="keyword">int</span> nt, <span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; nt) n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">init</span>(n), <span class="built_in">NTT</span>(n, a), <span class="built_in">NTT</span>(n, b), <span class="built_in">NTT</span>(n, c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            a[i] = <span class="number">1ll</span> * a[i] * c[i] % P, b[i] = <span class="number">1ll</span> * b[i] * c[i] % P;</span><br><span class="line">        <span class="built_in">NTT</span>(n, a, <span class="number">-1</span>), <span class="built_in">NTT</span>(n, b, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fail[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *S, <span class="keyword">int</span> m, <span class="keyword">int</span> *T)</span></span>&#123;</span><br><span class="line">    fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; T[j] != T[i - <span class="number">1</span>]) j = fail[j];</span><br><span class="line">        fail[i] = j += (T[j] == T[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; T[j] != S[i - <span class="number">1</span>]) j = fail[j];</span><br><span class="line">        j += (T[j] == S[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (j == m) ans[++cnt] = i - m, j = fail[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;pine.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;pine.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &gt;= n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pre</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) b[i] = <span class="built_in">read</span>(), b[i + n] = b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) c[i] = i &amp; <span class="number">1</span> ? P - <span class="built_in">C</span>(m, i) : <span class="built_in">C</span>(m, i);</span><br><span class="line">    Polynomial :: <span class="built_in">Trans</span>(<span class="number">2</span> * n, a, b, c);</span><br><span class="line"><span class="comment">//	for (register int i = 0; i &lt; n; ++i) printf(&quot;%d &quot;, a[i]); putchar(&#x27;\n&#x27;);</span></span><br><span class="line"><span class="comment">//	for (register int i = 0; i &lt; n; ++i) printf(&quot;%d &quot;, b[i]); putchar(&#x27;\n&#x27;);</span></span><br><span class="line">    <span class="built_in">KMP</span>(<span class="number">2</span> * n - <span class="number">1</span> - m, b + m, n - m, a + m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>差分</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>「模拟赛20190116 T2」序列</title>
    <url>/vc190116B-sol/</url>
    <content><![CDATA[<h2 id="题意">题意</h2><div class="story post-story">
<p><a href="https://www.codechef.com/problems/YASEQ">原题链接</a></p>
<p>给定一个序列的前<span class="math inline">\(n\)</span>项（<span class="math inline">\(a_0,a_1,a_2,\cdots,a_{n-1}\)</span>），保证对于所有<span class="math inline">\(0\le i\le n-1\)</span>，<span class="math inline">\(a_i\in \{n-1,n,n+1\}\)</span>。对于<span class="math inline">\(i\ge n\)</span>，<span class="math inline">\(a_i\)</span>的值为满足<span class="math inline">\(0\le j&lt; i\)</span>且<span class="math inline">\(a_j\ge i-j\)</span>的整数<span class="math inline">\(j\)</span>的数量。</p>
<p><span class="math inline">\(q\)</span>个询问，每次询问一个<span class="math inline">\(x\)</span>，求<span class="math inline">\(a_x\)</span>的值。</p>
<p><span class="math inline">\(1\le n,q\le 10^5,0\le x\le 10^{15}\)</span>。</p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<p>首先，我们可以利用归纳法证明对于任意<span class="math inline">\(i\)</span>，<span class="math inline">\(a_i\in \{n-1,n,n+1\}\)</span>：</p>
<blockquote>
<p>假设对于<span class="math inline">\(0\le j&lt; i\)</span>都满足该性质，则有<span class="math display">\[a_i=n-[a_{i-n}=n-1]+[a_{i-n-1}=n+1]\]</span>显然仍有<span class="math inline">\(a_i\in \{n-1,n,n+1\}\)</span>。</p>
</blockquote>
<p>为方便讨论，用<span class="math inline">\(0,1,2\)</span>分别代替<span class="math inline">\(n-1,n,n+1\)</span>。</p>
<p>可以发现，假设初始时对于所有<span class="math inline">\(i\ge n\)</span>，<span class="math inline">\(a_i=0\)</span>。然后对于一个<span class="math inline">\(a_i\)</span>，若<span class="math inline">\(a_i=0\)</span>，则不产生贡献；若<span class="math inline">\(a_i=1\)</span>，则对<span class="math inline">\(a_{i+n}\)</span>产生<span class="math inline">\(1\)</span>的贡献；若<span class="math inline">\(a_i=2\)</span>，则对<span class="math inline">\(a_{i+n},a_{i+n+1}\)</span>各产生<span class="math inline">\(1\)</span>的贡献。</p>
<p>然后我们先考虑一些子问题。</p>
<ol type="1">
<li><p>若初始时<span class="math inline">\(a_i\in \{0,1\}\)</span>，由于不存在<span class="math inline">\(2\)</span>，一定有<span class="math inline">\(a_{i+n}=a_i\)</span>，所以直接<span class="math inline">\(\bmod n\)</span>即可。</p></li>
<li><p>若初始时<span class="math inline">\(a_i\in \{1,2\}\)</span>，由于不存在<span class="math inline">\(0\)</span>，即不存在没有贡献的情况，所以对于<span class="math inline">\(a_i=2\)</span>，一定会导致<span class="math inline">\(a_{i+n}=1,a_{i+n+1}=2\)</span>，观察一下可以发现，此时<span class="math inline">\(a_{i+n+1}=a_i\)</span>，所以直接<span class="math inline">\(\bmod (n+1)\)</span>即可。</p></li>
</ol>
<p>考虑原问题，由于存在<span class="math inline">\(0\)</span>，将会导致有些位置没有贡献，那么对于<span class="math inline">\(a_i=2\)</span>，可能会导致<span class="math inline">\(a_{i+n}=1,a_{i+n+1}=1\)</span>（即<span class="math inline">\(a_{i+1}=0\)</span>时）。联系之前的两个问题，当不存在<span class="math inline">\(2\)</span>时，这种情况下一定会导致<span class="math inline">\(a_{i+n+1}=0\)</span>；当不存在<span class="math inline">\(0\)</span>时，这种情况下一定会导致<span class="math inline">\(a_{i+n+1}=2\)</span>。可是，当<span class="math inline">\(2,0\)</span>同时存在时，就会导致<span class="math inline">\(a_{i+n+1}=1\)</span>。</p>
<p>更形象一点地讲，把<span class="math inline">\(2\)</span>当作石头，把<span class="math inline">\(1\)</span>当作平地，把<span class="math inline">\(0\)</span>当作洞，这种情况就是石头调入洞里形成平地的情况。</p>
<p>假设初始数组中第<span class="math inline">\(i\)</span>个位置是洞，第<span class="math inline">\(j\)</span>个位置是石头，石头<span class="math inline">\(j\)</span>会在<span class="math inline">\(x\)</span>位置与洞<span class="math inline">\(i\)</span>重合，掉入洞中。又因为将会在所有满足<span class="math inline">\(p\equiv j\pmod{(n+1)}\)</span>且<span class="math inline">\(p\le x\)</span>的位置<span class="math inline">\(p\)</span>出现石头，洞同理。所以<span class="math inline">\(x\)</span>一定是满足下列同余方程组的最小正整数：</p>
<p><span class="math display">\[\begin{cases} x\equiv i\pmod{n}\\x\equiv j\pmod{(n+1)} \end{cases}\]</span></p>
<p>这个求解想怎么做怎么做吧...</p>
<p>然后由于会首尾拼接，我们把初始数组想成一个环，显然对于每个洞<span class="math inline">\(i\)</span>，一定是在环上与<span class="math inline">\(i\)</span><strong>有向距离</strong>最短的石子最终掉落在洞<span class="math inline">\(i\)</span>。那么我们直接<strong>扫两遍</strong>，用栈维护当前的石子（第二遍不清空栈，就相当于成了环），每次遇到洞就取出栈顶元素——石头<span class="math inline">\(j\)</span>（如果栈为空则跳过），算出<span class="math inline">\(x\)</span>的值，记录<span class="math inline">\(mat[i]=mat[j]=x\)</span>，一个点若没有<span class="math inline">\(mat\)</span>值，则记为<span class="math inline">\(INF\)</span>。</p>
<p><span class="math inline">\(mat\)</span>的定义显而易见，<span class="math inline">\(mat[i]\)</span>表示与<span class="math inline">\(i\)</span>有向距离最近的石子/洞与<span class="math inline">\(i\)</span>抵消的位置。</p>
<p>有了<span class="math inline">\(mat\)</span>以后对于询问就可以<span class="math inline">\(\mathcal O(1)\)</span>求了，可以根据<span class="math inline">\(mat[x\bmod n],mat[x\bmod (n+1)]\)</span>与<span class="math inline">\(x\)</span>的大小关系来计算贡献，注意除了比较<span class="math inline">\(mat\)</span>和<span class="math inline">\(x\)</span>的大小外，还需判断初始是否为石子/洞。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">int</span> n, q, a[N], top, sta[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x, mat[N]; <span class="comment">// 注意long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;sequence.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;sequence.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">1</span>; <span class="comment">// CC原题是多组数据，为了方便修改</span></span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">    	n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) mat[i] = <span class="number">0x3f3f3f3f3f3f3f3f</span>ll;</span><br><span class="line">    	top = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k)</span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    			<span class="keyword">if</span> (a[i] == n - <span class="number">1</span> &amp;&amp; top)&#123; <span class="comment">// 是洞，且栈非空</span></span><br><span class="line">    				<span class="keyword">int</span> j = sta[top--]; <span class="comment">// 取出栈顶元素</span></span><br><span class="line">    				mat[j] = mat[i] = (<span class="number">1ll</span> * (i + n) * (n + <span class="number">1</span>) - <span class="number">1ll</span> * j * n) % (<span class="number">1ll</span> * n * (n + <span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 根据中国剩余定理计算mat</span></span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">else</span> <span class="keyword">if</span> (a[i] == n + <span class="number">1</span>) sta[++top] = i; <span class="comment">// 石子入栈</span></span><br><span class="line">    	<span class="keyword">while</span> (q--)&#123;</span><br><span class="line">    		x = <span class="built_in">read</span>();</span><br><span class="line">    		<span class="keyword">int</span> ho = x % n, st = x % (n + <span class="number">1</span>);</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, n - (a[ho] == n - <span class="number">1</span> &amp;&amp; mat[ho] &gt; x) + (a[st] == n + <span class="number">1</span> &amp;&amp; mat[st] &gt; x));</span><br><span class="line">            <span class="comment">// O(1)计算答案，注意特判</span></span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>中国剩余定理</tag>
        <tag>栈</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title>「模拟赛20190705 T1」第一题</title>
    <url>/vc190705A-sol/</url>
    <content><![CDATA[<h2 id="题意">题意</h2><div class="story post-story">
<p>给定一棵 <span class="math inline">\(n\)</span> 个点的有根树，每个点有一个正整数<span class="math inline">\(b_i\)</span>，这个点的权值是 <span class="math inline">\([0,b_i]\)</span> 的一个随机<strong>实数</strong>。</p>
<p>求每个点的权值严格小于这个点所有儿子的权值的概率，模 <span class="math inline">\(10^9+7\)</span>。</p>
<p><span class="math inline">\(n\le 300,b_i\le 10^9\)</span>。</p>
<span id="more"></span>
</div><h2 id="所谓题解">所谓题解</h2><div class="story post-story">
<p><img src="/files/vc190705A-pic.png" class="lazyload" data-srcset="/files/vc190705A-pic.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
</div><h2 id="旺仔的方法">旺仔的方法</h2><div class="story post-story">
<p>考虑暴力。实数显然不能直接枚举。然而 <span class="math inline">\(b_i\)</span> 只有 <span class="math inline">\(n\)</span> 个，我们考虑离散，枚举每个点的权值在哪一段内。</p>
<p>我们按权值所属段是否相同分出一些联通块。树上的联通块还是一棵树，我们考虑求出每个联通块内部的概率。</p>
<p>由于一个联通块内的权值都属于同一段，也就是权值取值范围相同，那么问题转化成了：</p>
<blockquote>
<p>给定一棵树，每个点的权值是 <span class="math inline">\([0,1)\)</span> 的随机实数，求每个点权值严格小于这个点每个儿子的权值的概率。</p>
</blockquote>
<p>这个问题是一个经典问题，答案是 <span class="math inline">\(\prod\limits_{i=1}^{n} \frac{1}{sz_i}\)</span>，可以感性理解一下。<del>我不会证明</del></p>
<p>枚举每个点太慢，我们考虑 DP。用 <span class="math inline">\(dp_{i,j,k}\)</span> 表示以 <span class="math inline">\(i\)</span> 为根的子树，<span class="math inline">\(i\)</span> 的取值范围为 <span class="math inline">\(j\)</span>，以 <span class="math inline">\(i\)</span> 为根的联通块大小为 <span class="math inline">\(k\)</span> 时的概率。可以通过枚举每个儿子的取值范围是否与 <span class="math inline">\(i\)</span> 相同，枚举每个儿子的联通块大小进行转移。</p>
<p>相当于 <span class="math inline">\(n\)</span> 次树上背包，每次 <span class="math inline">\(O(n^2)\)</span>，复杂度为 <span class="math inline">\(O(n^3)\)</span>。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 305</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], b[N], fa[N], rt, inv[N], inva[N], sz[N], dp[N][N][N], tmp[N];</span><br><span class="line">std :: vector&lt;<span class="keyword">int</span>&gt; E[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1ll</span> * a * a % P) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1ll</span> * s * a % P;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    (x += y) &gt;= P ? x -= P : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b[u]; ++i) dp[u][i][<span class="number">1</span>] = <span class="number">1ll</span> * (a[i + <span class="number">1</span>] - a[i]) * inva[b[u]] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[u][i], sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = b[v] - <span class="number">1</span>; j &gt;= b[u]; --j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sz[v]; ++k)</span><br><span class="line">                <span class="built_in">add</span>(sum, dp[v][j][k]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = b[u] - <span class="number">1</span>; ~j; --j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sz[u] + sz[v]; ++k) tmp[k] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sz[u]; ++k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= sz[v]; ++l)</span><br><span class="line">                    <span class="built_in">add</span>(tmp[k + l], <span class="number">1ll</span> * dp[u][j][k] * dp[v][j][l] % P);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sz[u] + sz[v]; ++k)</span><br><span class="line">                dp[u][j][k] = (<span class="number">1ll</span> * dp[u][j][k] * sum + tmp[k]) % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sz[v]; ++k) <span class="built_in">add</span>(sum, dp[v][j][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        sz[u] += sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b[u]; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sz[u]; ++k)</span><br><span class="line">            dp[u][j][k] = <span class="number">1ll</span> * dp[u][j][k] * inv[k] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        a[i] = b[i] = <span class="built_in">read</span>(), fa[i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (fa[i]) E[fa[i]].<span class="built_in">push_back</span>(i); <span class="keyword">else</span> rt = i;</span><br><span class="line">    &#125;</span><br><span class="line">    std :: <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    m = std :: <span class="built_in">unique</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n) - a - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        b[i] = std :: <span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m, b[i]) - a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) inv[i] = <span class="built_in">qpow</span>(i, P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) inva[i] = <span class="built_in">qpow</span>(a[i], P - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(rt);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b[rt]; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="built_in">add</span>(ans, dp[rt][i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「模拟赛20190116 T3」MEX</title>
    <url>/vc190116C-sol/</url>
    <content><![CDATA[<h2 id="题意">题意</h2><div class="story post-story">
<p><a href="https://www.codechef.com/problems/MEXRNG">原题链接</a></p>
<p>给定一个长度为<span class="math inline">\(n\)</span>的序列，<span class="math inline">\(q\)</span>次询问<span class="math inline">\(l,r\)</span>，求原序列<span class="math inline">\([l,r]\)</span>中每个数的出现次数组成的集合<span class="math inline">\(S\)</span>的<span class="math inline">\(\text{MEX}\)</span>。</p>
<p>集合<span class="math inline">\(S\)</span>的<span class="math inline">\(\text{MEX}\)</span>是指最小的没有在集合<span class="math inline">\(S\)</span>中出现的正整数。</p>
<p><span class="math inline">\(n,q\le 1.5\times 10^5\)</span>。</p>
<span id="more"></span>
</div><h2 id="题解">题解</h2><div class="story post-story">
<h3 id="一个简单的暴力实现">一个简单的暴力实现</h3>
<p>首先离散，对于每个询问，按题意求出每个数的出现次数，再求出每个出现次数是否出现，然后枚举求出答案即可。</p>
<p>时间复杂度<span class="math inline">\(\mathcal O(nq)\)</span>。</p>
<h3 id="基于暴力思想的分块做法">基于暴力思想的分块做法</h3>
<p>显然答案不会超过<span class="math inline">\(\sqrt{2n}\)</span>，那么一个显然的优化是只需要记录所有<span class="math inline">\(\le \sqrt{2n}\)</span>的出现次数。</p>
<p>于是就可以<del>很自然地</del>想到分块了。分成<span class="math inline">\(\sqrt{n}\)</span>个块（在代码中为了卡常、卡内存可以作微调），直接暴力求出两块之间所有数的出现次数的出现次数（注意不是是否出现），记为<span class="math inline">\(V[x][y][i]\)</span>，表示<span class="math inline">\(x\)</span>块到<span class="math inline">\(y\)</span>块中出现次数<span class="math inline">\(i\)</span>的出现次数。这个可以很轻松的在扫的过程中求出来（<code>--c[b[a[i]]],++b[a[i]],++c[b[a[i]]]</code>，<span class="math inline">\(b[i]\)</span>表示数<span class="math inline">\(i\)</span>的出现次数，<span class="math inline">\(c[i]\)</span>表示出现次数<span class="math inline">\(i\)</span>的出现次数。即把原来的出现次数去掉，出现次数加一，把新的出现次数加入）。这一部分时间复杂度是<span class="math inline">\(\mathcal O(n\sqrt{n})\)</span>的。</p>
<p>可是我们发现，只求出这个好像还是有点难回答询问。为什么？因为这只求出了整块的答案，而旁边的两小块没有被处理。</p>
<p>我们再求出<span class="math inline">\(L[x][y][i]\)</span>表示<span class="math inline">\(x\)</span>块到<span class="math inline">\(y\)</span>块中，<span class="math inline">\(x\)</span>块向左<span class="math inline">\(i\)</span>个位置的数出现了多少次，同理<span class="math inline">\(R[x][y][i]\)</span>表示<span class="math inline">\(x\)</span>块到<span class="math inline">\(y\)</span>块中，<span class="math inline">\(y\)</span>块向右<span class="math inline">\(i\)</span>个位置的数出现了多少次。这两个数组也很好求，可以与之前的<span class="math inline">\(V\)</span>数组放在一起处理。</p>
<p>处理出这三个数组后，相当于持续了之前的<span class="math inline">\(b,c\)</span>数组。直接在两边的小块扫一遍即可。对于<span class="math inline">\(l,r\)</span>在同一块中的情况，直接暴力扫一遍即可。单次询问时间复杂度<span class="math inline">\(\mathcal O(\sqrt{n})\)</span>。</p>
<p>注意<span class="math inline">\(b[i]\)</span>的下标是<span class="math inline">\(\mathcal O(n)\)</span>级别，不能每次清零，可以额外记一下<span class="math inline">\(vis[i]\)</span>表示<span class="math inline">\(b[i]\)</span>的使用情况，若<span class="math inline">\(vis[i]=0\)</span>，则表示未使用，否则<span class="math inline">\(vis[i]\)</span>表示<span class="math inline">\(b[i]\)</span>在哪一次询问被使用，若是当前询问则可以直接加，否则需要用<span class="math inline">\(L\)</span>或<span class="math inline">\(R\)</span>数组中的值覆盖。</p>
</div><h2 id="代码">代码</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 150005</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">420</span>, C = <span class="number">360</span>, P = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, k, a[N], b[N], c[N], vis[N];</span><br><span class="line"><span class="keyword">int</span> L[<span class="number">365</span>][<span class="number">365</span>][<span class="number">425</span>], R[<span class="number">365</span>][<span class="number">365</span>][<span class="number">425</span>], V[<span class="number">365</span>][<span class="number">365</span>][<span class="number">555</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += B)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) b[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; P; ++j) c[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt; n; ++j)&#123;</span><br><span class="line">            --c[b[a[j]]], ++b[a[j]], ++c[b[a[j]]];</span><br><span class="line">            <span class="keyword">if</span> ((j + <span class="number">1</span>) % B == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="keyword">int</span> bi = i / B, bj = j / B;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; P; ++k) V[bi][bj][k] = c[k];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; B &amp;&amp; i - k - <span class="number">1</span> &gt;= <span class="number">0</span>; ++k) L[bi][bj][k] = b[a[i - k - <span class="number">1</span>]];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; B &amp;&amp; j + k + <span class="number">1</span> &lt; n; ++k) R[bi][bj][k] = b[a[j + k + <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> bl = (l - <span class="number">1</span>) / B + <span class="number">1</span>, br = (r + <span class="number">1</span>) / B - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> pl = B * bl, pr = B * (br + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (bl &lt;= br)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; P; ++i) c[i] = V[bl][br][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pl - l; ++i)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> j = pl - i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[a[j]] != q) vis[a[j]] = q, b[a[j]] = L[bl][br][i];</span><br><span class="line">            --c[b[a[j]]], ++b[a[j]], ++c[b[a[j]]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r - pr; ++i)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> j = pr + i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[a[j]] != q) vis[a[j]] = q, b[a[j]] = R[bl][br][i];</span><br><span class="line">            --c[b[a[j]]], ++b[a[j]], ++c[b[a[j]]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; P; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = l; i &lt;= r; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[a[i]] != q) vis[a[i]] = q, b[a[i]] = <span class="number">0</span>;</span><br><span class="line">            --c[b[a[i]]], ++b[a[i]], ++c[b[a[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; P; ++i) <span class="keyword">if</span> (!c[i]) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;mex.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;mex.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = b[i] = <span class="built_in">read</span>();</span><br><span class="line">    std :: <span class="built_in">sort</span>(b, b + n);</span><br><span class="line">    <span class="keyword">int</span> m = std :: <span class="built_in">unique</span>(b, b + n) - b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        a[i] = std :: <span class="built_in">lower_bound</span>(b, b + m, a[i]) - b;</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, l, r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> _ = <span class="number">1</span>; _ &lt;= q; ++_)&#123;</span><br><span class="line">        l = (<span class="built_in">read</span>() ^ (k * ans)) - <span class="number">1</span>, r = (<span class="built_in">read</span>() ^ (k * ans)) - <span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">solve</span>(_, l, r), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>题解</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>MEX</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式相关</title>
    <url>/polynomial-notes/</url>
    <content><![CDATA[<p>太久没更新博客，开一篇多项式相关的博客记一下多项式的一些基础操作吧。</p>
<span id="more"></span>
<h2 id="模域下的运算">模域下的运算</h2><div class="story post-story">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    (a += b) &gt;= P ? a -= P : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a &lt; b ? a += P - b : a -= b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b &gt;= P ? a + b - P : a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a + P - b : a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * a * b % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            s = <span class="built_in">mul</span>(s, a);</span><br><span class="line">        &#125;</span><br><span class="line">        a = <span class="built_in">mul</span>(a, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="快速傅里叶变换与快速傅里叶逆变换">快速傅里叶变换与快速傅里叶逆变换</h2><div class="story post-story">
<h3 id="快速傅里叶变换">快速傅里叶变换</h3>
<p>在这一节中，除特殊说明外，<span class="math inline">\(n\)</span> 是 <span class="math inline">\(2\)</span> 的幂次。</p>
<p>利用 FFT，我们可以在 <span class="math inline">\(O(n\log n)\)</span> 的时间内求出 <span class="math inline">\(F(\omega_n^0),F(\omega_n^1),\cdots,F(\omega_n^{n-1})\)</span> 的值，以及由这些值得到 <span class="math inline">\(F(x)\)</span> 的系数，其中 <span class="math inline">\(\omega_n^{i}\)</span> 表示单位根，这里不具体展开。</p>
<p>单位根具有一些优美的性质，如</p>
<ul>
<li><span class="math inline">\(\omega_{dn}^{dk}=\omega_n^k\)</span></li>
<li><span class="math inline">\(\omega_{n}^{\frac{n}{2}}=\omega_2^1=-1\)</span></li>
<li><span class="math inline">\(\omega_{n}^{k+\frac{n}{2}}=-\omega_{n}^{k}\)</span></li>
<li><span class="math inline">\(\omega_n^a=\omega_n^{a \bmod n}\)</span></li>
</ul>
<p>FFT 正是利用了这些性质加快速度。</p>
<p>假设原多项式为 <span class="math inline">\(F(x)=\sum\limits_{i=0}^{n-1} f_ix^i\)</span>，我们把 <span class="math inline">\(F(x)\)</span> 按指数奇偶性拆成两部分，即 <span class="math display">\[F_0(x)=\sum\limits_{i=0}^{\frac{n}{2}-1} f_{2i}x^i,F_1(x)=\sum\limits_{i=0}^{\frac{n}{2}-1} f_{2i+1}x^i\]</span> 那么有 <span class="math display">\[F(x)=F_0(x^2)+xF_1(x^2)\]</span></p>
<p>我们把 <span class="math inline">\(x=\omega_n^k\ (0\le k &lt; \frac{n}{2})\)</span> 代入 <span class="math inline">\(F(x)\)</span>，得到 <span class="math display">\[F(\omega_n^k)=F_0(\omega_{\frac{n}{2}}^k)+\omega_n^kF_1(\omega_{\frac{n}{2}}^k)\]</span></p>
<p>同理，把 <span class="math inline">\(x=\omega_n^{k+\frac{n}{2}}\ (0\le k &lt; \frac{n}{2})\)</span> 代入 <span class="math inline">\(F(x)\)</span>，得到 <span class="math display">\[F(\omega_n^k)=F_0(\omega_{\frac{n}{2}}^k)-\omega_n^kF_1(\omega_{\frac{n}{2}}^k)\]</span></p>
<p>发现问题转化成了两个子问题，直接分治求解即可。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>直接做常数太大，我们发现分治到底层时下标是原下标的二进制翻转，于是直接翻转完后从下往上合并即可。</p>
<p>可以用 <code>unsigned long long</code> 减少取模次数优化常数。</p>
<h3 id="快速傅里叶逆变换">快速傅里叶逆变换</h3>
<p>记多项式 <span class="math inline">\(G(x)=\sum\limits_{i=0}^{n-1}F(\omega_n^i)x^i\)</span>，考虑对 <span class="math inline">\(G(x)\)</span> 做 FFT，得到</p>
<p><span class="math display">\[\begin{aligned}G(\omega_n^k)&amp;=\sum\limits_{i=0}^{n-1}F(\omega_n^i)(\omega_n^k)^i\\&amp;=\sum\limits_{i=0}^{n-1}\left(\sum\limits_{j=0}^{n-1} f_j(\omega_n^i)^j\right)(\omega_n^k)^i\\&amp;=\sum\limits_{j=0}^{n-1}f_j\sum\limits_{i=0}^{n-1}(\omega_n^{j+k})^i\end{aligned}\]</span></p>
<p>发现只有当 <span class="math inline">\(j+k\equiv 0\pmod n\)</span> 时 <span class="math inline">\(\sum\limits_{i=0}^{n-1}(\omega_n^{j+k})^i=n\)</span>，其他情况都为 <span class="math inline">\(0\)</span>。于是</p>
<p><span class="math display">\[\begin{aligned}G(\omega_n^k)&amp;=\sum\limits_{j=0}^{n-1}f_j\sum\limits_{i=0}^{n-1}(\omega_n^{j+k})^i\\&amp;=f_{(n-k)\bmod n}\cdot n\end{aligned}\]</span></p>
<p>直接翻转后乘上 <span class="math inline">\(n\)</span> 的逆元即可，时间复杂度同样为 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="实现">实现</h3>
<p><span class="math inline">\(\omega_{2^k}^{i}\)</span> 只有 <span class="math inline">\(O(n)\)</span> 个，可以在程序的一开始预处理（同时还预处理了逆元）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LEN = <span class="number">1</span> &lt;&lt; <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="keyword">int</span>&gt; poly;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> omega[MAX_LEN], inv[MAX_LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123; <span class="comment">// 在程序开始调用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; MAX_LEN; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="built_in">qpow</span>(G, (P - <span class="number">1</span>) / (m &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        omega[m] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            omega[m + i] = <span class="built_in">mul</span>(omega[m + i - <span class="number">1</span>], w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_LEN; ++i) &#123;</span><br><span class="line">        inv[i] = <span class="built_in">mul</span>(P - P / i, inv[P % i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次需要预处理 <span class="math inline">\(rev[i]\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">poly rev;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; _n) &#123;</span><br><span class="line">        n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) &lt; n) &#123;</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    rev.<span class="built_in">resize</span>(n), rev[<span class="number">0</span>] = <span class="number">0</span>, --k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(poly &amp;f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    f.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> F[MAX_LEN];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        F[rev[i]] = f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意当 MAX_LEN &gt; 2^18 时这里需要把 F[i] 全部模 P</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, l = m &lt;&lt; <span class="number">1</span>; p &lt; n; p += l) &#123;</span><br><span class="line">            <span class="keyword">int</span> *W = omega + m;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *F0 = F + p, *F1 = F0 + m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i, ++F0, ++F1, ++W) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = (*F1) * (*W) % P;</span><br><span class="line">                *F1 = *F0 + P - t, *F0 += t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        f[i] = (F[i] % P + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IDFT</span><span class="params">(poly &amp;f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DFT</span>(f, n), std::<span class="built_in">reverse</span>(f.<span class="built_in">begin</span>() + <span class="number">1</span>, f.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">qpow</span>(n, P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        f[i] = <span class="built_in">mul</span>(f[i], t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="多项式加法与减法">多项式加法与减法</h2><div class="story post-story">
<p>对于每个 <span class="math inline">\(x_i\)</span> 的系数直接相加/相减即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Plus</span><span class="params">(poly a, poly b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = std::<span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>());</span><br><span class="line">    a.<span class="built_in">resize</span>(n), b.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">inc</span>(a[i], b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">poly <span class="title">Minus</span><span class="params">(poly a, poly b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = std::<span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>());</span><br><span class="line">    a.<span class="built_in">resize</span>(n), b.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">dec</span>(a[i], b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="多项式乘法">多项式乘法</h2><div class="story post-story">
<p>DFT 后把点值乘起来，在 IDFT 回去即可。</p>
<p>代码中的参数 <code>_n</code> 的作用在下面会提到。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Mul</span><span class="params">(poly a, poly b, <span class="keyword">int</span> _n = <span class="number">-1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> na = (<span class="keyword">int</span>)a.<span class="built_in">size</span>(), nb = (<span class="keyword">int</span>)b.<span class="built_in">size</span>(), n = _n;</span><br><span class="line">    <span class="keyword">if</span> (!na || !nb || !n) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">        n = na + nb - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _n = n, n = <span class="built_in">get</span>(n);</span><br><span class="line">    <span class="built_in">init</span>(n), <span class="built_in">DFT</span>(a, n), <span class="built_in">DFT</span>(b, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">mul</span>(a[i], b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">IDFT</span>(a, n);</span><br><span class="line">    a.<span class="built_in">resize</span>(_n);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以把计算 <span class="math inline">\(F^2(x)\)</span> 单独写一个函数，常数可以更小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Pow2</span><span class="params">(poly a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _n = <span class="number">2</span> * (<span class="keyword">int</span>)a.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">get</span>(_n);</span><br><span class="line">    <span class="built_in">init</span>(n), <span class="built_in">DFT</span>(a, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">mul</span>(a[i], a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">IDFT</span>(a, n);</span><br><span class="line">    a.<span class="built_in">resize</span>(_n);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="多项式求逆">多项式求逆</h2><div class="story post-story">
<blockquote>
<p>已知多项式 <span class="math inline">\(F(x)\)</span>，求一个多项式 <span class="math inline">\(G(x)\)</span> 满足 <span class="math inline">\(F(x)G(x)\equiv 1\pmod{x^n}\)</span>。</p>
</blockquote>
<p>假设我们已经求出 <span class="math inline">\(G_0(x)\)</span> 满足 <span class="math display">\[F(x)G_0(x)\equiv 1\pmod {x^{\lceil\frac{n}{2}\rceil}}\]</span> 那么有 <span class="math display">\[F(x)(G(x)-G_0(x))\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\]</span></p>
<p>由于 <span class="math inline">\(G(x)-G_0(x)\)</span> 是 <span class="math inline">\(n-1\)</span> 次多项式，两边同时乘 <span class="math inline">\(G(x)-G_0(x)\)</span> 得到 <span class="math display">\[F(x)(G(x)-G_0(x))^2\equiv 0\pmod{x^n}\]</span></p>
<p>展开后整理得到 <span class="math display">\[G(x)\equiv 2G_0(x)-F(x)G_0^2(x)\pmod {x^n}\]</span></p>
<p>迭代求出即可。</p>
<p>边界情况，即 <span class="math inline">\(n=1\)</span> 时，求 <span class="math inline">\(f_0\)</span> 的逆元即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Inv</span><span class="params">(poly f, <span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">get</span>(_n);</span><br><span class="line">    f.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="function">poly <span class="title">g</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="built_in">qpow</span>(f[<span class="number">0</span>], P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">2</span>; m &lt;= n; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = m &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="function">poly <span class="title">tmp</span><span class="params">(f.begin(), f.begin() + m)</span></span>;</span><br><span class="line">        <span class="built_in">init</span>(l), <span class="built_in">DFT</span>(tmp, l), <span class="built_in">DFT</span>(g, l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">            g[i] = (<span class="number">2</span> + <span class="number">1ll</span> * (P - tmp[i]) * g[i]) % P * g[i] % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">IDFT</span>(g, l), g.<span class="built_in">resize</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    g.<span class="built_in">resize</span>(_n);</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="多项式除法">多项式除法</h2><div class="story post-story">
<blockquote>
<p>已知 <span class="math inline">\(n-1\)</span> 次多项式 <span class="math inline">\(A(x)\)</span> 和 <span class="math inline">\(m-1\)</span> 次多项式 <span class="math inline">\(B(x)\)</span>，求 <span class="math inline">\(n-m\)</span> 次多项式 <span class="math inline">\(Q(x)\)</span> 和小于 <span class="math inline">\(m-1\)</span> 次的多项式 <span class="math inline">\(R(x)\)</span> 满足 <span class="math inline">\(A(x)=B(x)Q(x)+R(x)\)</span>。</p>
</blockquote>
<p>下面我们强制 <span class="math inline">\(R(x)\)</span> 为 <span class="math inline">\(m-2\)</span> 次，不足则高位补 <span class="math inline">\(0\)</span>。</p>
<p>用记号 <span class="math inline">\(F_r(x)\)</span> 表示 <span class="math inline">\(F(x)\)</span> 的系数翻转后的结果。有 <span class="math display">\[F_r(x)=x^{\operatorname{deg}F(x)}F(\frac{1}{x})\]</span></p>
<p>其中 <span class="math inline">\(\operatorname{deg}F(x)\)</span> 表示 <span class="math inline">\(F(x)\)</span> 的次数。</p>
<p>把原式中的 <span class="math inline">\(x\)</span> 用 <span class="math inline">\(\frac{1}{x}\)</span> 代替，得到 <span class="math display">\[A(\frac{1}{x})=B(\frac{1}{x})Q(\frac{1}{x})+R(\frac{1}{x})\]</span> 两边同乘 <span class="math inline">\(x^{n-1}\)</span> 得到 <span class="math display">\[x^{n-1}A(\frac{1}{x})=x^{m-1}B(\frac{1}{x})x^{n-m}Q(\frac{1}{x})+x^{n-m+1}\cdot x^{m-2}R(x)\]</span> 即 <span class="math display">\[A_r(x)=B_r(x)Q_r(x)+x^{n-m+1}R(x)\]</span> 那么有 <span class="math display">\[A_r(x)\equiv B_r(x)Q_r(x)\pmod{x^{n-m+1}}\]</span></p>
<p>由于 <span class="math inline">\(Q(x)\)</span> 是一个 <span class="math inline">\(n-m\)</span> 次多项式，所以 <span class="math inline">\(\bmod x^{n-m+1}\)</span> 不会对 <span class="math inline">\(Q(x)\)</span> 产生影响。</p>
<p>此时由于去掉了 <span class="math inline">\(R(x)\)</span>，直接做多项式求逆即可求出 <span class="math inline">\(Q(x)\)</span>。然后根据 <span class="math inline">\(R(x)=A(x)-B(x)Q(x)\)</span> 求出 <span class="math inline">\(R(x)\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::pair&lt;poly, poly&gt; <span class="title">Div</span><span class="params">(<span class="keyword">const</span> poly &amp;a, <span class="keyword">const</span> poly &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>(), m = b.<span class="built_in">size</span>();</span><br><span class="line">    poly Q, R;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) &#123;</span><br><span class="line">        R = a, R.<span class="built_in">resize</span>(m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;Q, R&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">poly <span class="title">A</span><span class="params">(a)</span>, <span class="title">B</span><span class="params">(b)</span></span>;</span><br><span class="line">    std::<span class="built_in">reverse</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>()), A.<span class="built_in">resize</span>(n - m + <span class="number">1</span>);</span><br><span class="line">    std::<span class="built_in">reverse</span>(B.<span class="built_in">begin</span>(), B.<span class="built_in">end</span>()), B.<span class="built_in">resize</span>(n - m + <span class="number">1</span>);</span><br><span class="line">    Q = <span class="built_in">Mul</span>(A, <span class="built_in">Inv</span>(B, n - m + <span class="number">1</span>));</span><br><span class="line">    Q.<span class="built_in">resize</span>(n - m + <span class="number">1</span>), std::<span class="built_in">reverse</span>(Q.<span class="built_in">begin</span>(), Q.<span class="built_in">end</span>());</span><br><span class="line">    R = <span class="built_in">Minus</span>(a, <span class="built_in">Mul</span>(b, Q)), R.<span class="built_in">resize</span>(m - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;Q, R&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="多项式求导与积分">多项式求导与积分</h2><div class="story post-story">
<p>求导有运算法则： - <span class="math inline">\((u(x)+v(x))&#39;=u&#39;(x)+v&#39;(x)\)</span> - <span class="math inline">\((u(x)\cdot v(x))&#39;=u&#39;(x)\cdot v(x)+u(x)\cdot v&#39;(x)\)</span></p>
<p>并且可以扩展到 <span class="math inline">\(n\)</span> 个函数。同时有 <span class="math inline">\(C&#39;=0,(x^n)&#39;=nx^{n-1}\)</span>。</p>
<p>于是 <span class="math display">\[F&#39;(x)=\left(\sum\limits_{i=0}^{n-1} f_ix^i\right)&#39;=\sum\limits_{i=0}^{n-1}(f_ix^i)&#39;=\sum\limits_{i=1}^{n-1} f_i\cdot ix^{i-1}\]</span></p>
<p>积分只要反着做一遍就好了。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Der</span><span class="params">(poly f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)f.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        f[i - <span class="number">1</span>] = <span class="built_in">mul</span>(f[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    f.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">poly <span class="title">Int</span><span class="params">(poly f)</span> </span>&#123;</span><br><span class="line">    f.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n = f.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; --i) &#123;</span><br><span class="line">        f[i] = <span class="built_in">mul</span>(f[i - <span class="number">1</span>], inv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="泰勒展开">泰勒展开</h2><div class="story post-story">
<p>泰勒展开是将一个在 <span class="math inline">\(x=x_0\)</span> 处具有 <span class="math inline">\(n\)</span> 阶导数的函数 <span class="math inline">\(f(x)\)</span> 利用关于 <span class="math inline">\(x-x_0\)</span> 的 <span class="math inline">\(n\)</span> 次多项式来逼近函数的方法。</p>
<p>当 <span class="math inline">\(n\)</span> 趋向于无穷时，我们可以直接用下面这个式子表示泰勒公式：</p>
<p><span class="math display">\[f(x)=\sum\limits_{i=0}^{\infty} \frac{f^{(i)}(x_0)}{i!}(x-x_0)^i\]</span></p>
<p>而麦克劳林级数就是上式 <span class="math inline">\(x_0=0\)</span> 的特殊形式。</p>
<p>要对泰勒展开有更好地理解可以看<a href="https://www.zhihu.com/question/25627482/answer/313088784">怎样更好地理解并记忆泰勒展开式？- 知乎</a>。</p>
</div><h2 id="牛顿迭代">牛顿迭代</h2><div class="story post-story">
<p>牛顿迭代法是一种用于解非线性方程 <span class="math inline">\(G(x)=0\)</span> 的近似方法。</p>
<p>而在我们研究多项式相关时，我们一般用牛顿迭代法解关于无穷幂级数 <span class="math inline">\(F(x)\)</span> 的非线性方程 <span class="math inline">\(G(F(x))=0\)</span>，求 <span class="math inline">\(F(x)\)</span> 在模 <span class="math inline">\(x^n\)</span> 意义下得到的多项式，<strong>其中 <span class="math inline">\(G(F(x))\)</span> 是一个自变量为多项式，应变量也为多项式的函数。</strong></p>
<p>我们假设已经求出答案模 <span class="math inline">\(x^{\lceil\frac{n}{2}\rceil}\)</span> 意义下的多项式 <span class="math inline">\(F_0(x)\)</span>，我们要求出答案模 <span class="math inline">\(x^n\)</span> 意义下的多项式 <span class="math inline">\(F_1(x)\)</span>。即我们已经有 <span class="math display">\[G(F_0(x))\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\]</span></p>
<p>我们把 <span class="math inline">\(G(F(x))\)</span> 在 <span class="math inline">\(F(x)=F_0(x)\)</span> 处泰勒展开，得到 <span class="math display">\[\begin{aligned}G(F(x))&amp;=G(F_0(x))\\ &amp;+G&#39;(F_0(x))(F(x)-F_0(x))\\ &amp;+\frac{G&#39;&#39;(F_0(x))}{2}(F(x)-F_0(x))^2\\&amp;+\cdots\end{aligned}\]</span></p>
<p>因为有 <span class="math inline">\(F_1(x)-F_0(x)\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>，所以有 <span class="math inline">\((F_1(x)-F_0(x))^2\equiv 0\pmod{x^n}\)</span>。</p>
<p>由于 <span class="math inline">\(F_1(x)\)</span> 是答案在模 <span class="math inline">\(x^n\)</span> 意义下的多项式，所以上述泰勒展开式中除前两项外的部分代入 <span class="math inline">\(F_1(x)\)</span> 后模 <span class="math inline">\(x^n\)</span> 为 <span class="math inline">\(0\)</span>。所以我们只需要考虑前两项。即 <span class="math inline">\(F_1(x)\)</span> 只需要满足 <span class="math display">\[G(F_0(x))+G&#39;(F_0(x))(F_1(x)-F_0(x))\equiv 0\pmod{x^n}\]</span></p>
<p>整理，得 <span class="math display">\[F_1(x)\equiv F_0(x)-\frac{G(F_0(x))}{G&#39;(F_0(x))}\pmod{x^n}\]</span></p>
<p>于是我们可以在 <span class="math inline">\(O(n\log n)\)</span> 的时间求出答案在模 <span class="math inline">\(x^n\)</span> 意义下的多项式。</p>
</div><h2 id="多项式对数函数">多项式对数函数</h2><div class="story post-story">
<blockquote>
<p>已知多项式 <span class="math inline">\(F(x)\)</span>（常数项为 <span class="math inline">\(1\)</span>），求多项式 <span class="math inline">\(G(x)\)</span> 满足 <span class="math inline">\(G(x)\equiv \ln F(x)\pmod{x^n}\)</span>。</p>
</blockquote>
<p>注意多项式的对数函数可以认为是多项式和麦克劳林级数的复合。这意味着多项式对数函数是一个无穷级数。我们只能求他在模 <span class="math inline">\(x^n\)</span> 意义下得到的多项式。</p>
<p>类似地，多项式求逆、多项式指数函数、多项式开根等我们都只能求出在模意义下的多项式。</p>
<p>注意 <span class="math inline">\(F(x)\)</span> 常数项不为 <span class="math inline">\(1\)</span> 时 <span class="math inline">\(\ln F(x)\)</span> 无意义。</p>
<p>两边同时求导，得到 <span class="math display">\[G&#39;(x)\equiv (\ln F(x))&#39;\pmod {x^{n-1}}\]</span> 由复合函数求导公式，得到 <span class="math display">\[G&#39;(x)\equiv \frac{F&#39;(x)}{F(x)}\pmod {x^{n-1}}\]</span> 然后两边同时求积分，得到 <span class="math display">\[\ln F(x)\equiv \int \frac{F&#39;(x)}{F(x)}\pmod {x^n}\]</span></p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>，瓶颈在于多项式乘法和多项式求逆。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Ln</span><span class="params">(<span class="keyword">const</span> poly &amp;a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    poly res = <span class="built_in">Int</span>(<span class="built_in">Mul</span>(<span class="built_in">Der</span>(a), <span class="built_in">Inv</span>(a, n)));</span><br><span class="line">    <span class="keyword">return</span> res.<span class="built_in">resize</span>(n), res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="多项式指数函数">多项式指数函数</h2><div class="story post-story">
<blockquote>
<p>已知多项式 <span class="math inline">\(F(x)\)</span>（常数项为 <span class="math inline">\(0\)</span>），求多项式 <span class="math inline">\(G(x)\)</span> 满足 <span class="math inline">\(G(x)\equiv \exp {F(x)}\pmod{x^n}\)</span>。</p>
</blockquote>
<p>多项式 <span class="math inline">\(\exp\)</span> 有两种做法，分别是 <span class="math inline">\(O(n\log n)\)</span> 的牛顿迭代法与 <span class="math inline">\(O(n\log^2 n)\)</span> 的分治法，并且分治法可以进一步优化成 <span class="math inline">\(O(\frac{n\log^2 n}{\log\log n})\)</span>。从实际运行效率上看，<span class="math inline">\(n\le 10^5\)</span> 时普通分治与牛顿迭代的运行速度不相上下，且分治法的实现更简单。</p>
<h3 id="牛顿迭代法">牛顿迭代法</h3>
<p>注意 <span class="math inline">\(F(x)\)</span> 常数项不为 <span class="math inline">\(0\)</span> 时 <span class="math inline">\(\exp F(x)\)</span> 无意义。</p>
<p>两边同时求 <span class="math inline">\(\ln\)</span>，得到 <span class="math display">\[\ln G(x)\equiv F(x)\pmod{x^n}\]</span> 即 <span class="math display">\[(\ln G(x))-F(x)\equiv 0\pmod{x^n}\]</span></p>
<p>定义函数 <span class="math display">\[H(G(x))=(\ln G(x))-F(x)\]</span> 那么我们要求 <span class="math inline">\(G(x)\)</span> 满足 <span class="math inline">\(H(G(x))\equiv 0\pmod{x^n}\)</span>。</p>
<p>套用牛顿迭代的式子，即假设我们求出了在模 <span class="math inline">\(x^{\lceil\frac{n}{2}\rceil}\)</span> 意义下的答案 <span class="math inline">\(G_0(x)\)</span>，那么有 <span class="math display">\[G(x)\equiv G_0(x)-\frac{H(G_0(x))}{H&#39;(G_0(x))}\pmod{x^n}\]</span></p>
<p>又因为有（要注意函数 <span class="math inline">\(H(G(x))\)</span> 的自变量是 <span class="math inline">\(G(x)\)</span> 而非 <span class="math inline">\(x\)</span>） <span class="math display">\[\begin{aligned}H&#39;(G(x))&amp;=\ln&#39; G(x)\\ &amp;=\frac{1}{G(x)}\end{aligned}\]</span></p>
<p>所以，经整理得 <span class="math display">\[G(x)\equiv G_0(x)(1-(\ln G_0(x))+F(x))\pmod{x^n}\]</span></p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。常数较大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">poly <span class="title">ExpNewton</span><span class="params">(poly f, <span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">get</span>(_n);</span><br><span class="line">    f.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="function">poly <span class="title">g</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">2</span>; m &lt;= n; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = m &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        poly tmp = <span class="built_in">Ln</span>(g, m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            tmp[i] = <span class="built_in">minus</span>(f[i], tmp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inc</span>(tmp[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">init</span>(l), <span class="built_in">DFT</span>(tmp, l), <span class="built_in">DFT</span>(g, l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">            g[i] = <span class="built_in">mul</span>(g[i], tmp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">IDFT</span>(g, l), g.<span class="built_in">resize</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g.<span class="built_in">resize</span>(_n), g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分治法">分治法</h3>
<p>我们在 <span class="math inline">\(G(x)\equiv \exp F(x)\pmod{x^n}\)</span> 两边同时求导，得到 <span class="math display">\[G&#39;(x)\equiv (\exp F(x))F&#39;(x)\pmod{x^n}\]</span></p>
<p>即 <span class="math display">\[G&#39;(x)\equiv G(x)F&#39;(x)\pmod{x^n}\]</span></p>
<p>两边同时求积分，得 <span class="math display">\[G(x)\equiv \int G(x)F&#39;(x)\]</span></p>
<p>直接分治 NTT 求解即可。时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<h4 id="关于卡常">关于卡常</h4>
<p>在处理区间 <span class="math inline">\([l,r)\)</span> 时我们需要将 <span class="math inline">\(f[0,r-l)\)</span> 与 <span class="math inline">\(g[l,\lfloor\frac{l+r+1}{2}\rfloor)\)</span> 作卷积，求积分以后再加到 <span class="math inline">\(g[\lfloor\frac{l+r+1}{2}\rfloor,r)\)</span> 上（其中 <span class="math inline">\(f,g\)</span> 分别是 <span class="math inline">\(F&#39;(x),G(x)\)</span> 的系数数组）。</p>
<p>发现我们真正需要的部分是卷积后中间一部分，前后两部分是没有用的。而通过计算发现后面部分的长度一定不超过前面部分的长度，FFT 是循环卷积，我们只要把长度限定到 <span class="math inline">\(r-l-1\)</span> 就可以把后面部分加到前面而不影响中间需要的部分。这样做对优化常数很有帮助。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExpSolve</span><span class="params">(<span class="keyword">const</span> poly &amp;f, poly &amp;g, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l) &#123;</span><br><span class="line">            g[l] = <span class="built_in">mul</span>(g[l], inv[l]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            g[l] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> md = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ExpSolve</span>(f, g, l, md);</span><br><span class="line">    <span class="function">poly <span class="title">tmp</span><span class="params">(Mul(poly(g.begin() + l, g.begin() + md), </span></span></span><br><span class="line"><span class="params"><span class="function">	  poly(f.begin(), f.begin() + r - l - <span class="number">1</span>), r - l - <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = md; i &lt; r; ++i) &#123;</span><br><span class="line">        <span class="built_in">inc</span>(g[i], tmp[i - l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ExpSolve</span>(f, g, md, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">poly <span class="title">Exp</span><span class="params">(poly f, <span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">    f.<span class="built_in">resize</span>(_n), f = <span class="built_in">Der</span>(f);</span><br><span class="line">    <span class="function">poly <span class="title">g</span><span class="params">(_n)</span></span>;</span><br><span class="line">    <span class="built_in">ExpSolve</span>(f, g, <span class="number">0</span>, _n);</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更为优秀的分治做法">更为优秀的分治做法</h3>
<p>咕咕咕</p>
</div><h2 id="多项式求任意次幂">多项式求任意次幂</h2><div class="story post-story">
<blockquote>
<p>给定多项式 <span class="math inline">\(F(x)\)</span> 和正整数 <span class="math inline">\(k\)</span>，求 <span class="math inline">\(G(x)\equiv F^k(x)\pmod{x^n}\)</span>。</p>
</blockquote>
<p>如果 <span class="math inline">\(F(x)\)</span> 常数项为 <span class="math inline">\(1\)</span>，那么有 <span class="math inline">\(G(x)=e^{k\ln F(x)}\)</span>。</p>
<p>而 <span class="math inline">\(F(x)\)</span> 常数项不为 <span class="math inline">\(1\)</span> 时，我们可以把 <span class="math inline">\(F(x)\)</span> 除以 <span class="math inline">\(ax^p\)</span> 使得常数项为 <span class="math inline">\(1\)</span>，最后再乘上 <span class="math inline">\(a^kx^{kp}\)</span>。</p>
<p>理论上来说这个方法可以求任意实数幂次，但是系数在模意义下运算，<span class="math inline">\(k\)</span> 为分数、无理数时很难求或者在模域下不存在答案。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Pow</span><span class="params">(poly a, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    a.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">int</span> t = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">            t = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) &#123;</span><br><span class="line">            a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> vi = <span class="built_in">qpow</span>(a[t], P - <span class="number">2</span>), vk = <span class="built_in">qpow</span>(a[t], k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - t; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">mul</span>(a[i + t], vi);</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">resize</span>(n - t);</span><br><span class="line">    t = std::<span class="built_in">min</span>(<span class="number">1ll</span> * t * k, <span class="number">1ll</span> * n);</span><br><span class="line">    <span class="keyword">if</span> (t == n) &#123;</span><br><span class="line">        a.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            a[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    a = <span class="built_in">Ln</span>(a, n - t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - t; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">mul</span>(a[i], k);</span><br><span class="line">    &#125;</span><br><span class="line">    a = <span class="built_in">Exp</span>(a, n - t), a.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - t - <span class="number">1</span>; ~i; --i) &#123;</span><br><span class="line">        a[i + t] = <span class="built_in">mul</span>(a[i], vk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>注意下面部分的代码还未更新。</p>
</div><h2 id="多项式开根">多项式开根</h2><div class="story post-story">
<blockquote>
<p>已知多项式 <span class="math inline">\(F(x)\)</span>，求多项式 <span class="math inline">\(G(x)\)</span> 满足 <span class="math inline">\(G^2(x)\equiv F(x)\pmod{x^n}\)</span>。</p>
</blockquote>
<p>定义函数 <span class="math inline">\(H(G(x))=G^2(x)-F(x)\)</span>，那么我们要求 <span class="math inline">\(G(x)\)</span> 使得 <span class="math inline">\(H(G(x))\equiv 0\pmod{x^n}\)</span>。</p>
<p>仍然假设我们已经求出了 <span class="math inline">\(G_0(x)\)</span> 满足 <span class="math inline">\(H(G_0(x))\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>。根据牛顿迭代的式子，得到 <span class="math display">\[\begin{aligned}G(x)&amp;\equiv G_0(x)-\frac{H(G_0(x))}{H&#39;(G_0(x))}\\&amp;=G_0(x)-\frac{G_0^2(x)-F(x)}{2G_0(x)}\\&amp;=\frac{G_0^2(x)+F(x)}{2G_0(x)}\pmod{x^n}\end{aligned}\]</span></p>
<p>在模意义下运算时，边界我们只要用 Cipolla 算法求二次剩余即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Sqrt</span><span class="params">(poly f, <span class="keyword">int</span> _n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">get</span>(_n);</span><br><span class="line">    f.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="function">poly <span class="title">g</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="built_in">Sqrt</span>(f[<span class="number">0</span>]); <span class="comment">// 求二次剩余</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> m = <span class="number">2</span>; m &lt;= n; m &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        poly tmp = <span class="built_in">Pow2</span>(g);</span><br><span class="line">        tmp.<span class="built_in">resize</span>(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) <span class="built_in">inc</span>(tmp[i], f[i]);</span><br><span class="line">        g = <span class="built_in">Multiply</span>(tmp, <span class="built_in">Inverse</span>(g, m)), g.<span class="built_in">resize</span>(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) g[i] = <span class="built_in">mul</span>(g[i], inv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g.<span class="built_in">resize</span>(_n), g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="多项式多点求值">多项式多点求值</h2><div class="story post-story">
<blockquote>
<p>给定多项式 <span class="math inline">\(F(x)\)</span> 和 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(a_i\)</span>，对于每个 <span class="math inline">\(a_i\)</span>，求 <span class="math inline">\(F(a_i)\)</span> 的值。</p>
</blockquote>
<p>记 <span class="math inline">\(k=\lfloor\frac{n}{2}\rfloor\)</span>，构造多项式 <span class="math inline">\(G_0(x)=\prod\limits_{i=1}^{k}(x-a_i)\)</span>，然后用多项式除法求出 <span class="math inline">\(D_0(x),R_0(x)\)</span> 满足 <span class="math inline">\(F(x)=D_0(x)G_0(x)+R_0(x)\)</span>。</p>
<p>发现对于 <span class="math inline">\(i\le k\)</span> 的 <span class="math inline">\(a_i\)</span>，代入后 <span class="math inline">\(D_0(x)G_0(x)=0\)</span>，也就是说 <span class="math inline">\(F(a_i)=R_0(a_i)\)</span>。</p>
<p>对于 <span class="math inline">\(i &gt; k\)</span> 的部分也可以同理构造多项式 <span class="math inline">\(G_1(x)\)</span> 求出 <span class="math inline">\(R_1(x)\)</span> 使得 <span class="math inline">\(F(a_i)=R_1(a_i)\)</span>。</p>
<p>于是我们把用 <span class="math inline">\(O(n\log n)\)</span> 的复杂度把原问题分成了两个规模减半的子问题。</p>
<p>每次的 <span class="math inline">\(G_0(x),G_1(x)\)</span> 可以一开始都预处理出来。</p>
<p>预处理部分复杂度 <span class="math inline">\(O(n\log^2n)\)</span>，总复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<p>注意到暴力展开计算常数非常小，在问题规模减到一定数值时可以暴力计算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs;</span><br><span class="line">    poly g;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> _T_cnt;</span><br><span class="line">std::vector&lt;tree_node&gt; _T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eval_inter_init</span><span class="params">(<span class="keyword">const</span> poly &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = _T_cnt++;</span><br><span class="line">    _T[u].ls = _T[u].rs = <span class="number">-1</span>, _T[u].g.<span class="built_in">resize</span>(r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r)&#123;</span><br><span class="line">        _T[u].g[<span class="number">0</span>] = <span class="built_in">minus</span>(<span class="number">0</span>, x[l]), _T[u].g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> md = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    _T[u].ls = <span class="built_in">eval_inter_init</span>(x, l, md);</span><br><span class="line">    _T[u].rs = <span class="built_in">eval_inter_init</span>(x, md, r);</span><br><span class="line">    _T[u].g = <span class="built_in">Multiply</span>(_T[_T[u].ls].g, _T[_T[u].rs].g);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Evaluate_solve</span><span class="params">(<span class="keyword">const</span> poly &amp;f, <span class="keyword">const</span> poly &amp;x, poly &amp;y, <span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">256</span>)&#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> n = f.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = l; k &lt; r; ++k)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">unsigned</span> now = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> b[<span class="number">17</span>], c1, c2, c3, c4;</span><br><span class="line">            b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; ++i) b[i] = b[i - <span class="number">1</span>] * x[k] % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - <span class="number">1</span>; i - <span class="number">15</span> &gt;= <span class="number">0</span>; i -= <span class="number">16</span>)&#123;</span><br><span class="line">                c1 = now * b[<span class="number">16</span>] + f[i] * b[<span class="number">15</span>] + f[i - <span class="number">1</span>] * b[<span class="number">14</span>] + f[i - <span class="number">2</span>] * b[<span class="number">13</span>];</span><br><span class="line">                c2 = f[i - <span class="number">3</span>] * b[<span class="number">12</span>] + f[i - <span class="number">4</span>] * b[<span class="number">11</span>] + f[i - <span class="number">5</span>] * b[<span class="number">10</span>] + f[i - <span class="number">6</span>] * b[<span class="number">9</span>];</span><br><span class="line">                c3 = f[i - <span class="number">7</span>] * b[<span class="number">8</span>] + f[i - <span class="number">8</span>] * b[<span class="number">7</span>] + f[i - <span class="number">9</span>] * b[<span class="number">6</span>] + f[i - <span class="number">10</span>] * b[<span class="number">5</span>];</span><br><span class="line">                c4 = f[i - <span class="number">11</span>] * b[<span class="number">4</span>] + f[i - <span class="number">12</span>] * b[<span class="number">3</span>] + f[i - <span class="number">13</span>] * b[<span class="number">2</span>] + f[i - <span class="number">14</span>] * b[<span class="number">1</span>];</span><br><span class="line">                now = (c1 + c2 + c3 + c4 + f[i - <span class="number">15</span>]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n % <span class="number">16</span> - <span class="number">1</span>; ~i; --i) now = (<span class="number">1ull</span> * now * x[k] + f[i]) % P;</span><br><span class="line">            y[k] = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> md = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    poly R;</span><br><span class="line">    R = <span class="built_in">Divide</span>(f, _T[_T[u].ls].g).second;</span><br><span class="line">    <span class="built_in">Evaluate_solve</span>(R, x, y, _T[u].ls, l, md);</span><br><span class="line">    R = <span class="built_in">Divide</span>(f, _T[_T[u].rs].g).second;</span><br><span class="line">    <span class="built_in">Evaluate_solve</span>(R, x, y, _T[u].rs, md, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">Evaluate</span><span class="params">(<span class="keyword">const</span> poly &amp;f, <span class="keyword">const</span> poly &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = x.<span class="built_in">size</span>(), rt = <span class="number">-1</span>;</span><br><span class="line">    _T_cnt = <span class="number">0</span>, _T.<span class="built_in">resize</span>(<span class="number">2</span> * m - <span class="number">1</span>), rt = <span class="built_in">eval_inter_init</span>(x, <span class="number">0</span>, m);</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="built_in">Evaluate_solve</span>(f, x, res, rt, <span class="number">0</span>, m);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="多项式快速插值">多项式快速插值</h2><div class="story post-story">
<blockquote>
<p>有一个 <span class="math inline">\(n-1\)</span> 次多项式 <span class="math inline">\(F(x)\)</span>，给定 <span class="math inline">\(n\)</span> 个点及对应的点值 <span class="math inline">\((x_i,y_i)\)</span>，求 <span class="math inline">\(F(x)\)</span>。</p>
</blockquote>
<p>根据拉格朗日插值公式，有 <span class="math display">\[\begin{aligned}F(x)&amp;=\sum_{i=1}^{n} y_i\prod_{i\ne j}\frac{x-x_j}{x_i-x_j}\\&amp;=\sum_{i=1}^{n}\frac{y_i}{\prod_{i\ne j}(x_i-x_j)}\prod_{i\ne j}(x-x_j)\end{aligned}\]</span></p>
<p>令 <span class="math inline">\(G(x)=\prod_{i=1}^{n}(x-x_i),H_i(x)=\frac{G(x)}{x-x_i}\)</span>，那么 <span class="math inline">\(\prod_{i\ne j}(x_i-x_j)=H_i(x_i)\)</span>。根据洛必达法则，有 <span class="math inline">\(H_i(x_i)=G&#39;(x_i)\)</span>。</p>
<p>于是我们用多项式多点求值求出所有 <span class="math inline">\(G&#39;(x_i)\)</span> 即可。</p>
<p>记 <span class="math inline">\(a_i=\frac{y_i}{G&#39;(x_i)}\)</span>，那么有 <span class="math display">\[F(x)=\sum_{i=1}^{n}a_i\prod_{i\ne j}(x-x_j)\]</span></p>
<p>然后我们分治求解。设当前区间为 <span class="math inline">\([l,r)\)</span>，中点 <span class="math inline">\(m=\lfloor\frac{l+r+1}{2}\rfloor\)</span>，我们要求 <span class="math display">\[\begin{aligned}F_{l,r}(x)&amp;=\sum_{i=l}^{r-1}a_i\prod_{l\le j &lt; r,j\ne i}(x-x_j) \\ &amp;=\left(\prod_{i=m}^{r-1}(x-x_i)\right)\sum_{i=l}^{m-1}a_i\prod_{l\le j &lt; m,i\ne j}(x-x_j)+\left(\prod_{i=l}^{m-1}(x-x_i)\right)\sum_{i=m}^{r-1}a_i\prod_{m\le j &lt; r,i\ne j}(x-x_j) \\ &amp;=\left(\prod_{i=m}^{r-1}(x-x_i)\right)F_{l,m}(x)+\left(\prod_{i=l}^{m-1}(x-x_i)\right)F_{m,r}(x)\end{aligned}\]</span></p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Divide_2</span><span class="params">(poly a, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">poly <span class="title">b</span><span class="params">(n - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - <span class="number">1</span>; i; --i)&#123;</span><br><span class="line">        b[i - <span class="number">1</span>] = a[i];</span><br><span class="line">        <span class="built_in">dec</span>(a[i - <span class="number">1</span>], <span class="built_in">mul</span>(a[i], t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">Inter_solve</span><span class="params">(<span class="keyword">const</span> poly &amp;x, <span class="keyword">const</span> poly &amp;y, <span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">64</span>)&#123;</span><br><span class="line">        <span class="function">poly <span class="title">f</span><span class="params">(r - l)</span>, g </span>= _T[u].g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = l; i &lt; r; ++i)&#123;</span><br><span class="line">            poly tmp = <span class="built_in">Divide_2</span>(g, <span class="built_in">minus</span>(<span class="number">0</span>, x[i]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; r - l; ++j) f[j] = (f[j] + <span class="number">1ull</span> * tmp[j] * y[i]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> md = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    poly A = _T[_T[u].rs].g, B = <span class="built_in">Inter_solve</span>(x, y, _T[u].ls, l, md);</span><br><span class="line">    poly C = _T[_T[u].ls].g, D = <span class="built_in">Inter_solve</span>(x, y, _T[u].rs, md, r);</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> m = <span class="built_in">get</span>(r - l);</span><br><span class="line">    <span class="built_in">init</span>(m), <span class="built_in">DFT</span>(A, m), <span class="built_in">DFT</span>(B, m), <span class="built_in">DFT</span>(C, m), <span class="built_in">DFT</span>(D, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) A[i] = (<span class="number">1ull</span> * A[i] * B[i] + <span class="number">1ull</span> * C[i] * D[i]) % P;</span><br><span class="line">    <span class="built_in">IDFT</span>(A, m), A.<span class="built_in">resize</span>(r - l);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">Interpolation</span><span class="params">(poly x, poly y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = x.<span class="built_in">size</span>(), rt = <span class="number">-1</span>;</span><br><span class="line">    _T_cnt = <span class="number">0</span>, _T.<span class="built_in">resize</span>((n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>), rt = <span class="built_in">eval_inter_init</span>(x, <span class="number">0</span>, n);</span><br><span class="line">    poly g = <span class="built_in">Derivative</span>(_T[rt].g);</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">Evaluate_solve</span>(g, x, res, rt, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) y[i] = <span class="built_in">mul</span>(y[i], <span class="built_in">qpow</span>(res[i], P - <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Inter_solve</span>(x, y, rt, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="多项式三角函数">多项式三角函数</h2><div class="story post-story">
<p>不会</p>
</div><h2 id="多项式反三角函数">多项式反三角函数</h2><div class="story post-story">
<p>不会</p>
</div><h2 id="mtt">MTT</h2><div class="story post-story">
<p>直接 FFT 的关键问题是精度不够。考虑将系数拆成 <span class="math inline">\(a\times 2^{15}+b\)</span> 的形式，则两个系数相乘会得到 <span class="math display">\[
\begin{aligned}
&amp; (a_1\times 2^{15}+b_1)(a_2\times 2^{15}+b_2) \\
=&amp; a_1a_2\times 2^{30}+(a_1b_2+a_2b_1)\times 2^{15}+b_1b_2
\end{aligned}
\]</span></p>
<p>做 <span class="math inline">\(4\)</span> 次 DFT 以及 <span class="math inline">\(3\)</span> 次 IDFT 即可。</p>
<p>这是 <span class="math inline">\(7\)</span> 次 DFT 的做法，<span class="math inline">\(4\)</span> 次甚至 <span class="math inline">\(3.5\)</span> 次 DFT 的做法暂时还不会。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + rhs.x, y + rhs.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - rhs.x, y - rhs.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex &amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MTTPoly &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_LEN = <span class="number">1</span> &lt;&lt; <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> std::vector&lt;<span class="keyword">int</span>&gt; poly;</span><br><span class="line"></span><br><span class="line">    Complex omega[MAX_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; MAX_LEN; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                omega[m + i] = &#123;<span class="built_in">cos</span>(pi / m * i), <span class="built_in">sin</span>(pi / m * i)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; _n) &#123;</span><br><span class="line">            n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; rev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) &lt; n) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        rev.<span class="built_in">resize</span>(n), rev[<span class="number">0</span>] = <span class="number">0</span>, --k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(std::vector&lt;Complex&gt; &amp;f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        f.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">static</span> Complex F[MAX_LEN];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            F[rev[i]] = f[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; n; p += m &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                Complex *W = omega + m;</span><br><span class="line">                Complex *F0 = F + p, *F1 = F0 + m;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i, ++W, ++F0, ++F1) &#123;</span><br><span class="line">                    Complex t = (*F1) * (*W);</span><br><span class="line">                    *F1 = *F0 - t, *F0 = *F0 + t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i] = F[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IDFT</span><span class="params">(std::vector&lt;Complex&gt; &amp;f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DFT</span>(f, n), std::<span class="built_in">reverse</span>(f.<span class="built_in">begin</span>() + <span class="number">1</span>, f.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i] = f[i] * (Complex)&#123;<span class="number">1.0</span> / n, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">poly <span class="title">Mul</span><span class="params">(<span class="keyword">const</span> poly &amp;f, <span class="keyword">const</span> poly &amp;g, <span class="keyword">int</span> P)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fn = f.<span class="built_in">size</span>(), gn = g.<span class="built_in">size</span>(), _n = fn + gn - <span class="number">1</span>;</span><br><span class="line">        <span class="function">std::vector&lt;Complex&gt; <span class="title">fa</span><span class="params">(fn)</span>, <span class="title">fb</span><span class="params">(fn)</span>, <span class="title">ga</span><span class="params">(gn)</span>, <span class="title">gb</span><span class="params">(gn)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fn; ++i) &#123;</span><br><span class="line">            fa[i].x = f[i] &gt;&gt; <span class="number">15</span>, fa[i].y = <span class="number">0</span>;</span><br><span class="line">            fb[i].x = f[i] &amp; <span class="number">32767</span>, fb[i].y = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gn; ++i) &#123;</span><br><span class="line">            ga[i].x = g[i] &gt;&gt; <span class="number">15</span>, ga[i].y = <span class="number">0</span>;</span><br><span class="line">            gb[i].x = g[i] &amp; <span class="number">32767</span>, gb[i].y = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">get</span>(_n);</span><br><span class="line">        <span class="built_in">init</span>(n), <span class="built_in">DFT</span>(fa, n), <span class="built_in">DFT</span>(fb, n), <span class="built_in">DFT</span>(ga, n), <span class="built_in">DFT</span>(gb, n);</span><br><span class="line">        <span class="function">std::vector&lt;Complex&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span>, <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            a[i] = fa[i] * ga[i];</span><br><span class="line">            b[i] = fa[i] * gb[i] + fb[i] * ga[i];</span><br><span class="line">            c[i] = fb[i] * gb[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">IDFT</span>(a, n), <span class="built_in">IDFT</span>(b, n), <span class="built_in">IDFT</span>(c, n);</span><br><span class="line">        <span class="function">poly <span class="title">ans</span><span class="params">(_n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _n; ++i) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> A = a[i].x + <span class="number">0.5</span>, B = b[i].x + <span class="number">0.5</span>, C = c[i].x + <span class="number">0.5</span>;</span><br><span class="line">            A %= P, B %= P, C %= P;</span><br><span class="line">            ans[i] = ((<span class="number">1</span> &lt;&lt; <span class="number">30</span>) * A + (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) * B + C) % P;</span><br><span class="line">            ans[i] = (P + ans[i]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><h2 id="完整代码">完整代码</h2><div class="story post-story">
<p>完整代码可以见 <a href="https://github.com/AutumnKite/Codes/blob/master/Templates/Polynomial.cpp">Codes/Polynomial.cpp at master · AutumnKite/Codes</a>。</p>

</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
</search>
