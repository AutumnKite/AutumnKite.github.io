<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Educational Codeforces Round 84 (Rated for Div. 2) 自闭记</title>
      <link href="/cf1327/"/>
      <url>/cf1327/</url>
      
        <content type="html"><![CDATA[<p>自闭了。</p><a id="more"></a><h2 id="a---sum-of-odd-integers">A - Sum of Odd Integers</h2><p><a href="https://codeforces.com/contest/1327/problem/A" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题解">题解</h3><p>首先，我们尝试取出最小的 <span class="math inline">\(k\)</span> 个正奇数：<span class="math inline">\(1,3,5,7,\cdots,2k-1\)</span>。</p><p>这些奇数的和为 <span class="math inline">\(\frac{(1+2k-1)k}{2}=k^2\)</span>。</p><p>那么我们如何构造才能使得 <span class="math inline">\(k\)</span> 个奇数互不相同且和为 <span class="math inline">\(n\)</span> 呢？</p><p>只要不断将最大的奇数加 <span class="math inline">\(2\)</span> 即可。</p><p>所以当 <span class="math inline">\(n-k^2\)</span> 是大于等于 <span class="math inline">\(0\)</span> 的偶数时，一定能够构造出解。</p><p>而当 <span class="math inline">\(n &lt; k^2\)</span> 时，最小的 <span class="math inline">\(k\)</span> 个正奇数的和已经有 <span class="math inline">\(k^2\)</span>，那么一定不能构造出解。</p><p>当 <span class="math inline">\(n-k^2\)</span> 不为偶数时，由于任意 <span class="math inline">\(k\)</span> 个奇数一定可以通过最小的 <span class="math inline">\(k\)</span> 个正奇数中的数 <span class="math inline">\(+2,-2\)</span> 得到，所以任意 <span class="math inline">\(k\)</span> 个奇数的和一定与 <span class="math inline">\(k^2\)</span> 的奇偶性相同，而 <span class="math inline">\(n\)</span> 的奇偶性与 <span class="math inline">\(k^2\)</span> 不同，所以一定不能构造出解。</p><p>所以「<span class="math inline">\(n-k^2\)</span> 是大于等于 <span class="math inline">\(0\)</span> 的偶数」是能构造出解的充要条件。</p><p>注意计算 <span class="math inline">\(k^2\)</span> 时要开 <code>long long</code>。另外，<span class="math inline">\(k\)</span> 与 <span class="math inline">\(k^2\)</span> 的奇偶性一定是相同的，所以我们判断 <span class="math inline">\(n\)</span> 与 <span class="math inline">\(k^2\)</span> 的奇偶性是否相同只需要判断 <span class="math inline">\(n\)</span> 与 <span class="math inline">\(k\)</span> 的奇偶性是否相同。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(n), read(k);</span><br><span class="line">    <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == (k &amp; <span class="number">1</span>) &amp;&amp; <span class="number">1l</span>l * k * k &lt;= n) prints(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">else</span> prints(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b---princesses-and-princes">B - Princesses and Princes</h2><p><a href="https://codeforces.com/contest/1327/problem/B" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题解-1">题解</h3><p>我这个彩笔又看错题了...</p><p>题目里说只要能够增加就行...而我以为要取增加最多的方案...</p><p>那么只要模拟一遍以后，如果存在一个没有匹配的公主，任选一个王子与她匹配即可。</p><p>如果需要「增加最多」，这样构造是否正确呢 QAQ</p><p>有没有神仙来证明一下或者给出一个反例啊 QAQ</p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, vis[N];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; E[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        vis[i] = <span class="number">0</span>, E[i].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, k; i &lt;= n; ++i)&#123;</span><br><span class="line">        read(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>, x; j &lt; k; ++j)</span><br><span class="line">            read(x), E[i].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> add_x = <span class="number">0</span>, add_y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)E[i].size(); ++j)</span><br><span class="line">            <span class="keyword">if</span> (!vis[E[i][j]])&#123; vis[E[i][j]] = <span class="number">1</span>, flag = <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag || add_x) <span class="keyword">continue</span>;</span><br><span class="line">        add_x = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!add_x) prints(<span class="string">"OPTIMAL"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        add_y = n;</span><br><span class="line">        <span class="keyword">while</span> (vis[add_y]) --add_y;</span><br><span class="line">        prints(<span class="string">"IMPROVE"</span>), print(add_x, <span class="string">' '</span>), print(add_y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c---game-with-chips">C - Game with Chips</h2><p><a href="https://codeforces.com/contest/1327/problem/C" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题解-2">题解</h3><p>考场上的我甚至想过把坐标旋转 <span class="math inline">\(x,y\)</span> 独立等等奇怪的玩意。</p><p>在想这东西的时候，发现这东西是有边界的，而且到边界他就不会继续走了。</p><p>于是我不会了。</p><p>转念一想，既然可以走 <span class="math inline">\(2nm\)</span> 步，好像直接把所有点移到 <span class="math inline">\((1,1)\)</span>，然后把所有点走一遍就好了！</p><p>移到 <span class="math inline">\((1,1)\)</span> 需要 <span class="math inline">\(n+m-2\)</span> 步，遍历所有点需要 <span class="math inline">\(nm-1\)</span> 步，步数显然是不超过 <span class="math inline">\(2nm\)</span> 的。</p><p>代码里移动到 <span class="math inline">\((1,1)\)</span> 用了 <span class="math inline">\(n+m\)</span> 步。</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(n), read(m), read(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= k; ++i) read(x), read(y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= k; ++i) read(x), read(y);</span><br><span class="line">    print(n + m + n * m - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">putchar</span>(<span class="string">'U'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">putchar</span>(<span class="string">'L'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) <span class="built_in">putchar</span>(i &amp; <span class="number">1</span> ? <span class="string">'R'</span> : <span class="string">'L'</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) <span class="built_in">putchar</span>(<span class="string">'D'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d---infinite-path">D - Infinite Path</h2><p><a href="https://codeforces.com/contest/1327/problem/D" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题解-3">题解</h3><p>首先看到一个排列求 <span class="math inline">\(k\)</span> 次幂，容易想到将排列看成若干置换环的形式。</p><p>如排列 <span class="math inline">\(p=\{2,4,1,3,6,5\}\)</span> 可以看成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 --&gt; 2</span><br><span class="line">^     |</span><br><span class="line">|     v</span><br><span class="line">3 &lt;-- 4</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 &lt;&#x3D;&#x3D;&gt; 6</span><br></pre></td></tr></table></figure><p>两个置换环。</p><p>将一个排列求 <span class="math inline">\(k\)</span> 次幂以后，某个点 <span class="math inline">\(i\)</span> 会重新指向原来环上从 <span class="math inline">\(i\)</span> 开始第 <span class="math inline">\(k\)</span> 个点。</p><p>那么由于我们只需要一个环满足颜色相等，容易想到将每个环单独处理以后取 <span class="math inline">\(\min\)</span> 即可。</p><p>对于一个环长为 <span class="math inline">\(l\)</span> 的环，我们将环上的点从某个点开始重新标号。我们判断一个 <span class="math inline">\(k\)</span> 是否可行，只需要记 <span class="math inline">\(p=\gcd(k,l)\)</span>，我们判断是否存在一个 <span class="math inline">\(0\le t &lt; p\)</span> 使得环上所有模 <span class="math inline">\(p\)</span> 等于 <span class="math inline">\(t\)</span> 的点颜色是否相同即可。</p><p>那么显然只要枚举所有 <span class="math inline">\(l\)</span> 的因数 <span class="math inline">\(k\)</span> 即可。</p><p>时间复杂度 <span class="math inline">\(O(n\sqrt{n})\)</span>。</p><h3 id="代码-3">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> n, p[N], c[N], vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    <span class="keyword">int</span> l = a.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">1l</span>l * i * i &lt;= l; ++i) <span class="comment">// 求因数</span></span><br><span class="line">        <span class="keyword">if</span> (l % i == <span class="number">0</span>)&#123;</span><br><span class="line">            d.push_back(i);</span><br><span class="line">            <span class="keyword">if</span> (i * i &lt; l) d.push_back(l / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(d.begin(), d.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k : d)&#123; <span class="comment">// 枚举 k</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt; l; j += k)</span><br><span class="line">                flag &amp;= a[j] == a[i]; <span class="comment">// 判断颜色是否相同</span></span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(p[i]), vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(c[i]);</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            tmp.push_back(c[i]), vis[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = p[i]; j != i; j = p[j])</span><br><span class="line">                tmp.push_back(c[j]), vis[j] = <span class="number">1</span>;</span><br><span class="line">            ans = <span class="built_in">std</span>::min(ans, solve(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">    print(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="e---count-the-blocks">E - Count The Blocks</h2><p><a href="https://codeforces.com/contest/1327/problem/E" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题解-4">题解</h3><p>设答案为 <span class="math inline">\(g_i\)</span>，考虑计算出 <span class="math inline">\(f_i=\sum\limits_{j=i}^{n} (j-i+1)g_j\)</span>，根据 <span class="math inline">\(f_i\)</span> 的实际意义，显然有 <span class="math inline">\(f_i=(n-i+1)\times 10^{n-i+1}\)</span>。</p><p>根据容斥，可以得到 <span class="math inline">\(g_i=f_i-2f_{i-1}+f_{i-2}\)</span>。这个式子的正确性也可以将 <span class="math inline">\(f_i\)</span> 的定义式子代入证明。</p><h3 id="代码-4">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123; (a += b) &gt;= P ? a -= P : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123; a &lt; b ? a += P - b : a -= b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">int</span> pw = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i)&#123;</span><br><span class="line">        f[i] = <span class="number">1l</span>l * pw * (n - i + <span class="number">1</span>) % P;</span><br><span class="line">        pw = <span class="number">10l</span>l * pw % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        dec(f[i], f[i + <span class="number">1</span>]), dec(f[i], f[i + <span class="number">1</span>]), inc(f[i], f[i + <span class="number">2</span>]);</span><br><span class="line">        print(f[i], <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="f---and-segments">F - AND Segments</h2><p><a href="https://codeforces.com/contest/1327/problem/F" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题解-5">题解</h3><p>不错，最后 5min 开始写代码，没调出来，直接死在这题上了。</p><hr /><p>上面是一个菜鸡 xjb BB，不要管他。</p><p>首先看到这题，一看是位运算，先考虑每位是否独立。</p><p>因为只有 and 运算的限制，所以很显然每一位是独立的。那么我们只需要求出每一位满足限制的方案数，然后乘起来即可。</p><p>对于当前位，有若干个限制，每个限制规定了一个区间的 and 和是 <span class="math inline">\(0\)</span> 还是 <span class="math inline">\(1\)</span>。</p><p>对于限制为 <span class="math inline">\(1\)</span> 的区间，直接强制每一位必须填 <span class="math inline">\(1\)</span>。而对于限制为 <span class="math inline">\(0\)</span> 的区间，看上去非常难搞。</p><p>一开始我以为可以容斥，但是若干区间取并这玩意非常难处理。</p><p>突然想到了联赛前的一道作业题：<a href="https://www.luogu.com.cn/problem/P4229" target="_blank" rel="noopener">P4229 某位歌姬的故事</a>。</p><p>那题由于需要离散，并且限制比较宽，所以 DP 是 <span class="math inline">\(O(nq)\)</span> 的。</p><p>然而这题不需要离散，并且只有 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span>，所以我们尝试去优化这个 DP。</p><p>预处理 <span class="math inline">\(\operatorname{pos}[i]\)</span> 表示 <span class="math inline">\(i\)</span> 之前（不包括 <span class="math inline">\(i\)</span>）第一个 <span class="math inline">\(0\)</span> 至少填在 <span class="math inline">\(\operatorname{pos}[i]\)</span> 位置。这个预处理可以参考 P4229 中的预处理。</p><p>考虑 DP，<span class="math inline">\(f[i][j]\)</span> 表示前 <span class="math inline">\(i\)</span> 位，最后一个 <span class="math inline">\(0\)</span> 的位置为 <span class="math inline">\(j\)</span> 时满足限制的方案数。分三种情况进行转移：</p><ul><li><span class="math inline">\(j&lt;\operatorname{pos}[i]\)</span> 时，有 <span class="math inline">\(f[i][j]=0\)</span>；</li><li><span class="math inline">\(\operatorname{pos}[i]\le j &lt; i\)</span> 时，有 <span class="math inline">\(f[i][j]=f[i-1][j]\)</span>；</li><li><span class="math inline">\(j=i\)</span> 时，若根据 <span class="math inline">\(1\)</span> 的限制，第 <span class="math inline">\(i\)</span> 位强制选 <span class="math inline">\(1\)</span>，那么 <span class="math inline">\(f[i][j]=0\)</span>；否则 <span class="math inline">\(f[i][j]=\sum\limits_{k=\operatorname{pos}[i]}^{i-1} f[i-1][k]\)</span>。</li></ul><p>对于第一种情况，我们只需要维护一个最左边不为 <span class="math inline">\(0\)</span> 的指针，每次把 <span class="math inline">\(&lt; \operatorname{pos}[i]\)</span> 的位置刷成 <span class="math inline">\(0\)</span> 即可。</p><p>对于第二种情况，由于没有任何改变，所以我们不需要进行任何处理。</p><p>对于第三种情况，我们只要单点修改第 <span class="math inline">\(i\)</span> 个位置的值即可。注意需要实时维护当前行的和。</p><p>于是这个 DP 的复杂度变成了 <span class="math inline">\(O(n)\)</span>。</p><p>每一位预处理复杂度为 <span class="math inline">\(O(m)\)</span>，所以总时间复杂度 <span class="math inline">\(O(k(n+m))\)</span>。</p><hr /><p>我的做法好像比官方题解的做法复杂一万倍。</p><p>另：这题跟绍一新生考试的 F 好像差不多...</p><h3 id="代码-5">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500005</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, m, a[N], l[N], r[N], x[N], f[N], pos[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123; (a += b) &gt;= P ? a -= P : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123; a &lt; b ? a += P - b : a -= b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(n), read(k), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        read(l[i]), read(r[i]), ++r[i], read(x[i]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> p = <span class="number">0</span>; p &lt; k; ++p)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) pos[i] = <span class="number">0</span>, a[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">if</span> (x[i] &gt;&gt; p &amp; <span class="number">1</span>) ++a[l[i]], --a[r[i]]; <span class="comment">// 差分实现区间加</span></span><br><span class="line">            <span class="keyword">else</span> pos[r[i]] = <span class="built_in">std</span>::max(pos[r[i]], l[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + <span class="number">1</span>; ++i) a[i] += a[i - <span class="number">1</span>], pos[i] = <span class="built_in">std</span>::max(pos[i], pos[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// a 预处理第 i 位是否强制选 1</span></span><br><span class="line">        <span class="comment">// pos 预处理 i 之前第一个 0 至少选在哪里</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; ++i) f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; pos[i]) dec(sum, f[l]), f[l] = <span class="number">0</span>, ++l; <span class="comment">// 把 &lt; pos[i] 的位置刷成 0</span></span><br><span class="line">            f[i] = a[i] ? <span class="number">0</span> : sum, inc(sum, f[i]); <span class="comment">// 修改第 i 个位置的 dp 值</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">1l</span>l * ans * f[n + <span class="number">1</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    print(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="g---letters-and-question-marks">G - Letters and Question Marks</h2><p><a href="https://codeforces.com/contest/1327/problem/G" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题解-6">题解</h3><p>事实上这个题还是非常简单的。（别问我为什么现场没过</p><p>首先可以对所有模式串建个 AC 自动机，每个点的权值就是这个点在 <span class="math inline">\(fail\)</span> 树上到根路径上所有点对应的字符串的权值和。</p><p>如果字符串 <span class="math inline">\(s\)</span> 已经全部确定，那么我们只要把 <span class="math inline">\(s\)</span> 在这个自动机上跑一遍，把经过节点的点权累加即可。</p><p>但是现在 <span class="math inline">\(s\)</span> 有若干个字符不确定。我们考虑对于 <span class="math inline">\(s\)</span> 的每段确定的极大子串，以及 AC 自动机上的点 <span class="math inline">\(u\)</span>，预处理从 <span class="math inline">\(u\)</span> 开始，按照这段子串跑，最终跑到的点以及沿路经过的点权和。</p><p>然后我们就可以 DP 了。记 <span class="math inline">\(f_{S,u}\)</span> 表示当前问号的位置用了 <span class="math inline">\(S\)</span> 这些字符，跑到自动机上的节点 <span class="math inline">\(u\)</span> 时，最大的权值和。</p><p>转移只需要枚举下一个问号填的字符即可。</p><p>记 <span class="math inline">\(n\)</span> 为字符串 <span class="math inline">\(s\)</span> 的长度，<span class="math inline">\(m\)</span> 为模式串的长度之和，<span class="math inline">\(c\)</span> 为字符集大小，则复杂度为 <span class="math inline">\(O(nm+2^cmc)\)</span>，可以通过本题。</p><h3 id="代码-6">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>, C = <span class="number">14</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> t[N], s[<span class="number">400005</span>];</span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; go[N][C + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> bitcnt[<span class="number">1</span> &lt;&lt; C];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">1</span> &lt;&lt; C][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC_Automaton</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> rt, cnt, trans[N][C], fail[N];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> w[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">new_node</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = cnt++;</span><br><span class="line">        w[u] = <span class="number">0</span>, fail[u] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; ++i) trans[u][i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cnt = <span class="number">0</span>, rt = new_node();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;s, <span class="keyword">long</span> <span class="keyword">long</span> _w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = rt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (trans[u][s[i]] == <span class="number">-1</span>) trans[u][s[i]] = new_node();</span><br><span class="line">            u = trans[u][s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        w[u] += _w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        fail[rt] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; ++i)</span><br><span class="line">            <span class="keyword">if</span> (~trans[rt][i]) Q.push_back(trans[rt][i]), fail[trans[rt][i]] = rt;</span><br><span class="line">            <span class="keyword">else</span> trans[rt][i] = rt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)Q.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q[i];</span><br><span class="line">            w[u] += w[fail[u]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j)</span><br><span class="line">                <span class="keyword">if</span> (~trans[u][j]) Q.push_back(trans[u][j]), fail[trans[u][j]] = trans[fail[u]][j];</span><br><span class="line">                <span class="keyword">else</span> trans[u][j] = trans[fail[u]][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; run(<span class="keyword">int</span> u, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;s)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)s.size(); ++i)</span><br><span class="line">            u = trans[u][s[i]], sum += w[u];</span><br><span class="line">        <span class="keyword">return</span> &#123;u, sum&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AT_HOME</span></span><br><span class="line">    freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"test.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n);</span><br><span class="line">    A.init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = reads(t), w;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        read(w);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) tmp.push_back(t[j] - <span class="string">'a'</span>);</span><br><span class="line">        A.insert(tmp, w);</span><br><span class="line">    &#125;</span><br><span class="line">    A.build();</span><br><span class="line">    <span class="keyword">int</span> len = reads(s);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i == len || s[i] == <span class="string">'?'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A.cnt; ++j)</span><br><span class="line">                go[j][cnt] = A.run(j, tmp);</span><br><span class="line">            tmp.clear(), ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> tmp.push_back(s[i] - <span class="string">'a'</span>);</span><br><span class="line">    bitcnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; C); ++i)</span><br><span class="line">        bitcnt[i] = bitcnt[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; C); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A.cnt; ++j)</span><br><span class="line">            f[i][j] = -INF;</span><br><span class="line">    f[<span class="number">0</span>][go[A.rt][<span class="number">0</span>].first] = go[A.rt][<span class="number">0</span>].second;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; C); ++S)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = bitcnt[S] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == cnt)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> u = <span class="number">0</span>; u &lt; A.cnt; ++u)</span><br><span class="line">                ans = <span class="built_in">std</span>::max(ans, f[S][u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= cnt) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> u = <span class="number">0</span>; u &lt; A.cnt; ++u)</span><br><span class="line">            <span class="keyword">if</span> (f[S][u] != -INF)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; ++i)</span><br><span class="line">                    <span class="keyword">if</span> (!(S &gt;&gt; i &amp; <span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="keyword">int</span> v = A.trans[u][i];</span><br><span class="line">                        <span class="keyword">int</span> S_ = S | (<span class="number">1</span> &lt;&lt; i), u_ = go[v][k].first;</span><br><span class="line">                        f[S_][u_] = <span class="built_in">std</span>::max(f[S_][u_], f[S][u] + A.w[v] + go[v][k].second);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我还是太菜了 /kk</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> DP </tag>
            
            <tag> 数学 </tag>
            
            <tag> 容斥原理 </tag>
            
            <tag> 状压DP </tag>
            
            <tag> 模拟 </tag>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Global Round 7 上 IM 记</title>
      <link href="/cf1326/"/>
      <url>/cf1326/</url>
      
        <content type="html"><![CDATA[<p>终于上 IM 了（</p><a id="more"></a><h2 id="a---bad-ugly-numbers">A - Bad Ugly Numbers</h2><p><a href="https://codeforces.com/contest/1326/problem/A" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题解">题解</h3><p>为什么您们都能想到构造 <span class="math inline">\(2333\cdots 333\)</span> 啊 QAQ</p><p>显然一个能被 <span class="math inline">\(p\)</span> 整除的数，加或减一个不能被 <span class="math inline">\(p\)</span> 整除的数后，不能被 <span class="math inline">\(p\)</span> 整除。</p><p>我们考虑 <span class="math inline">\(777\cdots 777\)</span> 能被 <span class="math inline">\(7\)</span> 整除，而 <span class="math inline">\(777\cdots 77x\)</span>（<span class="math inline">\(x &gt; 0\)</span>）不能被 <span class="math inline">\(7\)</span> 整除。</p><p>又<del>根据小学数学知识</del>，能被 <span class="math inline">\(4\)</span> 整除的数的特征是最后两位能被 <span class="math inline">\(4\)</span> 整除，由于 <span class="math inline">\(74\bmod 4\ne 0\)</span>，所以我们构造 <span class="math inline">\(777\cdots 774\)</span> 即可。</p><p>注意需要特判 <span class="math inline">\(n=1\)</span>。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> print(<span class="number">-1</span>), <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="built_in">putchar</span>(<span class="string">'7'</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'4'</span>), <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b---maximums">B - Maximums</h2><p><a href="https://codeforces.com/contest/1326/problem/B" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题解-1">题解</h3><p>由 <span class="math inline">\(c_i\)</span> 的定义可得 <span class="math display">\[\begin{aligned} b_i&amp;=a_i-c_i \\&amp;=a_i-\max\{0,\max\limits_{j=1}^{i-1} a_j\} \end{aligned}\]</span></p><p>移项后可得 <span class="math display">\[a_i=b_i+\max\{0,\max\limits_{j=1}^{i-1}a_j\}\]</span></p><p>我们只要在递推的同时维护 <span class="math inline">\(a_1,a_2,\cdots,a_{i-1}\)</span> 的最大值即可。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) now += a[i], print(now, <span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">else</span> print(now + a[i], <span class="string">' '</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c---permutation-partitions">C - Permutation Partitions</h2><p><a href="https://codeforces.com/contest/1326/problem/C" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题解-2">题解</h3><p>考场上我看到本题一脸懵逼，我发现我好像不会第一问...</p><p>冷静一下，发现显然答案的上界是取最大的 <span class="math inline">\(k\)</span> 个数，即 <span class="math inline">\((n-k+1)+(n-k+2)+\cdots+n=\frac{(2n-k+1)k}{2}\)</span>。</p><p>我们可以在原排列中标记出这最大的 <span class="math inline">\(k\)</span> 个数，记从左往右第 <span class="math inline">\(i\)</span> 个被标记的位置为 <span class="math inline">\(x_i\)</span>。</p><p>我们要把原排列划分成 <span class="math inline">\(k\)</span> 段意味着我们要找到 <span class="math inline">\(k-1\)</span> 个分界点，并且我们现在要求两个分界点之间恰好包含一个被标记的数。</p><p>那么显然第 <span class="math inline">\(i\)</span> 个分界点应该选在 <span class="math inline">\(x_i\)</span> 到 <span class="math inline">\(x_{i+1}\)</span> 之间。</p><p>每个分界点的选择是独立的（即不会影响其他分界点的选择），所以根据乘法原理，把每个分界点的方案数相乘即可。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(n), read(k);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lst = <span class="number">0</span>, ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        read(a[i]);</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; n - k)&#123;</span><br><span class="line">            sum += a[i];</span><br><span class="line">            <span class="keyword">if</span> (lst) ans = <span class="number">1l</span>l * ans * (i - lst) % P;</span><br><span class="line">            lst = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(sum, <span class="string">' '</span>), print(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d2---prefix-suffix-palindrome-hard-version">D2 - Prefix-Suffix Palindrome (Hard version)</h2><p><a href="https://codeforces.com/contest/1326/problem/D2" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题解-3">题解</h3><p>考场上看到本题的第一想法是枚举前后缀匹配的长度 <span class="math inline">\(l\)</span>，然后要求从 <span class="math inline">\(l+1\)</span> 开始的最长回文串或者以 <span class="math inline">\(n-l\)</span> 结尾的最长回文串。</p><p>刚打算去隔壁 <a href="https://www.luogu.com.cn/problem/P4555" target="_blank" rel="noopener">最长双回文串</a> 复制一个代码，意识到了不对...</p><p>如果求出来的回文串与前后缀有重叠怎么办？</p><p>考虑上面这个想法用暴力怎么实现。在我们将原串中间插入 <code>#</code> 后，用 manacher 算法以 <span class="math inline">\(i\)</span> 为回文中心的回文半径 <span class="math inline">\(d_i\)</span>。</p><p>然后我们枚举前后缀匹配长度 <span class="math inline">\(l\)</span>，分两种情况：</p><ul><li>对于所有 <span class="math inline">\(l+1\le i\le \frac{|s|+1}{2}\)</span> 且 <span class="math inline">\(i-d_i+1\le l+1\)</span>，求出 <span class="math inline">\(i\)</span> 的最大值；</li><li>对于所有 <span class="math inline">\(\frac{|s|+1}{2}\le i\le n-l\)</span> 且 <span class="math inline">\(i+d_i-1\ge n-l\)</span>，求出 <span class="math inline">\(i\)</span> 的最小值。</li></ul><p>可以发现，<span class="math inline">\(l\)</span> 越大，越容易满足限制，越容易使得 <span class="math inline">\(i\)</span> 取到极值。</p><p>所以我们求出最大的 <span class="math inline">\(l\)</span> 以后用上面的暴力实现即可。</p><p><del>如果你不怕被 hack 的话</del> manacher 也可以用哈希实现。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h3 id="代码-3">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000005</span>; <span class="comment">// 注意数组开大一倍</span></span><br><span class="line"><span class="keyword">int</span> n, d[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">(<span class="keyword">int</span> *d, <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, m = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        d[i] = i &gt; r ? <span class="number">0</span> : <span class="built_in">std</span>::min(r - i + <span class="number">1</span>, d[m - (i - m)]);</span><br><span class="line">        <span class="keyword">while</span> (i - d[i] &gt; <span class="number">0</span> &amp;&amp; i + d[i] &lt;= n &amp;&amp; s[i - d[i]] == s[i + d[i]]) ++d[i];</span><br><span class="line">        <span class="keyword">if</span> (i + d[i] - <span class="number">1</span> &gt; r) m = i, r = i + d[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = reads(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i) s[i &lt;&lt; <span class="number">1</span>] = s[i], s[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">    s[<span class="number">1</span>] = <span class="string">'#'</span>, n = n * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    manacher(d, s, n);</span><br><span class="line">    <span class="comment">// for (register int i = 1; i &lt;= n; ++i) debug("%d ", d[i]); debug("\n");</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[n - i + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> ++len;</span><br><span class="line">    <span class="comment">// debug("%d\n", len);</span></span><br><span class="line">    <span class="keyword">int</span> d1 = <span class="number">0</span>, d2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = len + <span class="number">1</span>; i &lt;= (n + <span class="number">1</span>) / <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i - d[i] + <span class="number">1</span> &lt;= len + <span class="number">1</span>) d1 = <span class="built_in">std</span>::max(d1, (i - len) * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = (n + <span class="number">1</span>) / <span class="number">2</span>; i &lt;= n - len; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i + d[i] - <span class="number">1</span> &gt;= n - len) d2 = <span class="built_in">std</span>::max(d2, (n - len - i + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (d1 &gt; d2)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len + d1; ++i)</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">'#'</span>) <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - len + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">'#'</span>) <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">'#'</span>) <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - len - d2 + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">'#'</span>) <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="e---bombs">E - Bombs</h2><p><a href="https://codeforces.com/contest/1326/problem/E" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题解-4">题解</h3><p>发现答案单调递减，可以考虑枚举答案 <span class="math inline">\(x\)</span>。</p><p>将 <span class="math inline">\(&gt; x\)</span>（即必须炸掉的数）的位置置为 <span class="math inline">\(1\)</span>，炸弹置为 <span class="math inline">\(-1\)</span>，其他位置置为 <span class="math inline">\(0\)</span>。</p><p>则合法的条件是所有后缀和 <span class="math inline">\(\le 0\)</span>。</p><p>用线段树维护即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><p>别问我为什么对，感觉挺对的就行了（雾</p><h3 id="代码-4">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300005</span>;</span><br><span class="line"><span class="keyword">int</span> n, p[N], q[N], pos[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mx[N &lt;&lt; <span class="number">2</span>], lz[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123; mx[u] += v, lz[u] += v; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        add(u &lt;&lt; <span class="number">1</span>, lz[u]), add(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, lz[u]), lz[u] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> add(u, v), <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> md = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        down(u);</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= md) modify(u &lt;&lt; <span class="number">1</span>, l, md, L, R, v);</span><br><span class="line">        <span class="keyword">if</span> (R &gt; md) modify(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, md + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">        mx[u] = <span class="built_in">std</span>::max(mx[u &lt;&lt; <span class="number">1</span>], mx[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(p[i]), pos[p[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(q[i]);</span><br><span class="line">    print(n, <span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">int</span> now = n;</span><br><span class="line">    T.modify(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, pos[n], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        T.modify(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, q[i], <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (T.mx[<span class="number">1</span>] &lt;= <span class="number">0</span>) --now, T.modify(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, pos[now], <span class="number">1</span>);</span><br><span class="line">        print(now, <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="f1---wise-men-easy-version">F1 - Wise Men (Easy Version)</h2><p><a href="https://codeforces.com/contest/1326/problem/F1" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题解-5">题解</h3><p>考场上看到 Easy Version <span class="math inline">\(n\le 14\)</span>，Hard Version <span class="math inline">\(n\le 18\)</span>，莫名就想到了 meet in middle...</p><p>可以预处理出 <span class="math inline">\(f_{S,T,i}\)</span> 表示当前排列中数的集合为 <span class="math inline">\(S\)</span>，导出的 01 字符串为 <span class="math inline">\(T\)</span>，且排列中最后一个数为 <span class="math inline">\(i\)</span> 的方案数。</p><p>然后考虑 meet in middle，合并两边的方案。</p><p>问题来了，我好像不会快速合并两边的方案 QAQ</p><p>但是问题不大，我们可以 <strong>暴力合并</strong>！</p><p>直接枚举左边的数集 <span class="math inline">\(S\)</span>，最后的 01 串 <span class="math inline">\(T\)</span>，以及中间相邻的两个数，显然方案数可以利用 <span class="math inline">\(f\)</span> 进行计算。</p><p>但是，你可能需要一些卡常技巧（设两边的大小分别为 <span class="math inline">\(B_1,B_2\)</span>）：</p><ol type="1"><li><span class="math inline">\(f\)</span> 数组只需要预处理所有 <span class="math inline">\(|S|=B_1\)</span> 或 <span class="math inline">\(|S|=B_2\)</span> 的位置，可以直接枚举所有排列进行统计，不需要进行 DP。</li><li>显然 01 串反转以后答案是不变的，所以我们只计算 <span class="math inline">\(T\le \operatorname{rev}(T)\)</span> 的位置即可。</li><li>可以预处理 <span class="math inline">\(2^n-1,2^{B_1-1}-1,2^{B_2-1}-1\)</span> 的值来减少运算次数。</li><li>由于枚举 <span class="math inline">\(T\)</span> 以后我们可以知道中间相邻两个数是否有边，我们可以预处理出与一个点有边/无边的点来快速枚举。</li><li>根据代码常数调整 <span class="math inline">\(B_1,B_2\)</span> 的大小。</li></ol><p>为了保险，你可以再加上 Ofast 和 O3 优化。</p><p>理论时间复杂度 <span class="math inline">\(O(C_{n}^{B_1}(B_1!+B_2!+2^n n^2))\)</span>，事实上有好几个 <span class="math inline">\(\frac{1}{2}\)</span> 的常数。</p><h3 id="代码-5">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, E[<span class="number">14</span>][<span class="number">14</span>], bitcnt[<span class="number">1</span> &lt;&lt; <span class="number">14</span>], rev[<span class="number">1</span> &lt;&lt; <span class="number">14</span>], p[<span class="number">14</span>], f[<span class="number">1</span> &lt;&lt; <span class="number">14</span>][<span class="number">1</span> &lt;&lt; <span class="number">6</span>][<span class="number">14</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">1</span> &lt;&lt; <span class="number">14</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">14</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(E[i][j] = getchar())) ;</span><br><span class="line">            E[i][j] ^= <span class="string">'0'</span>;</span><br><span class="line">            G[i][E[i][j]].push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line">    bitcnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) bitcnt[i] = bitcnt[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    rev[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); ++i) rev[i] = rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (i &amp; <span class="number">1</span>) &lt;&lt; (n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> B1 = n &gt;&gt; <span class="number">1</span>, B2 = n - B1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; n); ++S)</span><br><span class="line">        <span class="keyword">if</span> (bitcnt[S] == B1 || bitcnt[S] == B2)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                <span class="keyword">if</span> (S &gt;&gt; i &amp; <span class="number">1</span>) p[cnt++] = i;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> T = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt - <span class="number">1</span>; ++i)</span><br><span class="line">                    <span class="keyword">if</span> (E[p[i]][p[i + <span class="number">1</span>]]) T |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                ++f[S][T][p[cnt - <span class="number">1</span>]];</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">std</span>::next_permutation(p, p + cnt)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> U = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>, U1 = (<span class="number">1</span> &lt;&lt; (B1 - <span class="number">1</span>)) - <span class="number">1</span>, U2 = (<span class="number">1</span> &lt;&lt; (B2 - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; n); ++S)</span><br><span class="line">        <span class="keyword">if</span> (bitcnt[S] == B1)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> T = <span class="number">0</span>; T &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); ++T)</span><br><span class="line">                <span class="keyword">if</span> (T &lt;= rev[T])&#123;</span><br><span class="line">                    <span class="keyword">int</span> T1 = T &amp; U1, T2 = rev[T] &amp; U2, t = (T &gt;&gt; (B1 - <span class="number">1</span>)) &amp; <span class="number">1</span>, _S = U ^ S;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                        <span class="keyword">if</span> (f[S][T1][i])</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> j : G[i][t])</span><br><span class="line">                                ans[T] += f[S][T1][i] * f[_S][T2][j];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> T = <span class="number">0</span>; T &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); ++T)</span><br><span class="line">        <span class="keyword">if</span> (T &lt;= rev[T]) print(ans[T], <span class="string">' '</span>); <span class="keyword">else</span> print(ans[rev[T]], <span class="string">' '</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一分钟绝杀的感觉真的非常舒适（</p><h2 id="f2---wise-men-hard-version">F2 - Wise Men (Hard Version)</h2><p><a href="https://codeforces.com/contest/1326/problem/F2" target="_blank" rel="noopener">题目传送门</a></p><p>在路上了，绝对不鸽（</p><h2 id="g---spiderweb-trees">G - Spiderweb Trees</h2><p><a href="https://codeforces.com/contest/1326/problem/G" target="_blank" rel="noopener">题目传送门</a></p><p>tourist 都没过的题做个 **...</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> DP </tag>
            
            <tag> 贪心 </tag>
            
            <tag> manacher </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 递推 </tag>
            
            <tag> meet in middle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round #628 (Div. 2) 爆蛋记</title>
      <link href="/cf1325/"/>
      <url>/cf1325/</url>
      
        <content type="html"><![CDATA[<p>完全爆蛋，小号三场上橙无望 /kk</p><p><a href="https://codeforces.com/contest/1325/standings/participant/34006907#p34006907" target="_blank" rel="noopener">爆蛋链接</a></p><a id="more"></a><h2 id="a---ehab-and-gcd">A - EhAb AnD gCd</h2><p><a href="https://codeforces.com/contest/1325/problem/A" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题意">题意</h3><p>构造正整数 <span class="math inline">\(a,b\)</span> 满足 <span class="math inline">\(\gcd(a,b)+\operatorname{lcm}(a,b)=x\)</span>。</p><p><span class="math inline">\(x\le 10^9\)</span></p><h3 id="题解">题解</h3><p>构造 <span class="math inline">\(a=1,b=x-1\)</span> 即可。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(x);</span><br><span class="line">    print(<span class="number">1</span>, <span class="string">' '</span>), print(x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b---copycopycopycopycopy">B - CopyCopyCopyCopyCopy</h2><p><a href="https://codeforces.com/contest/1325/problem/B" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题意-1">题意</h3><p>求将一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span> 复制 <span class="math inline">\(n\)</span> 次后的 LIS 长度。</p><p><span class="math inline">\(n\le 10^5\)</span></p><h3 id="题解-1">题解</h3><p>显然最优方案是在复制的第一份中选最小值，第二份中选次小值……</p><p>所以 LIS 长度就是所有数去重后的数量。</p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">    <span class="built_in">std</span>::sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    print(<span class="built_in">std</span>::unique(a + <span class="number">1</span>, a + <span class="number">1</span> + n) - a - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c---ehab-and-path-etic-mexs">C - Ehab and Path-etic MEXs</h2><p><a href="https://codeforces.com/contest/1325/problem/C" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题意-2">题意</h3><p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，你需要给每条边定上互不相同的 <span class="math inline">\(0\sim n-2\)</span> 的整数权值，使得 <span class="math inline">\(\max\limits_{u,v} \operatorname{mex}(\operatorname{path}(u,v))\)</span> 最小。<span class="math inline">\(\operatorname{path}(u,v)\)</span> 表示 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 路径上所有边边权组成的集合。</p><p><span class="math inline">\(n\le 10^5\)</span></p><h3 id="题解-2">题解</h3><p>对于 <span class="math inline">\(n&gt;2\)</span> 时，我们始终可以找到一条包含 <span class="math inline">\(0,1\)</span> 的路径，所以有答案 <span class="math inline">\(\ge 2\)</span>。</p><p>我们只要找到一个度数 <span class="math inline">\(\ge 3\)</span> 的点，把 <span class="math inline">\(0,1,2\)</span> 放在这个点连出去的边中，就可以保证不存在某条路径同时包含 <span class="math inline">\(0,1,2\)</span>，即达到了答案的下界。</p><p>若没有度数 <span class="math inline">\(\ge 3\)</span> 的点，此时树的形态是一条链，答案显然为 <span class="math inline">\(n-1\)</span>，任意构造即可。</p><h3 id="代码-2">代码</h3><p>考场上想复杂了，尝试以某个叶子节点为根以后去考虑 <span class="math inline">\(0,1,2\)</span> 的放置，于是罚时罚没了（成功搞炸心态）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, ans[N];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; E[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>, u, v; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">        read(u), read(v), E[u].push_back(&#123;v, i&#125;), E[v].push_back(&#123;u, i&#125;), ans[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (E[i].size() == <span class="number">1</span>) ++cnt, id = i;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) print(i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[E[id][<span class="number">0</span>].second] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = E[id][<span class="number">0</span>].first, lst = id, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (E[u].size() == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[u][<span class="number">0</span>].first ^ E[u][<span class="number">1</span>].first ^ lst;</span><br><span class="line">        lst = u, u = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : E[u]) <span class="keyword">if</span> (p.first != lst) ans[p.second] = ++now;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == <span class="number">-1</span>) ans[i] = ++now;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) print(ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d---ehab-the-xorcist">D - Ehab the Xorcist</h2><p><a href="https://codeforces.com/contest/1325/problem/D" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题意-3">题意</h3><p>构造一个最短的序列使得异或和为 <span class="math inline">\(u\)</span>，和为 <span class="math inline">\(v\)</span>。</p><p><span class="math inline">\(u,v\le 10^{18}\)</span></p><h3 id="题解-3">题解</h3><p>考场上尝试从高位到低位逐位构造，但是他先 WA9 然后 WA18 了。</p><p>神仙 Froggy 告诉我本题考查了 if 语句。</p><p>我离当场去世真的只差一点.jpg</p><h3 id="代码-3">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> u, v;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(u), read(v);</span><br><span class="line">    <span class="keyword">if</span> (v &lt; u || (v - u) &amp; <span class="number">1</span>) <span class="keyword">return</span> print(<span class="number">-1</span>), <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">0</span>) <span class="keyword">return</span> print(<span class="number">0</span>), <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> print(<span class="number">2</span>), print(v &gt;&gt; <span class="number">1</span>, <span class="string">' '</span>), print(v &gt;&gt; <span class="number">1</span>), <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> print(<span class="number">1</span>), print(u), <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (u &amp; ((v - u) &gt;&gt; <span class="number">1</span>)) <span class="keyword">return</span> print(<span class="number">3</span>), print(u, <span class="string">' '</span>), print((v - u) &gt;&gt; <span class="number">1</span>), print((v - u) &gt;&gt; <span class="number">1</span>), <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> print(<span class="number">2</span>), print(u + ((v - u) &gt;&gt; <span class="number">1</span>), <span class="string">' '</span>), print((v - u) &gt;&gt; <span class="number">1</span>), <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="e---ehabs-real-number-theory-problem">E - Ehab's REAL Number Theory Problem</h2><p><a href="https://codeforces.com/contest/1325/problem/E" target="_blank" rel="noopener">题目传送门</a></p><h3 id="题意-4">题意</h3><p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，求出所有乘积为完全平方数的子序列（可以不连续）的最短长度。</p><p>保证 <span class="math inline">\(a_i\)</span> 的因数个数不超过 <span class="math inline">\(7\)</span>。</p><p><span class="math inline">\(n\le 10^5,a_i\le 10^6\)</span></p><h3 id="题解-4">题解</h3><p>由于包含三个不同质因子的数至少有 <span class="math inline">\((1+1)^3=8\)</span> 个因数，所以因数个数不超过 <span class="math inline">\(7\)</span> 说明不同质因子数量不超过 <span class="math inline">\(2\)</span>。</p><p>并且，我们可以去掉 <span class="math inline">\(a_i\)</span> 中包含的完全平方因子，这样处理后 <span class="math inline">\(a_i\)</span> 只会包含至多两个次数为 <span class="math inline">\(1\)</span> 的质因子。</p><p>于是我们可以把 <span class="math inline">\(a_i\)</span> 表示成 <span class="math inline">\(p\times q\)</span> 的形式，其中 <span class="math inline">\(p,q\)</span> 为质数或 <span class="math inline">\(1\)</span>。我们把这样的 <span class="math inline">\(a_i\)</span> 看成一条连接 <span class="math inline">\(p,q\)</span> 的无向边。</p><p>现在问题是在这样得到的图中选择最少数量的边（至少一条），使得只保留这些边后图中每个点的度数为偶数。</p><p>显然存在度数 <span class="math inline">\(&gt;2\)</span> 的点是不优的，所以我们可以强制最后每个点的度数为 <span class="math inline">\(2\)</span>（不考虑度数为 <span class="math inline">\(0\)</span> 的点）。</p><p>这意味着我们要求新图的最小环。</p><hr /><p>考场上<del>被人误导</del>想了一个假算法，就是把 <span class="math inline">\(&gt;1000\)</span> 的点扔掉，直接在他连的点之间互相连边以后跑 Floyd。</p><p>但是显然这样做是错的，会导致一个数被选多次。</p><hr /><p>考场上只想到了上面部分，于是当场去世了。</p><p>我们需要求出一个无向图的最小环。那么我们考虑枚举一个点 <span class="math inline">\(s\)</span> 以及一条边 <span class="math inline">\((u,v)\)</span>，得到以 <span class="math inline">\(s\)</span> 为起点的最短路树，求出包含点 <span class="math inline">\(s\)</span> 和<strong>非树边</strong> <span class="math inline">\((u,v)\)</span> 的最小环。</p><p>考虑最短路树上加入 <span class="math inline">\((u,v)\)</span>，我们得到了一个包含 <span class="math inline">\((u,v)\)</span> 但有可能不包含 <span class="math inline">\(s\)</span> 的环。</p><p>可以发现，我们直接用 <span class="math inline">\(\operatorname{dist}(s,u)+\operatorname{dist}(s,v)\)</span> 更新答案一定是对的，因为如果上面得到的环不包含 <span class="math inline">\(s\)</span>，一定会在枚举其他起点时被计算入答案，并且一定优于 <span class="math inline">\(\operatorname{dist}(s,u)+\operatorname{dist}(s,v)\)</span>，所以我们并不需要判断这个环是否包含 <span class="math inline">\(s\)</span>。</p><p>我们仍然需要考虑的是上述算法是否能覆盖到最优解。考虑最优解环上任意一个点 <span class="math inline">\(s\)</span>，环上一定存在一条边 <span class="math inline">\((u,v)\)</span> 不在以 <span class="math inline">\(s\)</span> 为起点形成的最短路树上。如果 <span class="math inline">\(u,v\)</span> 在这棵树上的 LCA 不是 <span class="math inline">\(s\)</span>，说明存在一个更小的环，与假设矛盾；否则此时 <span class="math inline">\(\operatorname{dist}(s,u)+\operatorname{dist}(s,v)\)</span> 一定就是最优解的环长。由于我们枚举了所有 <span class="math inline">\(s,u,v\)</span>，所以一定能覆盖到最优解。</p><hr /><p>然而上面的算法是 <span class="math inline">\(O(nm)\)</span> 的。</p><p>设 <span class="math inline">\(m=\max \{a_i\}\)</span>，可以发现我们需要求最小环的图与一般的图有一个很大的区别是，两个点 <span class="math inline">\(u,v\)</span> 若 <span class="math inline">\(uv&gt;m\)</span> 是不可能有边的，所以一定不会存在 <span class="math inline">\(u,v&gt;\sqrt{m}\)</span> 的连边。</p><p>那么显然一个环内至少存在一个点的编号是 <span class="math inline">\(\le \sqrt{m}\)</span> 的。根据上面算法能覆盖到最优解的证明过程，我们只要能够枚举到环上任意一个点作为 <span class="math inline">\(s\)</span> 就可以覆盖到这个环。所以，我们只要将上面求最小环的算法中 <span class="math inline">\(s\)</span> 的枚举范围缩小到 <span class="math inline">\(\sqrt{m}\)</span> 即可。</p><p>时间复杂度根据实现为 <span class="math inline">\(O(n\frac{\sqrt{m}}{\log m})\)</span> 或 <span class="math inline">\(O((n+\frac{m}{\log m})\frac{\sqrt{m}}{\log m})\)</span>。</p><p>除以 <span class="math inline">\(\log m\)</span> 是因为只需要考虑质数。</p><h3 id="代码-4">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000005</span>, M = <span class="number">100005</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> cnt, p[N], vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 欧拉筛预处理所有质数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) p[++cnt] = i, vis[i] = cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] * i &lt;= n; ++j)&#123;</span><br><span class="line">            vis[p[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[M];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; E[N];</span><br><span class="line"><span class="keyword">int</span> ans, ont[M], tim[N], dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123; <span class="comment">// bfs 求出最短路树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ont[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push_back(S), tim[S] = S, dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将 tim 置为每次 bfs 的起点，可以避免每次需要重置 dis 数组导致复杂度变劣</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)Q.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : E[u])&#123;</span><br><span class="line">            <span class="keyword">int</span> v = p.first, eid = p.second;</span><br><span class="line">            <span class="keyword">if</span> (tim[v] != S) Q.push_back(v), tim[v] = S, dis[v] = dis[u] + <span class="number">1</span>, ont[eid] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">// 枚举每条非树边，更新答案</span></span><br><span class="line">        <span class="keyword">if</span> (!ont[i] &amp;&amp; tim[v[i][<span class="number">0</span>]] == S &amp;&amp; tim[v[i][<span class="number">1</span>]] == S)</span><br><span class="line">            ans = <span class="built_in">std</span>::min(ans, dis[v[i][<span class="number">0</span>]] + dis[v[i][<span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    init(<span class="number">1000000</span>), p[<span class="number">0</span>] = <span class="number">1</span>, vis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i)&#123;</span><br><span class="line">        read(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="number">1l</span>l * p[j] * p[j] &lt;= x; ++j)</span><br><span class="line">            <span class="keyword">if</span> (x % p[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (x % p[j] == <span class="number">0</span>) x /= p[j], k ^= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (k) v[i].push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>) v[i].push_back(vis[x]);</span><br><span class="line">        <span class="keyword">while</span> (v[i].size() &lt; <span class="number">2</span>) v[i].push_back(<span class="number">0</span>);</span><br><span class="line">        E[v[i][<span class="number">1</span>]].push_back(&#123;v[i][<span class="number">0</span>], i&#125;), E[v[i][<span class="number">0</span>]].push_back(&#123;v[i][<span class="number">1</span>], i&#125;);</span><br><span class="line">        <span class="comment">// 连边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; ++i) tim[i] = <span class="number">-1</span>;</span><br><span class="line">    ans = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="keyword">if</span> (p[i] &lt;= <span class="number">1000</span>) bfs(i); <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 只需要考虑编号 &lt;=1000 且为质数的点</span></span><br><span class="line">    <span class="keyword">if</span> (ans == INF) print(<span class="number">-1</span>); <span class="keyword">else</span> print(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="f---ehabs-last-theorem">F - Ehab's Last Theorem</h2><p><a href="https://codeforces.com/contest/1325/problem/F" target="_blank" rel="noopener">题目传送门</a></p><p>咕咕咕...</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> BFS </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式相关</title>
      <link href="/polynomial-notes/"/>
      <url>/polynomial-notes/</url>
      
        <content type="html"><![CDATA[<p>太久没更新博客，开一篇多项式相关的博客记一下多项式的一些基础操作吧。</p><a id="more"></a><h2 id="模域下的运算">模域下的运算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">unsigned</span> &amp;a, <span class="keyword">const</span> <span class="keyword">unsigned</span> &amp;b)</span></span>&#123; (a += b) &gt;= P ? a -= P : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">unsigned</span> &amp;a, <span class="keyword">const</span> <span class="keyword">unsigned</span> &amp;b)</span></span>&#123; a &lt; b ? a += P - b : a -= b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">plus</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> &amp;a, <span class="keyword">const</span> <span class="keyword">unsigned</span> &amp;b)</span></span>&#123; <span class="keyword">return</span> a + b &gt;= P ? a + b - P : a + b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">minus</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> &amp;a, <span class="keyword">const</span> <span class="keyword">unsigned</span> &amp;b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? a + P - b : a - b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">mul</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> &amp;a, <span class="keyword">const</span> <span class="keyword">unsigned</span> &amp;b)</span></span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(a) * b % P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">qpow</span><span class="params">(<span class="keyword">unsigned</span> a, <span class="keyword">unsigned</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a)) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = mul(s, a);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速傅里叶变换与快速傅里叶逆变换">快速傅里叶变换与快速傅里叶逆变换</h2><h3 id="快速傅里叶变换">快速傅里叶变换</h3><p>在这一节中，除特殊说明外，<span class="math inline">\(n\)</span> 是 <span class="math inline">\(2\)</span> 的幂次。</p><p>利用 FFT，我们可以在 <span class="math inline">\(O(n\log n)\)</span> 的时间内求出 <span class="math inline">\(F(\omega_n^0),F(\omega_n^1),\cdots,F(\omega_n^{n-1})\)</span> 的值，以及由这些值得到 <span class="math inline">\(F(x)\)</span> 的系数，其中 <span class="math inline">\(\omega_n^{i}\)</span> 表示单位根，这里不具体展开。</p><p>单位根具有一些优美的性质，如 <span class="math inline">\(\omega_{dn}^{dk}=\omega_n^k\)</span>，<span class="math inline">\(\omega_{n}^{\frac{n}{2}}=\omega_2^1=-1\)</span>，<span class="math inline">\(\omega_{n}^{k+\frac{n}{2}}=-\omega_{n}^{k}\)</span>，<span class="math inline">\(\omega_n^a=\omega_n^{a \bmod n}\)</span>。FFT 正是利用了这些性质加快速度。</p><p>假设原多项式为<span class="math inline">\(F(x)=\sum\limits_{i=0}^{n-1} f_ix^i\)</span>，我们把 <span class="math inline">\(F(x)\)</span> 按指数奇偶性拆成两部分，即 <span class="math inline">\(F_0(x)=\sum\limits_{i=0}^{\frac{n}{2}-1} f_{2i}x^i,F_1(x)=\sum\limits_{i=0}^{\frac{n}{2}-1} f_{2i+1}x^i\)</span>，那么有 <span class="math inline">\(F(x)=F_0(x^2)+xF_1(x^2)\)</span>。</p><p>我们把 <span class="math inline">\(x=\omega_n^k\ (0\le k &lt; \frac{n}{2})\)</span> 代入 <span class="math inline">\(F(x)\)</span>，得到 <span class="math inline">\(F(\omega_n^k)=F_0(\omega_{\frac{n}{2}}^k)+\omega_n^kF_1(\omega_{\frac{n}{2}}^k)\)</span>。</p><p>同理，把 <span class="math inline">\(x=\omega_n^{k+\frac{n}{2}}\ (0\le k &lt; \frac{n}{2})\)</span> 代入 <span class="math inline">\(F(x)\)</span>，得到 <span class="math inline">\(F(\omega_n^k)=F_0(\omega_{\frac{n}{2}}^k)-\omega_n^kF_1(\omega_{\frac{n}{2}}^k)\)</span>。</p><p>发现问题转化成了两个子问题，直接分治求解即可。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><p>直接做常数太大，我们发现分治到底层时下标是原下标的二进制翻转，于是直接翻转完后从下往上合并即可。</p><p>可以用 <code>unsigned long long</code> 减少取模次数优化常数。</p><h3 id="快速傅里叶逆变换">快速傅里叶逆变换</h3><p>记多项式 <span class="math inline">\(G(x)=\sum\limits_{i=0}^{n-1}F(\omega_n^i)x^i\)</span>，考虑对 <span class="math inline">\(G(x)\)</span> 做 FFT，得到</p><p><span class="math display">\[\begin{aligned}G(\omega_n^k)&amp;=\sum\limits_{i=0}^{n-1}F(\omega_n^i)(\omega_n^k)^i\\&amp;=\sum\limits_{i=0}^{n-1}\left(\sum\limits_{j=0}^{n-1} f_j(\omega_n^i)^j\right)(\omega_n^k)^i\\&amp;=\sum\limits_{j=0}^{n-1}f_j\sum\limits_{i=0}^{n-1}(\omega_n^{j+k})^i\end{aligned}\]</span></p><p>发现只有当 <span class="math inline">\(j+k\equiv 0\pmod n\)</span> 时 <span class="math inline">\(\sum\limits_{i=0}^{n-1}(\omega_n^{j+k})^i=n\)</span>，其他情况都为 <span class="math inline">\(0\)</span>。于是</p><p><span class="math display">\[\begin{aligned}G(\omega_n^k)&amp;=\sum\limits_{j=0}^{n-1}f_j\sum\limits_{i=0}^{n-1}(\omega_n^{j+k})^i\\&amp;=f_{(n-k)\bmod n}\cdot n\end{aligned}\]</span></p><p>直接翻转后乘上 <span class="math inline">\(n\)</span> 的逆元即可，时间复杂度同样为 <span class="math inline">\(O(n\log n)\)</span>。</p><h3 id="实现">实现</h3><p><span class="math inline">\(\omega_{2^k}^{i}\)</span> 只有 <span class="math inline">\(O(n)\)</span> 个，可以在程序的一开始预处理（同时还预处理了逆元）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LEN 262144 <span class="comment">// 根据需要修改</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; poly;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> P = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">unsigned</span> omega[MAX_LEN], inv[MAX_LEN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123; <span class="comment">// 在程序的一开始需要调用一次 Init()</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> m = <span class="number">1</span>; m &lt; MAX_LEN; m &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> _o = qpow(G, (P - <span class="number">1</span>) / (m &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        omega[m] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) omega[m + i] = mul(omega[m + i - <span class="number">1</span>], _o);</span><br><span class="line">    &#125;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_LEN; ++i) inv[i] = mul(P - P / i, inv[P % i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次需要预处理 <span class="math inline">\(rev[i]\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">poly rev;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (res &lt; n) res &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) &lt; n) ++k;</span><br><span class="line">    rev.resize(n), rev[<span class="number">0</span>] = <span class="number">0</span>, --k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(poly &amp;f, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    f.resize(n);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ft[MAX_LEN]; <span class="comment">// 用 unsigned long long 优化常数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ft[rev[i]] = f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &amp; <span class="number">262144</span>)&#123; <span class="comment">// P * P 约为 10^18，乘约 18 次会爆 unsigned long long</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ft[i] %= P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> l = m &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> p = <span class="number">0</span>; p &lt; n; p += l)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">unsigned</span> *W = omega + m;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *F0 = ft + p, *F1 = ft + p + m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i, ++W, ++F0, ++F1)&#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="keyword">unsigned</span> t = (*F1) * (*W) % P;</span><br><span class="line">                *F1 = (*F0) + P - t, *F0 += t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = ft[i] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IDFT</span><span class="params">(poly &amp;f, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    DFT(f, n), <span class="built_in">std</span>::reverse(f.begin() + <span class="number">1</span>, f.end());</span><br><span class="line">    <span class="keyword">unsigned</span> t = qpow(n, P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = mul(f[i], t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多项式加法与减法">多项式加法与减法</h2><p>对于每个 <span class="math inline">\(x_i\)</span> 的系数直接相加/相减即可。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Plus</span><span class="params">(poly a, poly b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">std</span>::max(a.size(), b.size());</span><br><span class="line">    a.resize(n), b.resize(n);</span><br><span class="line">    poly res = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) inc(res[i], b[i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">Minus</span><span class="params">(poly a, poly b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">std</span>::max(a.size(), b.size());</span><br><span class="line">    a.resize(n), b.resize(n);</span><br><span class="line">    poly res = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) dec(res[i], b[i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多项式乘法">多项式乘法</h2><p>DFT 后把点值乘起来，在 IDFT 回去即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Multiply</span><span class="params">(poly a, poly b, <span class="keyword">int</span> _n = <span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a.size() || !b.size() || !_n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (_n == <span class="number">-1</span>) _n = a.size() + b.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.size() &lt;= <span class="number">30</span> || b.size() &lt;= <span class="number">30</span>)&#123; <span class="comment">// 范围较小时暴力跑更快</span></span><br><span class="line">        <span class="function">poly <span class="title">res</span><span class="params">(a.size() + b.size() - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)a.size(); ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)b.size(); ++j)</span><br><span class="line">                res[i + j] = (res[i + j] + <span class="number">1u</span>ll * a[i] * b[j]) % P;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = _n; i &lt; (<span class="keyword">int</span>)res.size(); ++i) inc(res[i % _n], res[i]);</span><br><span class="line">        <span class="keyword">return</span> res.resize(_n), res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = get(_n);</span><br><span class="line">    init(n), DFT(a, n), DFT(b, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = mul(a[i], b[i]);</span><br><span class="line">    IDFT(a, n), a.resize(_n);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以把计算 <span class="math inline">\(F^2(x)\)</span> 单独写一个函数，常数可以更小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Pow2</span><span class="params">(poly a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _n = a.size() * <span class="number">2</span> - <span class="number">1</span>, n = get(_n);</span><br><span class="line">    init(n), DFT(a, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = mul(a[i], a[i]);</span><br><span class="line">    IDFT(a, n), a.resize(_n);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多项式求逆">多项式求逆</h2><blockquote><p>已知多项式 <span class="math inline">\(F(x)\)</span>，求一个多项式 <span class="math inline">\(G(x)\)</span> 满足 <span class="math inline">\(F(x)G(x)\equiv 1\pmod{x^n}\)</span>。</p></blockquote><p>假设我们已经求出 <span class="math inline">\(G_0(x)\)</span> 满足 <span class="math inline">\(F(x)G_0(x)\equiv 1\pmod {x^{\frac{n}{2}}}\)</span>，那么有 <span class="math inline">\(F(x)(G(x)-G_0(x))\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>。</p><p>由于 <span class="math inline">\(G(x)-G_0(x)\)</span> 是 <span class="math inline">\(n-1\)</span> 次多项式，两边同时乘 <span class="math inline">\(G(x)-G_0(x)\)</span>，有 <span class="math inline">\(F(x)(G(x)-G_0(x))^2\equiv 0\pmod{x^n}\)</span>。</p><p>展开后整理得到 <span class="math inline">\(G(x)\equiv 2G_0(x)-F(x)G_0^2(x)\pmod {x^n}\)</span>。于是迭代求出即可。</p><p>边界条件为求 <span class="math inline">\(F(x)G(x)\equiv 1\pmod{x}\)</span>，直接求 <span class="math inline">\(f_0\)</span> 的逆元即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Inverse</span><span class="params">(poly f, <span class="keyword">int</span> _n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = get(_n);</span><br><span class="line">    f.resize(n);</span><br><span class="line">    <span class="function">poly <span class="title">g</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    g[<span class="number">0</span>] = qpow(f[<span class="number">0</span>], P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> m = <span class="number">2</span>; m &lt;= n; m &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">poly <span class="title">tmp</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) tmp[i] = f[i];</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> l = m &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        init(l), DFT(tmp, l), DFT(g, l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) g[i] = mul(g[i], minus(<span class="number">2</span>, mul(tmp[i], g[i])));</span><br><span class="line">        IDFT(g, l), g.resize(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g.resize(_n), g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多项式除法">多项式除法</h2><blockquote><p>已知 <span class="math inline">\(n-1\)</span> 次多项式 <span class="math inline">\(A(x)\)</span> 和 <span class="math inline">\(m-1\)</span> 次多项式 <span class="math inline">\(B(x)\)</span>，求 <span class="math inline">\(n-m\)</span> 次多项式 <span class="math inline">\(Q(x)\)</span> 和小于 <span class="math inline">\(m-1\)</span> 次的多项式 <span class="math inline">\(R(x)\)</span> 满足 <span class="math inline">\(A(x)=B(x)Q(x)+R(x)\)</span>。</p></blockquote><p>下面我们强制 <span class="math inline">\(R(x)\)</span> 为 <span class="math inline">\(m-2\)</span> 次，不足则高位补 <span class="math inline">\(0\)</span>。</p><p>用记号 <span class="math inline">\(F_r(x)\)</span> 表示 <span class="math inline">\(F(x)\)</span> 的系数翻转后的结果。有 <span class="math inline">\(F_r(x)=x^{\text{deg }F(x)}F(\frac{1}{x})\)</span>，<span class="math inline">\(\text{deg }F(x)\)</span> 表示 <span class="math inline">\(F(x)\)</span> 的次数。</p><p>把 <span class="math inline">\(A(x)=B(x)Q(x)+R(x)\)</span> 中的 <span class="math inline">\(x\)</span> 用 <span class="math inline">\(\frac{1}{x}\)</span> 代替，得到 <span class="math inline">\(A(\frac{1}{x})=B(\frac{1}{x})Q(\frac{1}{x})+R(\frac{1}{x})\)</span>，两边同乘 <span class="math inline">\(x^{n-1}\)</span> 得到 <span class="math inline">\(x^{n-1}A(\frac{1}{x})=x^{m-1}B(\frac{1}{x})x^{n-m}Q(\frac{1}{x})+x^{n-m+1}\cdot x^{m-2}R(x)\)</span>。</p><p>即 <span class="math inline">\(A_r(x)=B_r(x)Q_r(x)+x^{n-m+1}R(x)\)</span>，那么有 <span class="math inline">\(A_r(x)\equiv B_r(x)Q_r(x)\pmod{x^{n-m+1}}\)</span>。由于 <span class="math inline">\(Q(x)\)</span> 是一个 <span class="math inline">\(n-m\)</span> 次多项式，所以 <span class="math inline">\(\bmod x^{n-m+1}\)</span> 不会对 <span class="math inline">\(Q(x)\)</span> 产生影响。</p><p>此时由于去掉了 <span class="math inline">\(R(x)\)</span>，直接做多项式求逆即可求出 <span class="math inline">\(Q(x)\)</span>。然后根据 <span class="math inline">\(R(x)=A(x)-B(x)Q(x)\)</span> 求出 <span class="math inline">\(R(x)\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::pair&lt;poly, poly&gt; Divide(<span class="keyword">const</span> poly &amp;a, <span class="keyword">const</span> poly &amp;b)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size(), m = b.size();</span><br><span class="line">    poly Q, R;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> R = a, R.resize(m - <span class="number">1</span>), <span class="built_in">std</span>::make_pair(Q, R);</span><br><span class="line">    poly A(a), B(b);</span><br><span class="line">    <span class="built_in">std</span>::reverse(A.begin(), A.end()), A.resize(n - m + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::reverse(B.begin(), B.end()), B.resize(n - m + <span class="number">1</span>);</span><br><span class="line">    Q = Multiply(A, Inverse(B, n - m + <span class="number">1</span>));</span><br><span class="line">    Q.resize(n - m + <span class="number">1</span>), <span class="built_in">std</span>::reverse(Q.begin(), Q.end());</span><br><span class="line">    R = Minus(a, Multiply(b, Q)), R.resize(m - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(Q, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多项式求导与积分">多项式求导与积分</h2><p>求导有运算法则 <span class="math inline">\((u(x)+v(x))&#39;=u&#39;(x)+v&#39;(x)\)</span>，<span class="math inline">\((u(x)\cdot v(x))&#39;=u&#39;(x)\cdot v(x)+u(x)\cdot v&#39;(x)\)</span>，并且可以扩展到 <span class="math inline">\(n\)</span> 个函数。同时有 <span class="math inline">\(C&#39;=0,(x^n)&#39;=nx^{n-1}\)</span>。</p><p>那么 <span class="math inline">\(F&#39;(x)=\left(\sum\limits_{i=0}^{n-1} f_ix^i\right)&#39;=\sum\limits_{i=0}^{n-1}(f_ix^i)&#39;=\sum\limits_{i=1}^{n-1} f_i\cdot ix^{i-1}\)</span>。</p><p>积分只要反着做一遍就好了。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Derivative</span><span class="params">(poly f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = f.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) f[i - <span class="number">1</span>] = mul(f[i], i);</span><br><span class="line">    <span class="keyword">return</span> f.resize(n - <span class="number">1</span>), f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">Integral</span><span class="params">(poly f)</span></span>&#123;</span><br><span class="line">    f.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n = f.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - <span class="number">1</span>; i; --i) f[i] = mul(f[i - <span class="number">1</span>], inv[i]);</span><br><span class="line">    <span class="comment">// 逆元已经在 Init() 中预处理</span></span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>] = <span class="number">0</span>, f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泰勒展开">泰勒展开</h2><p>泰勒展开是将一个在 <span class="math inline">\(x=x_0\)</span> 处具有 <span class="math inline">\(n\)</span> 阶导数的函数 <span class="math inline">\(f(x)\)</span> 利用关于 <span class="math inline">\(x-x_0\)</span> 的 <span class="math inline">\(n\)</span> 次多项式来逼近函数的方法。</p><p>当 <span class="math inline">\(n\)</span> 趋向于无穷时，我们可以直接用下面这个式子表示泰勒公式：</p><p><span class="math display">\[f(x)=\sum\limits_{i=0}^{\infty} \frac{f^{(i)}(x_0)}{i!}(x-x_0)^i\]</span></p><p>而麦克劳林级数就是上式 <span class="math inline">\(x_0=0\)</span> 的特殊形式。</p><p>要对泰勒展开有更好地理解可以看<a href="https://www.zhihu.com/question/25627482/answer/313088784" target="_blank" rel="noopener">怎样更好地理解并记忆泰勒展开式？- 知乎</a>。</p><h2 id="牛顿迭代">牛顿迭代</h2><p>牛顿迭代法是一种用于解非线性方程 <span class="math inline">\(G(x)=0\)</span> 的近似方法。</p><p>而在我们研究多项式相关时，我们一般用牛顿迭代法解关于无穷幂级数 <span class="math inline">\(F(x)\)</span> 的非线性方程 <span class="math inline">\(G(F(x))=0\)</span>，求 <span class="math inline">\(F(x)\)</span> 在模 <span class="math inline">\(x^n\)</span> 意义下得到的多项式，<strong>其中 <span class="math inline">\(G(F(x))\)</span> 是一个自变量为多项式，应变量也为多项式的函数。</strong></p><p>我们假设已经求出答案模 <span class="math inline">\(x^{\lceil\frac{n}{2}\rceil}\)</span> 意义下的多项式 <span class="math inline">\(F_0(x)\)</span>，我们要求出答案模 <span class="math inline">\(x^n\)</span> 意义下的多项式 <span class="math inline">\(F_1(x)\)</span>。即我们已经有 <span class="math display">\[G(F_0(x))\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\]</span></p><p>我们把 <span class="math inline">\(G(F(x))\)</span> 在 <span class="math inline">\(F(x)=F_0(x)\)</span> 处泰勒展开，得到 <span class="math display">\[\begin{aligned}G(F(x))&amp;=G(F_0(x))\\ &amp;+G&#39;(F_0(x))(F(x)-F_0(x))\\ &amp;+\frac{G&#39;&#39;(F_0(x))}{2}(F(x)-F_0(x))^2\\&amp;+\cdots\end{aligned}\]</span></p><p>因为有 <span class="math inline">\(F_1(x)-F_0(x)\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>，所以有 <span class="math inline">\((F_1(x)-F_0(x))^2\equiv 0\pmod{x^n}\)</span>。</p><p>由于 <span class="math inline">\(F_1(x)\)</span> 是答案在模 <span class="math inline">\(x^n\)</span> 意义下的多项式，所以上述泰勒展开式中除前两项外的部分代入 <span class="math inline">\(F_1(x)\)</span> 后模 <span class="math inline">\(x^n\)</span> 为 <span class="math inline">\(0\)</span>。所以我们只需要考虑前两项。即 <span class="math inline">\(F_1(x)\)</span> 只需要满足 <span class="math display">\[G(F_0(x))+G&#39;(F_0(x))(F_1(x)-F_0(x))\equiv 0\pmod{x^n}\]</span></p><p>整理，得 <span class="math display">\[F_1(x)\equiv F_0(x)-\frac{G(F_0(x))}{G&#39;(F_0(x))}\pmod{x^n}\]</span></p><p>于是我们可以在 <span class="math inline">\(O(n\log n)\)</span> 的时间求出答案在模 <span class="math inline">\(x^n\)</span> 意义下的多项式。</p><h2 id="多项式对数函数">多项式对数函数</h2><blockquote><p>已知多项式 <span class="math inline">\(F(x)\)</span>（常数项为 <span class="math inline">\(1\)</span>），求多项式 <span class="math inline">\(G(x)\)</span> 满足 <span class="math inline">\(G(x)\equiv \ln F(x)\pmod{x^n}\)</span>。</p></blockquote><p>注意多项式的对数函数可以认为是多项式和麦克劳林级数的复合。这意味着多项式对数函数是一个无穷级数。我们只能求他在模 <span class="math inline">\(x^n\)</span> 意义下得到的多项式。</p><p>类似地，多项式求逆、多项式指数函数、多项式开根等我们都只能求出在模意义下的多项式。</p><p>注意 <span class="math inline">\(F(x)\)</span> 常数项不为 <span class="math inline">\(1\)</span> 时 <span class="math inline">\(\ln F(x)\)</span> 无意义。</p><p>两边同时求导，得到 <span class="math inline">\(G&#39;(x)\equiv (\ln F(x))&#39;\pmod {x^{n-1}}\)</span>。</p><p>由复合函数求导公式，得到 <span class="math inline">\(G&#39;(x)\equiv \frac{F&#39;(x)}{F(x)}\pmod {x^{n-1}}\)</span>。</p><p>然后两边同时求积分，得到 <span class="math display">\[\ln F(x)\equiv \int \frac{F&#39;(x)}{F(x)}\pmod {x^n}\]</span></p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>，瓶颈在于多项式乘法和多项式求逆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Ln</span><span class="params">(<span class="keyword">const</span> poly &amp;a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    poly res = Integral(Multiply(Derivative(a), Inverse(a, n)));</span><br><span class="line">    <span class="keyword">return</span> res.resize(n), res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多项式指数函数">多项式指数函数</h2><blockquote><p>已知多项式 <span class="math inline">\(F(x)\)</span>（常数项为 <span class="math inline">\(0\)</span>），求多项式 <span class="math inline">\(G(x)\)</span> 满足 <span class="math inline">\(G(x)\equiv \exp {F(x)}\pmod{x^n}\)</span>。</p></blockquote><p>多项式 <span class="math inline">\(\exp\)</span> 有两种做法，分别是 <span class="math inline">\(O(n\log n)\)</span> 的牛顿迭代法与 <span class="math inline">\(O(n\log^2 n)\)</span> 的分治法。但是，从实际运行效率上看，<span class="math inline">\(n\le 10^5\)</span> 时两种方法的运行速度不相上下，甚至有时分治方法更快。并且，分治方法依赖的函数更少，代码更短。</p><h3 id="牛顿迭代法">牛顿迭代法</h3><p>注意 <span class="math inline">\(F(x)\)</span> 常数项不为 <span class="math inline">\(0\)</span> 时 <span class="math inline">\(\exp F(x)\)</span> 无意义。</p><p>两边同时求 <span class="math inline">\(\ln\)</span>，得到 <span class="math inline">\(\ln G(x)\equiv F(x)\pmod{x^n}\)</span>，即 <span class="math inline">\((\ln G(x))-F(x)\equiv 0\pmod{x^n}\)</span>。</p><p>定义函数 <span class="math inline">\(H(G(x))=(\ln G(x))-F(x)\)</span>，那么我们要求 <span class="math inline">\(G(x)\)</span> 满足 <span class="math inline">\(H(G(x))\equiv 0\pmod{x^n}\)</span>。</p><p>套用牛顿迭代的式子，即假设我们求出了在模 <span class="math inline">\(x^{\lceil\frac{n}{2}\rceil}\)</span> 意义下的答案 <span class="math inline">\(G_0(x)\)</span>，那么有 <span class="math display">\[G(x)\equiv G_0(x)-\frac{H(G_0(x))}{H&#39;(G_0(x))}\pmod{x^n}\]</span></p><p>又因为有（要注意函数 <span class="math inline">\(H(G(x))\)</span> 的自变量是 <span class="math inline">\(G(x)\)</span> 而非 <span class="math inline">\(x\)</span>） <span class="math display">\[\begin{aligned}H&#39;(G(x))&amp;=\ln&#39; G(x)\\ &amp;=\frac{1}{G(x)}\end{aligned}\]</span></p><p>所以，经整理得 <span class="math display">\[G(x)\equiv G_0(x)(1-(\ln G_0(x))+F(x))\pmod{x^n}\]</span></p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。常数较大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Exp_Newton</span><span class="params">(poly f, <span class="keyword">int</span> _n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = get(_n);</span><br><span class="line">    f.resize(n);</span><br><span class="line">    <span class="function">poly <span class="title">g</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> m = <span class="number">2</span>; m &lt;= n; m &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        poly tmp = Ln(g, m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) tmp[i] = minus(f[i], tmp[i]);</span><br><span class="line">        inc(tmp[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> l = m &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        init(l), DFT(tmp, l), DFT(g, l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) g[i] = mul(g[i], tmp[i]);</span><br><span class="line">        IDFT(g, l), g.resize(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g.resize(_n), g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分治法">分治法</h3><p>我们在 <span class="math inline">\(G(x)\equiv \exp F(x)\pmod{x^n}\)</span> 两边同时求导，得到 <span class="math display">\[G&#39;(x)\equiv (\exp F(x))F&#39;(x)\pmod{x^n}\]</span></p><p>即 <span class="math display">\[G&#39;(x)\equiv G(x)F&#39;(x)\pmod{x^n}\]</span></p><p>两边同时求积分，得 <span class="math display">\[G(x)\equiv \int G(x)F&#39;(x)\]</span></p><p>直接分治 NTT 求解即可。时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><h4 id="关于卡常">关于卡常</h4><p>在处理区间 <span class="math inline">\([l,r)\)</span> 时我们需要将 <span class="math inline">\(f[0,r-l)\)</span> 与 <span class="math inline">\(g[l,\lfloor\frac{l+r+1}{2}\rfloor)\)</span> 作卷积，求积分以后再加到 <span class="math inline">\(g[\lfloor\frac{l+r+1}{2}\rfloor,r)\)</span> 上（其中 <span class="math inline">\(f,g\)</span> 分别是 <span class="math inline">\(F&#39;(x),G(x)\)</span> 的系数数组）。</p><p>发现我们真正需要的部分是卷积后中间一部分，前后两部分是没有用的。而通过计算发现后面部分的长度一定不超过前面部分的长度，FFT 是循环卷积，我们只要把长度限定到 <span class="math inline">\(r-l-1\)</span> 就可以把后面部分加到前面而不影响中间需要的部分。这样做对优化常数很有帮助。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exp_solve</span><span class="params">(<span class="keyword">const</span> poly &amp;a, poly &amp;b, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) <span class="keyword">return</span> l ? b[l] = <span class="number">1l</span>l * b[l] * inv[l] % P : b[l] = <span class="number">1</span>, <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> md = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    Exp_solve(a, b, l, md);</span><br><span class="line">    poly res = Multiply(poly(b.begin() + l, b.begin() + md), poly(a.begin(), a.begin() + r - l - <span class="number">1</span>), r - l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = md; i &lt; r; ++i) inc(b[i], res[i - l - <span class="number">1</span>]);</span><br><span class="line">    Exp_solve(a, b, md, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">Exp</span><span class="params">(poly a, <span class="keyword">int</span> _n)</span></span>&#123;</span><br><span class="line">    a = Derivative(a), a.resize(_n);</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(_n)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> Exp_solve(a, res, <span class="number">0</span>, _n), res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多项式求任意次幂">多项式求任意次幂</h2><blockquote><p>给定多项式 <span class="math inline">\(F(x)\)</span> 和正整数 <span class="math inline">\(k\)</span>，求 <span class="math inline">\(G(x)\equiv F^k(x)\pmod{x^n}\)</span>。</p></blockquote><p>如果 <span class="math inline">\(F(x)\)</span> 常数项为 <span class="math inline">\(1\)</span>，那么有 <span class="math inline">\(G(x)=e^{k\ln F(x)}\)</span>。</p><p>而 <span class="math inline">\(F(x)\)</span> 常数项不为 <span class="math inline">\(1\)</span> 时，我们可以把 <span class="math inline">\(F(x)\)</span> 除以 <span class="math inline">\(ax^p\)</span> 使得常数项为 <span class="math inline">\(1\)</span>，最后再乘上 <span class="math inline">\(a^kx^{kp}\)</span>。</p><p>理论上来说这个方法可以求任意实数幂次，但是系数在模意义下运算，<span class="math inline">\(k\)</span> 为分数、无理数时很难求或者在模域下不存在答案。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Pow</span><span class="params">(poly a, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    a.resize(n);</span><br><span class="line">    <span class="keyword">int</span> t = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i])&#123; t = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == n) <span class="keyword">return</span> !k ? a[<span class="number">0</span>] = <span class="number">1</span> : <span class="number">0</span>, a;</span><br><span class="line">    <span class="keyword">unsigned</span> vi = qpow(a[t], P - <span class="number">2</span>), vk = qpow(a[t], k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - t; ++i) a[i] = mul(a[i + t], vi);</span><br><span class="line">    a.resize(n - t);</span><br><span class="line">    t = <span class="built_in">std</span>::min(<span class="number">1l</span>l * t * k, <span class="number">1l</span>l * n);</span><br><span class="line">    <span class="keyword">if</span> (t == n)&#123;</span><br><span class="line">        a.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    a = Ln(a, n - t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - t; ++i) a[i] = mul(a[i], k);</span><br><span class="line">    a = Exp(a, n - t), a.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - t - <span class="number">1</span>; ~i; --i) a[i + t] = mul(a[i], vk);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多项式开根">多项式开根</h2><blockquote><p>已知多项式 <span class="math inline">\(F(x)\)</span>，求多项式 <span class="math inline">\(G(x)\)</span> 满足 <span class="math inline">\(G^2(x)\equiv F(x)\pmod{x^n}\)</span>。</p></blockquote><p>定义函数 <span class="math inline">\(H(G(x))=G^2(x)-F(x)\)</span>，那么我们要求 <span class="math inline">\(G(x)\)</span> 使得 <span class="math inline">\(H(G(x))\equiv 0\pmod{x^n}\)</span>。</p><p>仍然假设我们已经求出了 <span class="math inline">\(G_0(x)\)</span> 满足 <span class="math inline">\(H(G_0(x))\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>。根据牛顿迭代的式子，得到 <span class="math display">\[\begin{aligned}G(x)&amp;\equiv G_0(x)-\frac{H(G_0(x))}{H&#39;(G_0(x))}\\&amp;=G_0(x)-\frac{G_0^2(x)-F(x)}{2G_0(x)}\\&amp;=\frac{G_0^2(x)+F(x)}{2G_0(x)}\pmod{x^n}\end{aligned}\]</span></p><p>在模意义下运算时，边界我们只要用 Cipolla 算法求二次剩余即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Sqrt</span><span class="params">(poly f, <span class="keyword">int</span> _n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = get(_n);</span><br><span class="line">    f.resize(n);</span><br><span class="line">    <span class="function">poly <span class="title">g</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    g[<span class="number">0</span>] = Sqrt(f[<span class="number">0</span>]); <span class="comment">// 求二次剩余</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> m = <span class="number">2</span>; m &lt;= n; m &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        poly tmp = Pow2(g);</span><br><span class="line">        tmp.resize(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) inc(tmp[i], f[i]);</span><br><span class="line">        g = Multiply(tmp, Inverse(g, m)), g.resize(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) g[i] = mul(g[i], inv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g.resize(_n), g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多项式多点求值">多项式多点求值</h2><blockquote><p>给定多项式 <span class="math inline">\(F(x)\)</span> 和 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(a_i\)</span>，对于每个 <span class="math inline">\(a_i\)</span>，求 <span class="math inline">\(F(a_i)\)</span> 的值。</p></blockquote><p>记 <span class="math inline">\(k=\lfloor\frac{n}{2}\rfloor\)</span>，构造多项式 <span class="math inline">\(G_0(x)=\prod\limits_{i=1}^{k}(x-a_i)\)</span>，然后用多项式除法求出 <span class="math inline">\(D_0(x),R_0(x)\)</span> 满足 <span class="math inline">\(F(x)=D_0(x)G_0(x)+R_0(x)\)</span>。</p><p>发现对于 <span class="math inline">\(i\le k\)</span> 的 <span class="math inline">\(a_i\)</span>，代入后 <span class="math inline">\(D_0(x)G_0(x)=0\)</span>，也就是说 <span class="math inline">\(F(a_i)=R_0(a_i)\)</span>。</p><p>对于 <span class="math inline">\(i &gt; k\)</span> 的部分也可以同理构造多项式 <span class="math inline">\(G_1(x)\)</span> 求出 <span class="math inline">\(R_1(x)\)</span> 使得 <span class="math inline">\(F(a_i)=R_1(a_i)\)</span>。</p><p>于是我们把用 <span class="math inline">\(O(n\log n)\)</span> 的复杂度把原问题分成了两个规模减半的子问题。</p><p>每次的 <span class="math inline">\(G_0(x),G_1(x)\)</span> 可以一开始都预处理出来。</p><p>预处理部分复杂度 <span class="math inline">\(O(n\log^2n)\)</span>，总复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><p>注意到暴力展开计算常数非常小，在问题规模减到一定数值时可以暴力计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs;</span><br><span class="line">    poly g;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> _T_cnt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;tree_node&gt; _T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eval_inter_init</span><span class="params">(<span class="keyword">const</span> poly &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = _T_cnt++;</span><br><span class="line">    _T[u].ls = _T[u].rs = <span class="number">-1</span>, _T[u].g.resize(r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r)&#123;</span><br><span class="line">        _T[u].g[<span class="number">0</span>] = minus(<span class="number">0</span>, x[l]), _T[u].g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> md = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    _T[u].ls = eval_inter_init(x, l, md);</span><br><span class="line">    _T[u].rs = eval_inter_init(x, md, r);</span><br><span class="line">    _T[u].g = Multiply(_T[_T[u].ls].g, _T[_T[u].rs].g);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Evaluate_solve</span><span class="params">(<span class="keyword">const</span> poly &amp;f, <span class="keyword">const</span> poly &amp;x, poly &amp;y, <span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">256</span>)&#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> n = f.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = l; k &lt; r; ++k)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">unsigned</span> now = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> b[<span class="number">17</span>], c1, c2, c3, c4;</span><br><span class="line">            b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; ++i) b[i] = b[i - <span class="number">1</span>] * x[k] % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - <span class="number">1</span>; i - <span class="number">15</span> &gt;= <span class="number">0</span>; i -= <span class="number">16</span>)&#123;</span><br><span class="line">                c1 = now * b[<span class="number">16</span>] + f[i] * b[<span class="number">15</span>] + f[i - <span class="number">1</span>] * b[<span class="number">14</span>] + f[i - <span class="number">2</span>] * b[<span class="number">13</span>];</span><br><span class="line">                c2 = f[i - <span class="number">3</span>] * b[<span class="number">12</span>] + f[i - <span class="number">4</span>] * b[<span class="number">11</span>] + f[i - <span class="number">5</span>] * b[<span class="number">10</span>] + f[i - <span class="number">6</span>] * b[<span class="number">9</span>];</span><br><span class="line">                c3 = f[i - <span class="number">7</span>] * b[<span class="number">8</span>] + f[i - <span class="number">8</span>] * b[<span class="number">7</span>] + f[i - <span class="number">9</span>] * b[<span class="number">6</span>] + f[i - <span class="number">10</span>] * b[<span class="number">5</span>];</span><br><span class="line">                c4 = f[i - <span class="number">11</span>] * b[<span class="number">4</span>] + f[i - <span class="number">12</span>] * b[<span class="number">3</span>] + f[i - <span class="number">13</span>] * b[<span class="number">2</span>] + f[i - <span class="number">14</span>] * b[<span class="number">1</span>];</span><br><span class="line">                now = (c1 + c2 + c3 + c4 + f[i - <span class="number">15</span>]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n % <span class="number">16</span> - <span class="number">1</span>; ~i; --i) now = (<span class="number">1u</span>ll * now * x[k] + f[i]) % P;</span><br><span class="line">            y[k] = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> md = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    poly R;</span><br><span class="line">    R = Divide(f, _T[_T[u].ls].g).second;</span><br><span class="line">    Evaluate_solve(R, x, y, _T[u].ls, l, md);</span><br><span class="line">    R = Divide(f, _T[_T[u].rs].g).second;</span><br><span class="line">    Evaluate_solve(R, x, y, _T[u].rs, md, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">Evaluate</span><span class="params">(<span class="keyword">const</span> poly &amp;f, <span class="keyword">const</span> poly &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = x.size(), rt = <span class="number">-1</span>;</span><br><span class="line">    _T_cnt = <span class="number">0</span>, _T.resize(<span class="number">2</span> * m - <span class="number">1</span>), rt = eval_inter_init(x, <span class="number">0</span>, m);</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(m)</span></span>;</span><br><span class="line">    Evaluate_solve(f, x, res, rt, <span class="number">0</span>, m);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多项式快速插值">多项式快速插值</h2><blockquote><p>有一个 <span class="math inline">\(n-1\)</span> 次多项式 <span class="math inline">\(F(x)\)</span>，给定 <span class="math inline">\(n\)</span> 个点及对应的点值 <span class="math inline">\((x_i,y_i)\)</span>，求 <span class="math inline">\(F(x)\)</span>。</p></blockquote><p>根据拉格朗日插值公式，有 <span class="math display">\[\begin{aligned}F(x)&amp;=\sum_{i=1}^{n} y_i\prod_{i\ne j}\frac{x-x_j}{x_i-x_j}\\&amp;=\sum_{i=1}^{n}\frac{y_i}{\prod_{i\ne j}(x_i-x_j)}\prod_{i\ne j}(x-x_j)\end{aligned}\]</span></p><p>令 <span class="math inline">\(G(x)=\prod_{i=1}^{n}(x-x_i),H_i(x)=\frac{G(x)}{x-x_i}\)</span>，那么 <span class="math inline">\(\prod_{i\ne j}(x_i-x_j)=H_i(x_i)\)</span>。根据洛必达法则，有 <span class="math inline">\(H_i(x_i)=G&#39;(x_i)\)</span>。</p><p>于是我们用多项式多点求值求出所有 <span class="math inline">\(G&#39;(x_i)\)</span> 即可。</p><p>记 <span class="math inline">\(a_i=\frac{y_i}{G&#39;(x_i)}\)</span>，那么有 <span class="math display">\[F(x)=\sum_{i=1}^{n}a_i\prod_{i\ne j}(x-x_j)\]</span></p><p>然后我们分治求解。设当前区间为 <span class="math inline">\([l,r)\)</span>，中点 <span class="math inline">\(m=\lfloor\frac{l+r+1}{2}\rfloor\)</span>，我们要求 <span class="math display">\[\begin{aligned}F_{l,r}(x)&amp;=\sum_{i=l}^{r-1}a_i\prod_{l\le j &lt; r,j\ne i}(x-x_j) \\ &amp;=\left(\prod_{i=m}^{r-1}(x-x_i)\right)\sum_{i=l}^{m-1}a_i\prod_{l\le j &lt; m,i\ne j}(x-x_j)+\left(\prod_{i=l}^{m-1}(x-x_i)\right)\sum_{i=m}^{r-1}a_i\prod_{m\le j &lt; r,i\ne j}(x-x_j) \\ &amp;=\left(\prod_{i=m}^{r-1}(x-x_i)\right)F_{l,m}(x)+\left(\prod_{i=l}^{m-1}(x-x_i)\right)F_{m,r}(x)\end{aligned}\]</span></p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">poly <span class="title">Divide_2</span><span class="params">(poly a, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size();</span><br><span class="line">    <span class="function">poly <span class="title">b</span><span class="params">(n - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - <span class="number">1</span>; i; --i)&#123;</span><br><span class="line">        b[i - <span class="number">1</span>] = a[i];</span><br><span class="line">        dec(a[i - <span class="number">1</span>], mul(a[i], t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">Inter_solve</span><span class="params">(<span class="keyword">const</span> poly &amp;x, <span class="keyword">const</span> poly &amp;y, <span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">64</span>)&#123;</span><br><span class="line">        poly f(r - l), g = _T[u].g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = l; i &lt; r; ++i)&#123;</span><br><span class="line">            poly tmp = Divide_2(g, minus(<span class="number">0</span>, x[i]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; r - l; ++j) f[j] = (f[j] + <span class="number">1u</span>ll * tmp[j] * y[i]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> md = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    poly A = _T[_T[u].rs].g, B = Inter_solve(x, y, _T[u].ls, l, md);</span><br><span class="line">    poly C = _T[_T[u].ls].g, D = Inter_solve(x, y, _T[u].rs, md, r);</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> m = get(r - l);</span><br><span class="line">    init(m), DFT(A, m), DFT(B, m), DFT(C, m), DFT(D, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) A[i] = (<span class="number">1u</span>ll * A[i] * B[i] + <span class="number">1u</span>ll * C[i] * D[i]) % P;</span><br><span class="line">    IDFT(A, m), A.resize(r - l);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">Interpolation</span><span class="params">(poly x, poly y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = x.size(), rt = <span class="number">-1</span>;</span><br><span class="line">    _T_cnt = <span class="number">0</span>, _T.resize((n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>), rt = eval_inter_init(x, <span class="number">0</span>, n);</span><br><span class="line">    poly g = Derivative(_T[rt].g);</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    Evaluate_solve(g, x, res, rt, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) y[i] = mul(y[i], qpow(res[i], P - <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> Inter_solve(x, y, rt, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多项式三角函数">多项式三角函数</h2><p>不会</p><h2 id="多项式反三角函数">多项式反三角函数</h2><p>不会</p><h2 id="mtt">MTT</h2><p>不会</p><h2 id="完整代码">完整代码</h2><p>完整代码可以见 <a href="https://github.com/AutumnKite/Codes/blob/master/Templates/Polynomial.cpp" target="_blank" rel="noopener">Codes/Polynomial.cpp at master · AutumnKite/Codes</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFT </tag>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 1244E」Minimizing Difference</title>
      <link href="/cf1244e-sol/"/>
      <url>/cf1244e-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1244/problem/E" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，一次操作可以将序列中的某个数 <span class="math inline">\(+1\)</span> 或 <span class="math inline">\(-1\)</span>。</p><p>定义一个序列的差值为序列的最大值减去最小值得到的数。</p><p>求进行至多 <span class="math inline">\(k\)</span> 次操作后序列差值的最小值。</p><p><span class="math inline">\(n\le 10^5,a_i\le 10^9,k\le 10^{14}\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>显然可以二分答案 <span class="math inline">\(x\)</span>，然后就是求使得差值 <span class="math inline">\(\le x\)</span> 需要进行至少多少次操作。</p><p>将 <span class="math inline">\(a_i\)</span> 排序，假设最后的序列中的数在 <span class="math inline">\([p,p+x]\)</span> 中，记序列中最后一个 <span class="math inline">\(&lt; p\)</span> 的数为 <span class="math inline">\(a_l\)</span>，第一个 <span class="math inline">\(&gt;p+x\)</span> 的数为 <span class="math inline">\(a_r\)</span>，那么需要进行的操作数量是 <span class="math inline">\(p\times l-\sum_{i=1}^{l}a_i+\sum_{i=r}^{n}a_i-(p+x)\times (n-r+1)\)</span>。根据这个式子我们可以发现 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(p+x\)</span> 这两个数中一定有一个数是存在于原序列中的，否则可以进行调整使得操作次数更少。于是我们枚举所有情况进行判断即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log \max a_i)\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k, a[N], sum[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= n &amp;&amp; a[j] - a[i] &lt;= x) ++j;</span><br><span class="line">        <span class="keyword">if</span> (a[i] * (i - <span class="number">1</span>) - sum[i - <span class="number">1</span>] + sum[n] - sum[j - <span class="number">1</span>] - (a[i] + x) * (n - j + <span class="number">1</span>) &lt;= k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (a[i] - a[j] &gt; x) ++j;</span><br><span class="line">        <span class="keyword">if</span> ((a[i] - x) * (j - <span class="number">1</span>) - sum[j - <span class="number">1</span>] + sum[n] - sum[i] - a[i] * (n - i) &lt;= k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), k = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read();</span><br><span class="line">    <span class="built_in">std</span> :: sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = a[n] - a[<span class="number">1</span>], md, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) <span class="keyword">if</span> (check(md = (l + r) &gt;&gt; <span class="number">1</span>)) r = md - <span class="number">1</span>, ans = md; <span class="keyword">else</span> l = md + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 1244F」Chips</title>
      <link href="/cf1244f-sol/"/>
      <url>/cf1244f-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1244/problem/F" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>有一个大小为 <span class="math inline">\(n\)</span> 的环，环上每个点有一个颜色（黑/白）。定义一次操作是，对于每个点 <span class="math inline">\(i\)</span>，若他和他相邻的两个点中，白点多于黑点，则在新的环中， <span class="math inline">\(i\)</span> 变成白色，否则变为黑色。</p><p>求进行 <span class="math inline">\(k\)</span> 次操作后每个点的颜色。</p><p><span class="math inline">\(n\le 2\times 10^5,k\le 10^9\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>变色的条件相当于 <span class="math inline">\(i\)</span> 相邻两个点的颜色都与 <span class="math inline">\(i\)</span> 的颜色不同。对于一段长度 <span class="math inline">\(\ge 2\)</span> 的颜色相同的段，显然颜色是永远不会变的。只有这样的段之间的这些颜色交替改变的点的颜色会发生变化。例如 <code>WWWBWBWBWBBB</code> -&gt; <code>WWWWBWBWBBBB</code> -&gt; <code>WWWWWBWBBBBB</code> -&gt; <code>WWWWWWBBBBBB</code>。</p><p>考虑中间的颜色交替改变的一段（如上例中 <code>BWBWBW</code>），发现每进行一次操作，两边的点会向两边的颜色相同的连续段合并，中间的点会改变颜色。记这样的段中某个点 <span class="math inline">\(i\)</span> 到两边颜色相同连续段的距离是 <span class="math inline">\(a_i,b_i\)</span>，那么他会在第 <span class="math inline">\(\min(a_i,b_i)\)</span> 次操作被合并，颜色要看两边段的颜色和具体往哪边合并，被合并之后颜色就不会再变化，而在被合并之前颜色则是交替变化。所以只要根据 <span class="math inline">\(k\)</span> 和 <span class="math inline">\(\min(a_i,b_i)\)</span> 的大小进行讨论即可。</p><p>要注意的是，可能题目给定字符串的最前面一段和最后面一段是可以拼起来的，所以要对顺序进行一定的调整。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 400005</span></span><br><span class="line"><span class="keyword">int</span> n, k, d, dis1[N], dis2[N];</span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;k, a + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (check())&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) <span class="built_in">std</span> :: reverse(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%s"</span>, a + <span class="number">1</span>), <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[n + i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n + <span class="number">2</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] != a[i] &amp;&amp; a[i] != a[i + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123; d = i - <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (!d) d = (n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = d - n + <span class="number">1</span>; i &lt;= d; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] != a[i] &amp;&amp; a[i] != a[i + <span class="number">1</span>]) dis1[i] = dis1[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dis1[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = d; i &gt; d - n; --i)</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] != a[i] &amp;&amp; a[i] != a[i + <span class="number">1</span>]) dis2[i] = dis2[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dis2[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = d - n + <span class="number">1</span>; i &lt;= d; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] != a[i] &amp;&amp; a[i] != a[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> (k &gt;= <span class="built_in">std</span> :: min(dis1[i], dis2[i]))</span><br><span class="line">                <span class="keyword">if</span> (dis1[i] &lt; dis2[i]) b[i] = a[i - dis1[i]];</span><br><span class="line">                <span class="keyword">else</span> b[i] = a[i + dis2[i]];</span><br><span class="line">            <span class="keyword">else</span> b[i] = a[i] == <span class="string">'B'</span> &amp;&amp; (k &amp; <span class="number">1</span>) || (a[i] == <span class="string">'W'</span> &amp;&amp; (k &amp; <span class="number">1</span> ^ <span class="number">1</span>)) ? <span class="string">'W'</span> : <span class="string">'B'</span>;</span><br><span class="line">        <span class="keyword">else</span> b[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d - n; ++i) <span class="built_in">putchar</span>(b[i + n]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = d - n + <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">putchar</span>(b[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 1214H」Tiles Placement</title>
      <link href="/cf1214h-sol/"/>
      <url>/cf1214h-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1214/problem/H" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，你需要给每个点染一个 <span class="math inline">\(1\sim k\)</span> 的颜色，使得树上所有长度为 <span class="math inline">\(k\)</span> 的路径都恰好包含 <span class="math inline">\(k\)</span> 种颜色。</p><p><span class="math inline">\(n\le 2\times 10^5\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>根本不会构造.jpg</p><p><del>我来翻译官方题解了</del></p><p>显然如果一个点出去有三条路径（长度记为 <span class="math inline">\(a,b,c\)</span>）满足 <span class="math inline">\(a+b\ge k-1,a+c\ge k-1,b+c\ge k-1\)</span>，则一定不满足条件。否则，存在以下一个构造方案。</p><p>拉出一条直径，从左到右染 <span class="math inline">\(1,2,3,\cdots,k,1,2,3,\cdots\)</span> 。然后考虑直径外的部分，把直径分成两半，对于左边部分的某个染成 <span class="math inline">\(i\)</span> 的点，我们把这个点多出去的部分按深度从小到大染成 <span class="math inline">\(i,i-1,i-2,\cdots,1,k,k-1,k-2\cdots\)</span>；对于右边部分的某个染成 <span class="math inline">\(i\)</span> 的点，我们把这个点多出去的部分按深度从小到大染成 <span class="math inline">\(i,i+1,i+2,\cdots,k,1,2,3\cdots\)</span>。正确性可以参考官方题解。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = getchar(), f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">int</span> k, n;</span><br><span class="line"><span class="keyword">int</span> mx[N], cmx[N];</span><br><span class="line"><span class="keyword">int</span> rt, ed, dep[N], fa[N], cnt, p[N], on[N], col[N];</span><br><span class="line"><span class="keyword">int</span> edge, to[N &lt;&lt; <span class="number">1</span>], pr[N &lt;&lt; <span class="number">1</span>], hd[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span> :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dfs1(<span class="keyword">int</span> u, <span class="keyword">int</span> fa = <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span> :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; res(<span class="number">0</span>, u), tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa) tmp = dfs1(v, u), ++tmp.first, res = <span class="built_in">std</span> :: max(res, tmp);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dep[u] = dep[fa[u]] + <span class="number">1</span>, mx[u] = cmx[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa[u])&#123;</span><br><span class="line">            fa[v] = u, dfs2(v);</span><br><span class="line">            <span class="keyword">if</span> (mx[v] + <span class="number">1</span> &gt; mx[u]) cmx[u] = mx[u], mx[u] = mx[v] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mx[v] + <span class="number">1</span> &gt; cmx[u]) cmx[u] = mx[v] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    c = (c + d + k - <span class="number">1</span>) % k + <span class="number">1</span>, col[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa[u] &amp;&amp; !on[v]) dfs3(v, c, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), k = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">        u = read(), v = read(), addedge(u, v), addedge(v, u);</span><br><span class="line">    dfs2(rt = dfs1(<span class="number">1</span>).second);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cmx[i])</span><br><span class="line">            <span class="keyword">if</span> (mx[i] + <span class="number">1</span> &gt; dep[i]) <span class="keyword">if</span> (dep[i] + cmx[i] &gt;= k &amp;&amp; k &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>), <span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mx[i] + cmx[i] + <span class="number">1</span> &gt;= k &amp;&amp; k &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>), <span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!ed || dep[i] &gt; dep[ed]) ed = i;</span><br><span class="line">    cnt = dep[ed];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = ed; i; i = fa[i]) p[dep[i]] = i, on[i] = <span class="number">1</span>, col[i] = (dep[i] - <span class="number">1</span>) % k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = hd[p[i]]; j; j = pr[j])</span><br><span class="line">            <span class="keyword">if</span> (!on[to[j]]) dfs3(to[j], col[p[i]], i &lt;= cnt / <span class="number">2</span> ? <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, col[i]); <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> DP </tag>
            
            <tag> 树的直径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 1214G」Feeling Good</title>
      <link href="/cf1214g-sol/"/>
      <url>/cf1214g-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1214/problem/G" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>有一个 <span class="math inline">\(n\times m\)</span> 的黑白矩阵，初始时是全白的。有 <span class="math inline">\(q\)</span> 次操作，每次操作形如 <span class="math inline">\(a_i,l_i,r_i\)</span>，表示把 <span class="math inline">\(a_i\)</span> 行的 <span class="math inline">\(l_i\)</span> 列到 <span class="math inline">\(r_i\)</span> 列的格子反转颜色。</p><p>每次操作后，你要找出 <span class="math inline">\(x_1,y_1,x_2,y_2\)</span>，满足 <span class="math inline">\(x_1 &lt; x_2,y_1 &lt; y_2, col(x_1,y_1)=col(x_2,y_2),col(x_1,y_2)=col(x_2,y_1),col(x_1,y_1)\ne col(x_1,y_2)\)</span>。若不存在则输出 <span class="math inline">\(-1\)</span>。</p><p><span class="math inline">\(n,m\le 2000,q\le 5\times 10^5\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>考虑如何判断是否有解。</p><p>记 <span class="math inline">\(S_i=\{j\mid col(i,j)=\text{black}\}\)</span>。对于固定的两行 <span class="math inline">\(x_1,x_2\)</span>，有解的条件是 <span class="math inline">\(S_{x_1}\)</span> 不是 <span class="math inline">\(S_{x_2}\)</span> 的子集且 <span class="math inline">\(S_{x_2}\)</span> 不是 <span class="math inline">\(S_{x_1}\)</span> 的子集。</p><p>我们把这些集合按大小从小到大排序，若 <span class="math inline">\(S_1\subseteq S_2\subseteq S_3\subseteq\cdots\subseteq S_n\)</span>，则一定无解，否则一定存在一个 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(S_{i}\)</span> 不是 <span class="math inline">\(S_{i+1}\)</span> 的子集，又因为是按集合大小从小到大排序的，<span class="math inline">\(S_{i+1}\)</span> 也一定不是 <span class="math inline">\(S_i\)</span> 的子集，那么这两行就是满足条件的。</p><p>然后考虑求出一组解，我们只要把所有满足条件的 <span class="math inline">\(i\)</span> 都记下来。对于两个集合 <span class="math inline">\(S_{i},S_{i+1}\)</span>，其中一个 <span class="math inline">\(y\)</span> 一定是在 <span class="math inline">\(S_{i}\)</span> 中是黑色的但在 <span class="math inline">\(S_{i+1}\)</span> 中是白色的，另一个 <span class="math inline">\(y\)</span> 反之。</p><p>用 bitset 维护这些集合，然后用位运算和 <code>_Find_First</code> 函数即可求出 <span class="math inline">\(y_1,y_2\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(q(\frac{m}{w}+\log n))\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = getchar(), f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2005</span></span><br><span class="line"><span class="keyword">int</span> n, m, q, x1, _y1, x2, _y2;</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">bitset</span>&lt;N&gt; a[N], nw[N], tmp;</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">set</span>&lt; <span class="built_in">std</span> :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; S, ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a[i] &amp; a[j]) != a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">std</span> :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (check(p.first, p.second)) ans.insert(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="built_in">std</span> :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (check(p.first, p.second)) ans.erase(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="built_in">std</span> :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nx, i, pr;</span><br><span class="line">    <span class="keyword">auto</span> it = S.lower_bound(x), tmp = it;</span><br><span class="line">    i = x.second, nx = (++tmp) -&gt; second, pr = (--it) -&gt; second;</span><br><span class="line">    del(<span class="built_in">std</span> :: make_pair(pr, i)), del(<span class="built_in">std</span> :: make_pair(i, nx)), add(<span class="built_in">std</span> :: make_pair(pr, nx));</span><br><span class="line">    S.erase(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="built_in">std</span> :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nx, i, pr;</span><br><span class="line">    <span class="keyword">auto</span> it = S.lower_bound(x);</span><br><span class="line">    i=  x.second, nx = it -&gt; second, pr = (--it) -&gt; second;</span><br><span class="line">    add(<span class="built_in">std</span> :: make_pair(pr, i)), add(<span class="built_in">std</span> :: make_pair(i, nx)), del(<span class="built_in">std</span> :: make_pair(pr, nx));</span><br><span class="line">    S.insert(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), m = read(), q = read();</span><br><span class="line">    nw[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) nw[i] = nw[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span> | nw[<span class="number">1</span>];</span><br><span class="line">    a[n + <span class="number">1</span>] = nw[m], S.insert(<span class="built_in">std</span> :: make_pair(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) S.insert(<span class="built_in">std</span> :: make_pair(<span class="number">0</span>, i));</span><br><span class="line">    S.insert(<span class="built_in">std</span> :: make_pair(m, n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = read(), l = read(), r = read();</span><br><span class="line">        Erase(<span class="built_in">std</span> :: make_pair(a[k].count(), k));</span><br><span class="line">        a[k] ^= nw[r - l + <span class="number">1</span>] &lt;&lt; (l - <span class="number">1</span>);</span><br><span class="line">        Insert(<span class="built_in">std</span> :: make_pair(a[k].count(), k));</span><br><span class="line">        <span class="keyword">if</span> (ans.empty()) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            x1 = ans.begin() -&gt; first, x2 = ans.begin() -&gt; second;</span><br><span class="line">            _y1 = ((a[x1] ^ a[x2]) &amp; a[x1])._Find_first(), _y2 = ((a[x1] ^ a[x2]) &amp; a[x2])._Find_first();</span><br><span class="line">            <span class="keyword">if</span> (x1 &gt; x2) <span class="built_in">std</span> :: swap(x1, x2);</span><br><span class="line">            <span class="keyword">if</span> (_y1 &gt; _y2) <span class="built_in">std</span> :: swap(_y1, _y2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n"</span>, x1, _y1 + <span class="number">1</span>, x2, _y2 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bitset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 1214F」Employment</title>
      <link href="/cf1214f-sol/"/>
      <url>/cf1214f-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1214/problem/F" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>有一个大小为 <span class="math inline">\(m\)</span> 的环，还上有 <span class="math inline">\(n\)</span> 个点有工作单位，并且有 <span class="math inline">\(n\)</span> 个点上住着一个人。你需要为每个人分配一个工作单位，使得所有人到工作单位的距离之和最短。输出一个方案。</p><p><span class="math inline">\(m\le 10^9,n\le 2\times 10^5\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>下面的数组都从 <span class="math inline">\(0\)</span> 开始标号。先将 <span class="math inline">\(a,b\)</span> 数组分别从小到大排序，然后把 <span class="math inline">\(b\)</span> 数组变成 <span class="math inline">\(b_0,b_1,b_2,\cdots,b_{n-1},b_0+m,b_1+m,\cdots,b_{n-1}+m,b_0+2m,b_1+2m,\cdots,b_{n-1}+2m\)</span>，把 <span class="math inline">\(a\)</span> 数组变成 <span class="math inline">\(a_0+m,a_1+m,a_2+m,\cdots,a_{n-1}+m\)</span>。</p><p>考虑贪心，显然两个人的路径不能“交叉”，所以一定是小的和小的匹配，大的和大的匹配。问题变成了求 <span class="math inline">\(\min\limits_{0\le x\le 2n} \sum\limits_{i=0}^{n-1} |a_i-b_{i+x}|\)</span> 的值。</p><p>记 <span class="math inline">\(ans_x=\sum\limits_{i=0}^{n-1} |a_i-b_{i+x}|\)</span>，把绝对值拆开，则变成了</p><p><span class="math display">\[\begin{aligned}ans_x&amp;=\sum\limits_{i=0}^{n-1} |a_i-b_{i+x}| \\ &amp;=\sum\limits_{i=0}^{n-1} ([a_i &gt; b_{i+x}]a_i-[a_i &lt; b_{i+x}]a_i-[a_i &gt; b_{i+x}]b_{i+x}+[a_i &lt; b_{i+x}]b_{i+x})\end{aligned}\]</span></p><p>记 <span class="math inline">\(sa_{x}=\sum\limits_{i=0}^{n-1} ([a_i &gt; b_{i+x}]a_i-[a_i &lt; b_{i+x}]a_i),sb_{x}=\sum\limits_{i=0}^{n-1} ([a_i &lt; b_{i+x}]b_{i+x}-[a_i &gt; b_{i+x}]b_{i+x})\)</span>。考虑单独计算。</p><p>我们将 <span class="math inline">\(sa\)</span> 差分，发现 <span class="math inline">\(sa_x-sa_{x-1}=\sum\limits_{i=0}^{n-1} ([a_i &gt; b_{i+x}]a_i-[a_i &lt; b_{i+x}]a_i-[a_i &gt; b_{i+x-1}]a_i+[a_i &lt; b_{i+x-1}]a_i)\)</span>，发现若 <span class="math inline">\(a_i \le b_{i+x-1} \le b_{i+x}\)</span> 或 <span class="math inline">\(b_{i+x-1} \le b_{i+x} \le a_i\)</span> 时，这个式子恰好为 <span class="math inline">\(0\)</span>，只有当 <span class="math inline">\(b_{i+x-1} &lt; a_i &lt; b_{i+x}\)</span> 时，这个式子的值为 <span class="math inline">\(-2a_i\)</span>，而这个 <span class="math inline">\(x\)</span> 又是唯一的。于是对于每个 <span class="math inline">\(a_i\)</span> 求出这个唯一的 <span class="math inline">\(x\)</span>，在差分数组上直接修改即可。</p><p>我们依次考虑每个 <span class="math inline">\(b_i\)</span>，发现当 <span class="math inline">\(x\)</span> 小于某个值时，<span class="math inline">\(b_i\)</span> 对 <span class="math inline">\(sb_x\)</span> 的贡献是负的，否则是正的。于是我们求出这个值，然后区间加贡献即可。这个也可以用差分简单的实现。</p><p>发现求 <span class="math inline">\(sa_x,sb_x\)</span> 在实现的过程中都需要差分，不需要分开计算。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = getchar(), f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">int</span> n, ansi, ansid[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m, ans[N &lt;&lt; <span class="number">1</span>], Ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; rhs.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N], b[N * <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">abs</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; <span class="number">0</span> ? a : -a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">long</span> <span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    ans[l] += v, ans[r] -= v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m = read(), n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i].v = read(), a[i].id = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) b[i].v = read(), b[i].id = i;</span><br><span class="line">    <span class="built_in">std</span> :: sort(a, a + n), <span class="built_in">std</span> :: sort(b, b + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i].v += m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); ++i) b[i + n] = b[i], b[i + n].v += m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ans[<span class="number">0</span>] += a[i].v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">std</span> :: lower_bound(b, b + <span class="number">3</span> * n, a[i]) - b;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; i &amp;&amp; j &lt;= i + (n &lt;&lt; <span class="number">1</span>)) ans[j - i] -= <span class="number">2</span> * a[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span> * n; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; n)&#123; add(<span class="number">0</span>, j + <span class="number">1</span>, -b[j].v); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= (n &lt;&lt; <span class="number">1</span>))&#123; add(j - n + <span class="number">1</span>, (n &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, b[j].v); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">std</span> :: upper_bound(a, a + n, b[j]) - a;</span><br><span class="line">        add(j - i + <span class="number">1</span>, j + <span class="number">1</span>, b[j].v), add(j - n + <span class="number">1</span>, j - i + <span class="number">1</span>, -b[j].v);</span><br><span class="line">    &#125;</span><br><span class="line">    Ans = ans[<span class="number">0</span>], ansi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); ++i)&#123;</span><br><span class="line">        ans[i] += ans[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (ans[i] &lt; Ans) Ans = ans[i], ansi = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        ansid[a[i].id] = b[(i + ansi) % n].id;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ansid[i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 1214E」Petya and Construction Set</title>
      <link href="/cf1214e-sol/"/>
      <url>/cf1214e-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1214/problem/E" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>构造一个 <span class="math inline">\(2n-1\)</span> 个节点的树，满足 <span class="math inline">\(\forall i\in [1,n] : dis(2i-1,2i)=d_i\)</span>，<span class="math inline">\(dis(x,y)\)</span> 表示树上 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的距离，<span class="math inline">\(d_i\)</span> 是给定的。</p><p><span class="math inline">\(n\le 10^5\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>将 <span class="math inline">\(d_i\)</span> 从大到小排序，然后依次把所有奇数连成一条链（按对应的 <span class="math inline">\(d_i\)</span> 从大到小的顺序）。</p><p>然后依次考虑链上每个点对应的偶数点的位置。假设这个点是链上第 <span class="math inline">\(k\)</span> 个点，对应的 <span class="math inline">\(d_i\)</span> 记为 <span class="math inline">\(D\)</span>，那么显然只要把这个偶数点挂在链上第 <span class="math inline">\(k+D-1\)</span> 个点下面即可。要注意的是，如果第 <span class="math inline">\(k+D-1\)</span> 个点是链上最后一个点，那么再挂一个点要把链进行“扩充”。可以证明，在处理第 <span class="math inline">\(k\)</span> 个点时，链上一定存在 <span class="math inline">\(k+D-1\)</span> 个点（根据 <span class="math inline">\(d_i\)</span> 从大到小进行证明）。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = getchar(), f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, cnt, id[<span class="number">100005</span>];</span><br><span class="line"><span class="built_in">std</span> :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; d[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i].first = -read(), d[i].second = i;</span><br><span class="line">    <span class="built_in">std</span> :: sort(d + <span class="number">1</span>, d + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, <span class="number">2</span> * d[i].second - <span class="number">1</span>, <span class="number">2</span> * d[i + <span class="number">1</span>].second - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> x = i - d[i].first - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= n) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, <span class="number">2</span> * d[x].second - <span class="number">1</span>, <span class="number">2</span> * d[i].second);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, id[x - n], <span class="number">2</span> * d[i].second);</span><br><span class="line">        <span class="keyword">if</span> (x - n == cnt) id[++cnt] = <span class="number">2</span> * d[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 1214D」Treasure Island</title>
      <link href="/cf1214d-sol/"/>
      <url>/cf1214d-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1214/problem/D" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定一个 <span class="math inline">\(n\times m\)</span> 的地图，每个格子要么是障碍，要么是空格。你可以把除 <span class="math inline">\((1,1)\)</span> 和 <span class="math inline">\((n,m)\)</span> 外的若干个格子变成障碍，求使得 <span class="math inline">\((1,1)\)</span> 到 <span class="math inline">\((n,m)\)</span> <strong>没有路径</strong>最少需要把几个格子变成障碍。</p><p><span class="math inline">\(3\le n\cdot m\le 10^6\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>答案只可能是 <span class="math inline">\(0,1,2\)</span> 中的一种。</p><p><span class="math inline">\(0\)</span> 可以直接判；<span class="math inline">\(1\)</span> 就是 <span class="math inline">\((1,1)\)</span> 能走到 <span class="math inline">\((n,m)\)</span> 但必须都经过某个格子 <span class="math inline">\((x,y)\)</span>；否则就是 <span class="math inline">\(2\)</span>。</p><p>那么只要找出一条路径，若找不到就是 <span class="math inline">\(0\)</span>；然后再找一条强制不经过第一条路径中的点的路径，若找不到就是 <span class="math inline">\(1\)</span>；否则就是 <span class="math inline">\(2\)</span>。</p><p>吐槽一句：我一开始写了个求起点、终点到某个点的路径数量，然后用乘法原理判断，只可惜这东西要取模，于是愉快地 WA on 233 了（<a href="https://codeforces.com/contest/1214/submission/60334654" target="_blank" rel="noopener">Submission #60334654</a>）</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m, a[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">char</span> t[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || j &lt; <span class="number">1</span> || i &gt; n || j &gt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a[(i - <span class="number">1</span>) * m + j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    a[(i - <span class="number">1</span>) * m + j] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GG</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n || j &gt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ((i != <span class="number">1</span> || (j != <span class="number">1</span>)) &amp;&amp; get(a, i, j)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == n &amp;&amp; j == m) GG(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">set</span>(a, i, j, <span class="number">1</span>);</span><br><span class="line">    dfs2(i + <span class="number">1</span>, j), dfs2(i, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n || j &gt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ((i != <span class="number">1</span> || (j != <span class="number">1</span>)) &amp;&amp; get(a, i, j)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == n &amp;&amp; j == m) dfs2(<span class="number">1</span>, <span class="number">1</span>), GG(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">set</span>(a, i, j, <span class="number">1</span>);</span><br><span class="line">    dfs1(i + <span class="number">1</span>, j), dfs1(i, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, t + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (t[j] == <span class="string">'#'</span>) <span class="built_in">set</span>(a, i, j, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">1</span>), GG(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AtCoder」「JSC 2019 Qual F」Candy Retribution</title>
      <link href="/atcoder-jsc19qualF-sol/"/>
      <url>/atcoder-jsc19qualF-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_f" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>求满足以下条件的长度为 <span class="math inline">\(n\)</span> 的非负整数序列 <span class="math inline">\(a_1,a_2,a_3,\cdots,a_n\)</span> 的方案数 <span class="math inline">\(\bmod 10^9+7\)</span> 的值：</p><ol type="1"><li><span class="math inline">\(l\le \sum_{i=1}^n a_i\le r\)</span>；</li><li>将序列从大到小排序后，记为 <span class="math inline">\(a_1&#39;,a_2&#39;,a_3&#39;,\cdots,a_n&#39;\)</span>，满足 <span class="math inline">\(a_m&#39;=a_{m+1}&#39;\)</span>。</li></ol><p><span class="math inline">\(1\le m &lt; n\le 3\times 10^5,1\le l,r\le 3\times 10^5\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>显然第一个条件可以差分，假设总和的上界为 <span class="math inline">\(S\)</span>，用隔板法得到不考虑第二个条件的方案数为 <span class="math inline">\(C_{S+n}^n\)</span>。直接算满足第二个条件的不好算，我们考虑算不满足第二个条件的方案数，然后用总方案数减去即可。</p><p>我们枚举从大到小排序后的第 <span class="math inline">\(m\)</span> 个数为 <span class="math inline">\(x\)</span>，那么不满足条件的方案数等于在 <span class="math inline">\(n\)</span> 个位置中选出 <span class="math inline">\(m\)</span> 个位置使得这 <span class="math inline">\(m\)</span> 个位置的值 <span class="math inline">\(\ge x\)</span>，其余 <span class="math inline">\(n-m\)</span> 个位置的值 <span class="math inline">\(&lt; x\)</span>，<span class="math inline">\(n\)</span> 个数总和 <span class="math inline">\(\le S\)</span> 的方案数，减去在 <span class="math inline">\(n\)</span> 个位置中选出 <span class="math inline">\(m\)</span> 个位置使得这 <span class="math inline">\(m\)</span> 个位置的值 <span class="math inline">\(\ge x+1\)</span>，其余 <span class="math inline">\(n-m\)</span> 个位置的值 <span class="math inline">\(&lt; x\)</span>，<span class="math inline">\(n\)</span> 个数总和 <span class="math inline">\(\le S\)</span> 的方案数。</p><p>于是问题变成了求在 <span class="math inline">\(n\)</span> 个位置中选出 <span class="math inline">\(m\)</span> 个位置使得这 <span class="math inline">\(m\)</span> 个位置的值 <span class="math inline">\(\ge a\)</span>，其余 <span class="math inline">\(n-m\)</span> 个位置的值 <span class="math inline">\(&lt; b\)</span>，<span class="math inline">\(n\)</span> 个数总和 <span class="math inline">\(\le S\)</span> 的方案数。</p><p>发现隔板法可以解决的问题的条件是形如 <span class="math inline">\(a_i\ge lim_i\)</span> 这样的，于是我们把 <span class="math inline">\(&lt; b\)</span> 的部分容斥成这个形式。于是我们强制 <span class="math inline">\(i\)</span> 个位置 <span class="math inline">\(\ge b\)</span>，其他位置随便选。</p><p>问题变成了求在 <span class="math inline">\(n\)</span> 个位置中选出 <span class="math inline">\(m\)</span> 个位置使得这 <span class="math inline">\(m\)</span> 个位置的值 <span class="math inline">\(\ge a\)</span>，在剩余 <span class="math inline">\(n-m\)</span> 个位置中选 <span class="math inline">\(i\)</span> 个，使得这 <span class="math inline">\(i\)</span> 个位置的值 <span class="math inline">\(\ge b\)</span>，其他 <span class="math inline">\(n-m-i\)</span> 个位置的值 <span class="math inline">\(\ge 0\)</span>，总和 <span class="math inline">\(\le S\)</span> 的方案数。这个问题的答案就是 <span class="math inline">\(C_{n-m}^i\times C_{S-ma-ib+n}^n\)</span>。再乘上容斥系数 <span class="math inline">\((-1)^i\)</span> 即可。</p><p>由于需要保证 <span class="math inline">\(ix\le S\)</span>，复杂度是一个调和级数的形式，所以复杂度是 <span class="math inline">\(O(S\log S)\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 600005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, fac[N], inv[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123; (a += b) &gt;= P ? a -= P : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123; (a -= b) &lt; <span class="number">0</span> ? a += P : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> (a += b) &gt;= P ? a - P : a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> (a -= b) &lt; <span class="number">0</span> ? a + P : a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = P - <span class="number">2</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1l</span>l * a * a % P) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1l</span>l * s * a % P;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    inv[n] = qpow(fac[n]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i) inv[i - <span class="number">1</span>] = <span class="number">1l</span>l * inv[i] * i % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * fac[n] * inv[m] % P * inv[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt;= n - m &amp;&amp; t &lt;= S; t += r, ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1l</span>l * C(n - m, i) * C(S - t + n, n) % P;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) dec(res, s); <span class="keyword">else</span> inc(res, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * res * C(n, m) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = C(S + n, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i * m &lt;= S; ++i)</span><br><span class="line">        dec(res, minus(get(S - i * m, i), get(S - (i + <span class="number">1</span>) * m, i)));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), m = read(), l = read(), r = read();</span><br><span class="line">    init(n + r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, minus(solve(r), solve(l - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> JSC 2019 Qual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AtCoder」「JSC 2019 Qual E」Card Collector</title>
      <link href="/atcoder-jsc19qualE-sol/"/>
      <url>/atcoder-jsc19qualE-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_e" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>一个 <span class="math inline">\(H\times W\)</span> 的矩阵，有 <span class="math inline">\(n\)</span> 个位置有卡片，每张卡片上有个数字 <span class="math inline">\(a_i\)</span>。你可以在每行拿走一张卡片，然后在每列拿走一张卡片，求拿走的卡片的 <span class="math inline">\(a_i\)</span> 之和的最大值。</p><p><span class="math inline">\(1\le H,W,n,a_i\le 10^5\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>假设有 <span class="math inline">\(H+W\)</span> 个点，第 <span class="math inline">\(1\sim H\)</span> 个点表示行，第 <span class="math inline">\(H+1\sim H+W\)</span> 个点表示列。第 <span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 列的卡片对应一条 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(H+j\)</span> 的边，边权为卡片上的数字。我们把所有拿走的卡片对应的边拿出来，显然会形成一个环套树森林。简单证明一下：</p><blockquote><p>假设边是有向的，在第 <span class="math inline">\(i\)</span> 行选了第 <span class="math inline">\(j\)</span> 列的卡片，则选择 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(H+j\)</span> 的有向边；在第 <span class="math inline">\(i\)</span> 列选了第 <span class="math inline">\(j\)</span> 行的卡片，则选择 <span class="math inline">\(H+i\)</span> 到 <span class="math inline">\(j\)</span> 的有向边。那么每个点有且仅有一条出边，所以这是一个环套内向树森林。忽略边的方向，则是环套树森林。</p></blockquote><p>相当于我们要求出一个原图的边权之和最大的“生成环套树森林”。用类似于求最大生成树的 Kruskal 算法贪心选边即可。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, h, w, fa[<span class="number">200005</span>], g[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> r, c, v;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v &gt; rhs.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : (fa[x] = find(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x = find(x), y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">if</span> (g[x]) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">return</span> g[x] = <span class="number">1</span>, <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (g[x] &amp;&amp; g[y]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fa[y] = x, g[x] |= g[y], <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), h = read(), w = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i].r = read(), a[i].c = read(), a[i].v = read();</span><br><span class="line">    <span class="built_in">std</span> :: sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h + w; ++i) fa[i] = i, g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (merge(a[i].r, a[i].c + h)) ans += a[i].v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> JSC 2019 Qual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AtCoder」「JSC 2019 Qual D」Classified</title>
      <link href="/atcoder-jsc19qualD-sol/"/>
      <url>/atcoder-jsc19qualD-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_d" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>有一张 <span class="math inline">\(n\)</span> 个点的无向完全图 <span class="math inline">\(G=(V,E)\)</span>，你需要给每条边定一个正整数权值，使得<strong>不存在</strong>一条<strong>回路</strong>满足这条回路上的所有边权相等且回路长度为奇数。</p><p>你需要最小化最大的权值。请你输出一个解。</p><p><span class="math inline">\(n\le 500\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>题目里的条件相当于对于每一个权值 <span class="math inline">\(x\)</span>，记 <span class="math inline">\(E&#39;\)</span> 为所有边权等于 <span class="math inline">\(x\)</span> 的边组成的边集，满足 <span class="math inline">\(G&#39;=(V,E&#39;)\)</span> 是二分图。我们把 <span class="math inline">\(G&#39;\)</span> 叫做权值为 <span class="math inline">\(x\)</span> 的子图。</p><p>先猜一个结论，假设边权的最大值为 <span class="math inline">\(k\)</span>，则最大的有解的 <span class="math inline">\(n\)</span> 为 <span class="math inline">\(2^k\)</span>。用数学归纳法可以证明：</p><blockquote><p>显然 <span class="math inline">\(k=1,n=2\)</span> 是有解的，<span class="math inline">\(k=1,n=3\)</span> 是无解的。 假设我们已经证明了 <span class="math inline">\(k=t-1,n=2^{t-1}\)</span> 是有解的，<span class="math inline">\(k=t-1,n=2^{t-1}+1\)</span> 是无解的，我们要证明 <span class="math inline">\(k=t,n=2^t\)</span> 是有解的，<span class="math inline">\(k=t,n=2^t+1\)</span> 是无解的。 <span class="math inline">\(k=t,n=2^t\)</span> 是有解的很好证明，我们只要把这 <span class="math inline">\(n\)</span> 个点分成两个大小为 <span class="math inline">\(2^{t-1}\)</span> 的集合，两个集合之间的边边权为 <span class="math inline">\(t\)</span>，然后只要使得两个集合内部的边边权最大值为 <span class="math inline">\(t-1\)</span>，则权值为 <span class="math inline">\(t\)</span> 的子图已经符合条件。而对于两个集合，变成了两个相同的子问题，即 <span class="math inline">\(k=t-1,n=2^{t-1}\)</span>，我们已经证明了这是有解的，所以 <span class="math inline">\(k=t,n=2^t\)</span> 也是有解的。 <span class="math inline">\(k=t,n=2^t+1\)</span> 是无解的也很好证明。假设它是有解的，那么答案中权值为 <span class="math inline">\(t\)</span> 的子图一定是二分图且这个二分图的两个集合分别有解。由于总点数是 <span class="math inline">\(2^t+1\)</span>，那么这个二分图的两个集合中一定有一个集合大小 <span class="math inline">\(\ge 2^{t-1}+1\)</span>。已经证明 <span class="math inline">\(k=t-1,n=2^{t-1}+1\)</span> 是无解的，与“这个二分图的两个集合分别有解”矛盾，所以 <span class="math inline">\(k=t,n=2^t+1\)</span> 是无解的。</p></blockquote><p>所以答案为 <span class="math inline">\(\lceil \log_2 n\rceil\)</span>。考虑构造一个解。我们只要按照一个点的编号二进制下从右往左的第 <span class="math inline">\(\lceil \log_2 n\rceil\)</span> 位是 <span class="math inline">\(0\)</span> 还是 <span class="math inline">\(1\)</span> 分成两个集合，这两个集合之间的边边权设为 <span class="math inline">\(\lceil \log_2 n\rceil\)</span>，然后递归处理。</p><p>我们发现，两个点 <span class="math inline">\(i,j\)</span> 的边的边权其实就是 <span class="math inline">\(i\)</span> 与 <span class="math inline">\(j\)</span> 最高的不同的位从右往左的编号，也就是 <span class="math inline">\(\lfloor \log_2 (i \text{ xor }j)\rfloor+1\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, Log[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    Log[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n * <span class="number">2</span>; ++i) Log[i] = Log[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, Log[i ^ j] + <span class="number">1</span>), <span class="built_in">putchar</span>(<span class="string">" \n"</span>[j == n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> JSC 2019 Qual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AtCoder」「JSC 2019 Qual C」Cell Inversion</title>
      <link href="/atcoder-jsc19qualC-sol/"/>
      <url>/atcoder-jsc19qualC-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_c" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>有 <span class="math inline">\(2n\)</span> 个格子，每个格子初始为黑色或白色。你需要执行恰好 <span class="math inline">\(n\)</span> 次操作，使得最后所有格子变成白色。每次操作你可以选择两个从未选择过的格子 <span class="math inline">\(l,r (l &lt; r)\)</span>，然后将区间 <span class="math inline">\([l,r]\)</span> 的所有格子的颜色取反，即黑色的格子变成白色，白色的格子变成黑色。求方案数 <span class="math inline">\(\bmod 10^9+7\)</span> 的值。</p><p>两个方案不同当且仅当存在一个 <span class="math inline">\(i\in [1,n]\)</span>，满足第 <span class="math inline">\(i\)</span> 次操作选择的两个格子至少有一个不同。</p><p><span class="math inline">\(n\le 10^5\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>我们发现，操作的顺序与最后结果无关，于是我们强制 <span class="math inline">\(l\)</span> 从小到大，最后乘上 <span class="math inline">\(m!\)</span> 即可。</p><p>从左往右对于每个格子 <span class="math inline">\(i\)</span>，设 <span class="math inline">\(m\)</span> 次操作中有 <span class="math inline">\(x\)</span> 个操作 <span class="math inline">\(l &lt; r &lt; i\)</span>，有 <span class="math inline">\(y\)</span> 个操作 <span class="math inline">\(l &lt; i\le r\)</span>，那么有 <span class="math inline">\(y=i-1-2x\)</span>，所以 <span class="math inline">\(y\)</span> 与 <span class="math inline">\(i-1\)</span> 的奇偶性相同，于是可以直接判断 <span class="math inline">\(y\)</span> 的奇偶性。若 <span class="math inline">\(y\)</span> 是偶数，那么执行完所有 <span class="math inline">\(l &lt; i\)</span> 的操作后，<span class="math inline">\(i\)</span> 的颜色不会变化，此时若 <span class="math inline">\(i\)</span> 是黑色，那么一定存在一个操作 <span class="math inline">\(l = i &lt; r\)</span>，否则一定不存在，即一定存在一个操作 <span class="math inline">\(l &lt; i = r\)</span>。<span class="math inline">\(y\)</span> 为偶数同理。</p><p>经过上述处理，我们已经知道了每个格子是作为 <span class="math inline">\(l\)</span> 被选择还是作为 <span class="math inline">\(r\)</span> 被选择。</p><p>我们又发现，两个操作 <span class="math inline">\(l_1,r_1\)</span> 和 <span class="math inline">\(l_2,r_2\)</span>（<span class="math inline">\(l_1 &lt; r_2,l_2 &lt; r_1\)</span>），变成 <span class="math inline">\(l_1,r_2\)</span> 和 <span class="math inline">\(l_2,r_1\)</span> 结果也是不变的。</p><p>那么我们只要把所有左端点和右端点任意匹配即可。对于每个作为右端点的 <span class="math inline">\(i\)</span>，记 <span class="math inline">\([1,i-1]\)</span> 中作为左端点的点的数量减去作为右端点的点的数量为 <span class="math inline">\(d\)</span>，即多余的左端点个数，那么 <span class="math inline">\(i\)</span> 可以与这 <span class="math inline">\(d\)</span> 个左端点中的任意一个进行匹配，答案乘上 <span class="math inline">\(d\)</span>。最后再乘上 <span class="math inline">\(m!\)</span> 即可。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n, d, ans;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); ++i)</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) ^ (s[i] == <span class="string">'B'</span>)) s[i] = <span class="string">'R'</span>; <span class="keyword">else</span> s[i] = <span class="string">'L'</span>;</span><br><span class="line">    ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); ++i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'L'</span>) ++d;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!d) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>), <span class="number">0</span>;</span><br><span class="line">            ans = <span class="number">1l</span>l * ans * d % P, --d;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (d) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = <span class="number">1l</span>l * ans * i % P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> JSC 2019 Qual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「LOJ 6079」「2017 山东一轮集训 Day7」养猫</title>
      <link href="/loj6079-sol/"/>
      <url>/loj6079-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6079" target="_blank" rel="noopener">LOJ 6079</a></p><a id="more"></a><h2 id="题解">题解</h2><p><span class="math inline">\(n\le 1000\)</span>，还要输出方案，容易想到网络流。首先我们假设每个时刻都选 <code>S</code>，记 <span class="math inline">\(a_i=s_i-e_i\)</span>，那么问题变成了调整若干个时刻 <span class="math inline">\(j\)</span>，对于每个长度为 <span class="math inline">\(k\)</span> 的区间，调整的时刻数量 <span class="math inline">\(x\)</span> 应该满足 <span class="math inline">\(me\le x\le k-ms\)</span>，在这个前提下，使得 <span class="math inline">\(a_j\)</span> 之和尽量小。</p><p>考虑这样一个建模方法：源点 <span class="math inline">\(S\)</span> 向某个点 <span class="math inline">\(P\)</span> 连 <span class="math inline">\((k-ms,0)\)</span> 的边（<span class="math inline">\((x,y)\)</span> 表示流量上界为 <span class="math inline">\(x\)</span>，费用为 <span class="math inline">\(y\)</span> 的边，下同），点 <span class="math inline">\(P\)</span> 向 <span class="math inline">\([1,k]\)</span> 的点连 <span class="math inline">\((\infty,0)\)</span> 的边，点 <span class="math inline">\(i\)</span> 向 <span class="math inline">\(i+1\)</span> 连 <span class="math inline">\((k-ms-me,0)\)</span> 的边，<span class="math inline">\(i\)</span> 向 <span class="math inline">\(i+k\)</span> 连 <span class="math inline">\((1,a_i)\)</span> 的边（<span class="math inline">\(i+1,i+k&gt;n\)</span> 时则向汇点 <span class="math inline">\(T\)</span> 连边）。然后跑最小费用最大流的结果就是答案。</p><p>考虑这样建模为什么是对的。显然流只会从编号小的点流向编号大的点。我们假设从小到大处理每一个点 <span class="math inline">\(i\)</span>，处理过的点已经满足流量平衡，未处理的点则把入流先“屯”着。有入流的点说明这个点需要调整。对于当前要处理的点 <span class="math inline">\(i\)</span>，我们发现这个点“屯”着的流量就是 <span class="math inline">\([i,i+k-1]\)</span> 这个区间中还能放的点数，已经有入流的点属于已经确定的点。由于总流量是 <span class="math inline">\(k-ms\)</span>，而每个长度为 <span class="math inline">\(k\)</span> 的区间只考虑 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(i+1\)</span> 的边只能流出 <span class="math inline">\(k-ms-me\)</span> 的流量，所以一定会有至少 <span class="math inline">\(me\)</span> 个点被调整。（这一段是我自己yy的）</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">2005</span>, M = <span class="number">10005</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> S, T, edge, to[M], pr[M], cap[M], cost[M], hd[N];</span><br><span class="line">    Graph()&#123; edge = <span class="number">0</span>, <span class="built_in">memset</span>(hd, <span class="number">-1</span>, <span class="keyword">sizeof</span> hd); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        to[edge] = v, cap[edge] = w, cost[edge] = c, pr[edge] = hd[u], hd[u] = edge++;</span><br><span class="line">        to[edge] = u, cap[edge] = <span class="number">0</span>, cost[edge] = -c, pr[edge] = hd[v], hd[v] = edge++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> h, t, Q[<span class="number">1000005</span>], vis[N], mn[N], pre[N];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dis[N];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis), <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        h = <span class="number">0</span>, t = <span class="number">1</span>, Q[t] = S, dis[S] = <span class="number">0</span>, vis[S] = <span class="number">1</span>, pre[S] = <span class="number">0</span>, mn[S] = INF;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; t)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q[++h]; vis[u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; ~i; i = pr[i])</span><br><span class="line">                <span class="keyword">if</span> (cap[i] &amp;&amp; dis[u] + cost[i] &lt; dis[v = to[i]])&#123;</span><br><span class="line">                    dis[v] = dis[u] + cost[i], mn[v] = <span class="built_in">std</span> :: min(mn[u], cap[i]), pre[v] = i;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[v]) Q[++t] = v, vis[v] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[T] != dis[N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">int</span> _S, <span class="keyword">int</span> _T)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        S = _S, T = _T;</span><br><span class="line">        <span class="keyword">while</span> (SPFA())&#123;</span><br><span class="line">            res += mn[T] * dis[T];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = T; i != S; i = to[pre[i] ^ <span class="number">1</span>])</span><br><span class="line">                cap[pre[i]] -= mn[T], cap[pre[i] ^ <span class="number">1</span>] += mn[T];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;G;</span><br><span class="line"><span class="keyword">int</span> n, k, ms, me, a[<span class="number">1005</span>], E[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), k = read(), ms = read(), me = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read(), sum += a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] -= read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        G.addedge(i, i + <span class="number">1</span>, k - ms - me, <span class="number">0</span>);</span><br><span class="line">        E[i] = G.edge;</span><br><span class="line">        G.addedge(i, <span class="built_in">std</span> :: min(i + k, n + <span class="number">1</span>), <span class="number">1</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) G.addedge(<span class="number">0</span>, i, Graph :: INF, <span class="number">0</span>);</span><br><span class="line">    G.addedge(n + <span class="number">2</span>, <span class="number">0</span>, k - ms, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sum - G.MinCostMaxFlow(n + <span class="number">2</span>, n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (G.cap[E[i]]) <span class="built_in">putchar</span>(<span class="string">'S'</span>); <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'E'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> LOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「LOJ 6068」「2017 山东一轮集训 Day4」棋盘</title>
      <link href="/loj6068-sol/"/>
      <url>/loj6068-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6068" target="_blank" rel="noopener">LOJ 6068</a></p><a id="more"></a><h2 id="题解">题解</h2><p>这类棋盘上放棋子的问题，且根据这个数据范围，很容易想到网络流。</p><p>棋子的攻击方式有两种，我们先考虑同一行。我们把一行中极大的连续的 <code>.</code> 组成的区间叫做行连通块。显然不同的行连通块之间是互不影响的。对于同一个行连通块，假设当前已经有 <span class="math inline">\(x\)</span> 个棋子，那么再放入一个棋子后就会对答案产生 <span class="math inline">\(x\)</span> 的贡献。同理我们可以定义列连通块，也同样具有行连通块的性质。显然，每个 <code>.</code> 唯一地属于一个行连通块和列连通块。</p><p>那么就有一个初步的建模思路：建立两排点，左边是所有行连通块，右边是所有列连通块，源点 <span class="math inline">\(S\)</span> 向行连通块连边，列连通块向汇点 <span class="math inline">\(T\)</span> 连边，对于每个是 <code>.</code> 的位置，我们把包含它的行连通块向包含它的列连通块连边。</p><p>假设放入一个棋子对应 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 的一个单位的流量，那么这条路径上边上的费用之和应该是放入这个棋子对答案产生的贡献。对于一个行连通块 <span class="math inline">\(i\)</span>，假设它的大小为 <span class="math inline">\(sz_i\)</span>，那么应该从 <span class="math inline">\(S\)</span> 向 <span class="math inline">\(i\)</span> 连 <span class="math inline">\(sz_i\)</span> 条边，第 <span class="math inline">\(j\)</span> 条边的费用是 <span class="math inline">\(j-1\)</span>，流量上界是 <span class="math inline">\(1\)</span>，这样就能保证第 <span class="math inline">\(j\)</span> 次在这个行连通块放旗子时贡献是 <span class="math inline">\(j-1\)</span>。列连通块同理。行连通块向列连通块连的边费用为 <span class="math inline">\(0\)</span>，流量上界为 <span class="math inline">\(1\)</span>。</p><p>于是问题变成了求流量恰好为 <span class="math inline">\(k\)</span> 时的最小费用。可以发现，在跑费用流时，每次跑 SPFA 增广流量只会恰好增加 <span class="math inline">\(1\)</span>，于是在跑费用流时从小到大求出每个 <span class="math inline">\(k\)</span> 的答案即可。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">5005</span>, M = <span class="number">100005</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> S, T, edge, to[M], pr[M], cap[M], cost[M], hd[N];</span><br><span class="line">    Graph()&#123; edge = <span class="number">0</span>, <span class="built_in">memset</span>(hd, <span class="number">-1</span>, <span class="keyword">sizeof</span> hd); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        to[edge] = v, cap[edge] = w, cost[edge] = c, pr[edge] = hd[u], hd[u] = edge++;</span><br><span class="line">        to[edge] = u, cap[edge] = <span class="number">0</span>, cost[edge] = -c, pr[edge] = hd[v], hd[v] = edge++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> h, t, Q[<span class="number">1000005</span>], dis[N], vis[N], mn[N], pre[N];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis), <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        h = <span class="number">0</span>, t = <span class="number">1</span>, Q[t] = S, dis[S] = <span class="number">0</span>, vis[S] = <span class="number">1</span>, pre[S] = <span class="number">0</span>, mn[S] = INF;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; t)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q[++h]; vis[u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; ~i; i = pr[i])</span><br><span class="line">                <span class="keyword">if</span> (cap[i] &amp;&amp; dis[u] + cost[i] &lt; dis[v = to[i]])&#123;</span><br><span class="line">                    dis[v] = dis[u] + cost[i], mn[v] = <span class="built_in">std</span> :: min(mn[u], cap[i]), pre[v] = i;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[v]) Q[++t] = v, vis[v] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[T] != INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; MinCostMaxFlow(<span class="keyword">int</span> _S, <span class="keyword">int</span> _T)&#123;</span><br><span class="line">        <span class="built_in">std</span> :: <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(<span class="number">0</span>), S = _S, T = _T;</span><br><span class="line">        <span class="keyword">while</span> (SPFA())&#123;</span><br><span class="line">            res.push_back(res[res.size() - <span class="number">1</span>] + dis[T]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = T; i != S; i = to[pre[i] ^ <span class="number">1</span>])</span><br><span class="line">                cap[pre[i]] -= mn[T], cap[pre[i] ^ <span class="number">1</span>] += mn[T];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;G;</span><br><span class="line"><span class="keyword">int</span> n, q, cnt, cntr, cntc, rbel[<span class="number">55</span>][<span class="number">55</span>], cbel[<span class="number">55</span>][<span class="number">55</span>], sz[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a[i] + <span class="number">1</span>);</span><br><span class="line">    cntr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sz[cntr]) ++cntr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == <span class="string">'.'</span>) rbel[i][j] = cntr, ++sz[cntr];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sz[cntr]) ++cntr;</span><br><span class="line">    &#125;</span><br><span class="line">    cntc = cntr + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sz[cntc]) ++cntc;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[j][i] == <span class="string">'.'</span>) cbel[j][i] = cntc, ++sz[cntc];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sz[cntc]) ++cntc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntr; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz[i]; ++j)</span><br><span class="line">            G.addedge(<span class="number">0</span>, i, <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = cntr + <span class="number">1</span>; i &lt;= cntc; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz[i]; ++j)</span><br><span class="line">            G.addedge(i, cntc + <span class="number">1</span>, <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == <span class="string">'.'</span>) G.addedge(rbel[i][j], cbel[i][j], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    ans = G.MinCostMaxFlow(<span class="number">0</span>, cntc + <span class="number">1</span>);</span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span> (q--) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[read()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> LOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「LOJ 6073」「2017 山东一轮集训 Day5」距离</title>
      <link href="/loj6073-sol/"/>
      <url>/loj6073-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6073" target="_blank" rel="noopener">LOJ 6073</a></p><a id="more"></a><h2 id="题解">题解</h2><p>建议先做下这题的弱弱弱弱弱化版：<a href="https://loj.ac/problem/2558" target="_blank" rel="noopener">LOJ #2558. 「LNOI2014」LCA</a>。</p><p>设 <span class="math inline">\(dis_i\)</span> 表示根到 <span class="math inline">\(i\)</span> 的路径上的边权之和，<span class="math inline">\(dep_i\)</span> 表示根到 <span class="math inline">\(i\)</span> 的路径上的点数，答案可以表示成</p><p><span class="math display">\[\begin{aligned}\sum_{i\in \text{path}(u,v)}\text{dist}(p_i,k)&amp;=\sum_{i\in \text{path}(u,v)} \left(dis_{p_i}+dis_k-2dis_{\text{LCA}(p_i,k)}\right)\\&amp;=\left(dep_u+dep_v-2dep_{\text{LCA}(u,v)}+1\right)dis_k\\&amp;+\sum_{i\in \text{path}(u,v)} dis_{p_i}-2\sum_{i\in \text{path}(u,v)}dis_{\text{LCA}(p_i,k)}\end{aligned}\]</span></p><p>这个式子的第一项可以在预处理 <span class="math inline">\(dep_i,dis_i\)</span> 后快速计算，第二项可以预处理根到 <span class="math inline">\(i\)</span> 的路径上所有 <span class="math inline">\(dis_j\)</span> 之和（记为 <span class="math inline">\(sumd_i\)</span>）然后快速计算，关键是最后一项，即计算</p><p><span class="math display">\[\sum_{i\in \text{path}(u,v)}dis_{\text{LCA}(p_i,k)}\]</span></p><p>的值。</p><p>联系 <a href="https://loj.ac/problem/2558" target="_blank" rel="noopener">LOJ #2558. 「LNOI2014」LCA</a> 的做法，我们有了一个初步的暴力做法：</p><p>我们设 <span class="math inline">\(w_i\)</span> 表示 <span class="math inline">\(i\)</span> 与它父亲的边的边权，对于 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 路径上的每个点 <span class="math inline">\(i\)</span>，我们把 <span class="math inline">\(p_i\)</span> 到根的路径上所有点 <span class="math inline">\(j\)</span> 的“点权”加 <span class="math inline">\(w_j\)</span>，某个点的“点权”初始为 <span class="math inline">\(0\)</span>。然后，我们查询根到 <span class="math inline">\(k\)</span> 路径上所有点的“点权和”，这个值即为上面式子的值。</p><p>考虑优化这个暴力。与 <a href="https://loj.ac/problem/2558" target="_blank" rel="noopener">LOJ #2558. 「LNOI2014」LCA</a> 相似，我们可以差分。我们把 <span class="math inline">\(p_i\)</span> 到根的路径上所有点 <span class="math inline">\(j\)</span> 的“点权”加 <span class="math inline">\(w_j\)</span> 这样的一次操作叫做对点 <span class="math inline">\(i\)</span> 的一次操作。那么显然答案可以差分成对 <span class="math inline">\(u\)</span> 到根路径上每个点进行一次操作后的 <span class="math inline">\(k\)</span> 到根路径上的“点权”和，加上对 <span class="math inline">\(v\)</span> 到根路径上每个点进行一次操作后的 <span class="math inline">\(k\)</span> 到根路径上的“点权”和，减去对 <span class="math inline">\(\text{LCA}(u,v)\)</span> 到根路径上每个点进行一次操作后的 <span class="math inline">\(k\)</span> 到根路径上的“点权”和，减去对 <span class="math inline">\(\text{LCA}(u,v)\)</span> 的父亲到根路径上每个点进行一次操作后的 <span class="math inline">\(k\)</span> 到根路径上的“点权”和。注意上面四个操作都是在初始状态下进行的，并不是从上一个操作继承下来的。</p><p>四个操作我们可以对每个节点维护一棵线段树，第 <span class="math inline">\(i\)</span> 个点的线段树维护对 <span class="math inline">\(i\)</span> 到根路径上每个点进行一次操作后的区间的“点权”之和，注意这里的区间是指树剖后 DFS 序上的区间。求 <span class="math inline">\(k\)</span> 到根路径上的点权和可以树链剖分后在线段树上 <span class="math inline">\(O(\log^2n)\)</span> 得到。每个点的线段树可以从它父亲那里继承过来，即可持久化线段树，注意这里需要支持可持久化的区间修改、区间查询，线段树的写法与普通线段树有一些区别。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">int</span> type, n, q, p[N];</span><br><span class="line"><span class="keyword">int</span> edge, to[N &lt;&lt; <span class="number">1</span>], tw[N &lt;&lt; <span class="number">1</span>], pr[N &lt;&lt; <span class="number">1</span>], hd[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    to[++edge] = v, tw[edge] = w, pr[edge] = hd[u], hd[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[N], pre[N], sumd[N], ans;</span><br><span class="line"><span class="keyword">int</span> fa[N], sz[N], dep[N], son[N], top[N], idx, dfn[N], id[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dep[u] = dep[fa[u]] + <span class="number">1</span>, sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa[u])</span><br><span class="line">            fa[v] = u, dis[v] = dis[u] + tw[i], dfs(v), sz[u] += sz[v], </span><br><span class="line">            !son[u] || sz[v] &gt; sz[son[u]] ? son[u] = v : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp, dfn[u] = ++idx, id[idx] = u, pre[idx] = dis[u] - dis[fa[u]];</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs(son[u], tp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa[u] &amp;&amp; v != son[u]) dfs(v, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chairman_Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt, ls[N * <span class="number">150</span>], rs[N * <span class="number">150</span>], lz[N * <span class="number">150</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum[N * <span class="number">150</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> _u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        u = ++cnt, ls[u] = ls[_u], rs[u] = rs[_u], sum[u] = sum[_u], lz[u] = lz[_u];</span><br><span class="line">        <span class="keyword">if</span> (L == l &amp;&amp; r == R) <span class="keyword">return</span> ++lz[u], <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">        sum[u] += pre[R] - pre[L - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> md = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (R &lt;= md) modify(ls[u], ls[_u], l, md, L, R);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (L &gt; md) modify(rs[u], rs[_u], md + <span class="number">1</span>, r, L, R);</span><br><span class="line">        <span class="keyword">else</span> modify(ls[u], ls[_u], l, md, L, md), modify(rs[u], rs[_u], md + <span class="number">1</span>, r, md + <span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (L == l &amp;&amp; r == R) <span class="keyword">return</span> sum[u] + <span class="number">1l</span>l * lz[u] * (pre[R] - pre[L - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">1l</span>l * lz[u] * (pre[R] - pre[L - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> md = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (R &lt;= md) <span class="keyword">return</span> tmp + query(ls[u], l, md, L, R);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (L &gt; md) <span class="keyword">return</span> tmp + query(rs[u], md + <span class="number">1</span>, r, L, R);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> tmp + query(ls[u], l, md, L, md) + query(rs[u], md + <span class="number">1</span>, r, md + <span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="keyword">int</span> rt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _u = u;</span><br><span class="line">    u = p[u];</span><br><span class="line">    <span class="keyword">while</span> (top[u] != <span class="number">1</span>)&#123;</span><br><span class="line">        T.modify(rt[_u], rt[_u], <span class="number">1</span>, n, dfn[top[u]], dfn[u]);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    T.modify(rt[_u], rt[_u], <span class="number">1</span>, n, <span class="number">1</span>, dfn[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    rt[u] = rt[fa[u]], update(u), sumd[u] = sumd[fa[u]] + dis[p[u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa[u]) build(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) <span class="built_in">std</span> :: swap(u, v);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != <span class="number">1</span>)&#123;</span><br><span class="line">        res += T.query(rt, <span class="number">1</span>, n, dfn[top[u]], dfn[u]);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    res += T.query(rt, <span class="number">1</span>, n, <span class="number">1</span>, dfn[u]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    type = read();</span><br><span class="line">    n = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">        u = read(), v = read(), w = read(), addedge(u, v, w), addedge(v, u, w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) p[i] = read();</span><br><span class="line">    dfs(<span class="number">1</span>), dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pre[i] += pre[i - <span class="number">1</span>];</span><br><span class="line">    build(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read() ^ (type * ans), v = read() ^ (type * ans), k = read() ^ (type * ans);</span><br><span class="line">        <span class="keyword">int</span> l = lca(u, v);</span><br><span class="line">        ans = sumd[u] + sumd[v] - sumd[l] - sumd[fa[l]];</span><br><span class="line">        ans += <span class="number">1l</span>l * (dep[u] + dep[v] - dep[l] - dep[fa[l]]) * dis[k];</span><br><span class="line">        ans -= <span class="number">2</span> * (query(rt[u], k) + query(rt[v], k) - query(rt[l], k) - query(rt[fa[l]], k));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> LOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
            <tag> 可持久化线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「LOJ 6077」「2017 山东一轮集训 Day7」逆序对</title>
      <link href="/loj6077-sol/"/>
      <url>/loj6077-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6077" target="_blank" rel="noopener">LOJ 6077</a></p><a id="more"></a><h2 id="题解">题解</h2><p>考虑已经有一个 <span class="math inline">\([1,i-1]\)</span> 的排列，我们把 <span class="math inline">\(i\)</span> 这个数插进去，会使得逆序对数量加 <span class="math inline">\(x_i\)</span>，其中 <span class="math inline">\(x_i\in [0,i)\)</span>。那么问题转化成求 <span class="math inline">\(\sum_{i=1}^n x_i=k\)</span> 的解的数量，满足 <span class="math inline">\(\forall i\in [1,n]:0\le x_i &lt; i\)</span>。</p><p>考虑容斥，枚举不满足条件的位置个数 <span class="math inline">\(i\)</span> 和位置 <span class="math inline">\(p_1,p_2,p_3,\cdots,p_i\)</span>，那么问题变成了有若干个有 <span class="math inline">\(n\)</span> 个条件，其中有 <span class="math inline">\(i\)</span> 个条件是 <span class="math inline">\(x_{p_j}\ge p_j\)</span>，其他条件是 <span class="math inline">\(x_j\ge 0\)</span>。我们让 <span class="math inline">\(k\)</span> 减去 <span class="math inline">\(p_1+p_2+p_3+\cdots+p_i\)</span> 的值，就变成了一个经典的隔板法求不定方程非负整数解的数量的问题。即答案是</p><p><span class="math display">\[ans=\sum_{i=0}^{n}(-1)^i\sum_{p_1 &lt; p_2 &lt; p_3 &lt; \cdots &lt; p_i} C_{n-1+k-\sum_{j=1}^i p_j}^{n-1}\]</span></p><p>我们发现后面的组合数式子不需要关心 <span class="math inline">\(p_j\)</span> 具体的值，只需要知道 <span class="math inline">\(\sum_{j=1}^i p_j\)</span> 即可。于是我们枚举这个值，式子变成了</p><p><span class="math display">\[ans=\sum_{i=0}^n(-1)^i\sum_{j=0}^{k}F_{i,j}C_{k-j+n-1}^{n-1}\]</span></p><p>其中 <span class="math inline">\(F_{i,j}\)</span> 表示选 <span class="math inline">\(i\)</span> 个互不相同的数，且这些数在 <span class="math inline">\([1,n]\)</span> 的范围内，使得这 <span class="math inline">\(i\)</span> 个数和为 <span class="math inline">\(j\)</span> 的方案数。又可以注意到，因为 <span class="math inline">\(i\)</span> 个数要互不相同，所以当 <span class="math inline">\(j &lt; \frac{i(i+1)}{2}\)</span> 时，<span class="math inline">\(F_{i,j}=0\)</span>。又因为 <span class="math inline">\(j\)</span> 不能超过 <span class="math inline">\(k\)</span>，所以 <span class="math inline">\(i\)</span> 只需要枚举到 <span class="math inline">\(\lfloor\sqrt{2k}\rfloor\)</span> 即可。而组合数可以 <span class="math inline">\(O(n+k)\)</span> 预处理阶乘及阶乘的逆元，然后 <span class="math inline">\(O(1)\)</span> 计算。那么关键问题是如何求 <span class="math inline">\(F_{i,j}\)</span>。</p><p>这是经典的整数划分问题。假设当前有 <span class="math inline">\(i\)</span> 个数，和为 <span class="math inline">\(j\)</span>，那么有两种决策：</p><ol type="1"><li>把所有数加 <span class="math inline">\(1\)</span>，和变成了 <span class="math inline">\(i+j\)</span>；</li><li>在最前面加上一个数 <span class="math inline">\(1\)</span>，并把其他所有数加 <span class="math inline">\(1\)</span>，个数变成 <span class="math inline">\(i+1\)</span>，和变成 <span class="math inline">\(i+j+1\)</span>。</li></ol><p>可以证明所有方案都可以通过这两种变换唯一的遍历到。但是有些方案中会存在某个数大于 <span class="math inline">\(n\)</span> 的情况，需要减去。又因为所有数互不相同，且变换之前的方案是合法的，所以这个不合法的方案一定只会存在一个大于 <span class="math inline">\(n\)</span> 的数且这个数是 <span class="math inline">\(n+1\)</span>。那么这种不合法的方案数一定与去掉 <span class="math inline">\(n+1\)</span> 这个数后序列的方案数相等，直接减去即可。DP 的转移方程是</p><p><span class="math display">\[F_{i,j}=F_{i,j-i}+F_{i-1,j-i}-F_{i-1,j-n-1}\]</span></p><p>可以直接带上容斥系数，变成</p><p><span class="math display">\[F_{i,j}=F_{i,j-i}-F_{i-1,j-i}+F_{i-1,j-n-1}\]</span></p><p>处理完后直接计算即可。时间复杂度 <span class="math inline">\(O(n\sqrt{n})\)</span>。</p><p>还有一种用生成函数推导答案式子的方法，可以参考 <a href="https://blog.trisolaris.top/%E3%80%8Csdtt2017%E3%80%8Dinverse/" target="_blank" rel="noopener">Trisolaris's Blog</a>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n, k, fac[N &lt;&lt; <span class="number">1</span>], inv[N &lt;&lt; <span class="number">1</span>], t, F[<span class="number">455</span>][N], f[N], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    (a += b) &gt;= P ? a -= P : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    (a -= b) &lt; <span class="number">0</span> ? a += P : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = P - <span class="number">2</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1l</span>l * a * a % P) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1l</span>l * s * a % P;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + k; ++i) fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    inv[n + k] = qpow(fac[n + k]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n + k; i; --i) inv[i - <span class="number">1</span>] = <span class="number">1l</span>l * inv[i] * i % P;</span><br><span class="line">    t = <span class="built_in">std</span> :: min(n, <span class="keyword">int</span>(<span class="built_in">sqrt</span>(<span class="number">2</span> * k)) + <span class="number">1</span>);</span><br><span class="line">    F[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i * (i + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; j &lt;= k; ++j)&#123;</span><br><span class="line">            dec(F[i][j], F[i - <span class="number">1</span>][j - i]), inc(F[i][j], F[i][j - i]);</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= n + <span class="number">1</span>) inc(F[i][j], F[i - <span class="number">1</span>][j - n - <span class="number">1</span>]);</span><br><span class="line">            inc(f[j], F[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * fac[n] * inv[m] % P * inv[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), k = read();</span><br><span class="line">    init(n, k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) inc(ans, <span class="number">1l</span>l * f[i] * C(k - i + n - <span class="number">1</span>, n - <span class="number">1</span>) % P);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> LOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「LOJ 6066」「2017 山东一轮集训 Day3」第二题</title>
      <link href="/loj6066-sol/"/>
      <url>/loj6066-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6066" target="_blank" rel="noopener">LOJ 6066</a></p><a id="more"></a><h2 id="题解">题解</h2><p>答案具有单调性，于是二分 <span class="math inline">\(k\)</span>，问题转化成：</p><blockquote><p>是否存在两个点 <span class="math inline">\(u,v\)</span> 满足 <span class="math inline">\(u\)</span> 的 <span class="math inline">\(k-\)</span> 子树与 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(k-\)</span> 子树形态相同。</p></blockquote><p>解决这样的问题可以使用哈希，那么我们需要找到一种哈希的方式使得“形态”相同的树的哈希值相同，“形态”不同的树的哈希值不同。</p><p>由于节点标号与树的形态无关，儿子的顺序与树的形态有关，容易想到括号序列。于是问题变成：</p><blockquote><p>在以 <span class="math inline">\(u\)</span> 为根的子树对应的括号序列中，删去所有与 <span class="math inline">\(u\)</span> 距离 <span class="math inline">\(k+1\)</span> 的点为根的子树对应的括号序列后，求哈希值。</p></blockquote><p>由于每个点只会在 <span class="math inline">\(k+1\)</span> 级祖先处被遍历，所以求所有 <span class="math inline">\(k-\)</span> 子树的哈希值是 <span class="math inline">\(O(n)\)</span> 的。</p><p>求每个点的 <span class="math inline">\(k+1\)</span> 级祖先可以使用倍增做到 <span class="math inline">\(O(n\log n)\)</span> 或用长链剖分做到 <span class="math inline">\(O(n)\)</span>。</p><p>总时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><h2 id="代码">代码</h2><p>我使用了双哈希 + set 的方式进行判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Double_Hash&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>, B1 = <span class="number">233</span>, P1 = <span class="number">382538579</span>, B2 = <span class="number">331</span>, P2 = <span class="number">952959323</span>;</span><br><span class="line">    <span class="keyword">int</span> pw1[N], pw2[N];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> H1, H2;</span><br><span class="line">        node(<span class="keyword">int</span> _H1 = <span class="number">0</span>, <span class="keyword">int</span> _H2 = <span class="number">0</span>)&#123; H1 = _H1, H2 = _H2; &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> H1 == rhs.H1 &amp;&amp; H2 == rhs.H2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> H1 &lt; rhs.H1 || (H1 == rhs.H1 &amp;&amp; H2 &lt; rhs.H2);</span><br><span class="line">        &#125;</span><br><span class="line">        node <span class="keyword">operator</span> + (<span class="keyword">const</span> <span class="keyword">char</span> ch) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node((<span class="number">1l</span>l * H1 * B1 + ch) % P1, (<span class="number">1l</span>l * H2 * B2 + ch) % P2);</span><br><span class="line">        &#125;</span><br><span class="line">        node <span class="keyword">operator</span> + (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node((H1 + rhs.H1) % P1, (H2 + rhs.H2) % P2);</span><br><span class="line">        &#125;</span><br><span class="line">        node <span class="keyword">operator</span> - (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node((H1 - rhs.H1 + P1) % P1, (H2 - rhs.H2 + P2) % P2);</span><br><span class="line">        &#125;</span><br><span class="line">        node <span class="keyword">operator</span> &lt;&lt; (<span class="keyword">const</span> <span class="keyword">int</span> x) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node(<span class="number">1l</span>l * H1 * pw1[x] % P1, <span class="number">1l</span>l * H2 * pw2[x] % P2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;h[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n = N - <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        pw1[<span class="number">0</span>] = <span class="number">1</span>, pw2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            pw1[i] = <span class="number">1l</span>l * pw1[i - <span class="number">1</span>] * B1 % P1, pw2[i] = <span class="number">1l</span>l * pw2[i - <span class="number">1</span>] * B2 % P2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">node <span class="title">hash</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h[r] - (h[l - <span class="number">1</span>] &lt;&lt; (r - l + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) h[i] = h[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Double_Hash;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n, fa[N][<span class="number">20</span>], idx, l[N], r[N], dis[N];</span><br><span class="line"><span class="keyword">char</span> a[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N], po[N];</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">set</span>&lt;node&gt; S;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dis[u] = <span class="number">0</span>, l[u] = ++idx, a[idx] = <span class="number">23</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; ++i)</span><br><span class="line">        fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; son[u].size(); ++i)</span><br><span class="line">        v = son[u][i], fa[v][<span class="number">0</span>] = u, dfs(v), dis[u] = <span class="built_in">std</span> :: max(dis[u], dis[v] + <span class="number">1</span>);</span><br><span class="line">    r[u] = ++idx, a[idx] = <span class="number">97</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth_fa</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">18</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (k &gt;&gt; i &amp; <span class="number">1</span>) u = fa[u][i];</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) po[i].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        po[i].push_back(l[i]), po[i].push_back(r[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = kth_fa(i, k + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) po[p].push_back(l[i]), po[p].push_back(r[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">std</span> :: sort(po[i].begin(), po[i].end());</span><br><span class="line">    S.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (dis[i] &gt;= k)&#123;</span><br><span class="line">            node tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; po[i].size(); j += <span class="number">2</span>)</span><br><span class="line">                tmp = (tmp &lt;&lt; (po[i][j + <span class="number">1</span>] - po[i][j])) + hash(po[i][j], po[i][j + <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (S.count(tmp)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            S.insert(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) son[i].push_back(read());</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    pre(n &lt;&lt; <span class="number">1</span>), build(a, n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n, md, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) <span class="keyword">if</span> (check(md = (l + r) &gt;&gt; <span class="number">1</span>)) l = md + <span class="number">1</span>, ans = md; <span class="keyword">else</span> r = md - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> LOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 括号序列 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「LOJ 6074」「2017 山东一轮集训 Day6」子序列</title>
      <link href="/loj6074-sol/"/>
      <url>/loj6074-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6074" target="_blank" rel="noopener">LOJ 6074</a></p><a id="more"></a><h2 id="题解">题解</h2><p>设字符集大小为 <span class="math inline">\(m\)</span>，这里 <span class="math inline">\(m=9\)</span>，假设字符从 <span class="math inline">\(0\)</span> 开始标号。</p><p>显然可以 DP，设 <span class="math inline">\(dp_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 个字符中，以字符 <span class="math inline">\(j\)</span> 结尾的本质不同的子序列个数。特殊地，<span class="math inline">\(j=m\)</span> 表示子序列为空。有方程：</p><p><span class="math display">\[dp_{i,j}=\begin{cases}dp_{i-1,j} &amp; \text{ if } j\ne S_i \\ \sum_{k=0}^{m} dp_{i-1,k} &amp; \text{ if }j=S_i\end{cases}\]</span></p><p>初始值是 <span class="math inline">\(dp_{0,m}=1\)</span>。</p><p>发现 <span class="math inline">\(dp\)</span> 数组可以写成行向量，记</p><p><span class="math display">\[F_i=\begin{pmatrix}dp_{i,0} &amp; dp_{i,1} &amp; dp_{i,2} &amp; \cdots &amp; dp_{i,m}\end{pmatrix}\]</span></p><p>而转移可以表示为一个行向量乘上转移矩阵 <span class="math inline">\(M_i\)</span> 的形式：</p><p><span class="math display">\[\begin{aligned}M_i &amp;= \begin{pmatrix}1 &amp; &amp; 1 &amp; &amp; \\ &amp; 1 &amp; 1 &amp; &amp; \\ &amp; &amp; 1 &amp; &amp; \\ &amp; &amp; \vdots &amp; \ddots &amp; \\ &amp; &amp; 1 &amp; &amp; 1 \end{pmatrix} \\ F_i &amp;= F_{i-1}M_i\end{aligned}\]</span></p><p><span class="math inline">\(M_i\)</span> 是一个主对角线为 <span class="math inline">\(1\)</span>，<span class="math inline">\(S_i\)</span> 这一列为 <span class="math inline">\(1\)</span>，其余为 <span class="math inline">\(0\)</span> 的矩阵。</p><p>初始的行向量为</p><p><span class="math display">\[A=\begin{pmatrix}0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 1\end{pmatrix}\]</span></p><p>最后由于是求</p><p><span class="math display">\[\left(\sum_{i=0}^m dp_{n,i}\right)-1\]</span></p><p>所以最后需要乘上列向量</p><p><span class="math display">\[B=\begin{pmatrix}1 \\ 1 \\ 1 \\ \vdots \\ 1\end{pmatrix}\]</span></p><p>于是对于每个询问，答案可以表示成</p><p><span class="math display">\[\begin{aligned}ans&amp;=AM_lM_{l+1}M_{l+2}\cdots M_{r}B\\&amp;=AM_{l-1}^{-1}M_{l-2}^{-1}\cdots M_1^{-1}M_1M_2\cdots M_{r}B\end{aligned}\]</span></p><p>直接维护 <span class="math inline">\(M_i\)</span> 和 <span class="math inline">\(M_i^{-1}\)</span> 的前缀积（注意顺序），时间复杂度 <span class="math inline">\(O(nm^3+qm^3)\)</span>。</p><p>在维护完 <span class="math inline">\(M_i\)</span> 和 <span class="math inline">\(M_i^{-1}\)</span> 后，分别右乘一个 <span class="math inline">\(B\)</span> 和左乘一个 <span class="math inline">\(A\)</span>，这样询问部分的复杂度可以降到 <span class="math inline">\(O(qm)\)</span>。</p><p>预处理部分，我们来观察一些特殊性质。对于 <span class="math inline">\(M_i\)</span> 的前缀积，我们发现每次要算</p><p><span class="math display">\[\begin{aligned}CM_i&amp;=\begin{pmatrix}C_{0,0} &amp; C_{0,1} &amp; C_{0,2} &amp; \cdots &amp; C_{0,m} \\ C_{1,0} &amp; C_{1,1} &amp; C_{1,2} &amp; \cdots &amp; C_{1,m} \\ C_{2,0} &amp; C_{2,1} &amp; C_{2,2} &amp; \cdots &amp; C_{2,m} \\ &amp; &amp; &amp; \ddots &amp; \\ C_{m,0} &amp; C_{m,1} &amp; C_{m,2} &amp; \cdots &amp; C_{m,m} \end{pmatrix}\begin{pmatrix}1 &amp; &amp; 1 &amp; &amp; \\ &amp; 1 &amp; 1 &amp; &amp; \\ &amp; &amp; 1 &amp; &amp; \\ &amp; &amp; \vdots &amp; \ddots &amp; \\ &amp; &amp; 1 &amp; &amp; 1 \end{pmatrix} \\ &amp;= \begin{pmatrix}C_{0,0} &amp; C_{0,1} &amp; \sum_{j=0}^m C_{0,j} &amp; \cdots &amp; C_{0,m} \\ C_{1,0} &amp; C_{1,1} &amp; \sum_{j=0}^m C_{1,j} &amp; \cdots &amp; C_{1,m} \\ C_{2,0} &amp; C_{2,1} &amp; \sum_{j=0}^m C_{2,j} &amp; \cdots &amp; C_{2,m} \\ &amp; &amp; &amp; \ddots &amp; \\ C_{m,0} &amp; C_{m,1} &amp; \sum_{j=0}^m C_{m,j} &amp; \cdots &amp; C_{m,m} \end{pmatrix}\end{aligned}\]</span></p><p>相当于把 <span class="math inline">\(C\)</span> 的第 <span class="math inline">\(S_i\)</span> 列改成对应行的 <span class="math inline">\(C_{k,j}\)</span> 之和。且最后乘上 <span class="math inline">\(B\)</span> 相当于求每行的和。那么只要维护 <span class="math inline">\(C\)</span> 的每一行之和即可。于是维护 <span class="math inline">\(M_i\)</span> 的前缀积乘上 <span class="math inline">\(B\)</span> 的复杂度变成了 <span class="math inline">\(O(nm)\)</span>。</p><p>对于 <span class="math inline">\(M_i^{-1}\)</span> 的前缀积，我们先根据矩阵求逆的过程手动求出 <span class="math inline">\(M_i^{-1}\)</span>，发现</p><p><span class="math display">\[M_i^{-1}=\begin{pmatrix}1 &amp; &amp; -1 &amp; &amp; \\ &amp; 1 &amp; -1 &amp; &amp; \\ &amp; &amp; 1 &amp; &amp; \\ &amp; &amp; \vdots &amp; \ddots &amp; \\ &amp; &amp; -1 &amp; &amp; 1 \end{pmatrix}\]</span></p><p>即 <span class="math inline">\(M_i^{-1}\)</span> 是主对角线为 <span class="math inline">\(1\)</span>，第 <span class="math inline">\(S_i\)</span> 列除了第 <span class="math inline">\(S_i\)</span> 行外是 <span class="math inline">\(-1\)</span> 的矩阵。</p><p>维护 <span class="math inline">\(M_i^{-1}\)</span> 的前缀积时，我们要算</p><p><span class="math display">\[\begin{aligned}M_i^{-1}C&amp;=\begin{pmatrix}1 &amp; &amp; -1 &amp; &amp; \\ &amp; 1 &amp; -1 &amp; &amp; \\ &amp; &amp; 1 &amp; &amp; \\ &amp; &amp; \vdots &amp; \ddots &amp; \\ &amp; &amp; -1 &amp; &amp; 1 \end{pmatrix}\begin{pmatrix}C_{0,0} &amp; C_{0,1} &amp; C_{0,2} &amp; \cdots &amp; C_{0,m} \\ C_{1,0} &amp; C_{1,1} &amp; C_{1,2} &amp; \cdots &amp; C_{1,m} \\ C_{2,0} &amp; C_{2,1} &amp; C_{2,2} &amp; \cdots &amp; C_{2,m} \\ &amp; &amp; &amp; \ddots &amp; \\ C_{m,0} &amp; C_{m,1} &amp; C_{m,2} &amp; \cdots &amp; C_{m,m} \end{pmatrix} \\ &amp;= \begin{pmatrix}C_{0,0}-C_{2,0} &amp; C_{0,1}-C_{2,1} &amp; C_{0,2}-C_{2,2} &amp; \cdots &amp; C_{0,m}-C_{2,m} \\ C_{1,0}-C_{2,0} &amp; C_{1,1}-C_{2,1} &amp; C_{1,2}-C_{2,2} &amp; \cdots &amp; C_{1,m}-C_{2,m} \\ C_{2,0} &amp; C_{2,1} &amp; C_{2,2} &amp; \cdots &amp; C_{2,m} \\ &amp; &amp; &amp; \ddots &amp; \\ C_{m,0}-C_{2,0} &amp; C_{m,1}-C_{2,1} &amp; C_{m,2}-C_{2,2} &amp; \cdots &amp; C_{m,m}-C_{2,m} \end{pmatrix}\end{aligned}\]</span></p><p>可以发现，每一列除了 <span class="math inline">\(S_i\)</span> 这一行以外都减去的是同一个数，于是我们维护每一列减去的数，例如对于某一列</p><p><span class="math display">\[\begin{pmatrix}x_0-v \\ x_1-v \\ x_2-v \\ \vdots \\ x_m-v \end{pmatrix}\]</span></p><p>要变成</p><p><span class="math display">\[\begin{pmatrix}x_0-v-(x_2-v) \\ x_1-v-(x_2-v) \\ x_2-v \\ \vdots \\ x_m-v-(x_2-v) \end{pmatrix}==\begin{pmatrix}x_0-x_2 \\ x_1-x_2 \\ (2x_2-v)-x_2 \\ \vdots \\ x_m-x_2 \end{pmatrix}\]</span></p><p>于是只需要修改第 <span class="math inline">\(S_i\)</span> 那一行的值，并且更新每一列减去的值即可。</p><p>最后左乘 <span class="math inline">\(A\)</span> 相当于求最后一行的值。由于最后一行不会修改，始终是</p><p><span class="math display">\[\begin{pmatrix}0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 1\end{pmatrix}\]</span></p><p>所以直接减去对应列需要减的数即可。这一部分的时间复杂度也变成了 <span class="math inline">\(O(nm)\)</span>。</p><p>总时间复杂度 <span class="math inline">\(O(nm+qm)\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n, q, a[<span class="number">10</span>][<span class="number">10</span>], av[<span class="number">10</span>][<span class="number">10</span>], f[N][<span class="number">10</span>], fv[N][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a += b) &gt;= P ? a - P : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a -= b) &lt; <span class="number">0</span> ? a + P : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">        a[i][i] = av[i][i] = f[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++j)&#123;</span><br><span class="line">            f[i][j] = plus(minus(f[i - <span class="number">1</span>][j], a[j][t]), f[i - <span class="number">1</span>][j]);</span><br><span class="line">            a[j][t] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            fv[i][j] = av[t][j];</span><br><span class="line">            av[t][j] = minus(plus(av[t][j], av[t][j]), fv[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++j)</span><br><span class="line">            fv[i][j] = minus(j == <span class="number">9</span>, fv[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">islower</span>(s[++n] = getchar())) ;</span><br><span class="line">    --n;</span><br><span class="line">    init(n);</span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">            ans = plus(ans, <span class="number">1l</span>l * fv[l - <span class="number">1</span>][i] * f[r][i] % P);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, minus(ans, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> LOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 矩阵乘法 </tag>
            
            <tag> 矩阵求逆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「LOJ 6065」「2017 山东一轮集训 Day3」第一题</title>
      <link href="/loj6065-sol/"/>
      <url>/loj6065-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6065" target="_blank" rel="noopener">LOJ 6065</a></p><a id="more"></a><h2 id="题解">题解</h2><p>总的分为两种情况：<span class="math inline">\(1+1+2+2\)</span> 和 <span class="math inline">\(1+1+1+3\)</span>。</p><p>对于第一种情况，我们假设边长为 <span class="math inline">\(k\)</span>，<span class="math inline">\(6\)</span> 根棒子长度为 <span class="math inline">\(k,k,x_1,k-x_1,x_2,k-x_2\)</span>，并且强制 <span class="math inline">\(x_1\ge x_2\ge k-x_2\ge k-x_1\)</span>。</p><p>我们记 <span class="math inline">\(cnt_i\)</span> 表示长度为 <span class="math inline">\(i\)</span> 的棒子的数量，我们从小到大枚举 <span class="math inline">\(x_1\)</span>，同时维护 <span class="math inline">\(cntt_i\)</span> 表示在长度小于 <span class="math inline">\(x_1\)</span> 的棒子中选出两根拼成长度为 <span class="math inline">\(i\)</span> 的方案数。</p><p>具体计算的时候，为了避免算重，我们分三种情况进行计算：</p><ol type="1"><li><span class="math inline">\(x_1 &gt; x_2 &gt; k-x_2 &gt; k-x_1\)</span>，枚举 <span class="math inline">\(k\)</span>，方案数为 <span class="math inline">\(cnt_{x_1}\times cnt_{k-x_1}\times cntt_{k}\times C_{cnt_k}^2\)</span>；</li><li><span class="math inline">\(x_1 = x_2 &gt; k-x_2 = k-x_1\)</span>，同样枚举 <span class="math inline">\(k\)</span>，方案数为 <span class="math inline">\(C_{cnt_{x_1}}^2\times C_{cnt_{k-x_1}}^2\times C_{cnt_k}^2\)</span>；</li><li><span class="math inline">\(x_1 = x_2 = k-x_2 = k-x_1\)</span>，此时 <span class="math inline">\(k=2x_1\)</span>，方案数为 <span class="math inline">\(C_{cnt_{x_1}}^4\times C_{cnt_{2x_1}}^2\)</span>。</li></ol><p>对于第二种情况，假设棒子长度为 <span class="math inline">\(k,k,k,x_1,x_2,k-x_1-x_2\)</span>，强制 <span class="math inline">\(x_1\ge x_2\ge k-x_1-x_2\)</span>。</p><p>同样记录 <span class="math inline">\(cnt_i\)</span>，然后从小到大枚举 <span class="math inline">\(x_1\)</span>，同时记录 <span class="math inline">\(cntt_i\)</span>。</p><p>也分为三种情况：</p><ol type="1"><li><span class="math inline">\(x_1 &gt; x_2 &gt; k-x_1-x_2\)</span>，枚举 <span class="math inline">\(k\)</span>，方案数为 <span class="math inline">\(cnt_{x_1}\times cntt_{k-x_1}\times C_{cnt_k}^3\)</span>；</li><li><span class="math inline">\(x_1 = x_2 &gt; k-x_1-x_2\)</span>，枚举 <span class="math inline">\(k\)</span>，方案数为 <span class="math inline">\(C_{cnt_{x_1}}^2\times cnt_{k-2x_1}\times C_{cnt_k}^3\)</span>；</li><li><span class="math inline">\(x_1 = x_2 = k-x_1-x_2\)</span>，此时 <span class="math inline">\(k=3x_1\)</span>，方案数为 <span class="math inline">\(C_{cnt_{x_1}}^3\times C_{cnt_{3x_1}}^3\)</span>。</li></ol><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = getchar(), f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10000005</span></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], cnt[M], cntt[M];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123; <span class="keyword">return</span> x &lt; <span class="number">2</span> ? <span class="number">0</span> : x * (x - <span class="number">1</span>) / <span class="number">2</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C3</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123; <span class="keyword">return</span> x &lt; <span class="number">3</span> ? <span class="number">0</span> : x * (x - <span class="number">1</span>) * (x - <span class="number">2</span>) / <span class="number">6</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C4</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123; <span class="keyword">return</span> x &lt; <span class="number">4</span> ? <span class="number">0</span> : x * (x - <span class="number">1</span>) * (x - <span class="number">2</span>) * (x - <span class="number">3</span>) / <span class="number">24</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read(), ++cnt[a[i]];</span><br><span class="line">    <span class="built_in">std</span> :: sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    m = a[n];</span><br><span class="line">    n = <span class="built_in">std</span> :: unique(a + <span class="number">1</span>, a + <span class="number">1</span> + n) - a - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n &amp;&amp; a[j] - a[i] &lt; a[i]; ++j)</span><br><span class="line">            ans += <span class="number">1l</span>l * cntt[a[j]] * cnt[a[i]] * cnt[a[j] - a[i]] * C2(cnt[a[j]]),</span><br><span class="line">            ans += <span class="number">1l</span>l * C2(cnt[a[i]]) * C2(cnt[a[j] - a[i]]) * C2(cnt[a[j]]);</span><br><span class="line">        <span class="keyword">if</span> (a[i] * <span class="number">2</span> &lt;= m) ans += <span class="number">1l</span>l * C4(cnt[a[i]]) * C2(cnt[a[i] * <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">            ans += <span class="number">1l</span>l * C3(cnt[a[j]]) * cnt[a[i]] * cntt[a[j] - a[i]];</span><br><span class="line">            <span class="keyword">if</span> ((a[i] &lt;&lt; <span class="number">1</span>) &lt; a[j] &amp;&amp; a[j] &lt; a[i] * <span class="number">3</span>)</span><br><span class="line">                ans += <span class="number">1l</span>l * C3(cnt[a[j]]) * C2(cnt[a[i]]) * cnt[a[j] - (a[i] &lt;&lt; <span class="number">1</span>)];</span><br><span class="line">            <span class="keyword">if</span> (a[j] == a[i] * <span class="number">3</span>) ans += <span class="number">1l</span>l * C3(cnt[a[j]]) * C3(cnt[a[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[i] + a[j] &lt;= m) cntt[a[i] + a[j]] += cnt[a[i]] * cnt[a[j]];</span><br><span class="line">        <span class="keyword">if</span> ((a[i] &lt;&lt; <span class="number">1</span>) &lt;= m) cntt[a[i] &lt;&lt; <span class="number">1</span>] += C2(cnt[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> LOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「LOJ 6062」「2017 山东一轮集训 Day2」Pair</title>
      <link href="/loj6062-sol/"/>
      <url>/loj6062-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6062" target="_blank" rel="noopener">LOJ 6062</a></p><a id="more"></a><h2 id="题解">题解</h2><p>我们令 <span class="math inline">\(c_i=h-b_i\)</span>，并将序列 <span class="math inline">\(c\)</span> 从小到大排序。我们遍历 <span class="math inline">\(a\)</span> 的所有长度为 <span class="math inline">\(m\)</span> 的区间，将这个区间中的数从小到大排序后的第 <span class="math inline">\(i\)</span> 个数记为 <span class="math inline">\(d_i\)</span>。一个区间满足题目中的条件当且仅当 <span class="math inline">\(d_i\ge c_i\)</span>。</p><p>考虑离散，然后用权值线段树维护。记最大值为 <span class="math inline">\(t\)</span>，对于所有 <span class="math inline">\(c_i\)</span>，把线段树上 <span class="math inline">\([c_i,t]\)</span> 这段区间加 <span class="math inline">\(1\)</span>；对于当前区间中的所有 <span class="math inline">\(a_i\)</span>，把线段树上 <span class="math inline">\([a_i,t]\)</span> 这段区间减 <span class="math inline">\(1\)</span>，判断是否满足条件只需要判断线段树上是否有 <span class="math inline">\(&lt; 0\)</span> 的位置即可，这个可以维护最小值判断。正确性显然。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300005</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val[N &lt;&lt; <span class="number">2</span>], lz[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        val[u] = <span class="built_in">std</span> :: min(val[u &lt;&lt; <span class="number">1</span>], val[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        lz[u] += x, val[u] += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lz[u]) add(u &lt;&lt; <span class="number">1</span>, lz[u]), add(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, lz[u]), lz[u] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> add(u, x), <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> md = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        down(u);</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= md) modify(u &lt;&lt; <span class="number">1</span>, l, md, L, R, x);</span><br><span class="line">        <span class="keyword">if</span> (R &gt; md) modify(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, md + <span class="number">1</span>, r, L, R, x);</span><br><span class="line">        up(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> val[<span class="number">1</span>] &gt;= <span class="number">0</span>; &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="keyword">int</span> n, m, h, a[N], b[N], t, c[N], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), m = read(), h = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) b[i] = h - read(), c[++t] = b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read(), c[++t] = a[i];</span><br><span class="line">    <span class="built_in">std</span> :: sort(c + <span class="number">1</span>, c + <span class="number">1</span> + t);</span><br><span class="line">    t = <span class="built_in">std</span> :: unique(c + <span class="number">1</span>, c + <span class="number">1</span> + t) - c - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        b[i] = <span class="built_in">std</span> :: lower_bound(c + <span class="number">1</span>, c + <span class="number">1</span> + t, b[i]) - c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">std</span> :: lower_bound(c + <span class="number">1</span>, c + <span class="number">1</span> + t, a[i]) - c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        T.modify(<span class="number">1</span>, <span class="number">1</span>, t, b[i], t, <span class="number">1</span>), T.modify(<span class="number">1</span>, <span class="number">1</span>, t, a[i], t, <span class="number">-1</span>);</span><br><span class="line">    ans = T.query();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        T.modify(<span class="number">1</span>, <span class="number">1</span>, t, a[i], t, <span class="number">-1</span>), T.modify(<span class="number">1</span>, <span class="number">1</span>, t, a[i - m], t, <span class="number">1</span>), ans += T.query();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> LOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「LOJ 6060」「2017 山东一轮集训 Day1 / SDWC2018 Day1」Set</title>
      <link href="/loj6060-sol/"/>
      <url>/loj6060-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6060" target="_blank" rel="noopener">LOJ 6060</a></p><a id="more"></a><h2 id="题解">题解</h2><p>我们发现，<span class="math inline">\(x_1\text{ xor }x_2\)</span> 的值是固定的，也就是整个集合的异或和，我们记为 <span class="math inline">\(s\)</span>。</p><p>很显然 <span class="math inline">\(x_1+x_2\ge s\)</span>，我们把 <span class="math inline">\(x_1+x_2-s\)</span> 的值叫做“差值”。显然我们需要使差值最大化。</p><p>考虑 <span class="math inline">\(s\)</span> 第 <span class="math inline">\(i\)</span> 位（从右往左，从 <span class="math inline">\(0\)</span> 开始标号，下同），若是 <span class="math inline">\(1\)</span>，则 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 的这一位上有且仅有一个 <span class="math inline">\(1\)</span>，那么显然对差值的贡献为 <span class="math inline">\(0\)</span>；否则，<span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 的这一位要么都是 <span class="math inline">\(0\)</span>，要么都是 <span class="math inline">\(1\)</span>，显然最好是两个都为 <span class="math inline">\(1\)</span>，那么会对差值产生 <span class="math inline">\(2^{i+1}\)</span> 的贡献。</p><p>题目同时又规定，需要在最大化 <span class="math inline">\(x_1+x_2\)</span> 的前提下，最小化 <span class="math inline">\(x_1\)</span>，也就是要最大化 <span class="math inline">\(x_2\)</span>。</p><p>自然想到线性基。通常我们在线性基中插入、查询时直接从最高位遍历到最低位，因为我们可以认为高位的优先级高于低位。</p><p>但是，在本题中，由于要优先最大化差值，所以我们需要先最大化 <span class="math inline">\(x_2\)</span> 的所有在 <span class="math inline">\(s\)</span> 中为 <span class="math inline">\(0\)</span> 的那些位置。</p><p>于是，我们在插入、查询时，强制这些位置的优先级高于其他位置，而内部仍然按照从高位到低位的顺序进行遍历。这样就能保证先最大化差值，在这个前提下最大化 <span class="math inline">\(x_2\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum, a[N], b[<span class="number">65</span>], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">60</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (!(sum &gt;&gt; i &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!b[i]) <span class="keyword">return</span> b[i] = x, <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">                x ^= b[i];</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">60</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!b[i]) <span class="keyword">return</span> b[i] = x, <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">                x ^= b[i];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read(), sum ^= a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) insert(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">60</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (!(sum &gt;&gt; i &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> (!(ans &gt;&gt; i &amp; <span class="number">1</span>))</span><br><span class="line">                ans ^= b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">60</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!(ans &gt;&gt; i &amp; <span class="number">1</span>))</span><br><span class="line">                ans ^= b[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sum ^ ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> LOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「LOJ 6059」「2017 山东一轮集训 Day1」Sum</title>
      <link href="/loj6059-sol/"/>
      <url>/loj6059-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6059" target="_blank" rel="noopener">LOJ 6059</a></p><a id="more"></a><h2 id="题解">题解</h2><p>一眼 DP。并且很显然可以倍增优化。<span class="math inline">\(dp_{i,j,k}\)</span> 表示 <span class="math inline">\(2^i\)</span> 位，数字之和<strong>恰好</strong>为 <span class="math inline">\(j\)</span>，模 <span class="math inline">\(p\)</span> 为 <span class="math inline">\(k\)</span> 时的方案数。有如下转移：</p><p><span class="math display">\[dp_{i,j,k}=\sum_{j_1+j_2=j}\sum_{k_1\times 10^{2^{i-1}}+k_2\equiv k\pmod p}dp_{i-1,j_1,k_1}\times dp_{i-1,j_2,k_2}\]</span></p><p>直接这样做是 <span class="math inline">\(O(p^2m^2\log n)\)</span> 的。</p><p>只考虑 <span class="math inline">\(j\)</span> 这一维，很显然可以用 FFT 优化，于是复杂度变为 <span class="math inline">\(O(p^2m\log m\log n)\)</span>，但是常数较大，比较难卡过。</p><p>如果我们记</p><p><span class="math display">\[tmp_{j,k}=\sum_{t\times 10^{2^{i-1}}\equiv k\pmod p} dp_{i-1,j,t}\]</span></p><p>则原式变成了</p><p><span class="math display">\[dp_{i,j,k}=\sum_{j_1+j_2=j}\sum_{(k_1+k_2)\bmod p=k}tmp_{j_1,k_1}\times dp_{i-1,j_2,k_2}\]</span></p><p>然而这个 <span class="math inline">\(\bmod\)</span> 还是不太舒服，我们考虑把第二维值域扩充到 <span class="math inline">\([0,2p)\)</span>，然后再把 <span class="math inline">\([p,2p)\)</span> 这部分加到 <span class="math inline">\([0,p)\)</span>。则式子变得十分美观：</p><p><span class="math display">\[dp_{i,j,k}=\sum_{j_1+j_2=j}\sum_{k_1+k_2=k}tmp_{j_1,k_1}\times dp_{i-1,j_2,k_2}\]</span></p><p>我们把 <span class="math inline">\(j,k\)</span> 两维拍到一起，发现这个式子仍然是个卷积的形式。于是直接用 FFT 优化。</p><p>时间复杂度 <span class="math inline">\(O(mp\log (mp)\log n)\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 70005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 998244353</span></span><br><span class="line"><span class="keyword">int</span> n, p, m, pw[<span class="number">35</span>], dp[<span class="number">35</span>][N], s[N], tmp[N], len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    (x += y) &gt;= P ? x -= P : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x += y) &gt;= P ? x - P : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x -= y) &lt; <span class="number">0</span> ? x + P : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = P - <span class="number">2</span>, <span class="keyword">int</span> p = P)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1l</span>l * a * a % p) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1l</span>l * s * a % p;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number_Theory_Transform</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, rev[N], omega[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        n = m;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) &lt; n) ++k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) rev[i] = rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (i &amp; <span class="number">1</span>) &lt;&lt; k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) i &lt; rev[i] ? <span class="built_in">std</span> :: swap(a[i], a[rev[i]]), <span class="number">0</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> l = m &lt;&lt; <span class="number">1</span>, omega1 = qpow(o == <span class="number">1</span> ? <span class="number">3</span> : <span class="number">332748118</span>, (P - <span class="number">1</span>) / l);</span><br><span class="line">            omega[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) omega[i] = <span class="number">1l</span>l * omega[i - <span class="number">1</span>] * omega1 % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span>* p = a; p &lt; a + n; p += l)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">                    <span class="keyword">register</span> <span class="keyword">int</span> t = <span class="number">1l</span>l * omega[i] * p[m + i] % P;</span><br><span class="line">                    p[m + i] = del(p[i], t), upd(p[i], t);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> _n = qpow(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = <span class="number">1l</span>l * a[i] * _n % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> na, <span class="keyword">int</span> *A, <span class="keyword">int</span> nb, <span class="keyword">int</span> *B, <span class="keyword">int</span> *C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (na &lt;= <span class="number">20</span> &amp;&amp; nb &lt;= <span class="number">20</span>)&#123;</span><br><span class="line">        n = <span class="built_in">std</span> :: max(na, nb);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) C[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; na; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nb; ++j)</span><br><span class="line">                <span class="keyword">if</span> (i + j &lt; n) upd(C[i + j], <span class="number">1l</span>l * A[i] * B[j] % P);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a[N], b[N];</span><br><span class="line">    n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; na + nb - <span class="number">1</span>) n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; na; ++i) a[i] = A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nb; ++i) b[i] = B[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = na; i &lt; n; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = nb; i &lt; n; ++i) b[i] = <span class="number">0</span>;</span><br><span class="line">    T.init(n), T.NTT(a, <span class="number">1</span>), T.NTT(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = <span class="number">1l</span>l * a[i] * b[i] % P;</span><br><span class="line">    T.NTT(a, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">std</span> :: max(na, nb); ++i) C[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;p, &amp;m);</span><br><span class="line">    len = (m + <span class="number">1</span>) * p * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span> &amp;&amp; i &lt;= m; ++i) ++dp[<span class="number">0</span>][i * p * <span class="number">2</span> + i % p];</span><br><span class="line">    pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i) pw[i] = pw[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++i) pw[i] = qpow(<span class="number">10</span>, pw[i], p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) tmp[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p; ++k)</span><br><span class="line">                upd(tmp[j * p * <span class="number">2</span> + <span class="number">1l</span>l * k * pw[i] % p], dp[i][j * p * <span class="number">2</span> + k]);</span><br><span class="line">        multiply(len, tmp, len, dp[i], dp[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p; ++k)</span><br><span class="line">                upd(dp[i + <span class="number">1</span>][j * p * <span class="number">2</span> + k], dp[i + <span class="number">1</span>][j * p * <span class="number">2</span> + k + p]), dp[i + <span class="number">1</span>][j * p * <span class="number">2</span> + k + p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">30</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) tmp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p; ++k)</span><br><span class="line">                    upd(tmp[j * p * <span class="number">2</span> + <span class="number">1l</span>l * k * pw[i] % p], s[j * p * <span class="number">2</span> + k]), s[j * p * <span class="number">2</span> + k] = <span class="number">0</span>;</span><br><span class="line">            multiply(len, tmp, len, dp[i], s);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p; ++k)</span><br><span class="line">                    upd(s[j * p * <span class="number">2</span> + k], s[j * p * <span class="number">2</span> + k + p]), s[j * p * <span class="number">2</span> + k + p] = <span class="number">0</span>;</span><br><span class="line">            n -= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) upd(sum, s[i * p * <span class="number">2</span>]), <span class="built_in">printf</span>(<span class="string">"%d "</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> LOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 倍增 </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 1067A」Array Without Local Maximums</title>
      <link href="/cf1067a-sol/"/>
      <url>/cf1067a-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1067/problem/A" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，有些位置是 <span class="math inline">\(-1\)</span>，其余位置是 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(200\)</span> 的一个整数。你需要在 <span class="math inline">\(-1\)</span> 的位置填上<span class="math inline">\(1\)</span> 到 <span class="math inline">\(200\)</span> 的一个整数，使得序列 <span class="math inline">\(a\)</span> 是好的。一个序列 <span class="math inline">\(a\)</span> 是好的当且仅当满足以下三个条件：</p><ol type="1"><li><span class="math inline">\(a_1\le a_2\)</span></li><li><span class="math inline">\(a_n\le a_{n-1}\)</span></li><li><span class="math inline">\(\forall i\in [2,n-1],a_i\le \max(a_{i-1},a_{i+1})\)</span></li></ol><p>求方案数 <span class="math inline">\(\bmod 998244353\)</span> 的值。</p><p><span class="math inline">\(n\le 10^5\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>考虑 DP，<span class="math inline">\(dp_{i,j,0/1}\)</span> 表示前 <span class="math inline">\(i\)</span> 个数，<span class="math inline">\(a_i\)</span> 为 <span class="math inline">\(j\)</span>，<span class="math inline">\(a_{i-1}&lt; a_i\)</span> / <span class="math inline">\(a_{i-1}\ge a_i\)</span> 时的方案数。有转移</p><p><span class="math display">\[\begin{aligned} dp_{i,j,0}&amp;=\sum_{k=1}^{j-1} dp_{i-1,k,0}+dp_{i-1,k,1}\\ dp_{i,j,1}&amp;=dp_{i-1,j,0}+\sum_{k=j}^{200} dp_{i-1,k,1}\end{aligned}\]</span></p><p>可以发现这个式子可以用前缀和优化。</p><p>时间复杂度 <span class="math inline">\(O(nm)\)</span>，其中 <span class="math inline">\(m=200\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 998244353</span></span><br><span class="line"><span class="keyword">int</span> n, a[N], dp[N][<span class="number">205</span>][<span class="number">2</span>], pre[N][<span class="number">205</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x += y) &gt;= P ? x - P : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x -= y) &lt; <span class="number">0</span> ? x + P : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">suf</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> del(pre[i][<span class="number">200</span>][k], pre[i][j - <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="number">-1</span> || i == a[<span class="number">1</span>]) dp[<span class="number">1</span>][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        pre[<span class="number">1</span>][i][<span class="number">0</span>] = add(pre[<span class="number">1</span>][i - <span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">200</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="number">-1</span> || a[i] == j)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = add(pre[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>], pre[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = add(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], suf(i - <span class="number">1</span>, j, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            pre[i][j][<span class="number">0</span>] = add(pre[i][j - <span class="number">1</span>][<span class="number">0</span>], dp[i][j][<span class="number">0</span>]);</span><br><span class="line">            pre[i][j][<span class="number">1</span>] = add(pre[i][j - <span class="number">1</span>][<span class="number">1</span>], dp[i][j][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pre[n][<span class="number">200</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 1204D2」Kirk and a Binary String (hard version)</title>
      <link href="/cf1204d2-sol/"/>
      <url>/cf1204d2-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1204/problem/D2" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定一个长度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(01\)</span> 字符串 <span class="math inline">\(s\)</span>，求一个长度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(01\)</span> 字符串 <span class="math inline">\(t\)</span>，满足 <span class="math inline">\(\forall 1\le l\le r\le n:f(s[l,r])=f(t[l,r])\)</span>，其中 <span class="math inline">\(f(s[l,r])\)</span> 表示 <span class="math inline">\(s\)</span> 中第 <span class="math inline">\(l\)</span> 个字符到第 <span class="math inline">\(r\)</span> 个字符组成的子串的最长<strong>不下降子序列</strong>的长度，<span class="math inline">\(f(t[l,r])\)</span> 同理。</p><p>在满足以上条件的同时，你需要最大化 <span class="math inline">\(t\)</span> 中 <span class="math inline">\(0\)</span> 的数量。</p><p><span class="math inline">\(n\le 10^5\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>显然一定是把 <span class="math inline">\(s\)</span> 中的若干个 <span class="math inline">\(1\)</span> 改成 <span class="math inline">\(0\)</span>，且每段连续的 <span class="math inline">\(1\)</span> 一定是修改它的一个前缀。</p><p>我们发现，一个区间的最长不下降子序列一定可以表示成在区间的某个位置断开（特殊地，也可以在左端点的前面或右端点的后面），然后选断点左边的 <span class="math inline">\(0\)</span> 和断点右边的 <span class="math inline">\(1\)</span>，显然这个断点需要满足左边 <span class="math inline">\(0\)</span> 的个数加上右边 <span class="math inline">\(1\)</span> 的个数等于这个区间的最长不下降子序列长度。我们称这样的断点为这个区间的答案断点。显然答案断点必须满足右边 <span class="math inline">\(1\)</span> 的个数大于等于 <span class="math inline">\(0\)</span> 的个数，左边 <span class="math inline">\(0\)</span> 的个数大于等于 <span class="math inline">\(1\)</span> 的个数。但这个不是充要条件。</p><p>考虑一个 <span class="math inline">\(1\)</span> 能变成 <span class="math inline">\(0\)</span> 的条件，假设这个位置为 <span class="math inline">\(i\)</span>，那就是所有 <span class="math inline">\(i+1\)</span> 开始的所有区间必须存在一个最长不下降子序列是全为 <span class="math inline">\(1\)</span> 的。</p><p>我们又发现，只要 <span class="math inline">\([i+1,n]\)</span> 这个区间满足条件，所有区间就一定满足条件。</p><p>先给出做法：从后往前扫，记 <span class="math inline">\(cnt_i\)</span> 表示 <span class="math inline">\(i\sim n\)</span> <strong>没有改变的位置中</strong> <span class="math inline">\(0\)</span> 的个数减去 <span class="math inline">\(1\)</span> 的个数的值，那么 <span class="math inline">\(cnt_{i+1}=0\)</span> 时把 <span class="math inline">\(i\)</span> 这个位置改成 <span class="math inline">\(0\)</span>。</p><p>考虑这样为什么是对的（以下内容纯属口胡）。对于 <span class="math inline">\([i+1,n]\)</span> 的某个点 <span class="math inline">\(j\)</span>，我们把 <span class="math inline">\(j\sim n\)</span> 的<strong>所有位置中</strong> <span class="math inline">\(0\)</span> 的个数减去 <span class="math inline">\(1\)</span> 的个数的值记为 <span class="math inline">\(sum_j\)</span>。由于改变只会是 <span class="math inline">\(1\)</span> 变成 <span class="math inline">\(0\)</span>，所以有 <span class="math inline">\(cnt_j\le sum_j\)</span>。又因为只要碰到 <span class="math inline">\(1\)</span> 且 <span class="math inline">\(cnt_j=0\)</span> 就会改变，所以 <span class="math inline">\(sum_j\ge cnt_j\ge 0\)</span>。要 <span class="math inline">\(j\)</span> 前面的位置要成为答案断点，必须有 <span class="math inline">\(sum_j\le 0\)</span>，所以 <span class="math inline">\(sum_j\)</span> 只能等于 <span class="math inline">\(0\)</span>，即 <span class="math inline">\(0\)</span> 的个数等于 <span class="math inline">\(1\)</span> 的个数。因为 <span class="math inline">\(j\sim n\)</span> 满足这个条件，当前的 <span class="math inline">\(cnt_{i+1}=0\)</span>，所以 <span class="math inline">\(i+1\sim j-1\)</span> 所有位置中 <span class="math inline">\(0\)</span> 的个数一定小于等于 <span class="math inline">\(1\)</span> 的个数，要符合答案断点的必要条件，又只能是取等于。于是我们可以把 <span class="math inline">\(i+1\sim j-1\)</span> 的决策替换成 <span class="math inline">\(1\)</span>，于是 <span class="math inline">\(i+1\sim n\)</span> 就一定存在一个全为 <span class="math inline">\(1\)</span> 的最长不下降子序列。</p><p>差不多口胡完了，直接做就可以了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n, cnt = <span class="number">0</span>; i; --i) </span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'0'</span>) ++cnt;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt) --cnt;</span><br><span class="line">        <span class="keyword">else</span> s[i] = <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「模拟赛20190705 T1」第一题</title>
      <link href="/vc190705A-sol/"/>
      <url>/vc190705A-sol/</url>
      
        <content type="html"><![CDATA[<h2 id="题意">题意</h2><p>给定一棵 <span class="math inline">\(n\)</span> 个点的有根树，每个点有一个正整数<span class="math inline">\(b_i\)</span>，这个点的权值是 <span class="math inline">\([0,b_i]\)</span> 的一个随机<strong>实数</strong>。</p><p>求每个点的权值严格小于这个点所有儿子的权值的概率，模 <span class="math inline">\(10^9+7\)</span>。</p><p><span class="math inline">\(n\le 300,b_i\le 10^9\)</span>。</p><a id="more"></a><h2 id="所谓题解">所谓题解</h2><p><img src="https://autumnkite.github.io/files/vc190705A-pic.png" /></p><h2 id="旺仔的方法">旺仔的方法</h2><p>考虑暴力。实数显然不能直接枚举。然而 <span class="math inline">\(b_i\)</span> 只有 <span class="math inline">\(n\)</span> 个，我们考虑离散，枚举每个点的权值在哪一段内。</p><p>我们按权值所属段是否相同分出一些联通块。树上的联通块还是一棵树，我们考虑求出每个联通块内部的概率。</p><p>由于一个联通块内的权值都属于同一段，也就是权值取值范围相同，那么问题转化成了：</p><blockquote><p>给定一棵树，每个点的权值是 <span class="math inline">\([0,1)\)</span> 的随机实数，求每个点权值严格小于这个点每个儿子的权值的概率。</p></blockquote><p>这个问题是一个经典问题，答案是 <span class="math inline">\(\prod\limits_{i=1}^{n} \frac{1}{sz_i}\)</span>，可以感性理解一下。<del>我不会证明</del></p><p>枚举每个点太慢，我们考虑 DP。用 <span class="math inline">\(dp_{i,j,k}\)</span> 表示以 <span class="math inline">\(i\)</span> 为根的子树，<span class="math inline">\(i\)</span> 的取值范围为 <span class="math inline">\(j\)</span>，以 <span class="math inline">\(i\)</span> 为根的联通块大小为 <span class="math inline">\(k\)</span> 时的概率。可以通过枚举每个儿子的取值范围是否与 <span class="math inline">\(i\)</span> 相同，枚举每个儿子的联通块大小进行转移。</p><p>相当于 <span class="math inline">\(n\)</span> 次树上背包，每次 <span class="math inline">\(O(n^2)\)</span>，复杂度为 <span class="math inline">\(O(n^3)\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 305</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], b[N], fa[N], rt, inv[N], inva[N], sz[N], dp[N][N][N], tmp[N];</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; E[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1l</span>l * a * a % P) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1l</span>l * s * a % P;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    (x += y) &gt;= P ? x -= P : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b[u]; ++i) dp[u][i][<span class="number">1</span>] = <span class="number">1l</span>l * (a[i + <span class="number">1</span>] - a[i]) * inva[b[u]] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[u][i], sum = <span class="number">0</span>;</span><br><span class="line">        dfs(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = b[v] - <span class="number">1</span>; j &gt;= b[u]; --j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sz[v]; ++k)</span><br><span class="line">                add(sum, dp[v][j][k]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = b[u] - <span class="number">1</span>; ~j; --j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sz[u] + sz[v]; ++k) tmp[k] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sz[u]; ++k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= sz[v]; ++l)</span><br><span class="line">                    add(tmp[k + l], <span class="number">1l</span>l * dp[u][j][k] * dp[v][j][l] % P);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sz[u] + sz[v]; ++k)</span><br><span class="line">                dp[u][j][k] = (<span class="number">1l</span>l * dp[u][j][k] * sum + tmp[k]) % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sz[v]; ++k) add(sum, dp[v][j][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        sz[u] += sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b[u]; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sz[u]; ++k)</span><br><span class="line">            dp[u][j][k] = <span class="number">1l</span>l * dp[u][j][k] * inv[k] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"a.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"a.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        a[i] = b[i] = read(), fa[i] = read();</span><br><span class="line">        <span class="keyword">if</span> (fa[i]) E[fa[i]].push_back(i); <span class="keyword">else</span> rt = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span> :: sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    m = <span class="built_in">std</span> :: unique(a + <span class="number">1</span>, a + <span class="number">1</span> + n) - a - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        b[i] = <span class="built_in">std</span> :: lower_bound(a + <span class="number">1</span>, a + <span class="number">1</span> + m, b[i]) - a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) inv[i] = qpow(i, P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) inva[i] = qpow(a[i], P - <span class="number">2</span>);</span><br><span class="line">    dfs(rt);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b[rt]; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            add(ans, dp[rt][i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 树形DP </tag>
            
            <tag> 概率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AT1736」「Xmas Contest 2015」Destroy the Duplicated Poem</title>
      <link href="/atcoder-xmas15D-sol/"/>
      <url>/atcoder-xmas15D-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/xmascontest2015noon/tasks/xmascontest2015_d" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>有 <span class="math inline">\(n+1\)</span> 个字符串 <span class="math inline">\(S_0,S_1,S_2,\cdots,S_n\)</span>。<span class="math inline">\(S_0\)</span> 是空串，<span class="math inline">\(S_i\)</span> 是 <span class="math inline">\(S_{a_i}\)</span> 后加上字符 <span class="math inline">\(c_i\)</span> 的字符串。<span class="math inline">\(a_i,c_i\)</span> 都是给定的且 <span class="math inline">\(0\le a_i&lt; i\)</span>，<span class="math inline">\(c_i\)</span> 是小写字母。</p><p>定义字符串 <span class="math inline">\(T\)</span> 的周期是所有满足 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(X\)</span> 重复无穷多次后的字符串的前缀的字符串 <span class="math inline">\(X\)</span> 中最短的。例如 <code>abcabca</code> 的周期是 <code>abc</code>。</p><p>求 <span class="math inline">\(S_1,S_2,S_3,\cdots,S_n\)</span> 的周期的长度。</p><p><span class="math inline">\(n\le 500\,000\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>由题目给定的字符串生成方式，可以想到字典树。所有字符串对应字典树上根到某个点的路径。</p><p>可以发现，字符串的周期一定是字符串的某个前缀。且这个前缀的长度一定是 <span class="math inline">\(T[1,m-x]=T[m-x+1,m]\)</span> 的 <span class="math inline">\(x\)</span> 中的最小值（<span class="math inline">\(T[l..r]\)</span> 表示 <span class="math inline">\(T\)</span> 中 <span class="math inline">\(l\)</span> 到 <span class="math inline">\(r\)</span> 的子串，<span class="math inline">\(m\)</span> 表示 <span class="math inline">\(T\)</span> 的长度）。<span class="math inline">\(x\)</span> 最小，那么 <span class="math inline">\(m-x\)</span> 是最大的，所以这是一个求所有前缀=后缀中最长的前缀的形式，那么很自然地能想到 KMP。</p><p>在 trie 上做 KMP，不能直接跳 fail，如下图所示的情况就可以卡成 <span class="math inline">\(O(n^2)\)</span> 的复杂度：</p><p><img src="https://autumnkite.github.io/files/at-xmas15d-pic.png" /></p><p>因为都是小写字母，所以用 <span class="math inline">\(go_{i,c}\)</span>（在节点 <span class="math inline">\(i\)</span> 表示的字符串后加入字符 <span class="math inline">\(c\)</span> 后最长的前缀=后缀所在的节点） 记下这个跳 fail 的过程即可（有点像 AC 自动机，但不完全一样）。</p><p>时间复杂度 <span class="math inline">\(O(nk)\)</span>，<span class="math inline">\(k\)</span> 是字符集大小，这里为 <span class="math inline">\(26\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">int</span> n, dep[N], fail[N], go[N][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">char</span> a[N];</span><br><span class="line"><span class="keyword">int</span> edge, hd[N], to[N], pr[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa = <span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">if</span> (~fa)&#123;</span><br><span class="line">        dep[u] = dep[fa] + <span class="number">1</span>, fail[u] = go[fa][a[u]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) go[u][i] = go[fail[u]][i];</span><br><span class="line">        <span class="keyword">if</span> (fail[u] == fa) go[u][a[u]] = u;</span><br><span class="line">        tmp = go[fa][a[u]], go[fa][a[u]] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u]; i; i = pr[i]) dfs(to[i], u);</span><br><span class="line">    <span class="keyword">if</span> (~fa) go[fa][a[u]] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, fa; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;fa), addedge(fa, i); <span class="comment">// 建树</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] -= <span class="string">'a'</span>;</span><br><span class="line">    dep[<span class="number">0</span>] = <span class="number">0</span>, dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dep[i] - dep[fail[i]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> Xmas Contest 2015 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> trie </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AT1735」「Xmas Contest 2015」Colored Tiles</title>
      <link href="/atcoder-xmas15C-sol/"/>
      <url>/atcoder-xmas15C-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/xmascontest2015noon/tasks/xmascontest2015_c" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>这是一道交互题。</p><p>交互库中生成了一个 <span class="math inline">\(n\times m\)</span> 的每个格子有颜色的矩阵。颜色可以有任意多种。给定的是 <span class="math inline">\(n,m\)</span>。记矩阵中第 <span class="math inline">\(x\)</span> 行第 <span class="math inline">\(y\)</span> 列的颜色为 <span class="math inline">\(col(x,y)\)</span>（矩阵的行列下标从 <span class="math inline">\(1\)</span> 开始）。</p><p>你可以进行询问，询问的格式是 <code>? x1 y1 x2 y2</code>，交互库会告诉你 <span class="math inline">\(col(x1,y1)=col(x2,y2)\)</span> <strong>并且</strong> <span class="math inline">\(col(x1,y2)=col(x2,y1)\)</span> 是否成立。询问次数不能超过 <span class="math inline">\(4\,500\)</span>。</p><p>最后你应该输出 <code>! ans</code>，<span class="math inline">\(ans\)</span> 表示中心对称的子矩阵的数量。</p><p><span class="math inline">\(n\le 5,m\le 100\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p><img src="https://autumnkite.github.io/files/at-xmas15c-pic1.png" /></p><p>上图这个矩阵如果是中心对称的，那么 <span class="math inline">\(A\)</span> 反转一下一定与 <span class="math inline">\(B\)</span> 相等，且 <span class="math inline">\(C\)</span> 也是中心对称的。</p><p>那么考虑 <span class="math inline">\(A,B\)</span> 两行，设他们的行号分别为 <span class="math inline">\(i,j\)</span>，中间位置为 <span class="math inline">\(k\)</span>，两边为 <span class="math inline">\(l,r\)</span>，那么 <span class="math inline">\(A\)</span> 反转一下与 <span class="math inline">\(B\)</span> 相等可以转化成 <span class="math inline">\(\forall 0\le x\le k-l,col(i,k-x)=col(j,k+x)\text{ and }col(i,k+x)=col(j,k-x)\)</span>。这个与询问的格式就一样了。</p><p>并且可以发现，这是一个“类回文”的形式，所以可以用 manacher 解决，这样就可以减少询问次数。为了解决奇偶性问题，可以当作把每行扩展一倍，在相邻两个格子之间插入其他字符，注意询问时候要变回原来的下标。</p><p>就是说，对于任意两行 <span class="math inline">\(i,j(1\le i\le j\le n)\)</span>，求出每列向左右可以扩展的最多的列数。然后枚举矩阵的上下两行和对称中心所在的列数，求出在该条件下的极大中心对称的矩阵的列数，然后直接统计。</p><p>可以用 map 减少一定量的询问次数。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m, len[<span class="number">6</span>][<span class="number">6</span>][<span class="number">205</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; res.a || (a == res.a &amp;&amp; b &lt; res.b) || (a == res.a &amp;&amp; b == res.b &amp;&amp; c &lt; res.c) || (a == res.a &amp;&amp; b == res.b &amp;&amp; c == res.c &amp;&amp; d &lt; res.d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">map</span>&lt;node, <span class="keyword">int</span>&gt; M;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2 || y1 &gt; y2 || x1 &lt; <span class="number">1</span> || x2 &gt; n || y1 &lt; <span class="number">1</span> || y2 &gt; (m &gt;&gt; <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (M.count((node)&#123;x1, y1, x2, y2&#125;)) <span class="keyword">return</span> M[(node)&#123;x1, y1, x2, y2&#125;];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? %d %d %d %d\n"</span>, x1, y1, x2, y2), fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">char</span> opt[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, opt);</span><br><span class="line">    <span class="keyword">return</span> M[(node)&#123;x1, y1, x2, y2&#125;] = (opt[<span class="number">0</span>] == <span class="string">'y'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> *hw)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mr = <span class="number">0</span>, mid = <span class="number">0</span>, n = m;</span><br><span class="line">    hw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        hw[i] = i &lt;= mr ? <span class="built_in">std</span> :: min(hw[(mid &lt;&lt; <span class="number">1</span>) - i], mr - i + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i + hw[i] &lt;= mr) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> ((i - hw[i]) % <span class="number">2</span> == <span class="number">0</span> || check(x, (i - hw[i] + <span class="number">1</span>) / <span class="number">2</span>, y, (i + hw[i] + <span class="number">1</span>) / <span class="number">2</span>)) ++hw[i];</span><br><span class="line">        <span class="keyword">if</span> (i + hw[i] - <span class="number">1</span> &gt; mr) mid = i, mr = i + hw[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt;= n; ++j)</span><br><span class="line">            manacher(i, j, len[i][j]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k)&#123;</span><br><span class="line">                <span class="keyword">int</span> s = <span class="number">1e9</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> l = i, r = j; l &lt;= r; ++l, --r)</span><br><span class="line">                    s = <span class="built_in">std</span> :: min(s, len[l][r][k]);</span><br><span class="line">                ans += s &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"! %d\n"</span>, ans), fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> Xmas Contest 2015 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 交互 </tag>
            
            <tag> manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 1156E」Special Segments of Permutation</title>
      <link href="/cf1156e-sol/"/>
      <url>/cf1156e-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1156/problem/E" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定一个长度为 <span class="math inline">\(n\)</span> 的排列 <span class="math inline">\(a\)</span>，求有多少区间 <span class="math inline">\([l,r]\)</span> 满足 <span class="math inline">\(a_l+a_r=\max\limits_{i=l}^{r}a_i\)</span>。</p><p><span class="math inline">\(n\le 200\,000\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>用单调栈对每一个 <span class="math inline">\(a_i\)</span> 求出 <span class="math inline">\(l_i=j+1\)</span>，<span class="math inline">\(j\)</span> 是从 <span class="math inline">\(i\)</span> 向左第一个满足 <span class="math inline">\(a_j&gt;a_i\)</span> 的位置，<span class="math inline">\(r_i\)</span> 同理。</p><p>那么题目变为对于每个 <span class="math inline">\(i\)</span> 求在 <span class="math inline">\([l_i,i-1]\)</span> 和 <span class="math inline">\([i+1,r_i]\)</span> 中各选出一个数使得这两个数之和为 <span class="math inline">\(a_i\)</span> 的方案数。</p><p>结论是，我们只要枚举这两个区间中短的那个区间的每个数 <span class="math inline">\(a_j\)</span>，然后在另一个区间中查询 <span class="math inline">\(a_i-a_j\)</span> 是否存在即可。</p><p>看起来是 <span class="math inline">\(O(n^2)\)</span>，其实是 <span class="math inline">\(O(n\log n)\)</span> 的，因为每个数最多会被枚举到 <span class="math inline">\(\log n\)</span> 次。假设某个数被枚举到的所有区间 <span class="math inline">\([l_i,r_i]\)</span> 中，最大的区间长度为 <span class="math inline">\(m\)</span>，那么由于枚举的是短的区间，短的区间长度不会超过 <span class="math inline">\(\frac{m}{2}\)</span>。而如果这个数要被另一个区间枚举到，这个区间一定被之前那个短的区间包含，所以这个区间总长度不会超过 <span class="math inline">\(\frac{m}{2}\)</span>，而且又是短的区间，所以变成了 <span class="math inline">\(\frac{m}{4}\)</span>……感性理解一下，每个数枚举到的次数不会超过 <span class="math inline">\(\log n\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">int</span> n, a[N], p[N], l[N], r[N], top, sta[N], ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l &lt;= p[x] &amp;&amp; p[x] &lt;= r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i), p[a[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[sta[top]]) --top;</span><br><span class="line">        l[i] = sta[top] + <span class="number">1</span>;</span><br><span class="line">        sta[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sta[top = <span class="number">0</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[sta[top]]) --top;</span><br><span class="line">        r[i] = sta[top] - <span class="number">1</span>;</span><br><span class="line">        sta[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = l[i], r1 = i - <span class="number">1</span>, l2 = i + <span class="number">1</span>, r2 = r[i];</span><br><span class="line">        <span class="keyword">if</span> (r1 - l1 &gt; r2 - l2) <span class="built_in">std</span> :: swap(l1, l2), <span class="built_in">std</span> :: swap(r1, r2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = l1; j &lt;= r1; ++j)</span><br><span class="line">            <span class="keyword">if</span> (in(a[i] - a[j], l2, r2)) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复杂度分析 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AT1734」「Xmas Contest 2015」Broken Christmas Tree</title>
      <link href="/atcoder-xmas15B-sol/"/>
      <url>/atcoder-xmas15B-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/xmascontest2015noon/tasks/xmascontest2015_b" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p><span class="math inline">\(n\)</span> 个点的完全图中去掉给定的 <span class="math inline">\(m\)</span> 条边后，问是否存在一个生成树。若是，求出一种方案。</p><p><span class="math inline">\(n,m\le 2\times 10^5\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>显然贪心。假定以 <span class="math inline">\(1\)</span> 为根节点，把 <span class="math inline">\(1\)</span> 能连的点都与 <span class="math inline">\(1\)</span> 相连，然后对这些点进行同样的操作，直到所有点都相互连通。</p><p>用 <code>set</code> 记录每个点不能连的点，以及当前还有哪些点没有加入最小生成树（记做 <span class="math inline">\(num\)</span>）。用队列记录已经加入的点，对于队列中的点 <span class="math inline">\(u\)</span>，遍历 <span class="math inline">\(num\)</span>，若可以连则连，加入队列，并且从 <span class="math inline">\(num\)</span> 中删除；否则跳过。</p><p>关键是复杂度分析。对于遍历 <span class="math inline">\(num\)</span> 时可以连的情况，这种情况一定不会超过 <span class="math inline">\(n-1\)</span> 次，因为每次都会从 <span class="math inline">\(num\)</span> 中删除一个点；对于不可以连的情况，一定不会超过 <span class="math inline">\(m\)</span> 次，因为一条不能连的边不会重复遍历。所以总次数为 <span class="math inline">\(O(n+m)\)</span> 次。由于判断一个点与另一个点能否连接需要 <span class="math inline">\(O(\log n)\)</span>，所以总复杂度为 <span class="math inline">\(O((n+m)\log n)\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">int</span> n, m, h, t, Q[N], cnt, x[N], y[N];</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; num, E[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        E[x].insert(y), E[y].insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) num.insert(i);</span><br><span class="line">    h = <span class="number">0</span>, t = <span class="number">1</span>, Q[t] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; t)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q[++h];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = num.begin(), It = it; it != num.end(); ) <span class="comment">// 遍历，注意 auto 需要 C++11</span></span><br><span class="line">            <span class="keyword">if</span> (!E[u].count(*it)) x[++cnt] = u, y[cnt] = *it, Q[++t] = *it, It = it, ++it, num.erase(It);</span><br><span class="line">            <span class="keyword">else</span> ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num.size()) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x[i], y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> Xmas Contest 2015 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 复杂度分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AT1733」「Xmas Contest 2015」Accumulation</title>
      <link href="/atcoder-xmas15A-sol/"/>
      <url>/atcoder-xmas15A-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/xmascontest2015noon/tasks/xmascontest2015_a" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input n</span><br><span class="line">input <span class="symbol">x</span>, t, a, b, c</span><br><span class="line"><span class="keywords">for</span> i = <span class="number">1</span> .. n :</span><br><span class="line">    s_i = <span class="symbol">x</span></span><br><span class="line">    <span class="keywords">for</span> j = <span class="number">1</span> .. t :</span><br><span class="line">        <span class="symbol">x</span> = (a * <span class="symbol">x</span> + b) <span class="keywords">mod</span> c</span><br></pre></td></tr></table></figure><p>求 <span class="math inline">\(\sum\limits_{i=1}^{n} s_i\)</span> 的值（不需要对 <span class="math inline">\(c\)</span> 取模）。</p><p><span class="math inline">\(n\le 10^6, t\le 10^9,0\le x,a,b&lt; c\le 10^9\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>考虑快速进行 <code>for j = 1 .. t : x = (a * x + b) mod c</code> 这段操作。</p><p><span class="math display">\[\begin{aligned} j=1: &amp;\quad ax+b \\ j=2: &amp;\quad a(ax+b)+b=a^2x+ab+b \\ j=3: &amp; \quad a(a^2x+ab+b)+b=a^3x+a^2b+ab+b  \\ j=4: &amp; \quad a^4x+a^3b+a^2b+ab+b\\ \vdots&amp; \\ j=t:&amp;\quad a^tx+\sum_{k=0}^{t-1} a^kb=a^tx+b\sum_{k=0}^{t-1}a^k\end{aligned}\]</span></p><p>如果 <span class="math inline">\(c\)</span> 为质数，则这个式子可以直接用快速幂和等比数列求和公式进行计算。然而并没有保证 <span class="math inline">\(c\)</span> 是质数，怎么办呢？可以发现，<span class="math inline">\(x\)</span> 和 <span class="math inline">\(b\)</span> 在这个式子中是常数，而 <span class="math inline">\(a^t\)</span> 和 <span class="math inline">\(\sum\limits_{k=0}^{t-1}a^k\)</span> 有某种联系……</p><p>考虑用矩阵表示（记 <span class="math inline">\(f(t)=\sum\limits_{k=0}^{t-1}a^k\)</span>） <span class="math display">\[A=\begin{bmatrix} a^t &amp; f(t) \end{bmatrix},B=\begin{bmatrix} a^{t+1} &amp; f(t+1) \end{bmatrix}\]</span></p><p><span class="math inline">\(A\)</span> 如何才能转化为 <span class="math inline">\(B\)</span>，通过计算发现：<span class="math inline">\(a^{t+1}=a\cdot a^t,f(t+1)=a^t+f(t)\)</span>，那么很显然转移矩阵为 <span class="math display">\[C=\begin{bmatrix} a &amp; 1\\ 0 &amp; 1\end{bmatrix}\]</span></p><p>可以再验证一下 <span class="math inline">\(A\times C=B\)</span>。于是直接用矩阵快速幂进行优化即可。</p><p>可以发现，最后 <span class="math inline">\(x\)</span> 的转移一定可以表示为 <span class="math inline">\(px+q\)</span> 的形式，所以只要一开始预处理 <span class="math inline">\(p,q\)</span>，不需要每次进行矩阵快速幂。</p><p>时间复杂度 <span class="math inline">\(O(n+\log t)\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, x, m, a, b, P;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;res) <span class="keyword">const</span> &#123;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        <span class="built_in">memset</span>(ret.a, <span class="number">0</span>, <span class="keyword">sizeof</span> ret.a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j)</span><br><span class="line">                    ret.a[i][j] = (ret.a[i][j] + <span class="number">1l</span>l * a[i][k] * res.a[k][j]) % P;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A, B;</span><br><span class="line"><span class="function">Matrix <span class="title">qpow</span><span class="params">(Matrix a, <span class="keyword">int</span> b)</span></span>&#123; <span class="comment">// 矩阵快速幂</span></span><br><span class="line">    Matrix s = a;</span><br><span class="line">    <span class="keyword">for</span> (--b; b; b &gt;&gt;= <span class="number">1</span>, a = a * a) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = s * a;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &amp;n, &amp;x, &amp;m, &amp;a, &amp;b, &amp;P);</span><br><span class="line">    A.a[<span class="number">0</span>][<span class="number">0</span>] = a, A.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 初始矩阵</span></span><br><span class="line">    B.a[<span class="number">0</span>][<span class="number">0</span>] = a, B.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>, B.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>, B.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 转移矩阵</span></span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">1</span>) A = A * qpow(B, m - <span class="number">1</span>);</span><br><span class="line">    a = A.a[<span class="number">0</span>][<span class="number">0</span>], b = <span class="number">1l</span>l * b * A.a[<span class="number">0</span>][<span class="number">1</span>] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans += x, x = (<span class="number">1l</span>l * a * x + b) % P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>upd: 修复了代码中的一个漏洞</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> Xmas Contest 2015 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 1119F」Niyaz and Small Degrees</title>
      <link href="/cf1119f-sol/"/>
      <url>/cf1119f-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1119/problem/F" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定一棵 <span class="math inline">\(n\)</span> 个节点的树，有边权，对于所有 <span class="math inline">\(x\ (0\le x &lt; n)\)</span>，可以删去一些边，求使得所有节点的度数 <span class="math inline">\(\le x\)</span> 的删掉的边的边权之和的最小值。</p><p>节点的度数指以该点为某一端点的边的数量。</p><p><span class="math inline">\(n\le 250\,000\)</span></p><a id="more"></a><h2 id="暴力独立求解">暴力——独立求解</h2><p>显然是树形 DP，记 <span class="math inline">\(dp_{u,0/1}\)</span> 表示 <span class="math inline">\(u\)</span> 与父亲的连边不删/删时，以 <span class="math inline">\(u\)</span> 为根的子树满足所有节点度数 <span class="math inline">\(\le x\)</span> 的删掉的边的最小值。</p><p>不考虑度数限制，显然有 <span class="math inline">\(dp_{u,0}=dp_{u,1}=\sum \min(dp_{v,0},dp_{v,1}+w)\)</span>（<span class="math inline">\(v\)</span> 是 <span class="math inline">\(u\)</span> 的儿子，<span class="math inline">\(w\)</span> 表示对应边的边权）。记 <span class="math inline">\(d_i\)</span> 表示 <span class="math inline">\(i\)</span> 的度数，把 <span class="math inline">\(dp_{v,1}+w\le dp_{v,0}\)</span> 的儿子 <span class="math inline">\(v\)</span> 叫做好儿子，其余叫做坏儿子。考虑度数限制，假设求 <span class="math inline">\(dp_{u,0}\)</span>（<span class="math inline">\(dp_{u,1}\)</span> 同理），记 <span class="math inline">\(cnt\)</span> 为好儿子数量，我们需要把 <span class="math inline">\(\max(0,d_i-x-cnt)\)</span> 个坏儿子变成好儿子。</p><p>只需要维护一个堆，将所有坏儿子 <span class="math inline">\(dp_{v,1}+w-dp_{v,0}\)</span> 的值压入堆中，将前 <span class="math inline">\(\max(0,d_i-x-cnt)\)</span> 小的值之和记为 <span class="math inline">\(sum\)</span>，则 <span class="math inline">\(dp_{u,0}=sum+\sum dp_{v,0}\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n^2\log n)\)</span>。</p><h2 id="暴力代码">暴力代码</h2><p>注意代码实现与上述有很大差别，但思想一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 250005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> edge, to[N &lt;&lt; <span class="number">1</span>], pr[N &lt;&lt; <span class="number">1</span>], tw[N &lt;&lt; <span class="number">1</span>], hd[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    to[++edge] = v, tw[edge] = w, pr[edge] = hd[u], hd[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> u, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; val;</span><br><span class="line">    dp[u][<span class="number">0</span>] = dp[u][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa) dfs(X, v, u), val.push_back(dp[v][<span class="number">1</span>] + tw[i] - dp[v][<span class="number">0</span>]), dp[u][<span class="number">0</span>] += dp[v][<span class="number">0</span>];</span><br><span class="line">    dp[u][<span class="number">1</span>] = dp[u][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">std</span> :: sort(val.begin(), val.end());</span><br><span class="line">    <span class="keyword">int</span> d = val.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d &amp;&amp; (i &lt; d - X || val[i] &lt; <span class="number">0</span>); ++i) dp[u][<span class="number">1</span>] += val[i];</span><br><span class="line">    <span class="keyword">if</span> (!X) <span class="keyword">return</span> dp[u][<span class="number">0</span>] = INF, <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">    ++d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d - <span class="number">1</span> &amp;&amp; (i &lt; d - X || val[i] &lt; <span class="number">0</span>); ++i) dp[u][<span class="number">0</span>] += val[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">        u = read(), v = read(), w = read(), addedge(u, v, w), addedge(v, u, w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) dfs(i, <span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">"%lld "</span>, dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正解">正解</h2><p>可以发现对于某个 <span class="math inline">\(x\)</span>，若一个节点 <span class="math inline">\(u\)</span> 的度数 <span class="math inline">\(\le x\)</span>，那这个点本身就不需要考虑了，只需要将 <span class="math inline">\(w(u,v)\)</span> 加入与 <span class="math inline">\(v\)</span> 的堆中。</p><p>也就是说，我们把 <span class="math inline">\(u\)</span> 当做叶子节点来看待，即：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="regexp">/\       /</span><span class="string">\</span></span><br><span class="line">/__<span class="string">\</span>     /__<span class="string">\</span></span><br><span class="line">    <span class="string">\</span>   /</span><br><span class="line">      u</span><br></pre></td></tr></table></figure><p>也相当于把 <span class="math inline">\(u\)</span> “删去”，不同的是，与 <span class="math inline">\(u\)</span> 相连的点的度数不会改变。</p><p>如果我们可以每次在把所有度数 <span class="math inline">\(\le x\)</span> 的点删去后的森林中进行 DP（对每棵树进行 DP 然后把每棵树根节点的 <span class="math inline">\(dp\)</span> 值加起来，具体是加 <span class="math inline">\(dp_{i,0}\)</span> 还是 <span class="math inline">\(dp_{i,1}\)</span> 要看写法），点数之和为 <span class="math inline">\(\sum_{x=0}^{n-1}\sum_{i=1}^{n} [d_i&gt;x]=\sum_{i=1}^{n} d_i=2n-2=O(n)\)</span>，总时间复杂度就变为 <span class="math inline">\(O(n\log n)\)</span> 了。</p><p>具体实现时，可以用两个普通堆实现一个支持删除的堆。每次“删去”一个点 <span class="math inline">\(u\)</span> 时，在所有与该点相连的点 <span class="math inline">\(v\)</span> 对应的堆中加入 <span class="math inline">\(w(u,v)\)</span>；DP 时，假设需要把 <span class="math inline">\(cnt\)</span> 个坏儿子变为好儿子，则我们强制使得堆中只有 <span class="math inline">\(cnt\)</span> 个值，同时记录堆中所有值之和，这样 <span class="math inline">\(dp\)</span> 值就可以很容易地求出；求出 <span class="math inline">\(dp\)</span> 值之后，为了避免每次重新执行所有“删点操作”，我们需要将堆中由“删点”得来的值保留，即把强制删去的值重新插入堆中，把 DP 时得来的值从堆中删去。</p><h2 id="正解代码">正解代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 250005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="keyword">int</span> n, d[N], X, vis[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">vector</span>&lt; <span class="built_in">std</span> :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; E[N];</span><br><span class="line"><span class="built_in">std</span> :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; D[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    E[u].push_back(<span class="built_in">std</span> :: make_pair(v, w)), ++d[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">std</span> :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x, <span class="built_in">std</span> :: pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d[x.first] &gt; d[y.first];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Normal_Heap</span>&#123;</span> <span class="comment">// 普通大根堆</span></span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; a;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123; a.push_back(x), <span class="built_in">std</span> :: push_heap(a.begin(), a.end()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">top</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> a[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123; <span class="built_in">std</span> :: pop_heap(a.begin(), a.end()), a.pop_back(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">popn</span><span class="params">()</span></span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> x; <span class="keyword">return</span> <span class="built_in">std</span> :: pop_heap(a.begin(), a.end()), x = a[a.size() - <span class="number">1</span>], a.pop_back(), x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> a.size(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Erase_Heap</span>&#123;</span> <span class="comment">// 用两个普通堆实现的支持删除的大根堆</span></span><br><span class="line">    Normal_Heap a, b;</span><br><span class="line">    <span class="keyword">int</span> sz; <span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123; a.push(x), ++sz, sum += x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123; b.push(x), --sz, sum -= x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123; <span class="keyword">while</span> (a.size() &amp;&amp; b.size() &amp;&amp; a.top() == b.top()) a.pop(), b.pop(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">top</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> pre(), a.top(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123; pre(), --sz, sum -= a.top(), a.pop(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> sz; &#125;</span><br><span class="line">&#125;H[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="comment">// “删点”操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : E[u])&#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> v = to.first, w = to.second;</span><br><span class="line">        <span class="keyword">if</span> (d[v] &lt;= X) <span class="keyword">break</span>;</span><br><span class="line">        H[v].push(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; tmp, del;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    vis[u] = X;</span><br><span class="line">    <span class="keyword">int</span> num = d[u] - X;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; H[u].size() &gt; num; H[u].pop()) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : E[u])&#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> v = to.first, w = to.second;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (d[v] &lt;= X) <span class="keyword">break</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.clear(), del.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : E[u])&#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> v = to.first, w = to.second;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (d[v] &lt;= X) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = dp[v][<span class="number">1</span>] + w - dp[v][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">0</span>)&#123; --num, res += dp[v][<span class="number">1</span>] + w; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        res += dp[v][<span class="number">0</span>], H[u].push(x), del.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; H[u].size() &amp;&amp; H[u].size() &gt; num; H[u].pop()) tmp.push_back(H[u].top()); <span class="comment">// 强制弹堆</span></span><br><span class="line">    dp[u][<span class="number">0</span>] = res + H[u].sum;</span><br><span class="line">    <span class="keyword">for</span> (; H[u].size() &amp;&amp; H[u].size() &gt; num - <span class="number">1</span>; H[u].pop()) tmp.push_back(H[u].top()); <span class="comment">// 强制弹堆</span></span><br><span class="line">    dp[u][<span class="number">1</span>] = res + H[u].sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : tmp) H[u].push(i); <span class="comment">// 还原强制弹堆时删除的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : del) H[u].erase(i); <span class="comment">// 删除 DP 得来的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">        u = read(), v = read(), w = read(), addedge(u, v, w), addedge(v, u, w), sum += w;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        D[i] = <span class="built_in">std</span> :: make_pair(d[i], i), <span class="built_in">std</span> :: sort(E[i].begin(), E[i].end(), cmp);</span><br><span class="line">    <span class="built_in">std</span> :: sort(D + <span class="number">1</span>, D + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (X = <span class="number">1</span>; X &lt; n; ++X)&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n &amp;&amp; D[i].first == X) die(D[i].second), ++i;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> v = D[j].second;</span><br><span class="line">            <span class="keyword">if</span> (vis[v] == X) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(v), ans += dp[v][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %lld"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AT1732」「CODE FESTIVAL 2015 OKINAWA OPEN」Jungle</title>
      <link href="/atcoder-cfoo15J-sol/"/>
      <url>/atcoder-cfoo15J-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_j" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>有 <span class="math inline">\(n\)</span> 棵树，第 <span class="math inline">\(i\)</span> 棵树高度为 <span class="math inline">\(a_i\)</span>。你需要砍掉一些树，砍树规则如下：</p><ol type="1"><li>只能砍最多 <span class="math inline">\(m\)</span> 棵树。</li><li>对于每个 <span class="math inline">\(i\ (1\le i\le n-k+1)\)</span>，满足 <span class="math inline">\([i,i+k-1]\)</span> 中被砍掉的树的数量不超过 <span class="math inline">\(1\)</span>。</li></ol><p>被砍掉的树的位置的高度都变为 <span class="math inline">\(0\)</span>。</p><p>求砍树后 <span class="math inline">\(\max\limits_{1\le i\le n-k+1}\sum\limits_{j=i}^{i+k-1} a_j\)</span> 的最小值，即最小化所有长度为 <span class="math inline">\(k\)</span> 的区间的树的高度之和的最大值。</p><p><span class="math inline">\(n\le 10^5,a_i\le 10^9\)</span></p><a id="more"></a><h2 id="一个错误但可以-ac-的贪心解法">一个错误但可以 AC 的贪心解法</h2><p>求出 <span class="math inline">\(sum_i\)</span> 表示以 <span class="math inline">\(i\)</span> 结尾的长度为 <span class="math inline">\(k\)</span> 的区间的 <span class="math inline">\(a_i\)</span> 之和。然后求出 <span class="math inline">\(mx_i\)</span> 表示所有包含 <span class="math inline">\(i\)</span> 的长度为 <span class="math inline">\(k\)</span> 的区间中，最大的 <span class="math inline">\(sum_j\)</span> 减去 <span class="math inline">\(a_i\)</span> 的值，即 <span class="math inline">\(mx_i=\max\limits_{i\le j&lt; i+k}sum_j-a_i\)</span>。</p><p>显然可以二分。二分答案 <span class="math inline">\(x\)</span> 后，问题变成了一个判定性问题。</p><blockquote><p>是否存在一种砍树的方法，使得所有长度为 <span class="math inline">\(k\)</span> 的区间的树的高度之和都不超过 <span class="math inline">\(x\)</span>。</p></blockquote><p>可以发现，若一棵树 <span class="math inline">\(i\)</span> 能砍，必须满足 <span class="math inline">\(mx_i\le x\)</span>。对于每个不符合要求的区间，选择该区间中最后一棵能砍的树砍掉。可以发现，优先选最后一棵有时候是不优的，例如</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[O <span class="meta">X</span> <span class="meta">X</span> O] <span class="meta">X</span> [O <span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span>]</span><br></pre></td></tr></table></figure><p>这种情况（<code>O</code> 表示可以砍的树，<code>X</code> 表示不能砍的树，<code>[...]</code> 表示不符合条件的区间），显然方案是选两个区间的第一棵树。若优先选最后一棵，如果不考虑前后两个区间选择的树的距离，虽然也能得到“能”的答案，但方案是不满足要求的，可以用 <code>[X X X O] X [O X X X]</code> 的数据卡掉；如果考虑前后两个区间选择的树的距离，则会得到“不能”的答案，也是错误的。</p><p>我没有考虑前后两个区间选择的树的距离，所以 <code>[X X X O] X [O X X X]</code> 这种数据会得到一个偏小的答案，然而可以 AC。</p><p>附 hack 数据：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">10 </span><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span> <span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">5</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>答案是 <span class="math inline">\(9\)</span>，我的代码会输出 <span class="math inline">\(8\)</span>。</p><h2 id="贪心算法代码">贪心算法代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n, m, k, a[N], h, t, Q[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N], id[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> *cp)</span></span>&#123; <span class="comment">// 单调队列</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt;= t &amp;&amp; cp[Q[t]] &lt;= cp[x]) --t;</span><br><span class="line">    Q[++t] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    h = <span class="number">1</span>, t = <span class="number">1</span>, Q[t] = k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i + k &lt;= n ? push(i + k, sum) : <span class="keyword">void</span>(<span class="number">0</span>), ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[h] &lt; i) ++h;</span><br><span class="line">        <span class="keyword">if</span> (sum[Q[h]] - a[i] &lt;= x) id[i] = i; <span class="keyword">else</span> id[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    h = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) push(i, id);</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>; i &lt;= n - k + <span class="number">1</span>; push(i + k, id), ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[h] &lt; i) ++h;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum[i + k - <span class="number">1</span>] &lt;= x) <span class="keyword">continue</span>;</span><br><span class="line">        p = <span class="keyword">int</span>(id[Q[h]]), ++s;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i] - (i &gt; k ? a[i - k] : <span class="number">0</span>); <span class="comment">// 求 sum</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>, r = <span class="number">100000000000000l</span>l, md, ans;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) <span class="keyword">if</span> (check(md = (l + r) &gt;&gt; <span class="number">1</span>)) ans = md, r = md - <span class="number">1</span>; <span class="keyword">else</span> l = md + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正确的解法">正确的解法</h2><h3 id="一个正确但效率较低的二分-dp-解法">一个正确但效率较低的二分 +DP 解法</h3><p>仍然求出 <span class="math inline">\(sum_i,mx_i\)</span>，考虑二分。</p><p>考虑用 <span class="math inline">\(O(nk)\)</span> 的时间进行一个 DP 来判断。</p><p>首先考虑这样一个 DP 状态：<span class="math inline">\(dp_i\)</span> 表示前 <span class="math inline">\(i\)</span> 棵树（不包括 <span class="math inline">\(i\)</span>），满足所有长度为 <span class="math inline">\(k\)</span> 的区间的和都不超过 <span class="math inline">\(x\)</span>，且第 <span class="math inline">\(i-k\)</span> 棵树<strong>必砍</strong>时，最少需要砍多少棵树。</p><p>考虑主动转移，枚举下一棵砍的树 <span class="math inline">\(i+j\ (j\ge 0)\)</span>，若可以砍 <span class="math inline">\(i+j\)</span>（即满足 <span class="math inline">\(mx_{i+j}\le x\)</span> 且 <span class="math inline">\(\max\limits_{i\le p&lt; i+j} sum_p\le x\)</span>），则 <span class="math inline">\(dp_{i+j+k}\gets \min(dp_{i+j+k},dp_{i}+1)\)</span>。</p><p>然而直接这样做是 <span class="math inline">\(O(n^2)\)</span> 的。通过观察发现，若 <span class="math inline">\(j\ge k\)</span>，则可以把 <span class="math inline">\(dp_i\)</span> 先转移到 <span class="math inline">\(dp_{i+k}\)</span>，再把 <span class="math inline">\(dp_{i+k}\)</span> 向前转移。于是，我们只需要考虑 <span class="math inline">\(0\le j&lt; k\)</span> 即可。时间复杂度优化为 <span class="math inline">\(O(nk)\)</span>。</p><p>总的时间复杂度为 <span class="math inline">\(O(nk\log ans)\)</span>。</p><h3 id="另一个正确但效率较低的-dp-解法">另一个正确但效率较低的 DP 解法</h3><p>仍然求出 <span class="math inline">\(sum_i,mx_i\)</span>，但不二分，直接进行 DP。</p><p><span class="math inline">\(dp_{i,j}\)</span> 表示前 <span class="math inline">\(j\)</span> 棵树，砍了 <span class="math inline">\(i\)</span> 棵，<span class="math inline">\(j\)</span> 必须砍时 <span class="math inline">\(\max\limits_{k\le p&lt; j+k}sum_p\)</span> 的最小值。</p><p>当 <span class="math inline">\(i\)</span> 确定时，记 <span class="math inline">\(Mx_j\)</span> 表示前 <span class="math inline">\(j\)</span> 棵树（不包括 <span class="math inline">\(j\)</span>），砍了 <span class="math inline">\(i-1\)</span> 棵树且最后一棵砍的树 <span class="math inline">\(t\)</span> 满足 <span class="math inline">\(j-t\ge k\)</span> 的 <span class="math inline">\(\max\limits_{k\le p&lt; j} sum_p\)</span> 的最小值。</p><p>其实求 <span class="math inline">\(Mx_j\)</span> 的过程相当于一个 DP 的过程，显然有两种决策：当 <span class="math inline">\(t&lt; j-k\)</span> 时，<span class="math inline">\(Mx_j=\max(Mx_{j-1},sum_{j-1})\)</span>；当 <span class="math inline">\(t=j-k\)</span> 时，<span class="math inline">\(Mx_j=dp_{i-1,j-k}\)</span>。所以有 <span class="math inline">\(Mx_j=\min(\max(Mx_{j-1},sum_{j-1}),dp_{i-1,j-k})\)</span>。</p><p>求出 <span class="math inline">\(Mx_j\)</span> 后，求 <span class="math inline">\(dp_{i,j}\)</span> 就变得很显然：<span class="math inline">\(dp_{i,j}=\max(Mx_j,mx_j)\)</span>，分别表示 <span class="math inline">\(\max\limits_{k\le p&lt; j}sum_p\)</span> 的最小值，以及 <span class="math inline">\(\max\limits_{j\le p&lt; j+k}sum_p\)</span> 的最小值，这两部分互不影响，所以可以独立计算。</p><p>求出 <span class="math inline">\(dp_{i,j}\)</span> 后，求答案也变得很显然：由于 <span class="math inline">\(dp_{m,j}\)</span> 并没有包括 <span class="math inline">\(\max\limits_{j+k\le p\le n}sum_p\)</span>，把这部分与 <span class="math inline">\(dp_{m,j}\)</span> 取 <span class="math inline">\(\max\)</span> 即可。</p><p>可以使用滚动数组优化内存。时间复杂度为 <span class="math inline">\(O(nm)\)</span>。</p><h3 id="正解两者之并">正解——两者之并</h3><p>可以发现，<span class="math inline">\(m&gt; \lceil \frac{n}{k}\rceil\)</span> 与 <span class="math inline">\(m= \lceil \frac{n}{k}\rceil\)</span> 的情况答案是相同的。所以 <span class="math inline">\(m\)</span> 最大为 <span class="math inline">\(\lceil \frac{n}{k}\rceil\)</span>。</p><p>上面的两个 DP，可以发现当 <span class="math inline">\(k\le 50\)</span> 时第一个 DP 是可以过的。而 <span class="math inline">\(k&gt;50\)</span> 时，由于 <span class="math inline">\(m\)</span> 的级别是 <span class="math inline">\(\frac{n}{k}\)</span>，第二个 DP 可以过。</p><p>那么把两者合并一下就可以通过此题。</p><h2 id="正解代码">正解代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n, m, k, a[N], h, t, Q[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N], mx[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 单调队列维护</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt;= t &amp;&amp; sum[Q[t]] &lt;= sum[x]) --t;</span><br><span class="line">    Q[++t] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Subtask1&#123; <span class="comment">// 二分+DP O(nk log ans)</span></span><br><span class="line">    <span class="keyword">int</span> dp[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n + <span class="number">1</span>) i = n + <span class="number">1</span>;</span><br><span class="line">        dp[i] = <span class="built_in">std</span> :: min(dp[i], j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) dp[i] = <span class="number">1e9</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> Mx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; i + j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Mx &lt;= x &amp;&amp; mx[i + j] &lt;= x) upd(i + j + k, dp[i] + <span class="number">1</span>);</span><br><span class="line">                Mx = <span class="built_in">std</span> :: max(Mx, sum[i + j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if (x == 0) printf("%d %lld\n", i, Mx);</span></span><br><span class="line">            <span class="keyword">if</span> (Mx &lt;= x) upd(i + k, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n + <span class="number">1</span>] &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>, r = <span class="number">1e14</span>, md, ans;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) <span class="keyword">if</span> (check(md = (l + r) &gt;&gt; <span class="number">1</span>)) ans = md, r = md - <span class="number">1</span>; <span class="keyword">else</span> l = md + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Subtask2&#123; <span class="comment">// DP O(nm)=O(n^2/k)</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">2</span>][N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> Mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; k) Mx = <span class="built_in">std</span> :: max(Mx, sum[i - <span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="built_in">std</span> :: max(Mx, mx[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = i &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> Mx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; k) Mx = <span class="built_in">std</span> :: max(Mx, sum[j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; k) Mx = <span class="built_in">std</span> :: min(Mx, dp[!t][j - k]);</span><br><span class="line">                dp[t][j] = <span class="built_in">std</span> :: max(Mx, mx[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0x3f3f3f3f3f3f3f3f</span>ll;</span><br><span class="line">        Mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= n) Mx = <span class="built_in">std</span> :: max(Mx, sum[i + k]);</span><br><span class="line">            ans = <span class="built_in">std</span> :: min(ans, <span class="built_in">std</span> :: max(dp[m &amp; <span class="number">1</span>][i], Mx));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    m = <span class="built_in">std</span> :: min(m, n / k + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i] - (i &gt; k ? a[i - k] : <span class="number">0</span>);</span><br><span class="line">    h = <span class="number">1</span>, t = <span class="number">1</span>, Q[t] = k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i + k &lt;= n ? push(i + k) : <span class="keyword">void</span>(<span class="number">0</span>), ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[h] &lt; i) ++h;</span><br><span class="line">        mx[i] = sum[Q[h]] - a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">2005</span>) <span class="keyword">return</span> Subtask2 :: Main(), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">55</span>) <span class="keyword">return</span> Subtask1 :: Main(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> CODE FESTIVAL 2015 OKINAWA OPEN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 二分 </tag>
            
            <tag> RMQ </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AT1731」「CODE FESTIVAL 2015 OKINAWA OPEN」Implementation Addict</title>
      <link href="/atcoder-cfoo15I-sol/"/>
      <url>/atcoder-cfoo15I-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_i" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>有 <span class="math inline">\(n\)</span> 天，每天有一个值 <span class="math inline">\(a_i\)</span>（未确定的值），其中 <span class="math inline">\(a_i=0\)</span> 的天数称为“休息”，其他的称为“工作”。</p><p>若第 <span class="math inline">\(i\)</span> 天为“工作”，设第 <span class="math inline">\(i\)</span> 天之前（不包含第 <span class="math inline">\(i\)</span> 天）连续“工作”的天数为 <span class="math inline">\(k\)</span>，则 <span class="math inline">\(a_i=\max(0,A-kB)\)</span>（<span class="math inline">\(A,B\)</span> 给定）；若第 <span class="math inline">\(i\)</span> 天为“休息”，则 <span class="math inline">\(a_i=0\)</span>。</p><p>现已经确定 <span class="math inline">\(m\)</span> 天为“休息”，求 <span class="math inline">\(\sum_{i=1}^{n} a_i\)</span> 的最大值。</p><p><span class="math inline">\(n,A,B\le 10^9,m\le 10^5\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p><span class="math inline">\(m\)</span> 天“休息”，相当于把 <span class="math inline">\(n\)</span> 分成了 <span class="math inline">\(m+1\)</span> 份，每份是独立的，所以可以分别进行计算。所以，现在不再需要考虑 <span class="math inline">\(m\)</span> 天“休息”。假设当前子问题的天数为 <span class="math inline">\(n\)</span>。</p><p>为了使得和最大，一定是等分更优。例如 <span class="math inline">\(n=7\)</span>，分成 <span class="math inline">\(3\)</span> 块（即“休息” <span class="math inline">\(2\)</span> 天），则一定是分别工作 <span class="math inline">\(1,2,2\)</span> 天。为方便处理，可以将 <span class="math inline">\(n\)</span> 加 <span class="math inline">\(1\)</span>，钦定最后一天为“休息”。</p><p>假设分成 <span class="math inline">\(x\)</span> 块，设 <span class="math inline">\(t=\left\lfloor \frac{n}{x}\right\rfloor-1\)</span>，则一定是 <span class="math inline">\(n\bmod x\)</span> 块工作 <span class="math inline">\(t+1\)</span> 天，<span class="math inline">\(x-n\bmod x\)</span> 块工作 <span class="math inline">\(t\)</span> 天。这个可以直接用等差数列求和公式进行计算。</p><p>至于如何确定 <span class="math inline">\(x\)</span>，可以发现，答案是一个单峰函数，所以直接三分 <span class="math inline">\(x\)</span> 即可。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m, x[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A, B, ans;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 计算 n 天分成 x 块的答案</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = n / x - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((A + A - (m - <span class="number">1</span>) * B) * m &gt;&gt; <span class="number">1</span>) * x + (A - m * B) * (n % x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 三分求 n 天的答案</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> md = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">// 写的有点像二分，其实是三分</span></span><br><span class="line">        <span class="keyword">if</span> (get(n, md) &gt;= get(n, md + <span class="number">1</span>)) ans = md, r = md - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = md + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get(n, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lld%lld%d"</span>, &amp;n, &amp;A, &amp;B, &amp;m), x[m + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, x + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) ans += solve(x[i + <span class="number">1</span>] - x[i]); <span class="comment">// n 在这里已经加 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> CODE FESTIVAL 2015 OKINAWA OPEN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 三分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AT1730」「CODE FESTIVAL 2015 OKINAWA OPEN」Happy 2015</title>
      <link href="/atcoder-cfoo15H-sol/"/>
      <url>/atcoder-cfoo15H-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_h" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定 <span class="math inline">\(n\)</span> 个区间 <span class="math inline">\((l_r,r_i]\)</span>（注意原题中虽然写着 <span class="math inline">\([l_i,r_i]\)</span>，但通过转化后相当于 <span class="math inline">\((l_i,r_i]\)</span>），每个区间有存在和不存在两种状态。求所有 <span class="math inline">\(2^n\)</span> 种方案中，<strong>本质不同</strong>的方案的数量 <span class="math inline">\(\bmod (10^9+7)\)</span> 的值。</p><p>记一个方案的<strong>点集合</strong>为数轴上至少被一个区间覆盖的整数组成的集合，则两个方案<strong>本质不同</strong>当且仅当这两个方案的<strong>点集合</strong>不同。</p><p><span class="math inline">\(n\le 2000,0\le l_i&lt; r_i\le 10^9\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>为方便处理，我们把 <span class="math inline">\(l_i\)</span> 加 <span class="math inline">\(1\)</span> 使得区间变为闭区间。</p><p>显然，<span class="math inline">\(l_i,r_i\)</span> 可以离散，所以坐标变为 <span class="math inline">\(O(n)\)</span> 级别。</p><p>然后考虑一个 DP，<span class="math inline">\(dp_{i,0/1}\)</span> 表示覆盖前 <span class="math inline">\(i\)</span> 个点，且第 <span class="math inline">\(i\)</span> 个点必须覆盖/不覆盖的本质不同的方案数。</p><p>那么可以写出一个 <span class="math inline">\(O(n^2)\)</span> 的 DP，方程如下：<span class="math display">\[dp_{i,j}=\begin{cases} dp_{i-1,0}+dp_{i-1,1} &amp; \text{ if } j=0 \\ \sum\limits_{cov(k,i)=1} dp_{k-1,0} &amp; \text{ if } j=1 \end{cases}\]</span></p><p>其中 <span class="math inline">\(cov(k,i)=0/1\)</span> 表示是否存在一种区间覆盖方案使得刚好覆盖 <span class="math inline">\([k,i]\)</span>。</p><p><span class="math inline">\(cov(i,j)\)</span> 可以用如下方式处理：</p><p>记 <span class="math inline">\(p_i\)</span>（一个 vector） 表示所有右端点为 <span class="math inline">\(i\)</span> 的区间的左端点。</p><p>枚举 <span class="math inline">\(i\)</span>（被覆盖部分的左端点），首先枚举所有左端点为 <span class="math inline">\(i\)</span> 的区间 <span class="math inline">\([i,r_j]\)</span>，使得 <span class="math inline">\(cov(i,r_j)=1\)</span>。</p><p>然后枚举所有右端点 <span class="math inline">\(j\)</span>，再枚举所有右端点为 <span class="math inline">\(j\)</span> 的区间（即 <span class="math inline">\([p_{j,k},j]\)</span> ），若 <span class="math inline">\(p_{j,k}&gt; i\)</span> 且存在一个 <span class="math inline">\(x\in [p_{j,k},j]\)</span> 满足 <span class="math inline">\(cov(i,x)=1\)</span>，则 <span class="math inline">\(cov(i,j)=1\)</span>。</p><p>至于如何判断“存在一个 <span class="math inline">\(x\in [p_{j,k},j]\)</span> 满足 <span class="math inline">\(cov(i,x)=1\)</span>”，可以在枚举右端点求 <span class="math inline">\(cov(i,j)\)</span> 的同时用前缀和进行判断，具体实现见代码。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n, m, pos[<span class="number">4005</span>], sum[<span class="number">4005</span>], dp0[<span class="number">4005</span>], dp1[<span class="number">4005</span>];</span><br><span class="line"><span class="keyword">bool</span> cov[<span class="number">4005</span>][<span class="number">4005</span>];</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[<span class="number">4005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;a[<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    (x += y) &gt;= P ? x -= P : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].l, &amp;a[i].r), pos[++m] = a[i].l, pos[++m] = a[i].r;</span><br><span class="line">    <span class="built_in">std</span> :: sort(pos + <span class="number">1</span>, pos + <span class="number">1</span> + m);</span><br><span class="line">    m = <span class="built_in">std</span> :: unique(pos + <span class="number">1</span>, pos + <span class="number">1</span> + m) - pos - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        a[i].l = <span class="built_in">std</span> :: lower_bound(pos + <span class="number">1</span>, pos + <span class="number">1</span> + m, a[i].l) - pos + <span class="number">1</span>;</span><br><span class="line">        a[i].r = <span class="built_in">std</span> :: lower_bound(pos + <span class="number">1</span>, pos + <span class="number">1</span> + m, a[i].r) - pos;</span><br><span class="line">        p[a[i].r].push_back(a[i].l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以上分别为：转为闭区间、离散、处理 p</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        sum[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[j].l == i) cov[i][a[j].r] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt;= m; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p[j].size(); ++k)</span><br><span class="line">                <span class="keyword">if</span> (p[j][k] &gt; i &amp;&amp; sum[j] &gt; sum[p[j][k] - <span class="number">1</span>])&#123; cov[i][j] = <span class="number">1</span>; <span class="keyword">break</span>; &#125; <span class="comment">// 根据前缀和判断</span></span><br><span class="line">            sum[j + <span class="number">1</span>] = sum[j] + cov[i][j]; <span class="comment">// 同时处理前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以上为处理 cov</span></span><br><span class="line">    dp0[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        add(dp0[i], dp0[i - <span class="number">1</span>]), add(dp0[i], dp1[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (cov[j][i]) add(dp1[i], dp0[j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以上为 dp</span></span><br><span class="line">    add(dp0[m], dp1[m]), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp0[m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> CODE FESTIVAL 2015 OKINAWA OPEN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 离散 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AT1729」「CODE FESTIVAL 2015 OKINAWA OPEN」Gorgeous Vases</title>
      <link href="/atcoder-cfoo15G-sol/"/>
      <url>/atcoder-cfoo15G-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_g" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>有两个有序二元组 <span class="math inline">\((A,B),(C,D)\)</span>，<span class="math inline">\(A,B\)</span> 给定且保证 <span class="math inline">\(A\ge B\)</span>，<span class="math inline">\(C,D\)</span> 一开始为 <span class="math inline">\(0\)</span>。另外给定 <span class="math inline">\(n\)</span> 个有序二元组 <span class="math inline">\((p_i,q_i)\)</span>，有两种操作：</p><ol type="1"><li><span class="math inline">\(A\gets A-1,C\gets C+1\)</span></li><li><span class="math inline">\(B\gets B-1,D\gets D+1\)</span></li></ol><p>不断执行这两种操作，直到二元组变为 <span class="math inline">\((0,0),(A&#39;,B&#39;)\)</span>，其中 <span class="math inline">\(A&#39;,B&#39;\)</span> 表示最初的 <span class="math inline">\(A,B\)</span>。但<strong>任意时刻</strong>都需要满足：</p><ol type="1"><li><span class="math inline">\(A\ge B,C\ge D\)</span></li><li><span class="math inline">\(\forall i\in [1,n],(A,B)\ne (p_i,q_i),(C,D)\ne (p_i,q_i)\)</span>。</li></ol><p>求方案数 <span class="math inline">\(\bmod (10^9+7)\)</span> 的值。</p><p>记操作序列为由每次的操作编号组成的长度为 <span class="math inline">\(A&#39;+B&#39;\)</span> 的序列，则两个方案不同当且仅当两个方案的操作序列不同。</p><p><span class="math inline">\(1\le B\le A\le 10^5,0\le n\le 20\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>可以发现，题目可以转化为：</p><blockquote><p>从 <span class="math inline">\((0,0)\)</span> 走到 <span class="math inline">\((A,B)\)</span>，每次只能走 <span class="math inline">\((+1,0)\)</span> 或 <span class="math inline">\((0,+1)\)</span>（即只能向上、向右走），求满足以下条件的方案数： 1. 对于所有经过的点 <span class="math inline">\((x,y)\)</span>，<span class="math inline">\(x\ge y,A-x\ge B-y\)</span> 2. 不能经过点 <span class="math inline">\((p_i,q_i),(A-p_i,B-q_i)\)</span>。</p></blockquote><p>把 <span class="math inline">\((A,B)\)</span> 和所有不能经过的点称为障碍点，把障碍点按一定顺序排序后，可以很轻松地写出一个 DP：</p><p><span class="math inline">\(dp_i\)</span> 表示到达障碍点 <span class="math inline">\(i\)</span> 的方案数，则 <span class="math inline">\(dp_i=solve(0,i)-\sum dp_j+solve(j,i)\)</span>，其中 <span class="math inline">\(j\)</span> 在 <span class="math inline">\(i\)</span> 的左下方，<span class="math inline">\(solve(j,i)\)</span> 表示 <span class="math inline">\(j\)</span> 到 <span class="math inline">\(i\)</span> 的方案数，<span class="math inline">\(solve(0,i)\)</span> 表示 <span class="math inline">\((0,0)\)</span> 到 <span class="math inline">\(i\)</span> 的方案数。</p><p>发现关键在于如何求 <span class="math inline">\(solve(i,j)\)</span> 的值。那么问题又转化为：</p><blockquote><p>从 <span class="math inline">\((x_1,y_1)\)</span> 走到 <span class="math inline">\((x_2,y_2)\)</span>，只能向上、向右走，满足所有经过的点 <span class="math inline">\((x,y)\)</span> 在直线 <span class="math inline">\(y=x\)</span> 和 <span class="math inline">\(y=x-(A-B)\)</span> 之间（包括这两条直线上的点），求方案数。</p></blockquote><figure><img src="https://autumnkite.github.io/files/at-cfoo15g-pic1.png" alt="" /><figcaption>图 1</figcaption></figure><p>类似上图中的情况，求 <span class="math inline">\((x_1,y_2)\)</span> 到 <span class="math inline">\((x_2,y_2)\)</span> 的方案数。</p><p>首先，为方便起见，把两条直线分别向上、向下移动一个单位，这样我们就不能碰到这两条直线，碰到即算不符合。</p><p>考虑所有情况减去不符合要求的情况，所有情况可以用组合数直接计算，那么我们要计算下图中的两种情况的方案数。</p><figure><img src="https://autumnkite.github.io/files/at-cfoo15g-pic2.png" alt="" /><figcaption>图 2</figcaption></figure><p>我们先考虑左图的情况，可以发现，左图的情况可以把剩余部分按直线 <span class="math inline">\(y=x+1\)</span> 对称，如下图所示：</p><figure><img src="https://autumnkite.github.io/files/at-cfoo15g-pic3.png" alt="" /><figcaption>图 3</figcaption></figure><p>此时 <span class="math inline">\((x_1,y_1)\)</span> 到 <span class="math inline">\((x_2,y_2)\)</span> 一定会碰到 <span class="math inline">\(y=x+1\)</span>，即图 2 中左图的情况。</p><p>可是会发现，如果一个方案穿过了 <span class="math inline">\(y=x+1\)</span>，然后又穿过了 <span class="math inline">\(y=x-(A-B)-1\)</span>，则这个方案会被重复计算，需要减去。</p><p>可以发现，对称后，<span class="math inline">\(y=x-(A-B)-1\)</span> 这条直线到了最上面，即此时的情况为（下图中的左图）：</p><figure><img src="https://autumnkite.github.io/files/at-cfoo15g-pic4.png" alt="" /><figcaption>图 4</figcaption></figure><p>那么同样，对称后计算（如上图右图所示）。</p><p>如果还有重复情况（即上下上、上下上下等情况），则继续对称即可。</p><p>具体实现及细节见代码。</p><h2 id="代码">代码</h2><p>注意，代码并不是每次作对称然后判断正负的，而是把所有负的都减掉，再把所有正的加上，所以与上面的分析有所出入，请仔细理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> A, B, n, m, fac[<span class="number">200005</span>], inv[<span class="number">200005</span>], dp[<span class="number">50</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; res.x || x == res.x &amp;&amp; y &lt; res.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == res.x &amp;&amp; y == res.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[m].y &lt;= p[m].x &amp;&amp; p[m].y &gt;= p[m].x - A + B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1l</span>l * a * a % P) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1l</span>l * s * a % P;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    inv[n] = qpow(fac[n], P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i) inv[i - <span class="number">1</span>] = <span class="number">1l</span>l * inv[i] * i % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x &gt; b.x || a.y &gt; b.y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * fac[b.x - a.x + b.y - a.y] * inv[b.x - a.x] % P * inv[b.y - a.y] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123; (x += y) &gt;= P ? x -= P : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123; (x -= y) &lt; <span class="number">0</span> ? x += P : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(node a, node b)</span></span>&#123; <span class="comment">// 计算 a 到 b 的方案数，主要难在这个函数</span></span><br><span class="line">    <span class="keyword">int</span> res = F(a, b), w = A - B + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> node c = (node)&#123;b.y - <span class="number">1</span>, b.x + <span class="number">1</span>&#125;; c.x &gt;= a.x; c.x -= w, c.y += w) del(res, F(a, c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> node c = (node)&#123;b.x - w, b.y + w&#125;; c.x &gt;= a.x; c.x -= w, c.y += w) add(res, F(a, c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> node c = (node)&#123;b.y + w - <span class="number">1</span>, b.x - w + <span class="number">1</span>&#125;; c.y &gt;= a.y; c.x += w, c.y -= w) del(res, F(a, c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> node c = (node)&#123;b.x + w, b.y - w&#125;; c.y &gt;= a.y; c.x += w, c.y -= w) add(res, F(a, c));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;A, &amp;B, &amp;n), pre(A + B);</span><br><span class="line">    <span class="keyword">if</span> (A == B) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (!x &amp;&amp; !y) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>), <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == A &amp;&amp; x == B) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>), <span class="number">0</span>;</span><br><span class="line">        p[++m] = (node)&#123;x, y&#125;, !check(m) ? --m : <span class="number">0</span>;</span><br><span class="line">        p[++m] = (node)&#123;A - x, B - y&#125;, !check(m) ? --m : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>] = (node)&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, p[++m] = (node)&#123;A, B&#125;;</span><br><span class="line">    <span class="built_in">std</span> :: sort(p + <span class="number">1</span>, p + <span class="number">1</span> + m);</span><br><span class="line">    m = <span class="built_in">std</span> :: unique(p + <span class="number">1</span>, p + <span class="number">1</span> + m) - p - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        dp[i] = calc(p[<span class="number">0</span>], p[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            (dp[i] -= <span class="number">1l</span>l * dp[j] * calc(p[j], p[i]) % P) &lt; <span class="number">0</span> ? dp[i] += P : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> CODE FESTIVAL 2015 OKINAWA OPEN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 数学 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AT1728」「CODE FESTIVAL 2015 OKINAWA OPEN」Falconry</title>
      <link href="/atcoder-cfoo15F-sol/"/>
      <url>/atcoder-cfoo15F-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_f" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定平面上 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\((x_i,y_i)\)</span>，以及三只鸟的初始坐标 <span class="math inline">\((x_a,y_a),(x_b,y_b),(x_c,y_c)\)</span>。现在三只鸟要从初始点开始，依次飞到一些点（不需要回到起点），要求每个点至少被一只鸟飞到。求三只鸟总飞行距离之和的最小值。</p><p>从一个点 <span class="math inline">\((x_s,y_s)\)</span> 飞到另一个点 <span class="math inline">\((x_t,y_t)\)</span> 的飞行距离为这两个点的欧几里得距离，即 <span class="math display">\[\sqrt{(x_s - x_t)^2 + (y_s - y_t)^2}\]</span></p><p><span class="math inline">\(n\le 18\)</span>，所有横纵坐标的绝对值 <span class="math inline">\(\le 10^4\)</span>，时限 <span class="math inline">\(8s\)</span>。</p><a id="more"></a><h2 id="方法一">方法一</h2><p>三只鸟很难考虑，考虑一只鸟飞遍某个点集所需的最少时间。</p><p>记 <span class="math inline">\(dp_{t,i,j}\)</span> 表示第 <span class="math inline">\(t\)</span> 只鸟，飞遍点集 <span class="math inline">\(i\)</span>，最后停留在点 <span class="math inline">\(j\)</span> 的最小距离和。</p><p>转移很显然，只要在点集 <span class="math inline">\(i\)</span> 中枚举上一个点 <span class="math inline">\(k\)</span>，然后直接转移即可。</p><p>最后枚举每只鸟飞到的点集即可，因为两只鸟飞到的点集不会有交，所以复杂度为 <span class="math inline">\(O(3^n)\)</span>。具体实现时，可以枚举一个集合 <span class="math inline">\(A\)</span>，再枚举这个集合的子集 <span class="math inline">\(B\)</span>，假设全集为 <span class="math inline">\(C\)</span>，则三个集合分别为 <span class="math inline">\(B,A-B,C-A\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(3n^22^n+3^n)\)</span>，常数不大，最大点 <span class="math inline">\(2898ms\)</span>（<a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/submissions/3961803" target="_blank" rel="noopener">评测记录</a>）。</p><h2 id="方法二">方法二</h2><p>发现上面的方法比较慢，且主要在于 <span class="math inline">\(3^n\)</span> 的统计答案。考虑直接在第二只鸟、第三只鸟 DP 时，直接合并答案。</p><p>记 <span class="math inline">\(dp_{t,i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 只鸟，飞遍点集 <span class="math inline">\(i\)</span>，第 <span class="math inline">\(i\)</span> 只鸟停留在点 <span class="math inline">\(j\)</span> 时的最小距离和。</p><p>主要转移方程与方法一差不多，但是有一些细节需要注意，例如飞到第一个点时需要特殊转移，具体参见代码。也许有更好的、细节更少的写法，欢迎分享。</p><p>时间复杂度 <span class="math inline">\(O(3n^22^n)\)</span>，最大点 <span class="math inline">\(535ms\)</span>（<a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/submissions/4218967" target="_blank" rel="noopener">评测记录</a>）。</p><h2 id="代码">代码</h2><h3 id="方法一-1">方法一</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;a[<span class="number">20</span>], b[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">double</span> Dp[<span class="number">3</span>][<span class="number">300000</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(point a, point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;b[i].x, &amp;b[i].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">3</span>; ++t)&#123;</span><br><span class="line">        <span class="keyword">double</span> (*dp)[<span class="number">20</span>] = Dp[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">                dp[i][j] = <span class="number">1e100</span>;</span><br><span class="line">        dp[<span class="number">0</span>][n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) dp[<span class="number">1</span> &lt;&lt; i][i] = dis(b[t], a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">                        <span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span> &amp;&amp; k != j)</span><br><span class="line">                            dp[i][j] = <span class="built_in">std</span> :: min(dp[i][j], dp[<span class="number">1</span> &lt;&lt; j ^ i][k] + dis(a[k], a[j]));</span><br><span class="line">                    dp[i][n] = <span class="built_in">std</span> :: min(dp[i][n], dp[i][j]); <span class="comment">// 这个状态记录0~n-1的最小值</span></span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1e100</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j = (j - <span class="number">1</span>) &amp; i)&#123;</span><br><span class="line">            <span class="keyword">int</span> A = j, B = i ^ j, C = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) ^ i;</span><br><span class="line">            ans = <span class="built_in">std</span> :: min(ans, Dp[<span class="number">0</span>][A][n] + Dp[<span class="number">1</span>][B][n] + Dp[<span class="number">2</span>][C][n]);</span><br><span class="line">            <span class="keyword">if</span> (!j) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.12lf\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-1">方法二</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;a[<span class="number">20</span>], b;</span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">3</span>][<span class="number">300000</span>][<span class="number">20</span>], d[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(point a, point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">3</span>; ++t)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;b.x, &amp;b.y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">                dp[t][i][j] = <span class="number">1e100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                d[i][j] = dis(a[i], a[j]);</span><br><span class="line">        dp[t][<span class="number">0</span>][n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) dp[t][<span class="number">1</span> &lt;&lt; i][i] = dis(b, a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[t][i][n] = <span class="built_in">std</span> :: min(t ? dp[t - <span class="number">1</span>][i][n] : <span class="number">1e100</span>, dp[t][i][n]); <span class="comment">// 特殊转移 1</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">                        <span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span> &amp;&amp; k != j)</span><br><span class="line">                            dp[t][i][j] = <span class="built_in">std</span> :: min(dp[t][i][j], dp[t][<span class="number">1</span> &lt;&lt; j ^ i][k] + d[k][j]);</span><br><span class="line">                    dp[t][i][j] = <span class="built_in">std</span> :: min(dp[t][i][j], t ? dp[t - <span class="number">1</span>][<span class="number">1</span> &lt;&lt; j ^ i][n] + dis(b, a[j]) : <span class="number">1e100</span>); <span class="comment">// 特殊转移 2</span></span><br><span class="line">                    dp[t][i][n] = <span class="built_in">std</span> :: min(dp[t][i][n], dp[t][i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.12lf\n"</span>, dp[<span class="number">2</span>][(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有更好的写法或复杂度更优的做法请在评论中分享！</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> CODE FESTIVAL 2015 OKINAWA OPEN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AT1727」「CODE FESTIVAL 2015 OKINAWA OPEN」Enormous XOR Rectangle</title>
      <link href="/atcoder-cfoo15E-sol/"/>
      <url>/atcoder-cfoo15E-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_e" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p><span class="math inline">\(H\times W\)</span> 的矩阵，第 <span class="math inline">\(i(0\le i&lt; H)\)</span> 行第 <span class="math inline">\(j(0\le j&lt; W)\)</span> 列的数为 <span class="math inline">\(iW+j\)</span>。</p><p>选一个子矩阵，使得该子矩阵中所有元素 <code>xor</code> 的值最大。输出这个值。</p><p><span class="math inline">\(H,W\le 10^9\)</span></p><a id="more"></a><h2 id="分析">分析</h2><p>记 <span class="math inline">\(n\)</span> 为满足 <span class="math inline">\(2^{n-1} \le H\times W-1 &lt; 2^n\)</span> 的值。所以答案一定 <span class="math inline">\(&lt; 2^n\)</span>。</p><p>当 <span class="math inline">\(2^{n-1}-1\)</span> 与 <span class="math inline">\(2^{n-1}\)</span> 左右相邻时，由于 <span class="math inline">\((2^{n-1}-1)\text{ xor }(2^{n-1})=2^n-1\)</span>，所以答案显然为 <span class="math inline">\(2^n-1\)</span>。</p><p>否则，此时的情况一定是 <span class="math inline">\(2^{n-1}-1\)</span> 在某行的最后一列，<span class="math inline">\(2^{n-1}\)</span> 在这一行下面一行的第一列，所以 <span class="math inline">\(W\)</span> 此时一定能表示为 <span class="math inline">\(2^m(0\le m\le n-1)\)</span>。例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line"><span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span></span><br><span class="line">-----------</span><br><span class="line"><span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span></span><br><span class="line"><span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span></span><br><span class="line"><span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span></span><br></pre></td></tr></table></figure><p>图中 <span class="math inline">\(n=5,2^{n-1}-1=15,2^{n-1}=16\)</span>。</p><p>这种情况下，下界显然是 <span class="math inline">\(2^n-2^m=2^n-W\)</span>，即 <span class="math inline">\((2^{n-1}-1)\text{ xor }(2^{n-1}-1+2^m)\)</span>。记这个下界为 <span class="math inline">\(d\)</span>，考虑是否有答案超过 <span class="math inline">\(d\)</span> 的情况。</p><p>通过观察可以发现：</p><ol type="1"><li>一行中所有数的最高 <span class="math inline">\(n-m\)</span> 位都相同。</li><li>一列中所有数的最后 <span class="math inline">\(m\)</span> 位都相同。</li></ol><p>继续分析可以得到：</p><ol type="1"><li>若选偶数行，<code>xor</code> 值的最后 <span class="math inline">\(m\)</span> 位都是 <span class="math inline">\(0\)</span>，答案 <span class="math inline">\(\le d\)</span>。</li><li>若选偶数列，<code>xor</code> 值的最高 <span class="math inline">\(n-m\)</span> 位都是 <span class="math inline">\(0\)</span>，答案 <span class="math inline">\(\le d\)</span>。</li><li>若选奇数列，考虑每一行，一定在该行中存在一个数与该行的 <code>xor</code> 值相等，且每一行的这个数一定在同一列，所以选奇数列的所有情况相当于选 <span class="math inline">\(1\)</span> 列的所有情况。那么，为了得到最优的答案，一定选择最后一列。</li></ol><p>综上，我们选择的范围变成了最后一列，选奇数行。并且，若存在这样的答案，答案最后的 <span class="math inline">\(m\)</span> 位一定都为 <span class="math inline">\(1\)</span>。那么超过 <span class="math inline">\(d\)</span> 的答案只可能是 <span class="math inline">\(2^n-1\)</span>。</p><p>所以，问题变成了以一个序列上的问题：</p><blockquote><p><span class="math inline">\(H\)</span> 个数，第 <span class="math inline">\(i(0\le i&lt; H)\)</span> 个数为 <span class="math inline">\(i\)</span>，问是否存在一个区间，使得这个区间的 <code>xor</code> 值为 <span class="math inline">\(2^{n-m}-1\)</span>。</p></blockquote><p>例如：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> | <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>分界线左边最高位为 <span class="math inline">\(0\)</span>，右边最高位为 <span class="math inline">\(1\)</span>。由于要达到 <span class="math inline">\(2^{n-m}-1\)</span>，分界线右边必须选奇数个，才能保证最高位为 <span class="math inline">\(1\)</span>。</p><p>根据 <span class="math inline">\((2n)\text{ xor }(2n+1)=1\ (n\ge 0)\)</span>，可以证明分界线左边的数不需要选择。</p><p>根据 <span class="math inline">\(0\text{ xor }1\text{ xor }2\text{ xor }\cdots\text{ xor }(2^n-1)=0 \ (n\ge 2)\)</span>，可以证明右边若要选出 <span class="math inline">\(2^{n-m}-1\)</span>，必须选择 <span class="math inline">\(2^{n-m-1}\sim 2^{n-m}-2\)</span> 的所有数。</p><p>注意上述结论是一般情况，<span class="math inline">\(n-m\)</span> 特别小时可以特殊处理，不过仍然可以证明下面总结中的结论是正确的。</p><h2 id="结论">结论</h2><p>根据上面的分析、推导和转化，可以得到如下结论：</p><p>若 <span class="math inline">\(W\)</span> 不是 <span class="math inline">\(2\)</span> 的幂次，或者 <span class="math inline">\(H\)</span> 是 <span class="math inline">\(2\)</span> 的幂次，或者 <span class="math inline">\(H+1\)</span> 是 <span class="math inline">\(2\)</span> 的幂次，则答案为 <span class="math inline">\(2^n-W\)</span>，否则答案为 <span class="math inline">\(2^n-1\)</span>。</p><h3 id="技巧">技巧</h3><p>判断一个数是否是 <span class="math inline">\(2\)</span> 的幂次，可以根据 <span class="math inline">\(lowbit\)</span> 与该数本身是否相等来判断。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x &amp; -x) == x; &#125; <span class="comment">// 技巧</span></span><br><span class="line"><span class="keyword">int</span> H, W, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;H, &amp;W);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">1l</span>l * H * W - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp) ++n, tmp &gt;&gt;= <span class="number">1</span>; <span class="comment">// 求 n</span></span><br><span class="line">    <span class="keyword">if</span> (!check(W) || check(H) || check(H + <span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (<span class="number">1l</span>l &lt;&lt; n) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (<span class="number">1l</span>l &lt;&lt; n) - W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> CODE FESTIVAL 2015 OKINAWA OPEN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分类讨论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「LuoguP3846」「TJOI2007」可爱的质数 / BSGS 学习笔记</title>
      <link href="/luogu3846-sol-bsgs-notes/"/>
      <url>/luogu3846-sol-bsgs-notes/</url>
      
        <content type="html"><![CDATA[<p>大步小步法（Baby Step Giant Step, BSGS），用于解决求形如 <span class="math inline">\(a^x\equiv b \pmod P\)</span> 的最小非负整数解，其中<span class="math inline">\((a,P)=1\)</span>。</p><a id="more"></a><h2 id="求解">求解</h2><p>显然 <span class="math inline">\(x\)</span> 可以表示为 <span class="math inline">\(i\cdot t-j\)</span> 的形式，其中 <span class="math inline">\(t\)</span> 是常数。那么原方程化为 <span class="math display">\[\begin{aligned}  a^{it-j} &amp;\equiv b &amp;\pmod P \\ \frac{a^{it}}{a^j} &amp;\equiv b &amp;\pmod P \\ a^{it}&amp;\equiv ba^j &amp;\pmod P \end{aligned}\]</span></p><p>又根据欧拉定理可得，<span class="math inline">\(a^b\equiv a^{b\bmod \varphi(P)}\pmod P\)</span>，所以最小非负整数解一定满足 <span class="math inline">\(0\le x &lt; \varphi(P)\)</span>。</p><p>那么 <span class="math inline">\(t\)</span> 取 <span class="math inline">\(\lfloor \sqrt{\varphi(P)}\rfloor\)</span> 时，<span class="math inline">\(i,j\)</span> 的数量都是 <span class="math inline">\(\mathcal O(\sqrt{P})\)</span> 的。所以我们只要对于所有的 <span class="math inline">\(i\)</span> 求出 <span class="math inline">\(a^{it}\)</span>，对于所有的 <span class="math inline">\(j\)</span> 求出 <span class="math inline">\(ba^j\)</span>，然后匹配即可。</p><p>具体实现时，可以用 <code>map</code> 或 <code>hashmap</code> 实现快速查找。</p><h2 id="代码">代码</h2><p><a href="https://www.luogu.org/problemnew/show/P3846" target="_blank" rel="noopener">「TJOI2007」可爱的质数</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> P, a, b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    a %= P, b %= P;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">sqrt</span>(P) + <span class="number">1</span>, x = <span class="number">1</span>, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i, x = <span class="number">1l</span>l * x * a % P)</span><br><span class="line">        M[<span class="number">1l</span>l * x * b % P] = i;</span><br><span class="line">    y = x;</span><br><span class="line">    <span class="keyword">if</span> (M.count(<span class="number">1</span>) &amp;&amp; M[<span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i, x = <span class="number">1l</span>l * x * y % P)</span><br><span class="line">        <span class="keyword">if</span> (M.count(x)) <span class="keyword">return</span> i * t - M[x];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_ans</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"no solution\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;P, &amp;a, &amp;b);</span><br><span class="line">    write_ans(BSGS(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TJOI </tag>
            
            <tag> BSGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AT1726」「CODE FESTIVAL 2015 OKINAWA OPEN」Dictionary for Shiritori Game</title>
      <link href="/atcoder-cfoo15D-sol/"/>
      <url>/atcoder-cfoo15D-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_d" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定大小为 <span class="math inline">\(n\)</span> 的字符集和 <span class="math inline">\(m\)</span> 个单词，第 <span class="math inline">\(i\)</span> 个单词以字符 <span class="math inline">\(a_i\)</span> 开头，以字符 <span class="math inline">\(b_i\)</span> 结尾。</p><p>Snuke 和 Sothe 轮流玩单词接龙游戏（Snuke 先手）。每次游戏那个人必须说出一个以上个单词的末尾字符开头的单词，第一个人必须说出一个以字符 1 开头的单词。若轮到该人进行游戏时，说不出符合条件的单词，则该人失败。</p><p>假设两人绝对聪明，判断谁是胜者或者游戏会永远进行下去。</p><p><span class="math inline">\(n\le 10^5,m\le 2\times 10^5\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>每个字符当作一个状态，建出游戏图（<span class="math inline">\(a_i\to b_i\)</span>）。若游戏图中某个点的所有儿子都是必胜态，则当前点必败；若当前点的所有儿子中有一个状态是必败，则当前点必胜；否则为平局。</p><p>直接用 dfs 会因为有环而变得很难搞（求助路过的 dalao 帮蒟蒻看一下 <a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/submissions/3917268" target="_blank" rel="noopener">代码</a>，WA 3个点 QAQ），所以考虑建反图，倒着推。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) ;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 200005</span></span><br><span class="line"><span class="keyword">int</span> n, m, f[N], h, t, Q[N], d[N];</span><br><span class="line"><span class="keyword">int</span> edge, to[M], pr[M], hd[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;  <span class="comment">// 连边</span></span><br><span class="line">    to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i)</span><br><span class="line">        x = read(), y = read(), addedge(y, x), ++d[x]; <span class="comment">// 倒推，反向连边</span></span><br><span class="line">    h = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!d[i]) Q[++t] = i, f[i] = <span class="number">2</span>; <span class="comment">// 边界状态</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt; t)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q[++h];</span><br><span class="line">        <span class="keyword">if</span> (f[u] == <span class="number">2</span>)  <span class="comment">// 当前状态必败</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u]; i; i = pr[i])</span><br><span class="line">                !f[to[i]] ? Q[++t] = to[i] : <span class="number">0</span>, f[to[i]] = <span class="number">1</span>; <span class="comment">// 则父状态必胜</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 当前状态必胜</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u]; i; i = pr[i])</span><br><span class="line">                <span class="keyword">if</span> (!(--d[to[i]])) Q[++t] = to[i], f[to[i]] = <span class="number">2</span>; <span class="comment">// 所有后继状态都是必胜，则必败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f[<span class="number">1</span>] == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Draw\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (f[<span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Snuke\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (f[<span class="number">1</span>] == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"Sothe\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> CODE FESTIVAL 2015 OKINAWA OPEN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建图 </tag>
            
            <tag> 博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AT1725」「CODE FESTIVAL 2015 OKINAWA OPEN」Cat versus Wolf</title>
      <link href="/atcoder-cfoo15C-sol/"/>
      <url>/atcoder-cfoo15C-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_c" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定一个初始状态如图所示的建筑，共 <span class="math inline">\(n\)</span> 层（不包括 Daruma），自底向上编号 <span class="math inline">\(1\sim n\)</span>。</p><p>下图分别表示建筑的初始状态、奇数层的放置和偶数层的放置。</p><p><img src="https://code-festival-2015-okinawa.contest.atcoder.jp/img/other/code_festival_2015_okinawa/vfgagrt/C1.png" /></p><p>Snuke 和 Sothe 轮流进行游戏，Snuke 先手，每次游戏可以拿走建筑中的任意一块砖头，但不允许拿走砖头后建筑变得<strong>不平衡</strong>。如果不存在砖头可以被拿走，那么该玩家输。</p><p>给定一个未结束的游戏，判断两人在绝对聪明的情况下，谁是必胜者（需要根据以拿走的砖块数量确定先手）。</p><p><strong>不平衡</strong>的定义是，<span class="math inline">\(n\)</span>层中，存在某层没有砖块，或只有一块砖且这块砖在两侧。</p><p><span class="math inline">\(n\le 50000\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>显然是个博弈问题。且层与层之间独立，所以可以看作是 <span class="math inline">\(n\)</span> 个单独的游戏的和。那么我们只要求出每一层的 SG 函数值，然后 xor 起来即可。</p><p>每一层只有 <span class="math inline">\(2^3-3=5\)</span> 种可能的情况，分类讨论每种情况的 SG 函数值即可。</p><p>游戏图如下（0 表示没有砖块，1 表示有砖块，括号内的数表示该状态的 SG 函数值）：</p><p><img src="https://autumnkite.github.io/files/AT-CFOO15C-pic.png" /></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, S, ans;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[j]);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">'#'</span> &amp;&amp; s[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">'#'</span> &amp;&amp; s[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">'#'</span>) ans ^= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">'.'</span> &amp;&amp; s[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">'#'</span> &amp;&amp; s[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">'#'</span>) ans ^= <span class="number">1</span>, ++S;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">'#'</span> &amp;&amp; s[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">'#'</span> &amp;&amp; s[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">'.'</span>) ans ^= <span class="number">1</span>, ++S;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">'.'</span> &amp;&amp; s[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">'#'</span> &amp;&amp; s[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">'.'</span>) S += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">'#'</span> &amp;&amp; s[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">'.'</span> &amp;&amp; s[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">'#'</span>) ++S;</span><br><span class="line">        <span class="comment">// 五种情况分类讨论</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>((!ans) == (S &amp; <span class="number">1</span>) ? <span class="string">"Snuke\n"</span> : <span class="string">"Sothe\n"</span>); <span class="comment">// 注意判断先后手</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> CODE FESTIVAL 2015 OKINAWA OPEN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SG函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AT1724」「CODE FESTIVAL 2015 OKINAWA OPEN」Beware of the Sogginess!</title>
      <link href="/atcoder-cfoo15B-sol/"/>
      <url>/atcoder-cfoo15B-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_b" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定 <span class="math inline">\(n\)</span> 个二元组 <span class="math inline">\((a_i,b_i)\)</span>。一个二元组 <span class="math inline">\((a,b)\)</span> 可以变为 <span class="math inline">\((a+t,b-t)\ (0\le t\le b)\)</span>。你现在可以选择一些二元组并将它们<strong>分别</strong>进行（即互相独立）一次变换，使得变换后你选择的所有二元组 <span class="math inline">\((a_j,b_j)\)</span>，<span class="math inline">\(\sum a_j\ge A,\sum b_j\ge B\)</span>。求最少需要选择并变换的二元组数量。</p><p><span class="math inline">\(1\le n\le 50,1\le A,B,a_i,b_i\le 10^4\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>转化题意：给定 <span class="math inline">\(n\)</span> 个二元组 <span class="math inline">\((b_i,a_i+b_i)\)</span>，选择最少的二元组使得所有选择的二元组 <span class="math inline">\(\sum b_j\ge B,\sum (a_j+b_j)\ge A+B\)</span>。</p><p>于是就可以 DP 了。<span class="math inline">\(dp_{i,j}\)</span> 表示选择 <span class="math inline">\(i\)</span> 个二元组，<span class="math inline">\(\sum b_i=j\)</span> 时，<span class="math inline">\(\sum (a_i+b_i)\)</span> 的最大值。</p><p>考虑把 <span class="math inline">\(n\)</span> 个二元组依次加入，DP 方程很容易写出。</p><p>发现直接写，第二维有百万级别，怎么办？<span class="math inline">\(j&gt;B\)</span> 的状态都合并到 <span class="math inline">\(j=B\)</span> 处即可。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, A, B, a[<span class="number">55</span>], b[<span class="number">55</span>], dp[<span class="number">55</span>][<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmx</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123; x = <span class="built_in">std</span> :: max(x, y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;B, &amp;A), B += A; <span class="comment">// 与上面的 A,B 有区别，注意区分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, b + i, a + i), b[i] += a[i]; <span class="comment">// 与上面的 ai,bi 有区别，注意区分</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp), dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">// 依次加入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i - <span class="number">1</span>; ~j; --j) <span class="comment">// 倒着做，与 01 背包同理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= A; ++k)</span><br><span class="line">                <span class="keyword">if</span> (~dp[j][k]) cmx(dp[j + <span class="number">1</span>][k + a[i] &gt; A ? A : k + a[i]], dp[j][k] + b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (dp[i][A] &gt;= B) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> CODE FESTIVAL 2015 OKINAWA OPEN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AT1723」「CODE FESTIVAL 2015 OKINAWA OPEN」Automatic Map Generator</title>
      <link href="/atcoder-cfoo15A-sol/"/>
      <url>/atcoder-cfoo15A-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://code-festival-2015-okinawa-open.contest.atcoder.jp/tasks/code_festival_2015_okinawa_a" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>构造一张 <span class="math inline">\(H\times W\)</span> 的由岛屿<code>#</code>、海洋<code>.</code>组成的地图，岛屿为八连通，满足恰好包含 <span class="math inline">\(K\)</span> 个联通块。</p><p><span class="math inline">\(1\le H,W\le 100,1\le K\le 10000\)</span></p><a id="more"></a><h2 id="题解">题解</h2><p>为了放置更多的联通块，每个联通块恰好为一个单位时显然最优。</p><p>所以放一张类似于下图所示的地图即可（即在奇数行奇数列放置<code>#</code>，直到放满 <span class="math inline">\(K\)</span> 个）。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#.#.#.#.</span><br><span class="line">........</span><br><span class="line">#.#.#.#.</span><br></pre></td></tr></table></figure><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m, t;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (t &amp;&amp; (i &amp; <span class="number">1</span>) &amp;&amp; (j &amp; <span class="number">1</span>)) a[i][j] = <span class="string">'#'</span>, --t; <span class="keyword">else</span> a[i][j] = <span class="string">'.'</span>;</span><br><span class="line">    <span class="keyword">if</span> (t) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"IMPOSSIBLE\n"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="built_in">putchar</span>(a[i][j]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> AtCoder </category>
          
          <category> CODE FESTIVAL 2015 OKINAWA OPEN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2018 题解</title>
      <link href="/noip2018-sol/"/>
      <url>/noip2018-sol/</url>
      
        <content type="html"><![CDATA[<p>蒟蒻写的 NOIP2018 题解，欢迎吐槽。</p><a id="more"></a><div class="row">    <embed src="https://autumnkite.github.io/files/NOIP2018_Solution.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP2018 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PKUWC2019 自闭记</title>
      <link href="/pkuwc2019/"/>
      <url>/pkuwc2019/</url>
      
        <content type="html"><![CDATA[<p>评（tu）价（cao）：<a href="https://www.zhihu.com/question/309834123" target="_blank" rel="noopener">如何评价PKUWC 2019？ - 知乎</a></p><h2 id="day--n">Day -N</h2><p>联赛没考好。不过最后还是能去PKUWC。于是就又去某强者聚集的高中被吊锤了。</p><a id="more"></a><h2 id="day--1">Day -1</h2><p>晚上。吃完晚饭以后就到了火车站，大概7点左右到的吧。然后就是等人、取票、进站……</p><p>先乘高铁到杭州，然后在杭州转车（动卧）。在杭州也等了好一会吧，20:55，动车开了……</p><p>基本就是整理行李、玩手机以及各种探索（大雾。</p><h2 id="day-0">Day 0</h2><p>凌晨2点醒了一次，好像是被冷醒的，因为房间里吹出来的风是冷的。盖好被子以后就又睡着了，早上5:10就被fy吵醒了……总的来说睡眠质量极差。</p><p>8点就到中山了，有专车来接，直接到中山纪念中学报到了。纪中占地面积是真的大，850亩，风景挺好的。</p><p>没事干，就去旁边的孙中山故居逛了一圈，fy和ykl都去参加了那个答题，得到了一个胸章。</p><p>天气很好，气温很高，穿着棉袄、线衫、加绒裤，热到不行。</p><p>回酒店，在旁边的餐馆吃中饭，可惜的是烧鹅没了，只能吃烧鸭。4点回学校，试机，吃晚饭。这里的食堂不是很好，饭没有浙江的好吃。试机T2都不会做。</p><p>晚上逛学校，还好袋子里有地图，差点迷路……</p><h2 id="day-1">Day 1</h2><p>上午开营仪式，看了一下宣传片，听了纪中的校长、北大的两个教授的讲话。门开得正可海星。然后是营员合影。</p><p>下午的上机爆炸。T1就是个状压，我想到正解感觉好麻烦就放弃了……最后还是只有35的暴力。</p><p>T2想了好一会<span class="math inline">\(m=2\)</span>和链的做法，想了没多久也放弃了。</p><p>T3地主斗，写了2.5h一分未得。考后和同学的方法比较，感觉细节应该都判了啊。</p><p>最后35+0+0=35……自闭了，还是策略不对吧。</p><h2 id="day-2">Day 2</h2><p>早上突然想到地主斗那题，排的顺序是无关的，搜索的时候要判一下……</p><p>上午数学考试，实质是提答十合一，貌似是py优势场。我这种菜鸡只会写暴力，大概只对了两道？</p><p>下午的上机仍然爆炸，T1第一个包一眼，第二个包想了好久，不过还好搞出来了。</p><p>T2当时好像<span class="math inline">\(n,m\le 10\)</span>都不会，最后40分钟感觉没事干就写了个很fake的dfs，竟然过了。</p><p>T3不说了，计算几何告辞（知道前两个包怎么做，不会实现）。</p><p>当场自闭，T1满分想不出来，T2根本不会，为了防止跟昨天一样，我<del>果断</del>（其实还是很犹豫地）放弃了T3。</p><p>最后得分48+21+0=69。自闭了。</p><h2 id="day-3">Day 3</h2><p>这种分数显然进不了面试，滚粗。还是太菜了啊。</p><p>于是我和zyk就在ll的带领下去珠海<del>旅游</del>了（另外两人比较颓，没来）。</p><p>ll说我们主要是因为数学考太差，然而我觉得我都考太差……</p><p>先到海滨公园，看了珠海渔女。海岸线确实挺曲折的。然后就差不多要吃饭了，沿海岸线走到了一家海鲜餐厅，点了大概6碗菜吧，味道还不错。</p><p>饭吃完我们骑共享单车沿海岸线骑，一直骑到边防管理区（通往澳门的桥的桥头），大概骑了7km。发现那里离珠海站很近，就直接乘轻轨回到南朗，买了六点半的票。发现还早，于是提议去圆明新园逛一圈。</p><p>又骑了5km，在圆明新园里面逛了一圈，感觉就是个横店影视城的弱化版？去坐了一下缆车，但是观景体验极差，感觉浪费了150块钱。</p><p>差不多时间了就去珠海站附近，逛了一圈决定吃煲仔饭，吃完就去进站候车了。</p><p>基本一下午都在骑车、走路，心态崩。</p><h2 id="day-4">Day 4</h2><p>打算8点起床的，结果9点才醒，还是因为窗帘没拉好透出了光被亮醒的……起床之后去吃了早饭，然后洗了个澡，等ykl也完了以后就下去了。</p><p>退房，上大巴。大部分人都是去机场的，就我们四个人，变成包车了。一路上qq和司机聊得挺欢。</p><p>中饭吃车站里的麦当劳，高铁15:38开，就在车站里找了个位置玩手机。车站人很多，大概是因为春运？好不容易才找到位置。</p><p>晚饭在高铁上吃盒饭，拿了个鸡翅和鱼，竟然要￥60……而且不是很好吃……</p><p>到义乌，fy爸爸来接，到家23:00，等睡着就00:00了。</p><p>还是太菜了，省选根本没戏，正月要恶补文化课了。班主任还强迫我把期末考试补起来，啥都没复习，还没有状态……凉凉。</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
          <category> PKUWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「LuoguP3723」「AHOI / HNOI2017」礼物</title>
      <link href="/luogu3723-sol/"/>
      <url>/luogu3723-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3723" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定两个长度为<span class="math inline">\(n\)</span>的正整数序列<span class="math inline">\(a_0,a_1,a_2,\cdots,a_{n-1}\)</span>和<span class="math inline">\(b_0,b_1,b_2,\cdots,b_{n-1}\)</span>，满足<span class="math inline">\(a_i,b_i\le m\)</span>。</p><p>求<span class="math display">\[\sum_{i=0}^{n-1} ((a_i+c_0)-(b_{(i+k)\bmod n}+c_1))^2\]</span>的最小值，其中<span class="math inline">\(k,c_0,c_1\)</span>是非负整数。</p><p><span class="math inline">\(n\le 5\times 10^4,m\le 100\)</span>。</p><a id="more"></a><h2 id="题解">题解</h2><p>观察上式，可以发现我们并不关心<span class="math inline">\(c_0,c_1\)</span>具体的值，只关心<span class="math inline">\(c_0-c_1\)</span>的值。记<span class="math inline">\(c=c_0-c_1\)</span>，显然有<span class="math inline">\(-m\le c\le m\)</span>。于是变成了求<span class="math display">\[\sum_{i=0}^{n-1} (a_i-b_{(i+k)\bmod n}+c)^2\]</span>的最小值，其中<span class="math inline">\(0\le k\le n-1,-m\le c\le m\)</span>。</p><p>最朴素的做法是直接枚举<span class="math inline">\(k,c\)</span>计算答案，时间复杂度<span class="math inline">\(O(n^2m)\)</span>。</p><p>这个和的平方的形式很难优化，考虑把它展开：</p><p><span class="math display">\[\begin{aligned} &amp;\quad \sum_{i=0}^{n-1}(a_i-b_{(i+k)\bmod n}+c)^2 \\ &amp;=\sum_{i=0}^{n-1}(a_i^2+b_{(i+k)\bmod n}^2+c^2-2a_ib_{(i+k)\bmod n}+2a_ic-2b_{(i+k)\bmod n}c) \\ &amp;=-2\sum a_ib_{(i+k)\bmod n}+\sum a_i^2+\sum b_i^2+2c\sum (a_i-b_i)+nc^2 \end{aligned}\]</span></p><p>然后我们发现，<span class="math inline">\(k,c\)</span>并没有同时影响答案中的某一项。第一项为与<span class="math inline">\(k\)</span>有关的式子，显然后面部分为关于<span class="math inline">\(c\)</span>的一个二次函数。后面部分可以直接用二次函数的顶点公式计算（注意<span class="math inline">\(c\)</span>是整数，需要讨论两种情况），也可以直接枚举<span class="math inline">\(c\)</span>进行计算。</p><p>如果前面部分也直接枚举<span class="math inline">\(k\)</span>进行计算的话，时间复杂度为<span class="math inline">\(\mathcal O(n^2)\)</span>，仍不能通过。</p><p>先不考虑系数。<span class="math inline">\(\bmod\)</span>很难处理，考虑把<span class="math inline">\(b\)</span>倍长，原式变成了<span class="math inline">\(\sum a_ib_{i+k}\)</span>。联系卷积的基本形式<span class="math inline">\(c_i=\sum_{j=0}^{i} a_jb_{i-j}\)</span>，可以发现需要满足<span class="math inline">\(a,b\)</span>的下标之和为<span class="math inline">\(c\)</span>的下标，即一个与<span class="math inline">\(j\)</span>无关的值。那么我们考虑把<span class="math inline">\(a\)</span>翻转，原式变成了<span class="math inline">\(\sum a_{n-i-1}b_{i+k}\)</span>，此时<span class="math inline">\(n-i-1+i+k=n+k-1\)</span>，是一个与<span class="math inline">\(i\)</span>无关的值。于是就可以FFT了。由于<span class="math inline">\(0\le k\le n-1\)</span>，所以对应的答案（假设<span class="math inline">\(c=a*b\)</span>）就是<span class="math inline">\(c_{n-1},c_{n},c_{n+1},\cdots,c_{2n-2}\)</span>。</p><p>啥？FFT精度爆了？因为<span class="math inline">\(m\le 100\)</span>，所以<span class="math inline">\(0\le c_i\le nm^2\le 5\times 10^8&lt; 998244353\)</span>，直接用NTT即可。</p><p>时间复杂度<span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="代码">代码</h2><p><a href="https://www.luogu.org/recordnew/show/15492151" target="_blank" rel="noopener">评测记录</a>，开O2，总时间170ms，目前在第一页。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], b[N], c[N];</span><br><span class="line"><span class="keyword">namespace</span> Polynomial&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> P 998244353</span></span><br><span class="line">    <span class="keyword">int</span> omega[N], rev[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1l</span>l * a * a % P) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1l</span>l * s * a % P;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) &lt; n) ++k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) rev[i] = rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (i &amp; <span class="number">1</span>) &lt;&lt; k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123; (x += y) &gt;= P ? x -= P : <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> (x -= y) &lt; <span class="number">0</span> ? x + P : x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a, <span class="keyword">int</span> o = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (i &lt; rev[i]) <span class="built_in">std</span> :: swap(a[i], a[rev[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> m = <span class="number">1</span>, l; m &lt; n; m = l)&#123;</span><br><span class="line">            l = m &lt;&lt; <span class="number">1</span>, omega[<span class="number">0</span>] = <span class="number">1</span>, omega[<span class="number">1</span>] = qpow(~o ? <span class="number">3</span> : <span class="number">332748118</span>, (P - <span class="number">1</span>) / l);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i) omega[i] = <span class="number">1l</span>l * omega[i - <span class="number">1</span>] * omega[<span class="number">1</span>] % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> *p = a, t; p &lt; a + n; p += l)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)</span><br><span class="line">                    t = <span class="number">1l</span>l * p[k + m] * omega[k] % P, p[k + m] = sub(p[k], t), add(p[k], t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> _n = qpow(n, P - <span class="number">2</span>), i = <span class="number">0</span>; i &lt; n; ++i) a[i] = <span class="number">1l</span>l * a[i] * _n % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Multiply</span><span class="params">(<span class="keyword">int</span> na, <span class="keyword">int</span> *a, <span class="keyword">int</span> nb, <span class="keyword">int</span> *b, <span class="keyword">int</span> nc, <span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; nc) n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        init(n), NTT(n, a), NTT(n, b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) c[i] = <span class="number">1l</span>l * a[i] * b[i] % P;</span><br><span class="line">        NTT(n, c, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s = INF, ans = INF;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[n - i - <span class="number">1</span>] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) b[i + n] = b[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        s1 += <span class="number">1l</span>l * a[i] * a[i] + <span class="number">1l</span>l * b[i] * b[i], s2 += (a[i] &lt;&lt; <span class="number">1</span>) - (b[i] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    Polynomial :: Multiply(n, a, n &lt;&lt; <span class="number">1</span>, b, n &lt;&lt; <span class="number">1</span>, c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - <span class="number">1</span>; i &lt; (n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>; ++i) s = <span class="built_in">std</span> :: min(s, <span class="number">-2l</span>l * c[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = -m; i &lt;= m; ++i)</span><br><span class="line">        ans = <span class="built_in">std</span> :: min(ans, <span class="number">1l</span>l * n * i * i + s2 * i + s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AHOI </tag>
            
            <tag> HNOI </tag>
            
            <tag> NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「模拟赛20190116 T3」MEX</title>
      <link href="/vc190116C-sol/"/>
      <url>/vc190116C-sol/</url>
      
        <content type="html"><![CDATA[<h2 id="题意">题意</h2><p><a href="https://www.codechef.com/problems/MEXRNG" target="_blank" rel="noopener">原题链接</a></p><p>给定一个长度为<span class="math inline">\(n\)</span>的序列，<span class="math inline">\(q\)</span>次询问<span class="math inline">\(l,r\)</span>，求原序列<span class="math inline">\([l,r]\)</span>中每个数的出现次数组成的集合<span class="math inline">\(S\)</span>的<span class="math inline">\(\text{MEX}\)</span>。</p><p>集合<span class="math inline">\(S\)</span>的<span class="math inline">\(\text{MEX}\)</span>是指最小的没有在集合<span class="math inline">\(S\)</span>中出现的正整数。</p><p><span class="math inline">\(n,q\le 1.5\times 10^5\)</span>。</p><a id="more"></a><h2 id="题解">题解</h2><h3 id="一个简单的暴力实现">一个简单的暴力实现</h3><p>首先离散，对于每个询问，按题意求出每个数的出现次数，再求出每个出现次数是否出现，然后枚举求出答案即可。</p><p>时间复杂度<span class="math inline">\(\mathcal O(nq)\)</span>。</p><h3 id="基于暴力思想的分块做法">基于暴力思想的分块做法</h3><p>显然答案不会超过<span class="math inline">\(\sqrt{2n}\)</span>，那么一个显然的优化是只需要记录所有<span class="math inline">\(\le \sqrt{2n}\)</span>的出现次数。</p><p>于是就可以<del>很自然地</del>想到分块了。分成<span class="math inline">\(\sqrt{n}\)</span>个块（在代码中为了卡常、卡内存可以作微调），直接暴力求出两块之间所有数的出现次数的出现次数（注意不是是否出现），记为<span class="math inline">\(V[x][y][i]\)</span>，表示<span class="math inline">\(x\)</span>块到<span class="math inline">\(y\)</span>块中出现次数<span class="math inline">\(i\)</span>的出现次数。这个可以很轻松的在扫的过程中求出来（<code>--c[b[a[i]]],++b[a[i]],++c[b[a[i]]]</code>，<span class="math inline">\(b[i]\)</span>表示数<span class="math inline">\(i\)</span>的出现次数，<span class="math inline">\(c[i]\)</span>表示出现次数<span class="math inline">\(i\)</span>的出现次数。即把原来的出现次数去掉，出现次数加一，把新的出现次数加入）。这一部分时间复杂度是<span class="math inline">\(\mathcal O(n\sqrt{n})\)</span>的。</p><p>可是我们发现，只求出这个好像还是有点难回答询问。为什么？因为这只求出了整块的答案，而旁边的两小块没有被处理。</p><p>我们再求出<span class="math inline">\(L[x][y][i]\)</span>表示<span class="math inline">\(x\)</span>块到<span class="math inline">\(y\)</span>块中，<span class="math inline">\(x\)</span>块向左<span class="math inline">\(i\)</span>个位置的数出现了多少次，同理<span class="math inline">\(R[x][y][i]\)</span>表示<span class="math inline">\(x\)</span>块到<span class="math inline">\(y\)</span>块中，<span class="math inline">\(y\)</span>块向右<span class="math inline">\(i\)</span>个位置的数出现了多少次。这两个数组也很好求，可以与之前的<span class="math inline">\(V\)</span>数组放在一起处理。</p><p>处理出这三个数组后，相当于持续了之前的<span class="math inline">\(b,c\)</span>数组。直接在两边的小块扫一遍即可。对于<span class="math inline">\(l,r\)</span>在同一块中的情况，直接暴力扫一遍即可。单次询问时间复杂度<span class="math inline">\(\mathcal O(\sqrt{n})\)</span>。</p><p>注意<span class="math inline">\(b[i]\)</span>的下标是<span class="math inline">\(\mathcal O(n)\)</span>级别，不能每次清零，可以额外记一下<span class="math inline">\(vis[i]\)</span>表示<span class="math inline">\(b[i]\)</span>的使用情况，若<span class="math inline">\(vis[i]=0\)</span>，则表示未使用，否则<span class="math inline">\(vis[i]\)</span>表示<span class="math inline">\(b[i]\)</span>在哪一次询问被使用，若是当前询问则可以直接加，否则需要用<span class="math inline">\(L\)</span>或<span class="math inline">\(R\)</span>数组中的值覆盖。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 150005</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">420</span>, C = <span class="number">360</span>, P = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, k, a[N], b[N], c[N], vis[N];</span><br><span class="line"><span class="keyword">int</span> L[<span class="number">365</span>][<span class="number">365</span>][<span class="number">425</span>], R[<span class="number">365</span>][<span class="number">365</span>][<span class="number">425</span>], V[<span class="number">365</span>][<span class="number">365</span>][<span class="number">555</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += B)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) b[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; P; ++j) c[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt; n; ++j)&#123;</span><br><span class="line">            --c[b[a[j]]], ++b[a[j]], ++c[b[a[j]]];</span><br><span class="line">            <span class="keyword">if</span> ((j + <span class="number">1</span>) % B == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="keyword">int</span> bi = i / B, bj = j / B;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; P; ++k) V[bi][bj][k] = c[k];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; B &amp;&amp; i - k - <span class="number">1</span> &gt;= <span class="number">0</span>; ++k) L[bi][bj][k] = b[a[i - k - <span class="number">1</span>]];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; B &amp;&amp; j + k + <span class="number">1</span> &lt; n; ++k) R[bi][bj][k] = b[a[j + k + <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> bl = (l - <span class="number">1</span>) / B + <span class="number">1</span>, br = (r + <span class="number">1</span>) / B - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> pl = B * bl, pr = B * (br + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (bl &lt;= br)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; P; ++i) c[i] = V[bl][br][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pl - l; ++i)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> j = pl - i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[a[j]] != q) vis[a[j]] = q, b[a[j]] = L[bl][br][i];</span><br><span class="line">            --c[b[a[j]]], ++b[a[j]], ++c[b[a[j]]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r - pr; ++i)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> j = pr + i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[a[j]] != q) vis[a[j]] = q, b[a[j]] = R[bl][br][i];</span><br><span class="line">            --c[b[a[j]]], ++b[a[j]], ++c[b[a[j]]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; P; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = l; i &lt;= r; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[a[i]] != q) vis[a[i]] = q, b[a[i]] = <span class="number">0</span>;</span><br><span class="line">            --c[b[a[i]]], ++b[a[i]], ++c[b[a[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; P; ++i) <span class="keyword">if</span> (!c[i]) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"mex.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"mex.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    n = read(), q = read(), k = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = b[i] = read();</span><br><span class="line">    <span class="built_in">std</span> :: sort(b, b + n);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">std</span> :: unique(b, b + n) - b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">std</span> :: lower_bound(b, b + m, a[i]) - b;</span><br><span class="line">    pre();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, l, r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> _ = <span class="number">1</span>; _ &lt;= q; ++_)&#123;</span><br><span class="line">        l = (read() ^ (k * ans)) - <span class="number">1</span>, r = (read() ^ (k * ans)) - <span class="number">1</span>;</span><br><span class="line">        ans = solve(_, l, r), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> MEX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「模拟赛20190116 T2」序列</title>
      <link href="/vc190116B-sol/"/>
      <url>/vc190116B-sol/</url>
      
        <content type="html"><![CDATA[<h2 id="题意">题意</h2><p><a href="https://www.codechef.com/problems/YASEQ" target="_blank" rel="noopener">原题链接</a></p><p>给定一个序列的前<span class="math inline">\(n\)</span>项（<span class="math inline">\(a_0,a_1,a_2,\cdots,a_{n-1}\)</span>），保证对于所有<span class="math inline">\(0\le i\le n-1\)</span>，<span class="math inline">\(a_i\in \{n-1,n,n+1\}\)</span>。对于<span class="math inline">\(i\ge n\)</span>，<span class="math inline">\(a_i\)</span>的值为满足<span class="math inline">\(0\le j&lt; i\)</span>且<span class="math inline">\(a_j\ge i-j\)</span>的整数<span class="math inline">\(j\)</span>的数量。</p><p><span class="math inline">\(q\)</span>个询问，每次询问一个<span class="math inline">\(x\)</span>，求<span class="math inline">\(a_x\)</span>的值。</p><p><span class="math inline">\(1\le n,q\le 10^5,0\le x\le 10^{15}\)</span>。</p><a id="more"></a><h2 id="题解">题解</h2><p>首先，我们可以利用归纳法证明对于任意<span class="math inline">\(i\)</span>，<span class="math inline">\(a_i\in \{n-1,n,n+1\}\)</span>：</p><blockquote><p>假设对于<span class="math inline">\(0\le j&lt; i\)</span>都满足该性质，则有<span class="math display">\[a_i=n-[a_{i-n}=n-1]+[a_{i-n-1}=n+1]\]</span>显然仍有<span class="math inline">\(a_i\in \{n-1,n,n+1\}\)</span>。</p></blockquote><p>为方便讨论，用<span class="math inline">\(0,1,2\)</span>分别代替<span class="math inline">\(n-1,n,n+1\)</span>。</p><p>可以发现，假设初始时对于所有<span class="math inline">\(i\ge n\)</span>，<span class="math inline">\(a_i=0\)</span>。然后对于一个<span class="math inline">\(a_i\)</span>，若<span class="math inline">\(a_i=0\)</span>，则不产生贡献；若<span class="math inline">\(a_i=1\)</span>，则对<span class="math inline">\(a_{i+n}\)</span>产生<span class="math inline">\(1\)</span>的贡献；若<span class="math inline">\(a_i=2\)</span>，则对<span class="math inline">\(a_{i+n},a_{i+n+1}\)</span>各产生<span class="math inline">\(1\)</span>的贡献。</p><p>然后我们先考虑一些子问题。</p><ol type="1"><li><p>若初始时<span class="math inline">\(a_i\in \{0,1\}\)</span>，由于不存在<span class="math inline">\(2\)</span>，一定有<span class="math inline">\(a_{i+n}=a_i\)</span>，所以直接<span class="math inline">\(\bmod n\)</span>即可。</p></li><li><p>若初始时<span class="math inline">\(a_i\in \{1,2\}\)</span>，由于不存在<span class="math inline">\(0\)</span>，即不存在没有贡献的情况，所以对于<span class="math inline">\(a_i=2\)</span>，一定会导致<span class="math inline">\(a_{i+n}=1,a_{i+n+1}=2\)</span>，观察一下可以发现，此时<span class="math inline">\(a_{i+n+1}=a_i\)</span>，所以直接<span class="math inline">\(\bmod (n+1)\)</span>即可。</p></li></ol><p>考虑原问题，由于存在<span class="math inline">\(0\)</span>，将会导致有些位置没有贡献，那么对于<span class="math inline">\(a_i=2\)</span>，可能会导致<span class="math inline">\(a_{i+n}=1,a_{i+n+1}=1\)</span>（即<span class="math inline">\(a_{i+1}=0\)</span>时）。联系之前的两个问题，当不存在<span class="math inline">\(2\)</span>时，这种情况下一定会导致<span class="math inline">\(a_{i+n+1}=0\)</span>；当不存在<span class="math inline">\(0\)</span>时，这种情况下一定会导致<span class="math inline">\(a_{i+n+1}=2\)</span>。可是，当<span class="math inline">\(2,0\)</span>同时存在时，就会导致<span class="math inline">\(a_{i+n+1}=1\)</span>。</p><p>更形象一点地讲，把<span class="math inline">\(2\)</span>当作石头，把<span class="math inline">\(1\)</span>当作平地，把<span class="math inline">\(0\)</span>当作洞，这种情况就是石头调入洞里形成平地的情况。</p><p>假设初始数组中第<span class="math inline">\(i\)</span>个位置是洞，第<span class="math inline">\(j\)</span>个位置是石头，石头<span class="math inline">\(j\)</span>会在<span class="math inline">\(x\)</span>位置与洞<span class="math inline">\(i\)</span>重合，掉入洞中。又因为将会在所有满足<span class="math inline">\(p\equiv j\pmod{(n+1)}\)</span>且<span class="math inline">\(p\le x\)</span>的位置<span class="math inline">\(p\)</span>出现石头，洞同理。所以<span class="math inline">\(x\)</span>一定是满足下列同余方程组的最小正整数：</p><p><span class="math display">\[\begin{cases} x\equiv i\pmod{n}\\x\equiv j\pmod{(n+1)} \end{cases}\]</span></p><p>这个求解想怎么做怎么做吧...</p><p>然后由于会首尾拼接，我们把初始数组想成一个环，显然对于每个洞<span class="math inline">\(i\)</span>，一定是在环上与<span class="math inline">\(i\)</span><strong>有向距离</strong>最短的石子最终掉落在洞<span class="math inline">\(i\)</span>。那么我们直接<strong>扫两遍</strong>，用栈维护当前的石子（第二遍不清空栈，就相当于成了环），每次遇到洞就取出栈顶元素——石头<span class="math inline">\(j\)</span>（如果栈为空则跳过），算出<span class="math inline">\(x\)</span>的值，记录<span class="math inline">\(mat[i]=mat[j]=x\)</span>，一个点若没有<span class="math inline">\(mat\)</span>值，则记为<span class="math inline">\(INF\)</span>。</p><p><span class="math inline">\(mat\)</span>的定义显而易见，<span class="math inline">\(mat[i]\)</span>表示与<span class="math inline">\(i\)</span>有向距离最近的石子/洞与<span class="math inline">\(i\)</span>抵消的位置。</p><p>有了<span class="math inline">\(mat\)</span>以后对于询问就可以<span class="math inline">\(\mathcal O(1)\)</span>求了，可以根据<span class="math inline">\(mat[x\bmod n],mat[x\bmod (n+1)]\)</span>与<span class="math inline">\(x\)</span>的大小关系来计算贡献，注意除了比较<span class="math inline">\(mat\)</span>和<span class="math inline">\(x\)</span>的大小外，还需判断初始是否为石子/洞。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">int</span> n, q, a[N], top, sta[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x, mat[N]; <span class="comment">// 注意long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"sequence.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"sequence.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">1</span>; <span class="comment">// CC原题是多组数据，为了方便修改</span></span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">    n = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) mat[i] = <span class="number">0x3f3f3f3f3f3f3f3f</span>ll;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (a[i] == n - <span class="number">1</span> &amp;&amp; top)&#123; <span class="comment">// 是洞，且栈非空</span></span><br><span class="line">    <span class="keyword">int</span> j = sta[top--]; <span class="comment">// 取出栈顶元素</span></span><br><span class="line">    mat[j] = mat[i] = (<span class="number">1l</span>l * (i + n) * (n + <span class="number">1</span>) - <span class="number">1l</span>l * j * n) % (<span class="number">1l</span>l * n * (n + <span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 根据中国剩余定理计算mat</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == n + <span class="number">1</span>) sta[++top] = i; <span class="comment">// 石子入栈</span></span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">    x = read();</span><br><span class="line">    <span class="keyword">int</span> ho = x % n, st = x % (n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, n - (a[ho] == n - <span class="number">1</span> &amp;&amp; mat[ho] &gt; x) + (a[st] == n + <span class="number">1</span> &amp;&amp; mat[st] &gt; x));</span><br><span class="line">            <span class="comment">// O(1)计算答案，注意特判</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中国剩余定理 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 同余 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「LuoguP2042」「NOI2005」维护数列</title>
      <link href="/luogu2042-sol/"/>
      <url>/luogu2042-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2042" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>维护一个序列，支持插入序列、区间删除、区间覆盖、区间翻转、区间求和、求序列最大子段和（至少包含一个元素）。</p><p>插入总数<span class="math inline">\(\le 4\times 10^6\)</span>，任意时刻序列长度<span class="math inline">\(\le 5\times 10^5\)</span>。</p><h2 id="题解">题解</h2><p><span class="math inline">\(Splay\)</span>板子题。</p><a id="more"></a><p>不会<span class="math inline">\(Splay\)</span>的同学出门左转<a href="https://www.luogu.org/problemnew/show/P3391" target="_blank" rel="noopener">文艺平衡树</a>。</p><p>由于插入数量太大，直接开4000000的数组显得不现实，我们考虑建立回收栈（雾），删除时遍历子树，回收被删除的节点，新建节点时优先从回收栈里取点，但是要注意各个数组都要初始化。</p><p>总体思路是，对每个节点维护：<span class="math inline">\(val,sz,sum,la,ra,ma\)</span>，分别表示这个点本身的值、子树大小、子树的<span class="math inline">\(val\)</span>之和、该区间（以这个点为根的子树所表示的区间，下同）中包含最左边元素的最长子段和（<strong>可以不包含元素</strong>）、包含最右边元素的最长子段和（<strong>可以不包含元素</strong>）、整个区间的最大子段和（<strong>至少包含一个元素</strong>，即答案）；懒标记<span class="math inline">\(cov=0/1,rev=0/1\)</span>，分别表示该区间是否被覆盖、是否被翻转。</p><p>接下来我们仔细分析每一步操作。</p><h3 id="新建节点">新建节点</h3><p>已经讲过，若回收栈里有点，则优先拿来用，否则新建节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> _val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = top ? rb[top--] : ++cnt; <span class="comment">// rb即回收栈</span></span><br><span class="line">    son[x][<span class="number">0</span>] = son[x][<span class="number">1</span>] = fa[x] = rev[x] = cov[x] = <span class="number">0</span>, sz[x] = <span class="number">1</span>; <span class="comment">// 注意别忘记初始化</span></span><br><span class="line">    val[x] = ma[x] = sum[x] = _val, la[x] = ra[x] = <span class="built_in">std</span> :: max(_val, <span class="number">0</span>); <span class="comment">// la,ra可以不包含元素</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上传">上传</h3><p>主要是<span class="math inline">\(la,ra,ma\)</span>的更新。<span class="math inline">\(la\)</span>和<span class="math inline">\(ra\)</span>同理，以<span class="math inline">\(la\)</span>为例，当前节点的<span class="math inline">\(la\)</span>值就是<code>max(左子树的la,左子树的sum+当前节点的val+右子树的la)</code>，分别表示跨过当前节点和不跨过当前节点两种情况。对于<span class="math inline">\(ma\)</span>，也差不多，不跨过的情况是<code>max(左子树的ma,右子树的ma)</code>，跨过的情况是<code>左子树的ra+当前节点的val+右子树的la</code>，在这两种情况中再取个<span class="math inline">\(max\)</span>即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">    sz[u] = sz[ls] + sz[rs] + <span class="number">1</span>, sum[u] = sum[ls] + sum[rs] + val[u];</span><br><span class="line">    la[u] = <span class="built_in">std</span> :: max(la[ls], sum[ls] + val[u] + la[rs]);</span><br><span class="line">    ra[u] = <span class="built_in">std</span> :: max(ra[rs], sum[rs] + val[u] + ra[ls]);</span><br><span class="line">    ma[u] = <span class="built_in">std</span> :: max(<span class="built_in">std</span> :: max(ma[ls], ma[rs]), ra[ls] + val[u] + la[rs]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下传懒标记">下传懒标记</h3><p>比较简单，不需要考虑标记下传的顺序。</p><p>对于<span class="math inline">\(cov\)</span>标记，直接把左右儿子的<span class="math inline">\(val\)</span>设为当前节点的<span class="math inline">\(val\)</span>，<span class="math inline">\(sum\)</span>设为<span class="math inline">\(val\times sz\)</span>。而<span class="math inline">\(la,ra,ma\)</span>则需要分类讨论，若<span class="math inline">\(val&gt;0\)</span>，显然直接把整个区间选上更优，否则<span class="math inline">\(la,ra\)</span>不选，<span class="math inline">\(ma\)</span>只选一个点。</p><p>对于<span class="math inline">\(rev\)</span>标记，直接交换<strong>左右儿子</strong>的左右子树、<strong>左右儿子</strong>的<span class="math inline">\(la,ra\)</span>（注意不是交换当前节点的左右子树、<span class="math inline">\(la,ra\)</span>，这种写法在<a href="https://www.luogu.org/problemnew/show/P3391" target="_blank" rel="noopener">文艺平衡树</a>可以过，但是在本题中会出错）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (cov[u])&#123;</span><br><span class="line">        <span class="keyword">if</span> (ls) val[ls] = val[u], cov[ls] = <span class="number">1</span>, sum[ls] = sz[ls] * val[u];</span><br><span class="line">        <span class="keyword">if</span> (rs) val[rs] = val[u], cov[rs] = <span class="number">1</span>, sum[rs] = sz[rs] * val[u];</span><br><span class="line">        <span class="keyword">if</span> (val[u] &gt; <span class="number">0</span>)&#123; <span class="comment">// 分类讨论</span></span><br><span class="line">            <span class="keyword">if</span> (ls) la[ls] = ra[ls] = ma[ls] = sum[ls];</span><br><span class="line">            <span class="keyword">if</span> (rs) la[rs] = ra[rs] = ma[rs] = sum[rs];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ls) la[ls] = ra[ls] = <span class="number">0</span>, ma[ls] = val[u];</span><br><span class="line">            <span class="keyword">if</span> (rs) la[rs] = ra[rs] = <span class="number">0</span>, ma[rs] = val[u];</span><br><span class="line">        &#125;</span><br><span class="line">        cov[u] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rev[u])&#123;</span><br><span class="line">        <span class="keyword">if</span> (ls) rev[ls] ^= <span class="number">1</span>, <span class="built_in">std</span> :: swap(son[ls][<span class="number">0</span>], son[ls][<span class="number">1</span>]), <span class="built_in">std</span> :: swap(la[ls], ra[ls]);</span><br><span class="line">        <span class="keyword">if</span> (rs) rev[rs] ^= <span class="number">1</span>, <span class="built_in">std</span> :: swap(son[rs][<span class="number">0</span>], son[rs][<span class="number">1</span>]), <span class="built_in">std</span> :: swap(la[rs], ra[rs]);</span><br><span class="line">        <span class="comment">// 交换左右儿子的左右子树和la,ra</span></span><br><span class="line">        rev[u] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建树">建树</h3><p>直接按照原序列的顺序建树（注意不是按数的大小建树）。</p><p>可是直接插入是<span class="math inline">\(\mathcal O(n\log n)\)</span>的，且常数较大。我们直接取序列中点作为根，然后递归调用左边和右边，分别作为根的左儿子和右儿子。</p><p>这样我们可以做到<span class="math inline">\(\mathcal O(n)\)</span>建树，<span class="math inline">\(n\)</span>是序列长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> new_node(a[l]);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, u = new_node(a[mid]);</span><br><span class="line">    <span class="comment">// 以mid为该子树的根，递归处理左右两边</span></span><br><span class="line">    son[u][<span class="number">0</span>] = build(l, mid - <span class="number">1</span>, a), son[u][<span class="number">1</span>] = build(mid + <span class="number">1</span>, r, a);</span><br><span class="line">    fa[son[u][<span class="number">0</span>]] = fa[son[u][<span class="number">1</span>]] = u;</span><br><span class="line">    <span class="keyword">return</span> up(u), u; <span class="comment">// 注意更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="splay的基本操作rotatex和splayxg">Splay的基本操作：<span class="math inline">\(rotate(x)\)</span>和<span class="math inline">\(splay(x,g)\)</span></h3><p><span class="math inline">\(rotate(x)\)</span>表示将<span class="math inline">\(x\)</span>向上旋转，<span class="math inline">\(splay(x,g)\)</span>表示将<span class="math inline">\(x\)</span>旋转到<span class="math inline">\(g\)</span>的儿子。</p><p>注意<span class="math inline">\(rotate(x)\)</span>时需要上传操作，且要注意操作顺序。<span class="math inline">\(splay(x,g)\)</span>需要双旋。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> son[fa[x]][<span class="number">1</span>] == x; &#125; <span class="comment">// 返回x是他父亲的哪个儿子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k, <span class="keyword">int</span> y)</span></span>&#123; son[x][k] = y, fa[y] = x; &#125; <span class="comment">// 将x的k儿子变成y</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], d = dir(x);</span><br><span class="line">    <span class="built_in">set</span>(fa[y], dir(y), x), <span class="built_in">set</span>(y, d, son[x][!d]), <span class="built_in">set</span>(x, !d, y);</span><br><span class="line">    up(y), up(x); <span class="comment">// 注意上传以及上传的顺序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> g = <span class="number">0</span>)</span></span>&#123; <span class="comment">// g=0相当于旋转到根上</span></span><br><span class="line">    <span class="keyword">while</span> (fa[x] != g)&#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x];</span><br><span class="line">        <span class="keyword">if</span> (fa[y] != g) dir(y) == dir(x) ? rotate(y) : rotate(x);</span><br><span class="line">        rotate(x); <span class="comment">// 双旋</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!g) rt = x; <span class="comment">// 更新rt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求当前序列中第k个位置在splay中对应的节点">求当前序列中第<span class="math inline">\(k\)</span>个位置在Splay中对应的节点</h3><p>这是下面前五个操作中必需的一个操作，即把序列中的位置转化为树上的节点编号。</p><p>这是一个经典的求第<span class="math inline">\(k\)</span>小的问题，直接按照左子树的<span class="math inline">\(sz\)</span>和当前的<span class="math inline">\(k\)</span>的大小关系决定往左、往右还是直接返回当前节点。</p><p>注意，此时由于需要用到儿子的信息，我们必须把<span class="math inline">\(u\)</span>的标记下传。</p><p>且因为这样做会把根到要求的那个节点的路径上的所有节点都<span class="math inline">\(down\)</span>一遍，所以在其余操作中不需要再进行<span class="math inline">\(down\)</span>操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    down(u); <span class="comment">// 下传标记</span></span><br><span class="line">    <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == sz[ls] + <span class="number">1</span>) <span class="keyword">return</span> u; <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= sz[ls]) <span class="keyword">return</span> kth(ls, k); <span class="comment">// 向左走</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> kth(rs, k - sz[ls] - <span class="number">1</span>); <span class="comment">// 向右走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作">插入操作</h3><p>对于插入操作，我们直接把<span class="math inline">\(pos\)</span>对应的节点<span class="math inline">\(splay\)</span>到根上（记为<span class="math inline">\(u\)</span>），把<span class="math inline">\(pos+1\)</span>的位置旋转到根下面（记为<span class="math inline">\(v\)</span>，即此时<span class="math inline">\(fa[v]=u\)</span>）。此时<span class="math inline">\(v\)</span>的左子树一定为空（不存在一个整数<span class="math inline">\(x\)</span>满足<span class="math inline">\(pos&lt;x&lt;pos+1\)</span>）。那么直接把需要插入的序列<span class="math inline">\(\mathcal O(n)\)</span>建树，把根节点连到<span class="math inline">\(v\)</span>上，作为<span class="math inline">\(v\)</span>的左子树即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> tot, <span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = build(<span class="number">1</span>, tot, a);</span><br><span class="line">    <span class="keyword">int</span> u = kth(rt, x); splay(u);</span><br><span class="line">    <span class="keyword">int</span> v = kth(rt, x + <span class="number">1</span>); splay(v, u);</span><br><span class="line">    son[v][<span class="number">0</span>] = t, fa[t] = v, up(v), up(u);</span><br><span class="line">    <span class="comment">// 注意别忘记fa[t]=v和上传标记，不要习惯性打成up(u),up(v)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作">删除操作</h3><p>假设我们要删除的是区间<span class="math inline">\([l,r]\)</span>，那么同理，我们把<span class="math inline">\(l-1\)</span>对应的节点旋转到根上（记为<span class="math inline">\(u\)</span>），把<span class="math inline">\(r+1\)</span>的位置旋转到根下面（记为<span class="math inline">\(v\)</span>，即此时<span class="math inline">\(fa[v]=u\)</span>）。</p><p>此时<span class="math inline">\(v\)</span>的左子树所表示的区间即为<span class="math inline">\([l,r]\)</span>，那么我们直接把<span class="math inline">\(v\)</span>的左子树删除即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="comment">// 回收以u为根的子树</span></span><br><span class="line">    <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (ls) recycle(ls);</span><br><span class="line">    <span class="keyword">if</span> (rs) recycle(rs);</span><br><span class="line">    rb[++top] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = kth(rt, l - <span class="number">1</span>); splay(u);</span><br><span class="line">    <span class="keyword">int</span> v = kth(rt, r + <span class="number">1</span>); splay(v, u); <span class="comment">// 提区间操作</span></span><br><span class="line">    recycle(son[v][<span class="number">0</span>]), son[v][<span class="number">0</span>] = <span class="number">0</span>, up(v), up(u); <span class="comment">// 更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="覆盖操作">覆盖操作</h3><p>与删除同理，提取区间<span class="math inline">\([l,r]\)</span>，打上<span class="math inline">\(cov\)</span>标记，更新即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = kth(rt, l - <span class="number">1</span>); splay(u);</span><br><span class="line">    <span class="keyword">int</span> v = kth(rt, r + <span class="number">1</span>); splay(v, u);</span><br><span class="line">    <span class="keyword">int</span> t = son[v][<span class="number">0</span>]; <span class="comment">// 提区间</span></span><br><span class="line">    val[t] = c, cov[t] = <span class="number">1</span>, sum[t] = sz[t] * c;</span><br><span class="line">    <span class="keyword">if</span> (c &gt; <span class="number">0</span>) la[t] = ra[t] = ma[t] = sum[t];</span><br><span class="line">    <span class="keyword">else</span> la[t] = ra[t] = <span class="number">0</span>, ma[t] = c; <span class="comment">// 打标记，与down中同理</span></span><br><span class="line">    up(v), up(u); <span class="comment">// 更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="翻转操作">翻转操作</h3><p>同理，提取区间后，打上<span class="math inline">\(rev\)</span>标记并更新。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = kth(rt, l - <span class="number">1</span>); splay(u);</span><br><span class="line">    <span class="keyword">int</span> v = kth(rt, r + <span class="number">1</span>); splay(v, u);</span><br><span class="line">    <span class="keyword">int</span> t = son[v][<span class="number">0</span>]; <span class="comment">// 提区间</span></span><br><span class="line">    rev[t] ^= <span class="number">1</span>, <span class="built_in">std</span> :: swap(son[t][<span class="number">0</span>], son[t][<span class="number">1</span>]), <span class="built_in">std</span> :: swap(la[t], ra[t]);</span><br><span class="line">    <span class="comment">// 打标记，与down中同理</span></span><br><span class="line">    up(v), up(u); <span class="comment">// 更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求和操作">求和操作</h3><p>提取区间后直接输出<span class="math inline">\(sum\)</span>值即可，不需要更新。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = kth(rt, l - <span class="number">1</span>); splay(u);</span><br><span class="line">    <span class="keyword">int</span> v = kth(rt, r + <span class="number">1</span>); splay(v, u);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum[son[v][<span class="number">0</span>]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大子段和">最大子段和</h3><p>直接输出<span class="math inline">\(ma[rt]\)</span>即可。</p><h3 id="一些细节">一些细节</h3><ol type="1"><li>由于<span class="math inline">\(pos,l-1\)</span>可能会<span class="math inline">\(&lt;1\)</span>，<span class="math inline">\(pos+1,r\)</span>可能会<span class="math inline">\(&gt;n\)</span>，所以要考虑边界问题。我的代码中是直接把整个数组向右移动一位，并且使<span class="math inline">\(a[1]=a[n+2]=-\text{INF}\)</span>。个人觉得这个方法比较简单，只要在主程序中做一些简单的处理即可。</li><li>由于<span class="math inline">\(up\)</span>中没有判断左儿子或右儿子为空的情况（判起来会变得很鬼畜），所以我们令<span class="math inline">\(ma[0]=-\text{INF}\)</span>。</li></ol><h2 id="代码实现">代码实现</h2><p>总的再发一次吧。吸氧后<del>最快的一次</del>共1111ms。<a href="https://www.luogu.org/recordnew/show/15406481" target="_blank" rel="noopener">评测记录</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = !f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 500000000</span></span><br><span class="line"><span class="keyword">int</span> n, m, a[N];</span><br><span class="line"><span class="keyword">char</span> opt[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> k, x, tot, c[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> rt, cnt, son[N][<span class="number">2</span>], fa[N], sz[N], val[N];</span><br><span class="line">    <span class="keyword">int</span> rev[N], cov[N], sum[N], la[N], ra[N], ma[N];</span><br><span class="line">    <span class="keyword">int</span> top, rb[<span class="number">5000005</span>];</span><br><span class="line">    Splay()&#123;</span><br><span class="line">        rt = <span class="number">0</span>, cnt = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">        fa[<span class="number">0</span>] = son[<span class="number">0</span>][<span class="number">0</span>] = son[<span class="number">0</span>][<span class="number">1</span>] = sz[<span class="number">0</span>] = rev[<span class="number">0</span>] = cov[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        val[<span class="number">0</span>] = sum[<span class="number">0</span>] = la[<span class="number">0</span>] = ra[<span class="number">0</span>] = <span class="number">0</span>, ma[<span class="number">0</span>] = -INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> _val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = top ? rb[top--] : ++cnt;</span><br><span class="line">        son[x][<span class="number">0</span>] = son[x][<span class="number">1</span>] = fa[x] = rev[x] = cov[x] = <span class="number">0</span>, sz[x] = <span class="number">1</span>;</span><br><span class="line">        val[x] = ma[x] = sum[x] = _val, la[x] = ra[x] = <span class="built_in">std</span> :: max(_val, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (ls) recycle(ls);</span><br><span class="line">        <span class="keyword">if</span> (rs) recycle(rs);</span><br><span class="line">        rb[++top] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">        sz[u] = sz[ls] + sz[rs] + <span class="number">1</span>, sum[u] = sum[ls] + sum[rs] + val[u];</span><br><span class="line">        la[u] = <span class="built_in">std</span> :: max(la[ls], sum[ls] + val[u] + la[rs]);</span><br><span class="line">        ra[u] = <span class="built_in">std</span> :: max(ra[rs], sum[rs] + val[u] + ra[ls]);</span><br><span class="line">        ma[u] = <span class="built_in">std</span> :: max(<span class="built_in">std</span> :: max(ma[ls], ma[rs]), ra[ls] + val[u] + la[rs]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (cov[u])&#123;</span><br><span class="line">            <span class="keyword">if</span> (ls) val[ls] = val[u], cov[ls] = <span class="number">1</span>, sum[ls] = sz[ls] * val[u];</span><br><span class="line">            <span class="keyword">if</span> (rs) val[rs] = val[u], cov[rs] = <span class="number">1</span>, sum[rs] = sz[rs] * val[u];</span><br><span class="line">            <span class="keyword">if</span> (val[u] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ls) la[ls] = ra[ls] = ma[ls] = sum[ls];</span><br><span class="line">                <span class="keyword">if</span> (rs) la[rs] = ra[rs] = ma[rs] = sum[rs];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (ls) la[ls] = ra[ls] = <span class="number">0</span>, ma[ls] = val[u];</span><br><span class="line">                <span class="keyword">if</span> (rs) la[rs] = ra[rs] = <span class="number">0</span>, ma[rs] = val[u];</span><br><span class="line">            &#125;</span><br><span class="line">            cov[u] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rev[u])&#123;</span><br><span class="line">            <span class="keyword">if</span> (ls) rev[ls] ^= <span class="number">1</span>, <span class="built_in">std</span> :: swap(son[ls][<span class="number">0</span>], son[ls][<span class="number">1</span>]), <span class="built_in">std</span> :: swap(la[ls], ra[ls]);</span><br><span class="line">            <span class="keyword">if</span> (rs) rev[rs] ^= <span class="number">1</span>, <span class="built_in">std</span> :: swap(son[rs][<span class="number">0</span>], son[rs][<span class="number">1</span>]), <span class="built_in">std</span> :: swap(la[rs], ra[rs]);</span><br><span class="line">            rev[u] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dir</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> son[fa[x]][<span class="number">1</span>] == x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k, <span class="keyword">int</span> y)</span></span>&#123; son[x][k] = y, fa[y] = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x], d = dir(x);</span><br><span class="line">        <span class="built_in">set</span>(fa[y], dir(y), x), <span class="built_in">set</span>(y, d, son[x][!d]), <span class="built_in">set</span>(x, !d, y);</span><br><span class="line">        up(y), up(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> g = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (fa[x] != g)&#123;</span><br><span class="line">            <span class="keyword">int</span> y = fa[x];</span><br><span class="line">            <span class="keyword">if</span> (fa[y] != g) dir(y) == dir(x) ? rotate(y) : rotate(x);</span><br><span class="line">            rotate(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!g) rt = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> new_node(a[l]);</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, u = new_node(a[mid]);</span><br><span class="line">        son[u][<span class="number">0</span>] = build(l, mid - <span class="number">1</span>, a), son[u][<span class="number">1</span>] = build(mid + <span class="number">1</span>, r, a);</span><br><span class="line">        fa[son[u][<span class="number">0</span>]] = fa[son[u][<span class="number">1</span>]] = u;</span><br><span class="line">        <span class="keyword">return</span> up(u), u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        down(u);</span><br><span class="line">        <span class="keyword">int</span> ls = son[u][<span class="number">0</span>], rs = son[u][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == sz[ls] + <span class="number">1</span>) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= sz[ls]) <span class="keyword">return</span> kth(ls, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> kth(rs, k - sz[ls] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> tot, <span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = build(<span class="number">1</span>, tot, a);</span><br><span class="line">        <span class="keyword">int</span> u = kth(rt, x); splay(u);</span><br><span class="line">        <span class="keyword">int</span> v = kth(rt, x + <span class="number">1</span>); splay(v, u);</span><br><span class="line">        son[v][<span class="number">0</span>] = t, fa[t] = v, up(v), up(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = kth(rt, l - <span class="number">1</span>); splay(u);</span><br><span class="line">        <span class="keyword">int</span> v = kth(rt, r + <span class="number">1</span>); splay(v, u);</span><br><span class="line">        recycle(son[v][<span class="number">0</span>]), son[v][<span class="number">0</span>] = <span class="number">0</span>, up(v), up(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = kth(rt, l - <span class="number">1</span>); splay(u);</span><br><span class="line">        <span class="keyword">int</span> v = kth(rt, r + <span class="number">1</span>); splay(v, u);</span><br><span class="line">        <span class="keyword">int</span> t = son[v][<span class="number">0</span>];</span><br><span class="line">        val[t] = c, cov[t] = <span class="number">1</span>, sum[t] = sz[t] * c;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) la[t] = ra[t] = ma[t] = sum[t];</span><br><span class="line">        <span class="keyword">else</span> la[t] = ra[t] = <span class="number">0</span>, ma[t] = c;</span><br><span class="line">        up(v), up(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = kth(rt, l - <span class="number">1</span>); splay(u);</span><br><span class="line">        <span class="keyword">int</span> v = kth(rt, r + <span class="number">1</span>); splay(v, u);</span><br><span class="line">        <span class="keyword">int</span> t = son[v][<span class="number">0</span>];</span><br><span class="line">        rev[t] ^= <span class="number">1</span>, <span class="built_in">std</span> :: swap(son[t][<span class="number">0</span>], son[t][<span class="number">1</span>]), <span class="built_in">std</span> :: swap(la[t], ra[t]);</span><br><span class="line">        up(v), up(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query_sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = kth(rt, l - <span class="number">1</span>); splay(u);</span><br><span class="line">        <span class="keyword">int</span> v = kth(rt, r + <span class="number">1</span>); splay(v, u);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum[son[v][<span class="number">0</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query_max_sum</span><span class="params">()</span></span>&#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ma[rt]); &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), m = read(), n += <span class="number">2</span>, a[<span class="number">1</span>] = a[n] = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) a[i] = read(); <span class="comment">// 整体右移</span></span><br><span class="line">    T.rt = T.build(<span class="number">1</span>, n, a);</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, opt);</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'M'</span> &amp;&amp; opt[<span class="number">2</span>] == <span class="string">'X'</span>) T.query_max_sum();</span><br><span class="line">        <span class="keyword">else</span> x = read() + <span class="number">1</span>, tot = read(); <span class="comment">// +1是因为数组整体右移</span></span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'I'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) c[i] = read();</span><br><span class="line">            T.insert(x, tot, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'D'</span>) T.erase(x, x + tot - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'M'</span> &amp;&amp; opt[<span class="number">2</span>] == <span class="string">'K'</span>) T.cover(x, x + tot - <span class="number">1</span>, read());</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'R'</span>) T.reverse(x, x + tot - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'G'</span>) T.query_sum(x, x + tot - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如发现代码有问题请在评论中指出，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOI </tag>
            
            <tag> Splay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组 学习笔记</title>
      <link href="/suffix-array-notes/"/>
      <url>/suffix-array-notes/</url>
      
        <content type="html"><![CDATA[<p>后缀数组（Suffix Array, SA）是处理字符串的有力工具。它可以解决一些与字符串后缀LCP有关的问题。</p><a id="more"></a><h2 id="一些记号和约定">一些记号和约定</h2><ol type="1"><li>在字符串<span class="math inline">\(S\)</span>中，第<span class="math inline">\(i\)</span>个字符到第<span class="math inline">\(j\)</span>个字符（包括<span class="math inline">\(i,j\)</span>）组成的子串记作<span class="math inline">\(S[i,j]\)</span>。</li><li>在字符串<span class="math inline">\(S\)</span>中，第<span class="math inline">\(i\)</span>个字符开始的后缀记作<span class="math inline">\(\text{Suffix}(i)\)</span>。</li><li>记<span class="math inline">\(SA[i]\)</span>表示字符串<span class="math inline">\(S\)</span>的所有后缀从小到大排序后，第<span class="math inline">\(i\)</span>个后缀的开始位置。<span class="math inline">\(SA\)</span>即后缀数组。</li><li>记<span class="math inline">\(rank[i]\)</span>表示字符串<span class="math inline">\(S\)</span>的第<span class="math inline">\(i\)</span>个后缀从小到大的排名，即<span class="math inline">\(SA\)</span>的逆数组。</li></ol><p>下面给出一个例子（字符串下标从<span class="math inline">\(1\)</span>开始）：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String S:  <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> b</span><br><span class="line">    Rank:  <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line">--------------------------</span><br><span class="line">SA[<span class="number">1</span>]=<span class="number">4</span> -&gt; <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> b</span><br><span class="line">SA[<span class="number">2</span>]=<span class="number">5</span> -&gt; <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> b</span><br><span class="line">SA[<span class="number">3</span>]=<span class="number">6</span> -&gt; <span class="selector-tag">a</span> <span class="selector-tag">a</span> b</span><br><span class="line">SA[<span class="number">4</span>]=<span class="number">1</span> -&gt; <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> b</span><br><span class="line">SA[<span class="number">5</span>]=<span class="number">7</span> -&gt; <span class="selector-tag">a</span> b</span><br><span class="line">SA[<span class="number">6</span>]=<span class="number">2</span> -&gt; <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> b</span><br><span class="line">SA[<span class="number">7</span>]=<span class="number">8</span> -&gt; b</span><br><span class="line">SA[<span class="number">8</span>]=<span class="number">3</span> -&gt; <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> b</span><br></pre></td></tr></table></figure><p>由于<span class="math inline">\(rank\)</span>是<span class="math inline">\(SA\)</span>的逆数组，在求出<span class="math inline">\(SA\)</span>数组后，我们可以<span class="math inline">\(\mathcal O(|S|)\)</span>求出<span class="math inline">\(rank\)</span>数组，即<code>rank[sa[i]]=i</code>。</p><h2 id="一个简单的实现">一个简单的实现</h2><p>设字符串长度为<span class="math inline">\(n\)</span>且下标从<span class="math inline">\(1\)</span>开始。</p><p>我们直接把<span class="math inline">\(S\)</span>的每个后缀求出，然后用任意一种排序方法，在比较时暴力<span class="math inline">\(\mathcal O(n)\)</span>比较两个后缀的大小即可。</p><p>这种方法的复杂度太劣，我们尝试优化。</p><h2 id="倍增算法">倍增算法</h2><h3 id="前置知识">前置知识</h3><p>倍增，基数排序。</p><p>由于基数排序较为简单，这里不详细讲。</p><h3 id="算法思想">算法思想</h3><p>倍增算法的主要思想是：用倍增的方法对每个字符开始长度为<span class="math inline">\(2^k\)</span>的子串进行排序，求出排名。<span class="math inline">\(k\)</span>从<span class="math inline">\(0\)</span>开始，直到<span class="math inline">\(2^k&gt;n\)</span>时，这些子串就是<span class="math inline">\(S\)</span>的所有后缀。</p><p>可以发现，如果我们能<span class="math inline">\(\mathcal O(n)\)</span>求出每个字符开始长度为<span class="math inline">\(2^k\)</span>的子串排序后的结果，那么此算法的复杂度就是<span class="math inline">\(\mathcal O(n\log n)\)</span>的。</p><p>考虑利用<span class="math inline">\(k-1\)</span>时的排序结果快速求出当前结果。</p><p>由于我们已经求出每个字符开始长度为<span class="math inline">\(2^{k-1}\)</span>的子串的排名，那么字符串的比较变成了排名的比较。</p><p>这是一个双关键字排序，设当前字符为<span class="math inline">\(i\)</span>，则第一关键字为<span class="math inline">\(i\)</span>开始长度为<span class="math inline">\(2^{k-1}\)</span>的子串的排名，第二关键字为<span class="math inline">\(i+2^k\)</span>开始长度为<span class="math inline">\(2^{k-1}\)</span>的子串的排名。</p><p>如果用快速排序，则总复杂度为<span class="math inline">\(\mathcal O(n\log^2 n)\)</span>。</p><p>由于排名的值不会超过<span class="math inline">\(n\)</span>，我们考虑用基数排序做到总复杂度为<span class="math inline">\(\mathcal O(n\log n)\)</span>。</p><p>双关键字的基数排序只要先按照<strong>第二关键字</strong>从小到大排序，再按照<strong>第一关键字</strong>从小到大排序即可，都可以做到<span class="math inline">\(\mathcal O(n)\)</span>的复杂度。</p><h3 id="算法实现">算法实现</h3><h4 id="技巧">技巧</h4><p>直接基数排序的常数较大，我们考虑每次把排序后的结果暂存在<span class="math inline">\(SA\)</span>数组中，即当前的<span class="math inline">\(SA[i]\)</span>表示每个字符开始长度为<span class="math inline">\(2^k\)</span>的子串进行排序后，排名为<span class="math inline">\(i\)</span>的子串的起始位置。</p><p>这样一来，我们可以利用<span class="math inline">\(k-1\)</span>时求出来的<span class="math inline">\(SA\)</span>数组，直接按第二关键字排好序，再按第一关键字排序。</p><h4 id="代码">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sa[N], tx[N], ty[N], cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Radix_Sort</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> *x, <span class="keyword">int</span> *y, <span class="keyword">int</span> *sa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) cnt[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[x[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i) sa[cnt[x[y[i]]]--] = y[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[x] == a[y] &amp;&amp; a[x + l] == a[y + l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_SA</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> *a, <span class="keyword">int</span> *sa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x = tx, *y = ty;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) x[i] = a[i], y[i] = i;</span><br><span class="line">    Radix_Sort(n, m, x, y, sa);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; j &lt;&lt;= <span class="number">1</span>, m = p)&#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - j + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (sa[i] &gt; j) y[++p] = sa[i] - j;</span><br><span class="line">        Radix_Sort(n, m, x, y, sa);</span><br><span class="line">        <span class="built_in">std</span> :: swap(x, y), p = <span class="number">1</span>, x[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            x[sa[i]] = cmp(y, sa[i - <span class="number">1</span>], sa[i], j) ? p : ++p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码解释">代码解释</h4><p>代码中的<span class="math inline">\(x[i]\)</span>表示<span class="math inline">\(i\)</span>开始长度为<span class="math inline">\(j=2^k\)</span>的子串排序后的排名，<span class="math inline">\(y[i]\)</span>在前半部分表示按<strong>第二关键字</strong>排序后，排名为<span class="math inline">\(i\)</span>的子串的起始位置。</p><p><code>Radix_Sort</code>函数即基数排序，不详细阐述。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *x = tx, *y = ty;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) x[i] = a[i], y[i] = i;</span><br><span class="line">Radix_Sort(n, m, x, y, sa);</span><br></pre></td></tr></table></figure><p>这三行是初始化，由于长度为<span class="math inline">\(1\)</span>，直接按照字符本身为第一关键字进行排序，<span class="math inline">\(y[i]=i\)</span>时表示没有第二关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; j &lt;&lt;= <span class="number">1</span>, m = p)&#123;</span><br><span class="line">    p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n - j + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (sa[i] &gt; j) y[++p] = sa[i] - j;</span><br><span class="line">    Radix_Sort(n, m, x, y, sa);</span><br></pre></td></tr></table></figure><p><span class="math inline">\(j\)</span>枚举的是<span class="math inline">\(\frac{2^k}{2}\)</span>的值，即当前需要排序的子串长度的一半。首先把第二关键字为<span class="math inline">\(0\)</span>的位置加入<span class="math inline">\(y\)</span>。然后按第二关键字从小到大的加入<span class="math inline">\(y\)</span>。为什么可以这样写？因为<span class="math inline">\(sa[i]\)</span>表示排名为<span class="math inline">\(i\)</span>的子串的初始位置，即<span class="math inline">\(sa[i]\)</span>的排名一定是除<span class="math inline">\(0\)</span>外第<span class="math inline">\(i\)</span>小的，而以<span class="math inline">\(sa[i]\)</span>的排名作为第二关键字的位置就是<span class="math inline">\(sa[i]-j\)</span>，所以这样做就是把位置按第二关键字从小到大的加入<span class="math inline">\(y\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">std</span> :: swap(x, y), p = <span class="number">1</span>, x[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        x[sa[i]] = cmp(y, sa[i - <span class="number">1</span>], sa[i], j) ? p : ++p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段代码中，由于前面的<span class="math inline">\(y\)</span>数组毫无用处了，就交换<span class="math inline">\(x,y\)</span>，使得<span class="math inline">\(y\)</span>表示上一个<span class="math inline">\(j\)</span>时的排名，把<span class="math inline">\(x\)</span>更新为当前<span class="math inline">\(j\)</span>时的排名。这里不能直接写<code>x[sa[i]]=i</code>的原因是有些子串可能会相等，那么它们的排名也应该相等。<span class="math inline">\(p\)</span>记录的是排名不同的子串数量，如果<span class="math inline">\(p=n\)</span>则直接退出循环。</p><h2 id="另一种算法">另一种算法</h2><p>还有一种求后缀数组的算法，叫做<span class="math inline">\(\text{DC3}\)</span>。该算法可以做到复杂度<span class="math inline">\(\mathcal O(n)\)</span>建立后缀数组，但由于常数较大且代码复杂度较高，不推荐使用。</p><p>有兴趣的同学可以查阅参考资料<span class="math inline">\([1]\)</span>。</p><h2 id="height数组"><span class="math inline">\(height\)</span>数组</h2><p>在具体应用中，<span class="math inline">\(SA\)</span>数组的应用并不多，更多的是另一个可以利用<span class="math inline">\(SA,rank\)</span>数组求出的数组——<span class="math inline">\(height\)</span>数组。</p><h3 id="定义">定义</h3><p><span class="math inline">\(height[i]\)</span>表示<span class="math inline">\(\text{Suffix}(SA[i])\)</span>和<span class="math inline">\(\text{Suffix}(SA[i-1])\)</span>的最长公共前缀（Longest Common Prefix, LCP）。即排名相邻的两个后缀的<span class="math inline">\(\text{LCP}\)</span>。</p><h3 id="性质">性质</h3><h4 id="性质一">性质一</h4><p>对于任意<span class="math inline">\(i,j(rank[i]&lt;rank[j])\)</span>，<span class="math inline">\(\text{Suffix}(i)\)</span>与<span class="math inline">\(\text{Suffix}(j)\)</span>的<span class="math inline">\(\text{LCP}\)</span>为<span class="math inline">\(\min\limits_{rank[i]&lt;k\le rank[j]} height[k]\)</span>。</p><p>这个性质比较显然，证明略。</p><h4 id="性质二">性质二</h4><p>记<span class="math inline">\(H[i]=height[rank[i]]\)</span>。对于任意<span class="math inline">\(i&gt;1\)</span>，有<span class="math inline">\(H[i]\ge H[i-1]-1\)</span>。</p><p>证明：当<span class="math inline">\(H[i-1]\le 1\)</span>时显然。当<span class="math inline">\(H[i]&gt;1\)</span>时，假设排<span class="math inline">\(\text{Suffix}(i-1)\)</span>前一名的后缀是<span class="math inline">\(\text{Suffix}(k)\)</span>，则<span class="math inline">\(\text{Suffix}(i)\)</span>与<span class="math inline">\(\text{Suffix}(k+1)\)</span>的<span class="math inline">\(\text{LCP}\)</span>为<span class="math inline">\(H[i-1]-1\)</span>（相当于都去掉了第一位），且<span class="math inline">\(\text{Suffix}(k+1)\)</span>也排<span class="math inline">\(\text{Suffix}(i)\)</span>前面，则根据性质一，<span class="math inline">\(H[i]\)</span>不会小于这个值，得证。</p><h3 id="求法及代码实现">求法及代码实现</h3><p>根据性质二，直接按照<span class="math inline">\(height[rank[1]],height[rank[2]],\cdots,height[rank[n]]\)</span>的顺序求即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Height</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a, <span class="keyword">int</span> *sa, <span class="keyword">int</span> *rank, <span class="keyword">int</span> *height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rank[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>, j; i &lt;= n; height[rank[i]] = k, ++i)</span><br><span class="line">        <span class="keyword">if</span> (rank[i] &gt; <span class="number">1</span>) <span class="keyword">for</span> (k ? --k : <span class="number">0</span>, j = sa[rank[i] - <span class="number">1</span>]; a[i + k] == a[j + k]; ++k)</span><br><span class="line">    height[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<span class="math inline">\(k\)</span>最多减少<span class="math inline">\(n\)</span>次，且不会超过<span class="math inline">\(n\)</span>，所以时间复杂度为<span class="math inline">\(\mathcal O(n)\)</span>。</p><h2 id="例题">例题</h2><p>给定一个字符串，<span class="math inline">\(q\)</span>次询问某两后缀的最长公共前缀的长度。</p><h3 id="解法">解法</h3><p>建出<span class="math inline">\(height\)</span>数组后，根据<span class="math inline">\(height\)</span>数组的性质一，原问题可以转化为区间最小值问题，直接用<span class="math inline">\(\text{ST}\)</span>表维护即可。</p><p>时间复杂度<span class="math inline">\(\mathcal O(n\log n+q)\)</span>。</p><p>若使用<span class="math inline">\(\text{DC3}\)</span>算法求<span class="math inline">\(\text{SA}\)</span>，<span class="math inline">\(\text{RMQ}\)</span>问题<span class="math inline">\(\mathcal O(n)\)</span>预处理，则时间复杂度为<span class="math inline">\(\mathcal O(n+q)\)</span>。</p><p>更多的例题可以查阅参考资料<span class="math inline">\([1]\)</span>。</p><h2 id="参考资料">参考资料</h2><ol type="1"><li>IOI2009国家集训队论文《后缀数组——处理字符串的有力工具》，罗穗骞</li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manacher 学习笔记</title>
      <link href="/manacher-notes/"/>
      <url>/manacher-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="问题形式">问题形式</h2><p>给定一个字符串，求该字符串的最长回文子串。</p><p><a href="https://www.luogu.org/problemnew/show/P3805" target="_blank" rel="noopener">洛谷传送门</a></p><h2 id="一个简单的暴力实现">一个简单的暴力实现</h2><p>由于回文串是对称的，我们枚举对称轴（注意奇偶分类讨论）。然后从该对称轴向左向右扩展，直到两字母不相等。此时的字符串长度一定是以当前对称轴作为中心的最长回文子串。</p><p>时间复杂度<span class="math inline">\(\mathcal O(n^2)\)</span>。</p><a id="more"></a><h2 id="manacher---暴力的优化">Manacher - 暴力的优化</h2><p>为了避免奇偶分类讨论，我们现在字符之间以及字符串两端插入一个特殊字符（与字符串中所有字符都不相等）。</p><p>例如：<code>ababaab -&gt; #a#b#a#b#a#a#b#</code>，显然，原来是回文串的还是回文串，原来不是回文串的仍然不是回文串，长度稍做处理即可。</p><p>通过观察发现，暴力主要慢在相同的状态被重复枚举，没有利用回文串的性质。</p><p>记<span class="math inline">\(hw_i\)</span>表示以<span class="math inline">\(i\)</span>为对称轴时，最长的回文串的右端距离<span class="math inline">\(i\)</span>（包括最右端的字符和<span class="math inline">\(i\)</span>）的长度为<span class="math inline">\(hw_i\)</span>。栗子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char:    # a # b # a #</span><br><span class="line"> hw :    <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">char:    # a # b # b # a #</span><br><span class="line"> hw :    <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如何快速求出<span class="math inline">\(hw_i\)</span>？</p><p>考虑根据回文串的性质，利用已经求出的<span class="math inline">\(hw\)</span>值来求出当前的<span class="math inline">\(hw_i\)</span>。</p><p>引入两个辅助变量<span class="math inline">\(MaxRight,Mid\)</span>。<span class="math inline">\(MaxRight\)</span>表示当前访问到的所有回文子串，所能触及的最右一个字符的位置，<span class="math inline">\(Mid\)</span>表示对应的对称轴。</p><p>为方便观察，下面的图示中记<span class="math inline">\(x\)</span>为<span class="math inline">\(MaxRight\)</span>关于<span class="math inline">\(Mid\)</span>对称的位置，<span class="math inline">\(r\)</span>表示<span class="math inline">\(MaxRight\)</span>，<span class="math inline">\(m\)</span>表示<span class="math inline">\(Mid\)</span>，<span class="math inline">\(*\)</span>表示未触及的位置。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">x</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">m</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">r</span>|<span class="string">*</span>|<span class="string">*</span>|<span class="string">*</span>|</span><br></pre></td></tr></table></figure><p>当前要求<span class="math inline">\(hw_i\)</span>的位置<span class="math inline">\(i\)</span>一定在<span class="math inline">\(Mid\)</span>右边。那么我们根据<span class="math inline">\(i\le MaxRight\)</span>和<span class="math inline">\(i&gt;MaxRight\)</span>讨论：</p><h3 id="当ile-maxright时">当<span class="math inline">\(i\le MaxRight\)</span>时</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">x</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">j</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">m</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">i</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">r</span>|<span class="string">*</span>|<span class="string">*</span>|<span class="string">*</span>|</span><br></pre></td></tr></table></figure><p>记<span class="math inline">\(j\)</span>为<span class="math inline">\(i\)</span>关于<span class="math inline">\(m\)</span>的对称点。由于<span class="math inline">\(hw_j\)</span>已知，我们尝试利用<span class="math inline">\(hw_j\)</span>得出<span class="math inline">\(hw_i\)</span>的下界。</p><p>又分成两种小情况：</p><h4 id="hw_j比较小向左没有超过x"><span class="math inline">\(hw_j\)</span>比较小，向左没有超过<span class="math inline">\(x\)</span></h4><p>大概情况如图所示：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">x</span>|<span class="string"> </span>|<span class="string">-</span>|<span class="string">j</span>|<span class="string">-</span>|<span class="string"> </span>|<span class="string">m</span>|<span class="string"> </span>|<span class="string">-</span>|<span class="string">i</span>|<span class="string">-</span>|<span class="string"> </span>|<span class="string">r</span>|<span class="string">*</span>|<span class="string">*</span>|<span class="string">*</span>|</span><br></pre></td></tr></table></figure><p>此时显然<span class="math inline">\(hw_i\)</span>的下界为<span class="math inline">\(hw_j\)</span>。如图所示的情况一定也是上界，但如果<span class="math inline">\(i+hw_i-1\)</span>刚好等于<span class="math inline">\(MaxRight\)</span>，那么有可能可以继续扩展。由于不影响复杂度，为方便起见，无论哪一种情况都尝试扩展。</p><h4 id="hw_j比较大向左超过x"><span class="math inline">\(hw_j\)</span>比较大，向左超过<span class="math inline">\(x\)</span></h4><p>大概情况如图所示：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                    |<span class="string">             </span>|</span><br><span class="line">       /-------j----|<span class="string">--\          </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">x</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">j</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">m</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">i</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">r</span>|<span class="string">*</span>|<span class="string">*</span>|<span class="string">*</span>|</span><br><span class="line">                   \|<span class="string">------i------</span>|<span class="string">/</span></span><br><span class="line"><span class="string">                    </span>|<span class="string">             </span>|</span><br></pre></td></tr></table></figure><p>此时暂时只能确定两根较长的线之间的部分时回文的，所以<span class="math inline">\(hw_i\)</span>的下界是<span class="math inline">\(MaxRight-i+1\)</span>。然后同样地直接继续扩展即可。</p><p>实际实现中，这两种情况不需要特殊判断，只要在<span class="math inline">\(hw_j\)</span>和<span class="math inline">\(MaxRight-i+1\)</span>中取<span class="math inline">\(min\)</span>即可。</p><h3 id="当imaxright时">当<span class="math inline">\(i&gt;MaxRight\)</span>时</h3><p>此时显然<span class="math inline">\(hw_i\)</span>的求值不能利用之前的任意值，所以定下界为<span class="math inline">\(1\)</span>，也直接扩展即可。</p><h3 id="总结">总结</h3><h4 id="步骤">步骤</h4><p>综上所述，从左到右枚举<span class="math inline">\(i\)</span>的过程中，对于每个<span class="math inline">\(i\)</span>，算法步骤如下：</p><ol type="1"><li>若<span class="math inline">\(i\le MaxRight\)</span>，则令<span class="math inline">\(hw_i=min(hw_{2*Mid-i}, MaxRight-i+1)\)</span>，否则令<span class="math inline">\(hw_i=1\)</span>（显然，<span class="math inline">\(i\)</span>关于<span class="math inline">\(Mid\)</span>的对称点<span class="math inline">\(j\)</span>为<span class="math inline">\(2*Mid-i\)</span>）。</li><li>以<span class="math inline">\(i\)</span>为中心扩展回文串，直到左右两边字符不同，或者到达边界。</li><li>更新<span class="math inline">\(MaxRight\)</span>和<span class="math inline">\(Mid\)</span>。</li><li>更新答案。扩展出来的子串在原串中的长度一定为<span class="math inline">\(hw_i-1\)</span>。因为在添加字符后的串中该子串长度为<span class="math inline">\(2hw_i-1\)</span>，由于首尾一定是特殊字符，所以特殊字符数量比其他字符多<span class="math inline">\(1\)</span>，所以特殊字符数量为<span class="math inline">\(hw_i\)</span>，其他字符为<span class="math inline">\(hw_i-1\)</span>。</li></ol><h4 id="一个小技巧">一个小技巧</h4><p>如果你的字符串下标从<span class="math inline">\(1\)</span>开始，你可以令<span class="math inline">\(s_0\)</span>为那个特殊字符，这样就省去了判断边界的问题。</p><h4 id="复杂度分析">复杂度分析</h4><p>根据上面三种情况的分析，在继续扩展<span class="math inline">\(hw_i\)</span>时，每一次的扩展都可以更新<span class="math inline">\(MaxRight\)</span>，而<span class="math inline">\(MaxRight\)</span>最多变化<span class="math inline">\(n\)</span>次，所以总的时间复杂度为<span class="math inline">\(\mathcal O(n)\)</span>的。</p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">11000005</span>], *ps = buf;</span><br><span class="line"><span class="keyword">int</span> n, hw[<span class="number">22000005</span>], mr = <span class="number">0</span>, mid = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">22000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    buf[fread(buf, <span class="number">1</span>, <span class="number">11000005</span>, <span class="built_in">stdin</span>)] = <span class="string">'\0'</span>, s[<span class="number">0</span>] = <span class="string">'#'</span>; <span class="comment">// 小技巧</span></span><br><span class="line">    <span class="keyword">while</span> (*ps &gt;= <span class="string">'a'</span> &amp;&amp; *ps &lt;= <span class="string">'z'</span>) s[++n] = <span class="string">'#'</span>, s[++n] = *ps, ++ps;</span><br><span class="line">    s[++n] = <span class="string">'#'</span>; <span class="comment">// 插入特殊字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        hw[i] = i &lt;= mr ? <span class="built_in">std</span> :: min(hw[(mid &lt;&lt; <span class="number">1</span>) - i], mr - i + <span class="number">1</span>) : <span class="number">1</span>;  <span class="comment">// 得出下界</span></span><br><span class="line">        <span class="keyword">while</span> (s[i - hw[i]] == s[i + hw[i]]) ++hw[i]; <span class="comment">// 继续扩展</span></span><br><span class="line">        <span class="keyword">if</span> (i + hw[i] - <span class="number">1</span> &gt; mr) mid = i, mr = i + hw[i] - <span class="number">1</span>; <span class="comment">// 更新mr,mid</span></span><br><span class="line">        ans = <span class="built_in">std</span> :: max(ans, hw[i] - <span class="number">1</span>); <span class="comment">// 更新答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p><a href="https://segmentfault.com/a/1190000003914228" target="_blank" rel="noopener">最长回文子串——Manacher 算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「模拟赛20190105 T1」松</title>
      <link href="/vc190105A-sol/"/>
      <url>/vc190105A-sol/</url>
      
        <content type="html"><![CDATA[<h2 id="题意">题意</h2><p>给定两个长度为<span class="math inline">\(n\)</span>的<strong>数组</strong><span class="math inline">\(A,B\)</span>，下标范围<span class="math inline">\([0,n-1]\)</span>。</p><p>求所有整数<span class="math inline">\(k\in [0,n-1]\)</span>，满足存在一个<span class="math inline">\(m\)</span>次多项式<span class="math inline">\(C\)</span>，使得对于所有<span class="math inline">\(i\in [0,n-1]\)</span>，都有<span class="math inline">\(C(i)\equiv A_i-B_{(i+k)\bmod n} \pmod{998244353}\)</span>。</p><a id="more"></a><h2 id="题解">题解</h2><p>先附上PPT：</p><p><img src="https://i.loli.net/2019/01/08/5c343b9332fed.png" /></p><p><img src="https://i.loli.net/2019/01/08/5c344bd1d2530.png" /></p><p><del>这完全看不懂啊</del></p><p>首先，<span class="math inline">\(B\)</span>数组可以看成一个环，每次选环上的长度为<span class="math inline">\(n\)</span>的一段。所以我们直接把B数组复制接在末尾，变为原来的两倍长度。</p><p>然后，我们来理解这个差分。</p><p>对于任意一个<span class="math inline">\(m\)</span>次多项式<span class="math inline">\(f(x)\)</span>，当<span class="math inline">\(x\)</span>分别取<span class="math inline">\(0,1,2,\cdots,n(n\ge m+1)\)</span>时，将会得到<span class="math inline">\(n+1\)</span>个点值。将这<span class="math inline">\(n+1\)</span>个点值不断差分，<span class="math inline">\(m+1\)</span>次后会都变成<span class="math inline">\(0\)</span>。</p><p>例如，当<span class="math inline">\(f(x)=x^3+x^2-2x+1\)</span>时，分别取<span class="math inline">\(0,1,2,3,4,5\)</span>代入，得到<span class="math inline">\(6\)</span>个点值（第<span class="math inline">\(0\)</span>行）。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">9</span>   <span class="number">31</span>  <span class="number">73</span>  <span class="number">141</span></span><br><span class="line"><span class="number">1</span>       <span class="number">0</span>   <span class="number">8</span>   <span class="number">22</span>  <span class="number">42</span>  <span class="number">68</span></span><br><span class="line"><span class="number">2</span>           <span class="number">8</span>   <span class="number">14</span>  <span class="number">20</span>  <span class="number">26</span></span><br><span class="line"><span class="number">3</span>               <span class="number">6</span>   <span class="number">6</span>   <span class="number">6</span></span><br><span class="line"><span class="number">4</span>                   <span class="number">0</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure><p>然后可以发现，按表格中的排列，<span class="math inline">\(t\)</span>次差分以后（第<span class="math inline">\(k\)</span>行第<span class="math inline">\(i\)</span>列）<span class="math inline">\(c_i=\sum\limits_{j=0}^i (-1)^j C_k^j f(i-j)\)</span></p><p>例如，表中第二行第四个数<span class="math inline">\(20=(73-31)-(31-9)=73-2\times 31+9=C_2^0\times 73-C_2^1\times 31+C_2^2\times 9\)</span>。</p><p>又可以发现，<span class="math inline">\(c_i=\sum\limits_{j=0}^i (-1)^j C_k^j f(i-j)\)</span>是卷积的形式，所以直接用FFT/NTT优化。</p><p>这样，我们对<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>分别做一遍卷积，然后把<span class="math inline">\(A[m+1,n-1]\)</span>与<span class="math inline">\(B[m+1,2n-1]\)</span>做一次<span class="math inline">\(KMP\)</span>即可。</p><p>由于数据较水，直接<span class="math inline">\(hash\)</span>也能过。</p><p>注意特判<span class="math inline">\(m\ge n-1\)</span>的情况，此时任意<span class="math inline">\(k\)</span>都满足条件。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) ;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 998244353</span></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], b[N], c[N], fac[N], inv[N], cnt, ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1l</span>l * a * a % P) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) s = <span class="number">1l</span>l * s * a % P;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    inv[n] = qpow(fac[n], P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i; --i) inv[i - <span class="number">1</span>] = <span class="number">1l</span>l * inv[i] * i % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt; m ? <span class="number">0</span> : <span class="number">1l</span>l * fac[n] * inv[m] % P * inv[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Polynomial&#123;</span><br><span class="line">    <span class="keyword">int</span> omega[N], rev[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) &lt; n) ++k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) rev[i] = rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (i &amp; <span class="number">1</span>) &lt;&lt; k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a, <span class="keyword">int</span> o = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (i &lt; rev[i]) <span class="built_in">std</span> :: swap(a[i], a[rev[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> m = <span class="number">1</span>, l; m &lt; n; m = l)&#123;</span><br><span class="line">            l = m &lt;&lt; <span class="number">1</span>, omega[<span class="number">0</span>] = <span class="number">1</span>, omega[<span class="number">1</span>] = qpow(~o ? <span class="number">3</span> : <span class="number">332748118</span>, (P - <span class="number">1</span>) / l);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i) omega[i] = <span class="number">1l</span>l * omega[i - <span class="number">1</span>] * omega[<span class="number">1</span>] % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> *p = a, t; p &lt; a + n; p += l)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)</span><br><span class="line">                    t = <span class="number">1l</span>l * omega[k] * p[m + k] % P, (p[m + k] = p[k] - t) &lt; <span class="number">0</span> ? p[m + k] += P : <span class="number">0</span>,</span><br><span class="line">                    (p[k] += t) &gt;= P ? p[k] -= P : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>, _n = qpow(n, P - <span class="number">2</span>); i &lt; n; ++i) a[i] = <span class="number">1l</span>l * a[i] * _n % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Trans</span><span class="params">(<span class="keyword">int</span> nt, <span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; nt) n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        init(n), NTT(n, a), NTT(n, b), NTT(n, c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            a[i] = <span class="number">1l</span>l * a[i] * c[i] % P, b[i] = <span class="number">1l</span>l * b[i] * c[i] % P;</span><br><span class="line">        NTT(n, a, <span class="number">-1</span>), NTT(n, b, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fail[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *S, <span class="keyword">int</span> m, <span class="keyword">int</span> *T)</span></span>&#123;</span><br><span class="line">    fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; T[j] != T[i - <span class="number">1</span>]) j = fail[j];</span><br><span class="line">        fail[i] = j += (T[j] == T[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; T[j] != S[i - <span class="number">1</span>]) j = fail[j];</span><br><span class="line">        j += (T[j] == S[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (j == m) ans[++cnt] = i - m, j = fail[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"pine.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"pine.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    n = read(), m = read() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &gt;= n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) b[i] = read(), b[i + n] = b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) c[i] = i &amp; <span class="number">1</span> ? P - C(m, i) : C(m, i);</span><br><span class="line">    Polynomial :: Trans(<span class="number">2</span> * n, a, b, c);</span><br><span class="line"><span class="comment">//for (register int i = 0; i &lt; n; ++i) printf("%d ", a[i]); putchar('\n');</span></span><br><span class="line"><span class="comment">//for (register int i = 0; i &lt; n; ++i) printf("%d ", b[i]); putchar('\n');</span></span><br><span class="line">    KMP(<span class="number">2</span> * n - <span class="number">1</span> - m, b + m, n - m, a + m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 差分 </tag>
            
            <tag> NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性递推求1~n的逆元 学习笔记</title>
      <link href="/linear-inv-notes/"/>
      <url>/linear-inv-notes/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3811" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>求<span class="math inline">\(1\sim n\)</span>中所有整数在模<span class="math inline">\(p\)</span>意义下的乘法逆元。</p><h2 id="题解">题解</h2><p>设<span class="math inline">\(a=\left\lfloor\frac{P}{i}\right\rfloor,b=P\bmod i\)</span>，则<span class="math inline">\(ai+b=P\)</span></p><p>即<span class="math inline">\(ai+b\equiv 0 \pmod P\)</span></p><a id="more"></a><p><span class="math display">\[\begin{align*} &amp;\therefore \frac{ai+b}{ib}\equiv 0 \pmod P \\ &amp;\therefore ab^{-1}+i^{-1}\equiv 0 \pmod P \\ &amp;\therefore\ i^{-1}\equiv -ab^{-1} \pmod P  \end{align*}\]</span></p><p>即<span class="math display">\[inv(i)=\left(P-\left\lfloor\frac{P}{i}\right\rfloor\right)\cdot inv(P\bmod i)\bmod P\]</span></p><p>于是<span class="math inline">\(O(n)\)</span>递推求一下就可以了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, P, inv[<span class="number">3000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">10</span>) <span class="built_in">putchar</span>(x + <span class="number">48</span>); <span class="keyword">else</span> print(x / <span class="number">10</span>), <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;P);</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) inv[i] = <span class="number">1l</span>l * (P - P / i) * inv[P % i] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) print(inv[i]), <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 505E」Mr. Kitayuta vs. Bamboos</title>
      <link href="/cf505e-sol/"/>
      <url>/cf505e-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/505/E" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>有<span class="math inline">\(n\)</span>根竹子，竹子<span class="math inline">\(i\)</span>初始高度为<span class="math inline">\(h_i\)</span>，每天<strong>晚上</strong>会长高<span class="math inline">\(a_i\)</span>。</p><p>每天<strong>白天</strong>，你可以选择<span class="math inline">\(k\)</span>根竹子（同一根竹子在同一个白天可以多次选择），把他们的高度减少<span class="math inline">\(p\)</span>，若竹子当前高度<span class="math inline">\(-p\)</span>后<span class="math inline">\(&lt;0\)</span>，则竹子高度变为<span class="math inline">\(0\)</span>。</p><p>最小化<span class="math inline">\(m\)</span>天后最高的竹子的高度。</p><a id="more"></a><h2 id="题解">题解</h2><p>首先<code>最小化最大的...</code>这种问题，显然可以用二分答案。</p><p>二分<span class="math inline">\(m\)</span>天后最高的竹子的高度<span class="math inline">\(H\)</span>，然后问题就变成了判定性问题：是否存在一种方案，使得<span class="math inline">\(m\)</span>天后竹子高度都<span class="math inline">\(\le H\)</span>。</p><p>考虑怎么解决这个判定性问题。</p><p>如果按照题意一天一天模拟，就需要考虑把竹子高度减<span class="math inline">\(p\)</span>后<span class="math inline">\(&lt;0\)</span>的情况，会比较麻烦。</p><p>所以我们尝试倒着模拟这一过程。</p><p>即：竹子初始高度都设为<span class="math inline">\(H\)</span>，每根竹子每天会<strong>减少</strong><span class="math inline">\(a_i\)</span>的高度，然后你可以选择<span class="math inline">\(k\)</span>根竹子，把它们“拔高”<span class="math inline">\(p\)</span>。问<span class="math inline">\(m\)</span>天后竹子高度是否都<span class="math inline">\(\ge h_i\)</span>。</p><p>此时你<strong>必须保证</strong>竹子减少<span class="math inline">\(a_i\)</span>的高度后不会<span class="math inline">\(&lt;0\)</span>。</p><p>这样就好做了。我们用一个堆维护 当前状态下继续减少高度而不“拔高”，第<span class="math inline">\(m\)</span>天结束后竹子高度会<span class="math inline">\(&lt;h_i\)</span>的竹子 一直减少高度 多少天后的高度会<span class="math inline">\(&lt;0\)</span>。</p><p>（不理解这句话可以尝试看代码理解）</p><p>每次取出最快<span class="math inline">\(&lt;0\)</span>的竹子，对它“拔高”即可。注意中间可能会出现无论怎么“拔高”还是会<span class="math inline">\(&lt;0\)</span>的竹子，此时直接返回错误即可。</p><p>最后判断堆是否为空即可，因为堆中维护的是<span class="math inline">\(m\)</span>天后竹子高度会<span class="math inline">\(&lt;h_i\)</span>的竹子，所以堆空即代表所有竹子高度都<span class="math inline">\(\ge h_i\)</span>。</p><p>时间复杂度<span class="math inline">\(O((n+mk)\log n\log mx)\)</span>，其中<span class="math inline">\(mx\)</span>表示<span class="math inline">\(\max\limits_{1\le i\le n} h_i+a_im\)</span>（二分的上界）。</p><h2 id="代码">代码</h2><p><a href="http://codeforces.com/contest/505/submission/45262032" target="_blank" rel="noopener">Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, c[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p, a[<span class="number">100005</span>], h[<span class="number">100005</span>], l = <span class="number">0</span>, r, mid, ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> day, id;  <span class="comment">// 表示当前状态下（二分的高度+c[id]*p）day+1天后竹子id的高度会&lt;0</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;b) <span class="keyword">const</span> &#123;  <span class="comment">// 默认大根堆，所以重载&lt;时写的是&gt;</span></span><br><span class="line">        <span class="keyword">return</span> day &gt; b.day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Heap</span>&#123;</span>  <span class="comment">// 用algorithm中的堆相关的算法封装实现。</span></span><br><span class="line">    node h[<span class="number">200005</span>];</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; sz = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> !sz; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(node x)</span></span>&#123; h[++sz] = x, <span class="built_in">std</span> :: push_heap(h + <span class="number">1</span>, h + <span class="number">1</span> + sz); &#125;</span><br><span class="line">    <span class="function">node <span class="title">pop</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">std</span> :: pop_heap(h + <span class="number">1</span>, h + <span class="number">1</span> + sz), h[sz--]; &#125;</span><br><span class="line">    <span class="function">node <span class="title">top</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> h[<span class="number">1</span>]; &#125;</span><br><span class="line">&#125;H;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    H.clear(), <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c); <span class="comment">// c[i]表示竹子i被“拔高”了几次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (x - a[i] * m &lt; h[i]) H.push((node)&#123;x / a[i], i&#125;);  <span class="comment">// 初始堆的状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; !H.empty() &amp;&amp; i &lt;= m; ++i)  <span class="comment">// i表示倒着的第几天</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; !H.empty() &amp;&amp; j &lt;= k; ++j)&#123; <span class="comment">// 拔高k根竹子</span></span><br><span class="line">            node u = H.pop();</span><br><span class="line">            <span class="keyword">if</span> (u.day &lt; i) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 无论怎么“拔高”都不能满足条件</span></span><br><span class="line">            ++c[u.id];  <span class="comment">// “拔高”</span></span><br><span class="line">            <span class="keyword">if</span> (x + c[u.id] * p - a[u.id] * m &lt; h[u.id])  <span class="comment">// 还是不满足条件，就插入堆中</span></span><br><span class="line">                H.push((node)&#123;(x + c[u.id] * p) / a[u.id], u.id&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> H.empty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), m = read(), k = read(), p = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        h[i] = read(), a[i] = read(), r = <span class="built_in">std</span> :: max(r, h[i] + a[i] * m);  <span class="comment">// 二分上界</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) check(mid = l + r &gt;&gt; <span class="number">1</span>) ? ans = mid, r = mid - <span class="number">1</span> : l = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 295D」Greg and Caves</title>
      <link href="/cf295d-sol/"/>
      <url>/cf295d-sol/</url>
      
        <content type="html"><![CDATA[<blockquote><p>标签：DP</p></blockquote><p><a href="http://codeforces.com/problemset/problem/295/D" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定<span class="math inline">\(n,m\)</span>，你需要对一个<span class="math inline">\(n\times m\)</span>的矩阵黑白染色，满足：</p><ol type="1"><li>存在一个区间<span class="math inline">\([l,r]\)</span>，满足<span class="math inline">\(l\sim r\)</span>这些行有且仅有两个黑色格子，其他行不存在黑色格子。</li><li>存在一个<span class="math inline">\(t\ (l\le t\le r)\)</span>，使得对于所有的<span class="math inline">\(i,j\ (l\le i\le j\le t)\)</span>，满足第<span class="math inline">\(i\)</span>行以两个黑色格子为端点的区间（以下简称“区间”）被<span class="math inline">\(j\)</span>行的区间包含；同样地，对于所有的<span class="math inline">\(i,j\ (t\le i\le j\le r)\)</span>，第<span class="math inline">\(j\)</span>行的区间被第<span class="math inline">\(i\)</span>行的区间包含。</li></ol><p>求染色方案数<span class="math inline">\(\bmod (10^9+7)\)</span>的值。</p><a id="more"></a><h2 id="题解">题解</h2><p>比较简单的<span class="math inline">\(\mathrm{DP}\)</span>，设<span class="math inline">\(dp_{i,j}\)</span>表示上半部分（即<span class="math inline">\(l\)</span>到<span class="math inline">\(t\)</span>部分）的高度<strong>至多</strong>为<span class="math inline">\(i\)</span>，底边宽度（包含两个黑色格子）为<span class="math inline">\(j\)</span>且底边位置固定时的方案数。</p><h3 id="转移方程">转移方程</h3><p><span class="math display">\[dp_{i,j}=dp_{i,j-1}+\sum\limits_{k=2}^j dp_{i-1,k}\]</span></p><p>应该还是比较好理解的。初始值<span class="math inline">\(dp_{1,i}=dp_{i,1}=1\)</span>。</p><p>直接转移是<span class="math inline">\(O(n^3)\)</span>的，但是<span class="math inline">\(\sum\limits_{k=2}^j dp_{i-1,k}\)</span>可以在枚举<span class="math inline">\(j\)</span>的同时计算（即前缀和优化），时间复杂度可以做到<span class="math inline">\(O(n^2)\)</span>。</p><h3 id="答案">答案</h3><p>下半部分的方案与上半部分同理。</p><p>注意如果下半部分的底边长度和上半部分的底边长度相等，会有重复，所以应该减去。</p><p><span class="math display">\[ans=\sum\limits_{i=1}^n \sum\limits_{j=2}^m (dp_{i,j}-dp_{i-1,j})\times dp_{n-i+1,j}\times (m-j+1)\bmod 1000000007\]</span></p><p><span class="math inline">\(i\)</span>枚举的是下半部分的起始位置，<span class="math inline">\(j\)</span>枚举的是下半部分的底边宽度，第一项是上半部分减去长度相等的方案，第二项是下半部分的方案，第三项是计算底边在矩阵中的位移。</p><p>注意需要随时取模。</p><h2 id="代码">代码</h2><p><a href="http://codeforces.com/contest/295/submission/45051328" target="_blank" rel="noopener">Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n, m, dp[<span class="number">2005</span>][<span class="number">2005</span>], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= m; ++j)</span><br><span class="line">            (s += dp[i - <span class="number">1</span>][j]) %= P, dp[i][j] = (dp[i][j - <span class="number">1</span>] + s) % P; <span class="comment">// 前缀和优化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= m; ++j)</span><br><span class="line">            (ans += <span class="number">1l</span>l * (dp[i][j] - dp[i - <span class="number">1</span>][j] + P) * dp[n - i + <span class="number">1</span>][j] % P * (m - j + <span class="number">1</span>) % P) %= P; <span class="comment">// 计算答案，随时取模</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 599E」Sandy and Nuts</title>
      <link href="/cf599e-sol/"/>
      <url>/cf599e-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/599/E" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>有一棵<span class="math inline">\(n\)</span>个节点的以1为根的树，有<span class="math inline">\(m\)</span>条边已知，并且有<span class="math inline">\(q\)</span>个限制<span class="math inline">\(a_i,b_i,c_i\)</span>，需要满足<span class="math inline">\(\mathrm{LCA}(a_i,b_i)=c_i\)</span>。求满足条件的树的数量。</p><p><span class="math inline">\(m&lt; n\le 13,q\le 100\)</span>。</p><a id="more"></a><h2 id="题解">题解</h2><p>树形状压DP。DP状态很显然，<span class="math inline">\(dp_{u,mask}\)</span>表示以<span class="math inline">\(u\)</span>为根，由<span class="math inline">\(mask\)</span>这些点组成的子树的方案数。<span class="math inline">\(mask\)</span>是一个二进制状态。</p><p>为方便讨论，以下题解和代码节点编号从<span class="math inline">\(0\)</span>开始。</p><h3 id="转移方程">转移方程</h3><p><span class="math display">\[dp_{u,mask}=\sum dp_{v,submask}\times dp_{u,mask\oplus submask}\]</span></p><p><span class="math inline">\(\oplus\)</span>表示的是异或(<span class="math inline">\(xor\)</span>)运算。</p><p>但是，我们直接枚举<span class="math inline">\(v,submask\)</span>会有重复，例如一棵二叉树，根为<span class="math inline">\(root\)</span>，左右儿子分别为<span class="math inline">\(leftson,rightson\)</span>。当枚举<span class="math inline">\(v=leftson\)</span>时会计算这棵树，<span class="math inline">\(v=rightson\)</span>时又会计算这棵树，就会出现重复。</p><p>所以，我们规定一个点<span class="math inline">\(pos\in mask\ (pos\ne u)\)</span>，强制<span class="math inline">\(pos\)</span>在<span class="math inline">\(submask\)</span>中才能转移。</p><h3 id="转移条件">转移条件</h3><p>题目中有两种限制条件，分别为边和<span class="math inline">\(\mathrm{LCA}\)</span>。</p><ol type="1"><li>对于<span class="math inline">\(\mathrm{LCA}\)</span>的限制： 1.1. 对于限制<span class="math inline">\((a,b,c)\)</span>，如果<span class="math inline">\(c=u\)</span>，但是<span class="math inline">\(a,b\in submask\)</span>，那么<span class="math inline">\(\mathrm{LCA}\)</span>一定不为<span class="math inline">\(c\)</span>，不满足条件。 1.2. 对于限制<span class="math inline">\((a,b,c)\)</span>， 如果<span class="math inline">\(c\in submask\)</span>，但<span class="math inline">\(a,b\)</span>中有<strong>至少</strong>一个不在<span class="math inline">\(submask\)</span>中，则<span class="math inline">\(\mathrm{LCA}\)</span>一定不为<span class="math inline">\(c\)</span>，不满足条件。</li><li>对于边的限制： 2.1. 对于边<span class="math inline">\((x,y)\)</span>，如果<span class="math inline">\(x,y\ne u\)</span>，但是<span class="math inline">\(x,y\)</span>其中一个在<span class="math inline">\(submask\)</span>中，另一个不在，则这条边不可能在树上，不满足条件。 2.2. 如果<span class="math inline">\(u\)</span>与<span class="math inline">\(i\)</span>有边且<span class="math inline">\(i\in submask\)</span>的<span class="math inline">\(i\)</span>的数量大于1，则不可能有满足条件的树，不满足条件。</li></ol><p>在2.2中，如果这样的<span class="math inline">\(i\)</span>的数量等于1，则转移时<span class="math inline">\(v\)</span>不用枚举，<span class="math inline">\(v\)</span>只能是那个<span class="math inline">\(i\)</span>。否则<span class="math inline">\(v\)</span>需要在<span class="math inline">\(submask\)</span>中枚举。</p><h3 id="关于复杂度">关于复杂度</h3><p>子集枚举可以用<code>for (register int submask = mask; submask; submask = (submask - 1) &amp; mask)</code>。</p><p>此时复杂度并不是<span class="math inline">\(O(4^n)\)</span>，而是<span class="math inline">\(O(3^n)\)</span>，因为每次枚举到的<span class="math inline">\(submask\)</span>一定是<span class="math inline">\(mask\)</span>的子集。状态数为<span class="math inline">\(3^n\)</span>。</p><p>因为此时<span class="math inline">\(n\)</span>个数有三种状态：不在<span class="math inline">\(mask\)</span>中，在<span class="math inline">\(mask\)</span>但不在<span class="math inline">\(submask\)</span>中，在<span class="math inline">\(submask\)</span>中。所以是<span class="math inline">\(3^n\)</span>。</p><p>所以复杂度为<span class="math inline">\(O(3^nn(n+q+m))\)</span>。</p><p>观察代码可以发现这个复杂度非常不满，很多状态和子集是没用的。加上CF的评测机速度，还是可以过的。</p><h2 id="代码">代码</h2><p><a href="http://codeforces.com/problemset/submission/599/45029702" target="_blank" rel="noopener">Code</a> 实测93ms</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m, q, edge[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> x, y; &#125; E[<span class="number">15</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> <span class="keyword">int</span> x, y, z; &#125; a[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">15</span>][<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span></span>&#123; <span class="keyword">return</span> s &amp; (<span class="number">1</span> &lt;&lt; x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> mask)</span></span>&#123; <span class="comment">// 用记搜实现</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> &amp;res = dp[u][mask];</span><br><span class="line">    <span class="keyword">if</span> (~res) <span class="keyword">return</span> res;</span><br><span class="line">    res = <span class="number">0</span>, mask -= <span class="number">1</span> &lt;&lt; u;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span> (pos = <span class="number">0</span>; pos &lt; n; ++pos) <span class="keyword">if</span> (in(pos, mask)) <span class="keyword">break</span>; <span class="comment">// 强制pos在submask中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> submask = mask; submask; submask = (submask - <span class="number">1</span>) &amp; mask) <span class="comment">// 枚举子集</span></span><br><span class="line">        <span class="keyword">if</span> (in(pos, submask))&#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">1</span>, v, cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 条件1.1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">                <span class="keyword">if</span> (a[i].z == u &amp;&amp; in(a[i].x, submask) &amp;&amp; in(a[i].y, submask))</span><br><span class="line">                    &#123; flag = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 条件1.2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) </span><br><span class="line">                <span class="keyword">if</span> (in(a[i].z, submask) &amp;&amp; (!in(a[i].x, submask) || !in(a[i].y, submask)))</span><br><span class="line">                    &#123; flag = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 条件2.1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">                    <span class="keyword">if</span> (E[i].x != u &amp;&amp; E[i].y != u &amp;&amp; (in(E[i].x, submask) ^ in(E[i].y, submask)))</span><br><span class="line">                        &#123; flag = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 条件2.2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                <span class="keyword">if</span> (edge[u][i] &amp;&amp; in(i, submask))&#123; ++cnt; v = i; &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">1</span>) res += dfs(v, submask) * dfs(u, mask ^ submask ^ (<span class="number">1</span> &lt;&lt; u));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; n; ++v)</span><br><span class="line">                    <span class="keyword">if</span> (in(v, submask)) res += dfs(v, submask) * dfs(u, mask ^ submask ^ (<span class="number">1</span> &lt;&lt; u)); <span class="comment">// 转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;E[i].x, &amp;E[i].y), --E[i].x, --E[i].y, <span class="comment">// 编号从0开始</span></span><br><span class="line">        edge[E[i].x][E[i].y] = edge[E[i].y][E[i].x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z), --a[i].x, --a[i].y, --a[i].z; <span class="comment">// 同上</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) dp[i][<span class="number">1</span> &lt;&lt; i] = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, dfs(<span class="number">0</span>, (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 状压DP </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BZOJ2753」「SCOI2012」滑雪与时间胶囊</title>
      <link href="/bzoj2753-sol/"/>
      <url>/bzoj2753-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2753" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定一个<span class="math inline">\(n\)</span>个点，<span class="math inline">\(m\)</span>条边的有权无向图，每个点有一个高度，求一个以<span class="math inline">\(1\)</span>为根的树，满足父亲的高度大于等于儿子的高度。在树的节点数最多的情况下，树上的边权之和最小。</p><a id="more"></a><h2 id="题解">题解</h2><p>如果没有高度限制，直接<span class="math inline">\(Kruskal\)</span>一遍就好了。</p><p>有了高度呢？其实变成了有向图，求一个点最多，边权值和最小的生成树。</p><p>第一问很好做，直接对这个有向图从<span class="math inline">\(1\)</span>开始<span class="math inline">\(bfs/dfs\)</span>一遍就好了。</p><p><span class="math inline">\(bfs/dfs\)</span>之后，原来的有向图就变成了从1开始能到达的所有点组成的一个有向图。</p><p>显然，如果两个点高度相同，那么这两个点之间连的边可以看成无向边，直接按边权排序做即可。</p><p>再考虑一个问题，两个点<span class="math inline">\(x,y\)</span>需要在树上联通，一定不会通过另一个高度比它们小的点进行联通的。</p><p>所以我们对于新图中的每条边<span class="math inline">\(u\to v\)</span>，优先按<span class="math inline">\(h_v\)</span>从大到小，<span class="math inline">\(h_v\)</span>相等按边权从小到大排序即可。</p><p>然后就是最简单的Kruskal了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">    Problem: 2753</span></span><br><span class="line"><span class="comment">    User: rill7747</span></span><br><span class="line"><span class="comment">    Language: C++</span></span><br><span class="line"><span class="comment">    Result: Accepted</span></span><br><span class="line"><span class="comment">    Time:6972 ms</span></span><br><span class="line"><span class="comment">    Memory:84612 kb</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000005</span></span><br><span class="line"><span class="keyword">int</span> n, m, h[N], fa[N], cnt;</span><br><span class="line"><span class="keyword">int</span> edge, to[N], tw[N], pr[N], hd[N], vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    to[++edge] = v, tw[edge] = w, pr[edge] = hd[u], hd[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h[v] &gt; h[res.v] || h[v] == h[res.v] &amp;&amp; w &lt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;E[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    ++cnt, vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v = to[i]]) dfs(v);</span><br><span class="line">        E[++m] = (node)&#123;u, v, tw[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = find(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">    <span class="keyword">if</span> (fx == fy) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fa[fy] = fx, <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span> :: sort(E + <span class="number">1</span>, E + <span class="number">1</span> + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (merge(E[i].u, E[i].v)) ans += E[i].w, ++sum;</span><br><span class="line">        <span class="keyword">if</span> (sum == cnt - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) h[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read(), w = read();</span><br><span class="line">        <span class="keyword">if</span> (h[u] &gt;= h[v]) addedge(u, v, w);</span><br><span class="line">        <span class="keyword">if</span> (h[v] &gt;= h[u]) addedge(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    m = <span class="number">0</span>, dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %lld"</span>, cnt, Kruskal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> BZOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SCOI </tag>
            
            <tag> Kruskal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BZOJ1568」「JSOI2008」Blue Mary开公司</title>
      <link href="/bzoj1568-sol-lcst-notes/"/>
      <url>/bzoj1568-sol-lcst-notes/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1568" target="_blank" rel="noopener">题目传送门</a></p><p>李超线段树模板题。</p><h2 id="题意">题意</h2><p>维护一个二维平面，支持两种操作：插入一条直线（<span class="math inline">\(y=kx+b\)</span>）；询问当前插入的所有直线<span class="math inline">\(x=x_0\)</span>时最大的纵坐标的值。</p><a id="more"></a><h2 id="题解">题解</h2><p>李超线段树。</p><p>一个节点同样表示一个区间<span class="math inline">\([l,r]\)</span>，记录的是一条直线<span class="math inline">\(id[u]\)</span>，这条直线是<span class="math inline">\(x=mid\)</span>时纵坐标最大的直线。</p><p>插入一条直线时，流程如下：</p><ol type="1"><li>直线<span class="math inline">\(id[u]\)</span>和<span class="math inline">\(i\)</span>没有交点：直接取<span class="math inline">\(y\)</span>值大的，退出。</li><li>如果当<span class="math inline">\(x=mid\)</span>时，直线<span class="math inline">\(i\)</span>的<span class="math inline">\(y\)</span>值比<span class="math inline">\(id[u]\)</span>大，那么<strong>交换</strong><span class="math inline">\(id[u],i\)</span>。</li><li>如果<span class="math inline">\(id[u]\)</span>和<span class="math inline">\(i\)</span>的交点在mid左边，即当<span class="math inline">\(x=l\)</span>时，直线<span class="math inline">\(i\)</span>的<span class="math inline">\(y\)</span>值大于等于<span class="math inline">\(id[u]\)</span>，那么递归处理<span class="math inline">\([l,mid]\)</span>，这种情况下其实<span class="math inline">\([mid+1,r]\)</span>的直线要改变，但因为询问时是从叶子节点到根节点取<span class="math inline">\(max\)</span>的，所以没有必要更新。</li><li>如果<span class="math inline">\(id[u]\)</span>和<span class="math inline">\(i\)</span>的交点在mid右边，即当<span class="math inline">\(x=r\)</span>时，直线<span class="math inline">\(i\)</span>的<span class="math inline">\(y\)</span>值大于等于<span class="math inline">\(id[u]\)</span>，那么递归处理<span class="math inline">\([mid+1,r]\)</span>，此时没有3中的情况。</li></ol><p>至于询问，已经提过，只要从叶节点到根取max就好了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">int</span> n, m, x;</span><br><span class="line"><span class="keyword">double</span> k[N], b[N];</span><br><span class="line"><span class="keyword">char</span> opt[<span class="number">15</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Li_Chao_Segment_Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k[u] * (x - <span class="number">1</span>) + b[u] &lt;= k[v] * (x - <span class="number">1</span>) + b[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (check(id[u], x, l) &amp;&amp; check(id[u], x, r)) <span class="keyword">return</span> id[u] = x, <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(id[u], x, mid)) <span class="built_in">std</span> :: swap(id[u], x);</span><br><span class="line">        <span class="keyword">if</span> (check(id[u], x, l)) Insert(u &lt;&lt; <span class="number">1</span>, l, mid, x);</span><br><span class="line">        <span class="keyword">if</span> (check(id[u], x, r)) Insert(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> k[l] * (x - <span class="number">1</span>) + b[l];</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) ans = Query(u &lt;&lt; <span class="number">1</span>, l, mid, x);</span><br><span class="line">        <span class="keyword">else</span> ans = Query(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span> :: max(ans, k[id[u]] * (x - <span class="number">1</span>) + b[id[u]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m); m--; )&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, opt);</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'P'</span>) ++n, <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, b + n, k + n), T.Insert(<span class="number">1</span>, <span class="number">1</span>, <span class="number">50000</span>, n);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">int</span>(T.Query(<span class="number">1</span>, <span class="number">1</span>, <span class="number">50000</span>, x) / <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> BZOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSOI </tag>
            
            <tag> 李超线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BZOJ3083」遥远的国度</title>
      <link href="/bzoj3083-sol/"/>
      <url>/bzoj3083-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3083" target="_blank" rel="noopener">题目传送门</a></p><h2 id="题意">题意</h2><p>给定一棵有点权的树和初始的根，支持三种操作：换根，修改路径上的权值，查询子树权值<span class="math inline">\(min\)</span>。</p><a id="more"></a><h2 id="题解">题解</h2><p>如果没有换根，这就是树剖+线段树裸题了。</p><p>那么有换根呢？首先我们一开始认定初始给定的根作为根进行树剖。</p><p>换根之后，路径修改显然不产生影响，直接用线段树维护就好了。假设现在的根为<span class="math inline">\(rt\)</span>，查询子树的根节点为<span class="math inline">\(x\)</span>，分以下三种情况（可以脑补一下或者画个图）：</p><ol type="1"><li><span class="math inline">\(rt=x\)</span></li><li><span class="math inline">\(rt\)</span>在<span class="math inline">\(x\)</span>的子树外</li><li><span class="math inline">\(rt\)</span>在<span class="math inline">\(x\)</span>的子树内（不包括<span class="math inline">\(x\)</span>）</li></ol><p>注意这里的子树是相对于以初始根为根时的树而言的。</p><p>对于1，相当于查询整棵树的min，直接在整棵线段树上查询就好了。</p><p>对于2，又有两种情况：一种是<span class="math inline">\(x\)</span>在<span class="math inline">\(rt\)</span>的子树内（不包括<span class="math inline">\(rt\)</span>），另一种是<span class="math inline">\(x\)</span>的子树和<span class="math inline">\(rt\)</span>的子树互不包含。</p><p>画一下图即可知道，这两种情况是一样的，即不需要考虑换根，换根之后<span class="math inline">\(x\)</span>子树中的节点没有变化，直接查询以初始根为根时<span class="math inline">\(x\)</span>的子树min。</p><p>对于3，就有点麻烦了。我们设<span class="math inline">\(u\)</span>是<span class="math inline">\(x\)</span>到<span class="math inline">\(rt\)</span>这条链上除<span class="math inline">\(x\)</span>外的第二个点（<span class="math inline">\(x\)</span>的儿子）。那么在纸上画一下即可得知，换根后的<span class="math inline">\(x\)</span>的子树变为整棵树减去换根前<span class="math inline">\(u\)</span>的子树（注意不是<span class="math inline">\(x\)</span>的子树减去<span class="math inline">\(u\)</span>的子树）。</p><p>那么问题在于求u。算法描述如下（设树剖后节点<span class="math inline">\(i\)</span>所在重链的顶端节点为<span class="math inline">\(top[i]\)</span>，节点<span class="math inline">\(i\)</span>的父亲为<span class="math inline">\(fa[i]\)</span>，节点<span class="math inline">\(i\)</span>的重儿子是<span class="math inline">\(son[i]\)</span>）：</p><ol type="1"><li><span class="math inline">\(u\gets rt\)</span></li><li>如果<span class="math inline">\(fa[top[u]]\)</span>在<span class="math inline">\(x\)</span>的子树中并且不等于<span class="math inline">\(x\)</span>，那么<span class="math inline">\(u\gets fa[top[u]]\)</span>。不断执行这一过程直至条件不成立。</li><li>如果<span class="math inline">\(fa[top[u]]=x\)</span>，那么<span class="math inline">\(u=top[u]\)</span>，否则<span class="math inline">\(u=son[x]\)</span></li></ol><p>解释一下第三步，因为最后如果<span class="math inline">\(fa[top[u]]=x\)</span>那么<span class="math inline">\(top[u]\)</span>刚好就是这条链上<span class="math inline">\(x\)</span>的儿子了，否则说明<span class="math inline">\(fa[top[u]]\)</span>是<span class="math inline">\(x\)</span>的祖先，即<span class="math inline">\(x\)</span>和<span class="math inline">\(u\)</span>在同一条重链上，那么这条链上<span class="math inline">\(x\)</span>的儿子就是<span class="math inline">\(x\)</span>的重儿子。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">    Problem: 3083</span></span><br><span class="line"><span class="comment">    User: rill7747</span></span><br><span class="line"><span class="comment">    Language: C++</span></span><br><span class="line"><span class="comment">    Result: Accepted</span></span><br><span class="line"><span class="comment">    Time:3312 ms</span></span><br><span class="line"><span class="comment">    Memory:13452 kb</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], rt;</span><br><span class="line"><span class="keyword">int</span> edge, to[N &lt;&lt; <span class="number">1</span>], pr[N &lt;&lt; <span class="number">1</span>], hd[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N], sz[N], son[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa[u])</span><br><span class="line">            fa[v] = u, dep[v] = dep[u] + <span class="number">1</span>, dfs(v), sz[u] += sz[v], </span><br><span class="line">            !son[u] || sz[v] &gt; sz[son[u]] ? son[u] = v : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> top[N], idx, st[N], id[N], ed[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp, id[st[u] = ++idx] = u;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs(son[u], tp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = hd[u], v; i; i = pr[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = to[i]) != fa[u] &amp;&amp; v != son[u]) dfs(v, v);</span><br><span class="line">    ed[u] = idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> val[N &lt;&lt; <span class="number">2</span>], lz[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> val[u] = a[id[l]], lz[u] = <span class="number">0</span>, <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(u &lt;&lt; <span class="number">1</span>, l, mid), build(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    val[u] = <span class="built_in">std</span> :: min(val[u &lt;&lt; <span class="number">1</span>], val[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lz[u]) val[u &lt;&lt; <span class="number">1</span>] = val[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = lz[u &lt;&lt; <span class="number">1</span>] = lz[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = lz[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> val[u] = lz[u] = v, <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; down(u);</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) modify(u &lt;&lt; <span class="number">1</span>, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid) modify(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    val[u] = <span class="built_in">std</span> :: min(val[u &lt;&lt; <span class="number">1</span>], val[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> val[u];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">2147483647</span>; down(u);</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) ans = <span class="built_in">std</span> :: min(ans, query(u &lt;&lt; <span class="number">1</span>, l, mid, L, R));</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid) ans = <span class="built_in">std</span> :: min(ans, query(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, L, R));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) <span class="built_in">std</span> :: swap(u, v);</span><br><span class="line">        modify(<span class="number">1</span>, <span class="number">1</span>, n, st[top[u]], st[u], w), u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) <span class="built_in">std</span> :: swap(u, v);</span><br><span class="line">    modify(<span class="number">1</span>, <span class="number">1</span>, n, st[v], st[u], w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == rt) <span class="keyword">return</span> val[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (st[rt] &lt; st[u] || st[rt] &gt; ed[u]) <span class="keyword">return</span> query(<span class="number">1</span>, <span class="number">1</span>, n, st[u], ed[u]);</span><br><span class="line">    <span class="keyword">int</span> v = rt;</span><br><span class="line">    <span class="keyword">while</span> (st[fa[top[v]]] &gt; st[u] &amp;&amp; st[fa[top[v]]] &lt;= ed[u]) v = fa[top[v]];</span><br><span class="line">    <span class="keyword">if</span> (fa[top[v]] == u) v = top[v]; <span class="keyword">else</span> v = son[u];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span> :: min(query(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, st[v] - <span class="number">1</span>), query(<span class="number">1</span>, <span class="number">1</span>, n, ed[v] + <span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">        u = read(), v = read(), addedge(u, v), addedge(v, u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read();</span><br><span class="line">    rt = read();</span><br><span class="line">    dfs(rt), dfs(rt, rt), build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt = read(), x, y, w;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) rt = read();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">2</span>) x = read(), y = read(), w = read(), Modify(x, y, w);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Query(read()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> BZOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分类讨论 </tag>
            
            <tag> 树链剖分 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2018之前</title>
      <link href="/before-noip2018/"/>
      <url>/before-noip2018/</url>
      
        <content type="html"><![CDATA[<p>好久没更新博客了。</p><a id="more"></a><p>10/14初赛，当时感觉凉凉……emmm不过后来答案出来以后感觉也还可以，选择题连蒙带猜地做竟然只错了1个？</p><p>问题求解T2 想到根据二进制位分类讨论，但没往排列组合方面想。</p><p>估分93，ZJ提高，应该还可以吧。</p><p>坐等分数线。</p><p>虽然初赛还可以，但是ZJ提高组……感觉要凉啊。希望能拿一等。</p><p>只有20多天了，突然发现好像什么都不会了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP2018 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国剩余定理 学习笔记</title>
      <link href="/crt-notes/"/>
      <url>/crt-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>中国剩余定理用来解决如下问题：</p><p>求关于<span class="math inline">\(x\)</span>的方程组</p><p><span class="math display">\[\begin{cases} x \equiv a_1 \pmod{p_1} \\ x \equiv a_2 \pmod{p_2} \\ \cdots \\ x \equiv a_n\pmod{p_n}\end{cases}\]</span></p><p>的最小非负整数解。</p><p><strong>其中<span class="math inline">\(p_i\)</span>两两互质。</strong></p><a id="more"></a><h2 id="前置技能">前置技能</h2><p>扩展欧几里得求乘法逆元</p><h2 id="求解">求解</h2><p>设<span class="math inline">\(M=\prod_{i=1}^{n} p_i,d_i=\frac{M}{p_i}\)</span>，即<span class="math inline">\(d_i\)</span>表示除<span class="math inline">\(p_i\)</span>外所有<span class="math inline">\(p\)</span>的乘积。</p><p>记<span class="math inline">\(inv_i\)</span>表示<span class="math inline">\(d_i\)</span>在模<span class="math inline">\(p_i\)</span>域下的逆元（因为<span class="math inline">\(p\)</span>两两互质，所以<span class="math inline">\(d_i\)</span>一定与<span class="math inline">\(p_i\)</span>互质，所以一定存在逆元），即<span class="math inline">\(inv_i \times d_i \equiv 1 \pmod{p_i}\)</span>。记<span class="math inline">\(x_i=inv_i\times d_i\)</span>，则：</p><ol type="1"><li>因为<span class="math inline">\(d_i\)</span>能被除<span class="math inline">\(p_i\)</span>外的所有<span class="math inline">\(p\)</span>整除，所以<span class="math inline">\(x_i\)</span>一定能被除<span class="math inline">\(p_i\)</span>外的所有<span class="math inline">\(p\)</span>整除，所以<span class="math inline">\(x_ia_i\)</span>一定能被除<span class="math inline">\(p_i\)</span>外的所有<span class="math inline">\(p\)</span>整除。</li><li><span class="math inline">\(x_i\equiv 1 \pmod{p_i}\)</span>，所以<span class="math inline">\(a_ix_i\equiv a_i \pmod{p_i}\)</span>。</li></ol><p>根据以上两条推论可得，答案为<span class="math inline">\(\left( \sum_{i=1}^{n} a_ix_i \right) \bmod M\)</span>。因为对于第<span class="math inline">\(i\)</span>个方程，根据推论1，对于所有的<span class="math inline">\(j\ne i\)</span>，<span class="math inline">\(a_jx_j\)</span>不会对该方程组产生贡献，即<span class="math inline">\(a_jx_j\equiv 0 \pmod{p_i} (j\ne i)\)</span>。只有<span class="math inline">\(a_ix_i\)</span>会对第<span class="math inline">\(i\)</span>个方程产生贡献，且根据推论2，恰好会产生<span class="math inline">\(a_i\)</span>的贡献。又因为对于所有<span class="math inline">\(i\)</span>，<span class="math inline">\(M\equiv 0\pmod{p_i}\)</span>，所以答案加上或减去若干个<span class="math inline">\(M\)</span>都满足方程组。求的是最小非负整数解，所以答案<span class="math inline">\(\bmod M\)</span>。</p><h2 id="代码">代码</h2><p>中国剩余定理模板题：<a href="https://www.luogu.org/problemnew/show/P3868" target="_blank" rel="noopener">[TJOI2009]猜数字</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> &amp;x, <span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x0, y0, g = exgcd(b, a % b, x0, y0);</span><br><span class="line">    <span class="keyword">return</span> x = y0, y = x0 - a / b * y0, g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">15</span>], p[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, y, g = exgcd(a, p, x, y);</span><br><span class="line">    <span class="keyword">if</span> (g != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qmul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (a %= p, b %= p; b; b &gt;&gt;= <span class="number">1</span>, a = (a + a) % p) b &amp; <span class="number">1</span> ? s = (s + a) % p : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, p + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = (a[i] % p[i] + p[i]) % p[i];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> m = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) m = m * p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> d = m / p[i], d_ = inv(d, p[i]);</span><br><span class="line">        (ans += qmul(qmul(d, d_, m), a[i], m)) %= m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中国剩余定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展欧几里得 学习笔记</title>
      <link href="/exgcd-notes/"/>
      <url>/exgcd-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>形式1：求方程<span class="math inline">\(ax+by=c\)</span>的任意一组整数解。</p><p>形式2：求同余方程<span class="math inline">\(ax\equiv c\pmod b\)</span>的最小整数解。</p><a id="more"></a><p>可以发现两种形式的问题可以互相转化。</p><h2 id="前置技能">前置技能</h2><p>辗转相除法求gcd</p><h2 id="求解">求解</h2><p>根据裴蜀定理，当且仅当<span class="math inline">\(gcd(a,b)|c\)</span>时，原方程有整数解。</p><p>所以我们考虑解决方程<span class="math inline">\(ax+by=gcd(a,b)\)</span>，最后同乘<span class="math inline">\(\frac{c}{gcd(a,b)}\)</span>即可。</p><p>为方便描述，我们用<span class="math inline">\(\%\)</span>代替<span class="math inline">\(\bmod\)</span>。</p><p>有性质<span class="math inline">\(gcd(a,b)=gcd(b,a\%b)\)</span></p><p>我们假设已经解出方程<span class="math inline">\(bx&#39;+(a\%b)y&#39;=gcd(b,a\%b)\)</span>，即<span class="math inline">\(bx&#39;+(a\%b)y&#39;=gcd(a,b)\)</span>。</p><p>将<span class="math inline">\(a\%b\)</span>展开，得<span class="math inline">\(bx&#39;+(a-\lfloor \frac{a}{b}\rfloor\times b)y&#39;=gcd(a,b)\)</span>。</p><p>即<span class="math inline">\(ay&#39;+b(x&#39;-\lfloor \frac{a}{b}\rfloor y&#39;)=gcd(a,b)\)</span>。</p><p>令<span class="math inline">\(x=y&#39;,y=x&#39;-\lfloor \frac{a}{b}\rfloor y&#39;\)</span>，我们得到了原方程得一组解。</p><p>所以可以递归求解，终止条件是<span class="math inline">\(b=0\)</span>，此时<span class="math inline">\(gcd(a,b)=a\)</span>，方程组的解是<span class="math inline">\(x=1,y=0\)</span>。</p><p>求<span class="math inline">\(x\)</span>最小的解：</p><p>因为如果<span class="math inline">\((x,y)\)</span>是一组解，则<span class="math inline">\((x+\frac{b}{gcd(a,b)},y-\frac{a}{gcd(a,b)})\)</span>也是一组解，可以根据这个求出最小解。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">    <span class="keyword">int</span> x0, y0, g = exgcd(b, a % b, x0, y0);</span><br><span class="line">    <span class="keyword">return</span> x = y0, y = x0 - a / b * y0, g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="keyword">int</span> x, y, g = exgcd(a, b, x, y);</span><br><span class="line">    <span class="keyword">if</span> (c % g) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"Impossible"</span>), <span class="number">0</span>;</span><br><span class="line">    x *= c / g, y *= c / g;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 扩展欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乘法逆元 学习笔记</title>
      <link href="/inv-notes/"/>
      <url>/inv-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>用来解决模域下的除法问题。</p><h2 id="求解">求解</h2><p>乘法逆元的定义：<span class="math inline">\(ab\equiv 1 \pmod p\)</span>，则<span class="math inline">\(b\)</span>称为<span class="math inline">\(a\)</span>在模<span class="math inline">\(p\)</span>域下的乘法逆元。乘法逆元不一定存在，存在条件请参见下文。</p><a id="more"></a><p>这样我们就可以轻松解决模域下的除法问题。即假设我们要求<span class="math inline">\(\frac{a}{b} \bmod p\)</span>的值，用<span class="math inline">\(inv(x)\)</span>表示<span class="math inline">\(x\)</span>在模<span class="math inline">\(p\)</span>域下的乘法逆元，则<span class="math inline">\(\frac{a}{b} \bmod p=\frac{a\cdot b\cdot inv(b)}{b}\bmod p=a\cdot inv(b) \bmod p\)</span>，所以我们把除法变成了乘法，就可以利用乘法在模域下的一些性质对原问题进行求解或转化。</p><p>问题在于如何求出<span class="math inline">\(inv(b)\)</span>。求乘法逆元有许多方法。</p><h3 id="扩展欧几里得">扩展欧几里得</h3><p>根据乘法逆元的定义，我们要求<span class="math inline">\(inv(a)\)</span>，就是求同余方程<span class="math inline">\(ax\equiv 1 \pmod p\)</span>的最小整数解。</p><p>考虑将该同余方程转化为一般形式，即<span class="math inline">\(ax+py=1\)</span>。</p><p>很容易就能求出<span class="math inline">\(x\)</span>的最小整数解。</p><p>根据裴蜀定理可知，方程<span class="math inline">\(ax+by=c\)</span>只有当<span class="math inline">\(gcd(a,b)|c\)</span>时才有整数解。所以<strong>只有当<span class="math inline">\(gcd(a,p)=1\)</span>时，逆元才唯一存在</strong>。</p><h3 id="费马小定理">费马小定理</h3><p>费马小定理：当<span class="math inline">\(p\)</span>是质数时，<span class="math inline">\(a^{p-1}\equiv 1 \pmod p\)</span>。即<span class="math inline">\(a\cdot a^{p-2}\equiv 1\pmod p\)</span>。所以<span class="math inline">\(inv(a)=a^{p-2}\)</span>。</p><h3 id="欧拉定理">欧拉定理</h3><p>欧拉定理：当<span class="math inline">\(a,p\)</span>互质时，<span class="math inline">\(a^{\varphi(p)}\equiv 1 \pmod p\)</span>。即<span class="math inline">\(a\cdot a^{\varphi(p)-1}\equiv 1\pmod p\)</span>。所以<span class="math inline">\(inv(a)=a^{\varphi(p)-1}\)</span>。</p><p><span class="math inline">\(\varphi(p)\)</span>即欧拉函数，表示小于等于<span class="math inline">\(p\)</span>的正整数中，与<span class="math inline">\(p\)</span>互质的数的个数。</p><p>因为当<span class="math inline">\(p\)</span>是质数时，<span class="math inline">\(\varphi(p)=p-1\)</span>，所以费马小定理是欧拉定理的特殊形式。</p><p><span class="math inline">\(\varphi(p)\)</span>的求法不详细介绍。</p><h3 id="特例">特例</h3><p>还有一些奇怪的特例，例如求<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>所有数在模<span class="math inline">\(p\)</span>域下的逆元，还有<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>所有数的阶乘在模<span class="math inline">\(p\)</span>域下的逆元，这些可以<span class="math inline">\(O(n)\)</span>求出。</p><p>不详细介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Codeforces 815D」Karen and Cards</title>
      <link href="/cf815d-sol/"/>
      <url>/cf815d-sol/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/815/D" target="_blank" rel="noopener">题目传送门</a></p><h2 id="karen-and-cards">Karen and Cards</h2><p>Karen just got home from the supermarket, and is getting ready to go to sleep.</p><a id="more"></a><figure><img src="http://codeforces.com/predownloaded/2b/98/2b98bfcf516f93477a5a209118c7c4582fc9db2d.png" alt="" /><figcaption>img</figcaption></figure><p>After taking a shower and changing into her pajamas, she looked at her shelf and saw an album. Curious, she opened it and saw a trading card collection.</p><p>She recalled that she used to play with those cards as a child, and, although she is now grown-up, she still wonders a few things about it.</p><p>Each card has three characteristics: strength, defense and speed. The values of all characteristics of all cards are positive integers. The maximum possible strength any card can have is <span class="math inline">\(p\)</span>, the maximum possible defense is <span class="math inline">\(q\)</span> and the maximum possible speed is <span class="math inline">\(r\)</span>.</p><p>There are <span class="math inline">\(n\)</span> cards in her collection. The <span class="math inline">\(i\)</span>-th card has a strength <span class="math inline">\(a_i\)</span>, defense <span class="math inline">\(b_i\)</span> and speed <span class="math inline">\(c_i\)</span>, respectively.</p><p>A card beats another card if at least two of its characteristics are strictly greater than the corresponding characteristics of the other card.</p><p>She now wonders how many different cards can beat all the cards in her collection. Two cards are considered different if at least one of their characteristics have different values.</p><h3 id="input">Input</h3><p>The first line of input contains four integers, <span class="math inline">\(n,p,q\)</span> and <span class="math inline">\(r\)</span> (<span class="math inline">\(1 \le n,p,q,r \le 500000\)</span>), the number of cards in the collection, the maximum possible strength, the maximum possible defense, and the maximum possible speed, respectively.</p><p>The next <span class="math inline">\(n\)</span> lines each contain three integers. In particular, the <span class="math inline">\(i\)</span>-th line contains <span class="math inline">\(a_i,b_i\)</span> and <span class="math inline">\(c_i\)</span> (<span class="math inline">\(1\le a_i\le p,1\le b_i\le q,1\le c_i\le r\)</span>), the strength, defense and speed of the <span class="math inline">\(i\)</span>-th collection card, respectively.</p><h3 id="output">Output</h3><p>Output a single integer on a line by itself, the number of different cards that can beat all the cards in her collection.</p><h3 id="examples">Examples</h3><h4 id="input-1">Input</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">4</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="output-1">Output</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="input-2">Input</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">10</span> <span class="number">10</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="output-2">Output</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">972</span></span><br></pre></td></tr></table></figure><h3 id="note">Note</h3><p>In the first test case, the maximum possible strength is 4, the maximum possible defense is 4 and the maximum possible speed is 5. Karen has three cards:</p><ul><li>The first card has strength 2, defense 2 and speed 5.</li><li>The second card has strength 1, defense 3 and speed 4.</li><li>The third card has strength 4, defense 1 and speed 1.</li></ul><p>There are 10 cards that beat all the cards here:</p><ol type="1"><li>The card with strength 3, defense 3 and speed 5.</li><li>The card with strength 3, defense 4 and speed 2.</li><li>The card with strength 3, defense 4 and speed 3.</li><li>The card with strength 3, defense 4 and speed 4.</li><li>The card with strength 3, defense 4 and speed 5.</li><li>The card with strength 4, defense 3 and speed 5.</li><li>The card with strength 4, defense 4 and speed 2.</li><li>The card with strength 4, defense 4 and speed 3.</li><li>The card with strength 4, defense 4 and speed 4.</li><li>The card with strength 4, defense 4 and speed 5.</li></ol><p>In the second test case, the maximum possible strength is 10, the maximum possible defense is 10 and the maximum possible speed is 10. Karen has five cards, all with strength 1, defense 1 and speed 1.</p><p>Any of the 972 cards which have at least two characteristics greater than 1 can beat all of the cards in her collection.</p><h2 id="problem">Problem</h2><p>给定<span class="math inline">\(n\)</span>个三元组<span class="math inline">\((a_i,b_i,c_i)\)</span>，以及三元组中每个数的上限<span class="math inline">\(p,q,r\)</span>，定义一个三元组能击败另一个三元组当且仅当这个三元组中有任意两个数<strong>严格大于</strong>另一个三元组<strong>对应</strong>的两个数。求有多少三元组能击败所有<span class="math inline">\(n\)</span>个三元组。</p><h2 id="solution">Solution</h2><p>记满足条件的三元组为<span class="math inline">\((x,y,z)\)</span>。显然如果枚举<span class="math inline">\(x\)</span>，则三元组可以分为两类：<span class="math inline">\(a_i&lt;x\)</span>与<span class="math inline">\(a_i\ge x\)</span>。对于<span class="math inline">\(a_i&lt;x\)</span>的三元组，只需要满足<span class="math inline">\(y&gt;b_i\)</span><strong>或者</strong><span class="math inline">\(z&gt;c_i\)</span>。而对于<span class="math inline">\(a_i\ge x\)</span>的三元组，需要满足<span class="math inline">\(y&gt;b_i\)</span><strong>并且</strong><span class="math inline">\(z&gt;c_i\)</span>。</p><p>记<span class="math inline">\(smx_j(j\in [1,q])\)</span>表示<span class="math inline">\(b_i\ge j\)</span>的三元组中最大的<span class="math inline">\(c_i\)</span>，<span class="math inline">\(mx3\)</span>表示<span class="math inline">\(a_i\ge x\)</span>的三元组中最大的<span class="math inline">\(c_i\)</span>。那么<span class="math inline">\(z\)</span>的方案数就是<span class="math inline">\(r-max(smx_y,mx3)\)</span>，即<span class="math inline">\(z\)</span>需要满足<span class="math inline">\(z&gt;smx_y,z&gt;mx3\)</span>，因为对于<span class="math inline">\(a_i\ge x\)</span>的三元组，<span class="math inline">\(z\)</span>一定大于<span class="math inline">\(c_i\)</span>，且对于<span class="math inline">\(b_i\ge y\)</span>的三元组，<span class="math inline">\(z\)</span>也一定大于<span class="math inline">\(c_i\)</span>。</p><p>记<span class="math inline">\(mx2\)</span>表示<span class="math inline">\(a_i\ge x\)</span>的三元组中最大的<span class="math inline">\(b_i\)</span>，那么当<span class="math inline">\(x\)</span>固定时，总方案可以用<code>for (int i=mx2+1;i&lt;=q;i++) ans+=r-max(smx[i],mx3);</code>进行统计。</p><p>这样的话，因为我们要统计<span class="math inline">\(a_i\ge x\)</span>的三元组中最大的<span class="math inline">\(b_i\)</span>（<span class="math inline">\(mx2\)</span>），最大的<span class="math inline">\(c_i\)</span>（<span class="math inline">\(mx3\)</span>），所以我们应该倒着枚举<span class="math inline">\(x\)</span>。</p><p>时间复杂度？<span class="math inline">\(\mathcal O(n^2)\)</span>。显然不能过。</p><p>考虑优化<code>for (int i=mx2+1;i&lt;=q;i++) ans+=r-max(smx[i],mx3);</code>这段代码。</p><p><span class="math inline">\(max\)</span>很不好处理，我们考虑把它拆开分别计算。由<span class="math inline">\(smx_i\)</span>的定义可得，<span class="math inline">\(\{smx_i\}\)</span>单调不升，也就是<span class="math inline">\(i\)</span>越小，<span class="math inline">\(smx_i\)</span>越大。那么我们找到一个<span class="math inline">\(max\)</span>分界线，记为<span class="math inline">\(k\)</span>，使得<span class="math inline">\(i\ge k\)</span>时，<span class="math inline">\(smx_i\le mx3\)</span>，<span class="math inline">\(i&lt;k\)</span>时，<span class="math inline">\(smx_i&gt;mx3\)</span>。于是就可以<span class="math inline">\(\mathcal O(1)\)</span>计算答案了，用前缀和维护<span class="math inline">\(\{smx_i\}\)</span>的区间和即可。</p><p>显然，<span class="math inline">\(\{smx_i\},mx2,mx3\)</span>很容易维护。那么<span class="math inline">\(k\)</span>怎么办呢？因为<span class="math inline">\(x\)</span>从大到小枚举，<span class="math inline">\(mx3\)</span>会逐渐变大，而<span class="math inline">\(\{smx_i\}\)</span>单调不升，所以<span class="math inline">\(k\)</span>慢慢变小（向前），一直维护即可。</p><p>一些细节具体见代码。</p><h2 id="source">Source</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(ch)&amp;&amp;ch!=EOF;ch=getchar()) <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500005</span>;</span><br><span class="line"><span class="keyword">int</span> n,La,Lb,Lc,smx[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">card</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> b,c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;card&gt; d[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,sum[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),La=read(),Lb=read(),Lc=read(); <span class="comment">//La,Lb,Lc分别代表p,q,r</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a=min(La,read()),b=min(Lb,read()),c=min(Lc,read());</span><br><span class="line">        d[a].push_back((card)&#123;b,c&#125;);</span><br><span class="line">        smx[b]=max(smx[b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=Lb<span class="number">-1</span>;i;--i) smx[i]=max(smx[i],smx[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Lb;++i) sum[i]=sum[i<span class="number">-1</span>]+smx[i]; <span class="comment">//smx[i]的前缀和</span></span><br><span class="line">    <span class="keyword">int</span> mxb=<span class="number">0</span>,mxc=<span class="number">0</span>,k=Lb+<span class="number">1</span>; <span class="comment">//初始值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> x=La;x;--x)&#123; <span class="comment">//从大到小枚举</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d[x].size();++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=d[x][i].b,z=d[x][i].c;</span><br><span class="line">            mxb=max(mxb,y),mxc=max(mxc,z); <span class="comment">//维护mx2和mx3</span></span><br><span class="line">            <span class="keyword">while</span> (k&gt;mxb+<span class="number">1</span>&amp;&amp;smx[k<span class="number">-1</span>]&lt;mxc) --k; <span class="comment">//维护k</span></span><br><span class="line">        &#125;</span><br><span class="line">        k=max(k,mxb+<span class="number">1</span>); <span class="comment">//防止越界</span></span><br><span class="line">        ans+=<span class="number">1l</span>l*(Lc-mxc)*(Lb-k+<span class="number">1</span>)+<span class="number">1l</span>l*Lc*(k-mxb<span class="number">-1</span>)-sum[k<span class="number">-1</span>]+sum[mxb]; <span class="comment">//利用前缀和O(1)统计答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维数点 </tag>
            
            <tag> 单调性 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
