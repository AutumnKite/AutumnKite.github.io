<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round #632 (Div. 2) 裂开记]]></title>
    <url>%2Fcf1333%2F</url>
    <content type="text"><![CDATA[打得非常裂开，被 D 续了半年。 A - Little Artem 题目传送门 题解 首先我们考虑将所有格子填上黑色，此时 \(B=W=0\)。 我们尝试将一个格子变成白色，可以发现将一个格子变成白色会使得 \(W\) 变成 \(1\)，\(B\) 变成这个格子上下左右的黑色格子数量。 我们的目标是使得 \(B=2,W=1\)，那么我们只要选择角落上的格子变成白色即可。 代码 12345678910111213void solve() &#123; read(n), read(m); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (i == n &amp;&amp; j == m) &#123; putchar('W'); &#125; else &#123; putchar('B'); &#125; &#125; putchar('\n'); &#125;&#125; B - Kind Anton 题目传送门 题解 考虑从后往前依次将 \(a_i\) 变成 \(b_i\)。 考虑对于当前位置 \(i\)，若 \(b_i &lt; a_i\)（即需要变小），那么显然只需要存在一个 \(j\) 满足 \(j &lt; i\) 且 \(a_j=-1\) 就可以不断将 \(a_i\) 减 \(1\) 直到等于 \(b_i\)；同理，若 \(b_i &gt; a_i\)（即需要变大），那么只需要存在一个 \(j\) 满足 \(j &lt; i\) 且 \(a_j=1\) 就可以不断将 \(a_i\) 加 \(1\) 直到等于 \(b_i\)。 那么我们只需要从左往右找到第一个 \(1\) 和 \(-1\) 然后进行判断即可。 代码 12345678910111213141516171819202122232425262728293031323334353637const int N = 200005;int n, a[N], b[N];void solve() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; for (int i = 1; i &lt;= n; ++i) &#123; read(b[i]); &#125; int p1 = 1, p2 = 1; while (p1 &lt;= n &amp;&amp; a[p1] &lt; 1) &#123; if (a[p1] &lt; b[p1]) &#123; printStr("NO"); return; &#125; ++p1; &#125; if (p1 &lt;= n &amp;&amp; a[p1] &lt; b[p1]) &#123; printStr("NO"); return; &#125; while (p2 &lt;= n &amp;&amp; a[p2] &gt; -1) &#123; if (a[p2] &gt; b[p2]) &#123; printStr("NO"); return; &#125; ++p2; &#125; if (p2 &lt;= n &amp;&amp; a[p2] &gt; b[p2]) &#123; printStr("NO"); return; &#125; printStr("YES");&#125; C - Eugene and an array 题目传送门 题解 不知道为什么 CF 的评论里有很多人说这题很难，感觉好像就是个套路题？ 首先考虑求出 \(a_i\) 的前缀和 \(b_i=\sum\limits_{j=1}^{i} a_j\)，那么一个区间 \((l,r]\) 合法当且仅当不存在 \(l\le j &lt; i\le r\) 使得 \(b_i=b_j\)。 考虑对于一个 \(b_i\)，求出上一个与 \(b_i\) 相同的位置 \(lst_i\)，即 \[lst_i=\max\{j\ |\ j&lt;i,b_j=b_i\}\] 不存在则 \(lst_i=-1\)。 那么区间 \((l,r]\) 合法的条件变为对于所有 \(0\le i\le n\)，满足 \(l &gt; lst_i\) 或 \(r &lt; i\)。 那么我们只要从左往右枚举 \(r\)，那么 \(l\) 需要大于 \(\max\{lst_j\ |\ j \le r\}\)，直接在枚举的同时维护 \(lst\) 数组的前缀 \(\max\) 即可。 代码 12345678910111213141516171819202122232425262728const int N = 200005;int n, lst[N];long long a[N];std::map&lt;long long, int&gt; M;void solve() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); a[i] += a[i - 1]; &#125; for (int i = 0; i &lt;= n; ++i) &#123; // 用 std::map 计算 lst 数组 if (!M.count(a[i])) &#123; lst[i] = -1; &#125; else &#123; lst[i] = M[a[i]]; &#125; M[a[i]] = i; &#125; int mx = -1; long long ans = 0; for (int i = 0; i &lt;= n; ++i) &#123; mx = std::max(mx, lst[i]); ans += i - mx - 1; &#125; print(ans);&#125; D - Challenges in school №41 题目传送门 题解 考场上的我不知道在干什么... 首先我们把 \(\mathtt{R}\) 看成 \(1\)，\(\mathtt{L}\) 看成 \(0\)，那么交换轮数的上界为逆序对数。如果 \(k\) 大于逆序对数，那一定无解。 然后我们考虑求出交换轮数的下界并求出一组解。 由于总交换次数固定，为逆序对数，那么我们只要每一轮贪心地将可以交换的相邻的数对交换即可。 考场上并没有过多的时间证明交换轮数下界的级别，所以代码中我直接使用了 \(\mathtt{set}\) 来快速找到所有需要交换的数对。 在求出达到下界的这一组解后，若 \(k\) 大于这个下界，我们只需要将同一轮中的若干次交换拆成若干轮，直到轮数搞好为 \(k\) 即可。 由于我使用了 \(\mathtt{set}\)，所以复杂度是 \(O(n^2\log n)\) 的，可以通过此题。 另外，可以证明下界一定是 \(O(n)\) 级别的（根据官方题解的下界求法），所以直接每次暴力找可以交换的数对，时间复杂度 \(O(n^2)\)。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const int N = 3005;int n, k, a[N];char s[N];std::set&lt;int&gt; S;std::vector&lt;std::pair&lt;int, int&gt;&gt; move;void solve() &#123; read(n), read(k), readStr(s + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = (s[i] == 'R'); if (i == 1 || a[i] != a[i - 1]) S.insert(i); &#125; S.insert(n + 1); int cnt = 0; while (1) &#123; std::vector&lt;int&gt; p; int x = 1; while (x &lt;= n) &#123; if (a[x] || x == 1) &#123; x = *S.upper_bound(x); continue; &#125; p.push_back(x - 1); std::swap(a[x], a[x - 1]); int tmp = *S.upper_bound(x); if (x &gt; 2 &amp;&amp; !a[x - 2]) &#123; S.erase(x - 1); &#125; else &#123; S.insert(x - 1); &#125; if (!a[x + 1]) &#123; S.insert(x + 1); &#125; x = tmp; &#125; if (p.empty()) &#123; break; &#125; ++cnt; for (int v : p) &#123; move.push_back(&#123;v, cnt&#125;); &#125; &#125; if (k &lt; cnt || k &gt; (int)move.size()) &#123; print(-1); return; &#125; for (int i = (int)move.size() - 1; i &gt;= 1; --i) &#123; move[i].second -= move[i - 1].second; &#125; for (int i = 0; i &lt; (int)move.size(); ++i) &#123; if (move[i].second) &#123; continue; &#125; if (cnt == k) &#123; break; &#125; move[i].second = 1; ++cnt; &#125; std::vector&lt;std::vector&lt;int&gt;&gt; ans(k); int now = 0; for (auto p : move) &#123; now += p.second; // debug("%d %d\n", p.first, p.second); ans[now - 1].push_back(p.first); &#125; for (auto p : ans) &#123; print((int)p.size(), ' '); for (int v : p) &#123; print(v, ' '); &#125; putchar('\n'); &#125;&#125; E - Road to 1600 题目传送门 题解 直接考虑一个很大的棋盘看上去非常难做。我们考虑首先将车和后延一条固定的、相同的路径引导至一个较小的棋盘内。 考虑到 \(n\le 2\) 时一定无解，我们只要将最后的棋盘控制在 \(3\times 3\) 的规模即可。 如何构造一个满足题目条件的 \(3\times 3\) 的棋盘？ 一共只有 \(3\times 3=9\) 个数，我们可以直接暴力枚举所有棋盘！ 注意这个棋盘的最小值所在的格子必须与路径的终点在同一行或同一列，这样才可以保证车和后在这个棋盘中的起点相同。 暴力代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int a[5][5], p[15], vis[5][5];bool rook(int x1, int y1, int x2, int y2) &#123; return x1 == x2 || y1 == y2;&#125;bool queen(int x1, int y1, int x2, int y2) &#123; return x1 == x2 || y1 == y2 || x1 + y1 == x2 + y2 || x1 - y1 == x2 - y2;&#125;template&lt;typename T&gt;int work(T check) &#123; // check 是一个判断两点是否可以互相到达的函数（上方 rook 和 queen 中的一种） int x = 0, y = 0; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; if (a[i][j] == 1) &#123; x = i, y = j; &#125; vis[i][j] = 0; &#125; &#125; vis[x][y] = 1; int res = 0; while (1) &#123; int nx = 0, ny = 0, mn = 10, type = 2; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; if (!vis[i][j]) &#123; int tp = !check(x, y, i, j); if (tp &lt; type || (tp == type &amp;&amp; a[i][j] &lt; mn)) &#123; nx = i, ny = j, mn = a[i][j], type = tp; &#125; &#125; &#125; &#125; if (type == 2) &#123; break; &#125; res += type, x = nx, y = ny, vis[x][y] = 1; &#125; return res;&#125;int main() &#123; for (int i = 1; i &lt;= 9; ++i) &#123; p[i] = i; &#125; while (1) &#123; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; a[i][j] = p[(i - 1) * 3 + j]; &#125; &#125; if (work(rook) &lt; work(queen)) &#123; for (int i = 1; i &lt;= 9; ++i) &#123; print(p[i], ' '); if (i % 3 == 0) &#123; putchar('\n'); &#125; &#125; return 0; &#125; if (!std::next_permutation(p + 1, p + 1 + 9)) &#123; break; &#125; &#125;&#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839const int N = 505;int n, a[N][N];void solve() &#123; read(n); if (n &lt;= 2) &#123; print(-1); return; &#125; int B = n * n - 9; a[1][1] = B + 1, a[1][2] = B + 2, a[1][3] = B + 4; a[2][1] = B + 5, a[2][2] = B + 3, a[2][3] = B + 8; a[3][1] = B + 9, a[3][2] = B + 6, a[3][3] = B + 7; int now = 0; for (int i = 4; i &lt;= n; ++i) &#123; if (i &amp; 1) &#123; for (int j = 1; j &lt;= i; ++j) &#123; a[i][j] = ++now; &#125; for (int j = i - 1; j; --j) &#123; a[j][i] = ++now; &#125; &#125; else &#123; for (int j = 1; j &lt;= i; ++j) &#123; a[j][i] = ++now; &#125; for (int j = i - 1; j; --j) &#123; a[i][j] = ++now; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; print(a[i][j], ' '); &#125; putchar('\n'); &#125;&#125; F - Kate and imperfection 题目传送门 题解 考虑依次求出 \(I_2,I_3,\cdots,I_n\)。 开始时集合大小为 \(1\)，我们强制集合中只包含 \(1\)。我们贪心地往集合内加入元素。 由于我们需要使集合中两两 \(\gcd\) 的最大值最小，一开始我们一定是考虑依次加入所有质数。 加入完所有质数后，我们不可能再保证答案为 \(1\)，我们考虑放宽限制，使得两两 \(\gcd\) 的最大值为 \(2\)。 显然，我们可以加入 \(4=2\times 2\)，但不可以加入 \(6=2\times 3,8=2\times 4,\cdots\)。 然后我们考虑使得最大值为 \(3\)，那么我们可以加入 \(6=2\times 3,9=3\times 3\)，但不能加入 \(12=4\times 3,\cdots\)。 接下来考虑使得最大值为 \(4\)，我们可以加入 \(8=2\times 4\)，可是我们不能加入 \(12=3\times 4\)，因为之前已经加入了 \(6\)。 那么什么时候可以加入 \(12\)？在我们枚举最大值为 \(6\) 时才可以加入 \(12\)。 再往后模拟若干次，大胆猜想，一个数 \(x\) 会在枚举最大值为 \(x\) 的最大真因子（即不等于本身的因子）时被加入集合。 直接使用欧拉筛求出 \(2\) 到 \(n\) 每个数的最大真因子即可。 时间复杂度 \(O(n)\)。 （做题全靠猜结论.jpg） 上述做法的正确性可以参考官方题解。 代码 123456789101112131415161718192021222324252627282930const int N = 500005;int n, c[N];int cnt, p[N], vis[N], minp[N];void solve() &#123; read(n); for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) &#123; p[++cnt] = i; minp[i] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; 1ll * p[j] * i &lt;= n; ++j) &#123; vis[i * p[j]] = 1; minp[i * p[j]] = p[j]; if (i % p[j] == 0) &#123; break; &#125; &#125; &#125; for (int i = 2; i &lt;= n; ++i) &#123; ++c[i / minp[i]]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= c[i]; ++j) &#123; print(i, ' '); &#125; &#125; putchar('\n');&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #630 (Div. 2) 被爆踩记]]></title>
    <url>%2Fcf1332%2F</url>
    <content type="text"><![CDATA[被神仙 Froggy 爆踩了。 A - Exercising Walk 题目传送门 题意 在二维平面上有一个矩形 \((x_1,y_1),(x_2,y_2)\)，你初始在 \((x,y)\)。你被强制规定往左、右、上、下四个方向分别走恰好 \(a,b,c,d\) 步。 你可以任意调整走的顺序。判断是否可以不走出这个矩形。 \(0\le a,b,c,d\le 10^8,-10^8\le x_1\le x\le x_2\le 10^8,-10^8\le y_1\le y\le y_2\le 10^8\)。 题解 如果 \(a+b \ge 1\) 且 \(x_1=x=x_2\)，那么一定不合法。纵坐标同理。 首先因为走的步数是强制规定的，所以我们可以得到终点 \((x_t,y_t)\)。 我们考虑先在原地不断左右来回走，把 \(a,b\) 抵消成只剩一个。然后直接沿着剩下那个的方向走完即可。纵坐标同理。 可以发现，这样走一定能始终保持在 \((x,y)\) 和 \((x_t,y_t)\) 形成的矩形内。 那么我们只要判断 \((x_t,y_t)\) 是否在 \((x_1,y_1),(x_2,y_2)\) 这个矩形内即可。 代码 12345678910int a, b, c, d, x, y, x1, y1, x2, y2;void solve()&#123; read(a), read(b), read(c), read(d); read(x), read(y), read(x1), read(y1), read(x2), read(y2); if ((a || b) &amp;&amp; x1 == x2) return prints("No"), void(0); if ((c || d) &amp;&amp; y1 == y2) return prints("No"), void(0); x = x + b - a, y = y + d - c; if (x1 &lt;= x &amp;&amp; x &lt;= x2 &amp;&amp; y1 &lt;= y &amp;&amp; y &lt;= y2) return prints("Yes"), void(0); prints("No");&#125; B - Composite Coloring 题目传送门 题意 有 \(n\) 个大于 \(1\) 的合数 \(a_i\)，你需要给每个数一个颜色 \(c_i\)，使得对于任意颜色相同的点对 \(i,j\ (i\ne j)\)，满足 \(\gcd(a_i,a_j) &gt; 1\)。 你不需要最小化颜色数，但是你需要保证颜色数不超过 \(11\)，并且每种颜色都出现。 \(1\le n\le 1000,4\le a_i\le 1000\)。 题解 我这个憨批一直把 \(\sqrt{1000}\) 当作 \(300\) 左右在算...我也不知道我在想什么... 事实上，\(\lfloor\sqrt{1000}\rfloor=31\)，这意味着任意 \(a_i\) 都含有一个不超过 \(31\) 的质因子。 而 \(31\) 以内的质数只有 \(11\) 个，分别是 \(2,3,5,7,11,13,17,19,23,29,31\)。 直接求出每个数的最小质因子 \(p_i\) 后，把 \(p_i\) 相同的数颜色染成相同即可。 代码 1234567891011121314151617181920212223const int N = 1005;const int p[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31&#125;;int n, c[N];std::vector&lt;int&gt; b[11];void solve()&#123; read(n); for (register int i = 0; i &lt; 11; ++i) b[i].clear(); for (register int i = 1; i &lt;= n; ++i)&#123; int x; read(x); for (register int j = 0; j &lt; 11; ++j) if (x % p[j] == 0)&#123; b[j].push_back(i); break; &#125; &#125; int cnt = 0; for (register int i = 0; i &lt; 11; ++i) if (b[i].size())&#123; ++cnt; for (int v : b[i]) c[v] = cnt; &#125; print(cnt); for (register int i = 1; i &lt;= n; ++i) print(c[i], ' '); putchar('\n');&#125; C - K-Complete Word 题目传送门 题意 一个长度为 \(n\) 的字符串 \(s\) 被称作 \(k\)-complete 的当且仅当满足以下条件： \(s\) 是回文串，即对于所有 \(1\le i\le n\) 满足 \(s_i=s_{n-i+1}\)； \(s\) 存在一个长度为 \(k\) 的周期，即对于所有 \(1\le i\le n-k\)，满足 \(s_i=s_{i+k}\)。 给定一个长度为 \(n\) 的小写字母串 \(s\) 和正整数 \(k\)，每次可以修改 \(s\) 某个位置的字符，求最少修改次数使得 \(s\) 是 \(k\)-complete 的。 \(1\le k &lt; n\le 2\times 10^5\)，\(n\) 能被 \(k\) 整除。 题解 显然满足条件的 \(s\) 一定是一个长度为 \(k\) 的回文串重复 \(\frac{n}{k}\) 次拼接而成的。 这就意味着，我们可以把 \(s\) 中的所有字符分成若干组，每一组中的字符都要相等。 那么我们只要将每一组的字符都修改成这一组中出现次数最多的那个字符即可。 代码 12345678910111213141516171819const int N = 200005;int n, k;int c[26];char s[N], a[N];void solve()&#123; read(n), read(k), reads(s); for (register int i = 0; i &lt; (k + 1) / 2; ++i)&#123; for (register int j = 0; j &lt; 26; ++j) c[j] = 0; for (register int j = i; j &lt; n; j += k) ++c[s[j] - 'a']; for (register int j = k - i - 1; j &lt; n; j += k) ++c[s[j] - 'a']; char mx = std::max_element(c, c + 26) - c; for (register int j = i; j &lt; n; j += k) a[j] = mx + 'a'; for (register int j = k - i - 1; j &lt; n; j += k) a[j] = mx + 'a'; &#125; int ans = 0; for (register int i = 0; i &lt; n; ++i) ans += a[i] != s[i]; // debug("%s\n", a); print(ans);&#125; D - Walk on Matrix 题目传送门 题意 有一个问题： 给定一个 \(n\times m\) 的矩阵 \(\{a_{i,j}\}\)，求一条从 \((1,1)\) 到 \((n,m)\) 的路径，使得路径上所有数按位与（\(\operatorname{and}\)）的结果最大。 有一个错误的 DP 做法： 请你构造一个满足 \(1\le n,m\le 500,0\le a_{i,j}\le 3\times 10^5\) 的矩阵，使得最优答案与这个错误 DP 得到的答案恰好差 \(k\)。 \(0\le k\le 10^5\)。 题解 我们可以把 \(a_{i,j}=0\) 的位置视为不能经过的点，那么我们只需要构造一个点 \((x,y)\) 使得： 所有 \((1,1)\) 到 \((n,m)\) 的路径必须经过 \((x,y)\)。 \((x,y)\) 到 \((n,m)\) 的路径唯一（为了方便构造）。 记 \(P_1\) 为从 \((1,1)\) 到 \((n,m)\) 的最优路径，\(P_2\) 为从 \((1,1)\) 到 \((x,y)\) 的最优路径加上 \((x,y)\) 到 \((n,m)\) 的唯一路径，需要满足 \(w(P_1)-w(P_2)=k\)。 记 \(P_1\) 为从 \((1,1)\) 到 \((n,m)\) 的最优路径上 \((1,1)\) 到 \((x,y)\) 的路径，\(P_2\) 为从 \((1,1)\) 到 \((x,y)\) 的最优路径，需要满足 \(w(P_1) &lt; w(P_2)\)。 其中 \(w(P)\) 表示路径 \(P\) 上所有数的 \(\operatorname{and}\) 和。 那么构造就非常简单了，我们只要构造矩阵 \[\begin{bmatrix} 2^{18}-1 &amp; 2^{17} \\ k &amp; 2^{18}-1 \\ 0 &amp; k\end{bmatrix}\] 即可满足条件。 代码 12345678int k;void solve()&#123; read(k); print(3, ' '), print(2); print((1 &lt;&lt; 18) - 1, ' '), print(1 &lt;&lt; 17); print(k, ' '), print((1 &lt;&lt; 18) - 1); print(0, ' '), print(k);&#125; E - Height All the Same 题目传送门 题意 考虑一个 \(n\times m\) 的矩阵 \(\{a_{i,j}\}\)，每次可以执行两种操作中的一种： 把相邻两个元素分别加 \(1\)。 将某个元素加 \(2\); 我们称这个矩阵是好的当且仅当你可以通过若干次操作使得所有元素相等。 给定 \(n,m,l,r\)，求满足 \(l\le a_{i,j}\le r\) 的好的矩阵数量。 \(1\le n,m\le 10^9,1\le l\le r\le 10^9\)。 题解 当整个矩阵的奇偶性相同时，我们只要用若干次 \(2\) 操作调整即可。 \(1\) 操作相当于改变了相邻两个元素的奇偶性。对于任意两个元素，我们可以将这两个元素路径上相邻两个元素执行 \(1\) 操作，就可以改变这两个元素的奇偶性而不改变其他元素的奇偶性。 那么我们只需要使得初始矩阵奇数数量或偶数数量为偶数即可。问题得到了转化。 现在需要解决的问题是： 有 \(n\) 个数，每个数有 \(p\) 的概率是奇数，\(1-p\) 的概率是偶数。记 \(n_0\) 为这 \(n\) 个数中偶数的数量，\(n_1\) 为奇数的数量，求满足 \(n_0\) 或 \(n_1\) 至少有一个是偶数的概率。 因为有 \(n_0+n_1=n\)，所以当 \(n\) 是奇数时，\(n_0,n_1\) 的奇偶性不相同，一定有一个偶数，所以概率为 \(1\)。 否则，\(n_0,n_1\) 奇偶性相同，我们只需要计算 \(n_1\) 为偶数时的概率。 答案式子为 \[ \begin{aligned} f_n &amp;=\sum_{i=0}^{\lfloor\frac{n}{2}\rfloor} \begin{pmatrix} n \\ 2i \end{pmatrix} p^{2i} (1-p)^{n-2i} \\ &amp;=(1-p)\sum_{i=0}^{\lfloor\frac{n}{2}\rfloor} \left(\begin{pmatrix} n-1 \\ 2i \end{pmatrix}+\begin{pmatrix} n-1 \\ 2i-1 \end{pmatrix}\right) p^{2i} (1-p)^{(n-1)-2i} \\ &amp;=(1-p)\left(\sum_{i=0}^{\lfloor\frac{n-1}{2}\rfloor} \begin{pmatrix} n-1 \\ 2i \end{pmatrix}p^{2i}(1-p)^{(n-1)-2i} + \frac{p}{1-p} \sum_{i=1}^{\lfloor\frac{n}{2}\rfloor} \begin{pmatrix} n-1 \\ 2i-1 \end{pmatrix}p^{2i-1}(1-p)^{(n-1)-(2i-1)}\right) \\ &amp;=(1-p)\left(f_{n-1}+\frac{p}{1-p}\left(-f_{n-1}+\sum_{i=0}^{n-1} \begin{pmatrix} n-1 \\ i \end{pmatrix} p^i (1-p)^{(n-1)-i}\right) \right) \\ &amp;=(1-p)(f_{n-1}+\frac{p}{1-p}(-f_{n-1}+(p+(1-p))^{n-1})) \\ &amp;=(1-2p)f_{n-1}+p \end{aligned} \] 用特征方程或者错位相减等方法，化简后可以得到 \(f_n\) 的通项公式 \[f_n=\frac{1+(1-2p)^n}{2}\] 注意到模数为 \(998\,244\,353\)，而 \(l,r\) 的范围是 \(10^9\)，在算 \(p\) 时可能会出现 \(r-l+1\) 没有逆元的情况。一种解决方案是将 \(p\) 写成 \(\frac{c}{r-l+1}\) 的形式，将最后的 \((r-l+1)^n\) 乘进去后化简，可以去掉分母中的 \(r-l+1\)。 代码 12345678910111213const int P = 998244353, Inv2 = (P + 1) &gt;&gt; 1;int n, m, l, r;int qpow(int a, long long b)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if (b &amp; 1) s = 1ll * s * a % P; return s;&#125;void solve()&#123; read(n), read(m), read(l), read(r); if (1ll * n * m % 2 == 1) return print(qpow(r - l + 1, 1ll * n * m)), void(0); if ((r - l + 1) &amp; 1) return print(1ll * (qpow(r - l + 1, 1ll * n * m) + 1) * Inv2 % P), void(0); else return print(1ll * qpow(r - l + 1, 1ll * n * m) * Inv2 % P), void(0);&#125; F - Independent Set 题目传送门 题意 对于一个无向图 \(G=(V,E)\)，一个独立集是一个 \(V\) 的子集 \(V&#39;\)，满足对于所有 \(u,v\in V&#39;\)，有 \((u,v)\not\in E\)。 一个边导出子图是由边集 \(E\) 的一个子集 \(E&#39;\) 以及所有在 \(E&#39;\) 的边中出现至少一次的点组成的。 给定一棵树 \(G=(V,E)\)，我们定义 \(G[E&#39;]\) 表示边集为 \(E&#39;\) 时 \(G\) 的边导出子图，\(w(G)\) 表示图 \(G\) 的独立集数量。求 \[\sum_{E&#39;\subset E, E&#39;\ne \varnothing} w(G[E&#39;])\] \(n\le 3\times 10^5\)，答案对 \(998\,244\,353\) 取模。 题解 对于一棵树求独立集数量，这个问题可以用简单的 DP 解决。 在这个问题中，无非就是多了另外一个决策——断边。我们仍然考虑使用 DP 去解决这个问题。首先我们强制以 \(1\) 为根。 设 \(f_{u,0/1,0/1}\) 表示以 \(u\) 为根的子树，\(u\) 与父亲的边在/不在边导出子图内，\(u\) 在/不在独立集内时的方案数。转移如下： \[ \begin{aligned} f_{u,1,1} &amp;= \prod_{v\in \operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1}+f_{v,1,0}) \\ f_{u,1,0} &amp;= \prod_{v\in \operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1}+f_{v,1,0}+f_{v,1,1}) \\ f_{u,0,1} &amp;= \prod_{v\in \operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1}+f_{v,1,0}) - \prod_{v\in \operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1})\\ f_{u,0,0} &amp;= \prod_{v\in \operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1}+f_{v,1,0}+f_{v,1,1}) \end{aligned} \] 当 \(u\) 的连边都不在边导出子图内时也是合法的，但是此时 \(u\) 不能选在独立集内，所以 \(f_{u,0,1}\) 的转移需要减去所有与儿子的边都不在子图内的情况，而 \(f_{u,0,0}\) 不需要减。 最后答案即为 \(f_{1,0,0}+f_{1,0,1}-1\)（减 \(1\) 是减去边集为空的情况）。 时间复杂度 \(O(n)\)。 代码 12345678910111213141516171819202122232425const int N = 300005, P = 998244353;int n;std::vector&lt;int&gt; E[N];int f[N][2][2];void dfs(int u, int fa = 0)&#123; int mul = 1; f[u][1][0] = f[u][1][1] = 1; for (int v : E[u]) if (v != fa)&#123; dfs(v, u); f[u][1][0] = 1ll * f[u][1][0] * (0ll + f[v][0][0] + f[v][0][1] + f[v][1][0] + f[v][1][1]) % P; f[u][1][1] = 1ll * f[u][1][1] * (0ll + f[v][0][0] + f[v][0][1] + f[v][1][0]) % P; mul = 1ll * mul * (0ll + f[v][0][0] + f[v][0][1]) % P; &#125; f[u][0][1] = (f[u][1][1] - mul + P) % P; f[u][0][0] = f[u][1][0];&#125;void solve()&#123; read(n); for (register int i = 1; i &lt;= n; ++i) E[i].clear(); for (register int i = 1, u, v; i &lt; n; ++i) read(u), read(v), E[u].push_back(v), E[v].push_back(u); dfs(1); print((0ll + f[1][0][0] + f[1][0][1] + P - 1) % P);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
        <tag>数学</tag>
        <tag>容斥原理</tag>
        <tag>模拟</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个镜像]]></title>
    <url>%2Fmirror%2F</url>
    <content type="text"><![CDATA[由于最近 GitHub 遭到多次攻击，国内经常上不去 GitHub Pages，且 GitHub 加载较慢，所以在 Gitee 上搭了一个镜像站，尽量做到实时同步（因为 Gitee Pages 需要手动部署）。 GitHub Pages 链接 Gitee Pages 链接]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 84 (Rated for Div. 2) 自闭记]]></title>
    <url>%2Fcf1327%2F</url>
    <content type="text"><![CDATA[自闭了。 A - Sum of Odd Integers 题目传送门 题解 首先，我们尝试取出最小的 \(k\) 个正奇数：\(1,3,5,7,\cdots,2k-1\)。 这些奇数的和为 \(\frac{(1+2k-1)k}{2}=k^2\)。 那么我们如何构造才能使得 \(k\) 个奇数互不相同且和为 \(n\) 呢？ 只要不断将最大的奇数加 \(2\) 即可。 所以当 \(n-k^2\) 是大于等于 \(0\) 的偶数时，一定能够构造出解。 而当 \(n &lt; k^2\) 时，最小的 \(k\) 个正奇数的和已经有 \(k^2\)，那么一定不能构造出解。 当 \(n-k^2\) 不为偶数时，由于任意 \(k\) 个奇数一定可以通过最小的 \(k\) 个正奇数中的数 \(+2,-2\) 得到，所以任意 \(k\) 个奇数的和一定与 \(k^2\) 的奇偶性相同，而 \(n\) 的奇偶性与 \(k^2\) 不同，所以一定不能构造出解。 所以「\(n-k^2\) 是大于等于 \(0\) 的偶数」是能构造出解的充要条件。 注意计算 \(k^2\) 时要开 long long。另外，\(k\) 与 \(k^2\) 的奇偶性一定是相同的，所以我们判断 \(n\) 与 \(k^2\) 的奇偶性是否相同只需要判断 \(n\) 与 \(k\) 的奇偶性是否相同。 代码 123456int n, k;void solve()&#123; read(n), read(k); if ((n &amp; 1) == (k &amp; 1) &amp;&amp; 1ll * k * k &lt;= n) prints("YES"); else prints("NO");&#125; B - Princesses and Princes 题目传送门 题解 我这个彩笔又看错题了... 题目里说只要能够增加就行...而我以为要取增加最多的方案... 那么只要模拟一遍以后，如果存在一个没有匹配的公主，任选一个王子与她匹配即可。 如果需要「增加最多」，这样构造是否正确呢 QAQ 有没有神仙来证明一下或者给出一个反例啊 QAQ 代码 123456789101112131415161718192021222324252627const int N = 100005;int n, vis[N];std::vector&lt;int&gt; E[N];void solve()&#123; read(n); for (register int i = 1; i &lt;= n; ++i) vis[i] = 0, E[i].clear(); for (register int i = 1, k; i &lt;= n; ++i)&#123; read(k); for (register int j = 0, x; j &lt; k; ++j) read(x), E[i].push_back(x); &#125; int add_x = 0, add_y = 0; for (register int i = 1; i &lt;= n; ++i)&#123; bool flag = 0; for (register int j = 0; j &lt; (int)E[i].size(); ++j) if (!vis[E[i][j]])&#123; vis[E[i][j]] = 1, flag = 1; break; &#125; if (flag || add_x) continue; add_x = i; &#125; if (!add_x) prints("OPTIMAL"); else&#123; add_y = n; while (vis[add_y]) --add_y; prints("IMPROVE"), print(add_x, ' '), print(add_y); &#125;&#125; C - Game with Chips 题目传送门 题解 考场上的我甚至想过把坐标旋转 \(x,y\) 独立等等奇怪的玩意。 在想这东西的时候，发现这东西是有边界的，而且到边界他就不会继续走了。 于是我不会了。 转念一想，既然可以走 \(2nm\) 步，好像直接把所有点移到 \((1,1)\)，然后把所有点走一遍就好了！ 移到 \((1,1)\) 需要 \(n+m-2\) 步，遍历所有点需要 \(nm-1\) 步，步数显然是不超过 \(2nm\) 的。 代码里移动到 \((1,1)\) 用了 \(n+m\) 步。 代码 1234567891011121314int n, m, k;void solve()&#123; read(n), read(m), read(k); for (register int i = 1, x, y; i &lt;= k; ++i) read(x), read(y); for (register int i = 1, x, y; i &lt;= k; ++i) read(x), read(y); print(n + m + n * m - 1); for (register int i = 1; i &lt;= n; ++i) putchar('U'); for (register int i = 1; i &lt;= m; ++i) putchar('L'); for (register int i = 1; i &lt;= n; ++i)&#123; for (register int j = 1; j &lt; m; ++j) putchar(i &amp; 1 ? 'R' : 'L'); if (i &lt; n) putchar('D'); &#125; putchar('\n');&#125; D - Infinite Path 题目传送门 题解 首先看到一个排列求 \(k\) 次幂，容易想到将排列看成若干置换环的形式。 如排列 \(p=\{2,4,1,3,6,5\}\) 可以看成： 12341 --&gt; 2^ || v3 &lt;-- 4 以及 15 &lt;&#x3D;&#x3D;&gt; 6 两个置换环。 将一个排列求 \(k\) 次幂以后，某个点 \(i\) 会重新指向原来环上从 \(i\) 开始第 \(k\) 个点。 那么由于我们只需要一个环满足颜色相等，容易想到将每个环单独处理以后取 \(\min\) 即可。 对于一个环长为 \(l\) 的环，我们将环上的点从某个点开始重新标号。我们判断一个 \(k\) 是否可行，只需要记 \(p=\gcd(k,l)\)，我们判断是否存在一个 \(0\le t &lt; p\) 使得环上所有模 \(p\) 等于 \(t\) 的点颜色是否相同即可。 那么显然只要枚举所有 \(l\) 的因数 \(k\) 即可。 时间复杂度 \(O(n\sqrt{n})\)。 代码 123456789101112131415161718192021222324252627282930313233343536const int N = 200005;int n, p[N], c[N], vis[N];int solve(std::vector&lt;int&gt; &amp;a)&#123; std::vector&lt;int&gt; d; int l = a.size(); for (register int i = 1; 1ll * i * i &lt;= l; ++i) // 求因数 if (l % i == 0)&#123; d.push_back(i); if (i * i &lt; l) d.push_back(l / i); &#125; std::sort(d.begin(), d.end()); for (int k : d)&#123; // 枚举 k for (register int i = 0; i &lt; k; ++i)&#123; bool flag = 1; for (register int j = i; j &lt; l; j += k) flag &amp;= a[j] == a[i]; // 判断颜色是否相同 if (flag) return k; &#125; &#125; return l;&#125;void solve()&#123; read(n); for (register int i = 1; i &lt;= n; ++i) read(p[i]), vis[i] = 0; for (register int i = 1; i &lt;= n; ++i) read(c[i]); int ans = n; for (register int i = 1; i &lt;= n; ++i) if (!vis[i])&#123; std::vector&lt;int&gt; tmp; tmp.push_back(c[i]), vis[i] = 1; for (register int j = p[i]; j != i; j = p[j]) tmp.push_back(c[j]), vis[j] = 1; ans = std::min(ans, solve(tmp)); &#125; print(ans);&#125; E - Count The Blocks 题目传送门 题解 设答案为 \(g_i\)，考虑计算出 \(f_i=\sum\limits_{j=i}^{n} (j-i+1)g_j\)，根据 \(f_i\) 的实际意义，显然有 \(f_i=(n-i+1)\times 10^{n-i+1}\)。 根据容斥，可以得到 \(g_i=f_i-2f_{i-1}+f_{i-2}\)。这个式子的正确性也可以将 \(f_i\) 的定义式子代入证明。 代码 1234567891011121314151617const int N = 200005, P = 998244353;int n, f[N];void inc(int &amp;a, int b)&#123; (a += b) &gt;= P ? a -= P : 0; &#125;void dec(int &amp;a, int b)&#123; a &lt; b ? a += P - b : a -= b; &#125;void solve()&#123; read(n); int pw = 10; for (register int i = n; i; --i)&#123; f[i] = 1ll * pw * (n - i + 1) % P; pw = 10ll * pw % P; &#125; for (register int i = 1; i &lt;= n; ++i)&#123; dec(f[i], f[i + 1]), dec(f[i], f[i + 1]), inc(f[i], f[i + 2]); print(f[i], ' '); &#125; putchar('\n');&#125; F - AND Segments 题目传送门 题解 不错，最后 5min 开始写代码，没调出来，直接死在这题上了。 上面是一个菜鸡 xjb BB，不要管他。 首先看到这题，一看是位运算，先考虑每位是否独立。 因为只有 and 运算的限制，所以很显然每一位是独立的。那么我们只需要求出每一位满足限制的方案数，然后乘起来即可。 对于当前位，有若干个限制，每个限制规定了一个区间的 and 和是 \(0\) 还是 \(1\)。 对于限制为 \(1\) 的区间，直接强制每一位必须填 \(1\)。而对于限制为 \(0\) 的区间，看上去非常难搞。 一开始我以为可以容斥，但是若干区间取并这玩意非常难处理。 突然想到了联赛前的一道作业题：P4229 某位歌姬的故事。 那题由于需要离散，并且限制比较宽，所以 DP 是 \(O(nq)\) 的。 然而这题不需要离散，并且只有 \(0\) 和 \(1\)，所以我们尝试去优化这个 DP。 预处理 \(\operatorname{pos}[i]\) 表示 \(i\) 之前（不包括 \(i\)）第一个 \(0\) 至少填在 \(\operatorname{pos}[i]\) 位置。这个预处理可以参考 P4229 中的预处理。 考虑 DP，\(f[i][j]\) 表示前 \(i\) 位，最后一个 \(0\) 的位置为 \(j\) 时满足限制的方案数。分三种情况进行转移： \(j&lt;\operatorname{pos}[i]\) 时，有 \(f[i][j]=0\)； \(\operatorname{pos}[i]\le j &lt; i\) 时，有 \(f[i][j]=f[i-1][j]\)； \(j=i\) 时，若根据 \(1\) 的限制，第 \(i\) 位强制选 \(1\)，那么 \(f[i][j]=0\)；否则 \(f[i][j]=\sum\limits_{k=\operatorname{pos}[i]}^{i-1} f[i-1][k]\)。 对于第一种情况，我们只需要维护一个最左边不为 \(0\) 的指针，每次把 \(&lt; \operatorname{pos}[i]\) 的位置刷成 \(0\) 即可。 对于第二种情况，由于没有任何改变，所以我们不需要进行任何处理。 对于第三种情况，我们只要单点修改第 \(i\) 个位置的值即可。注意需要实时维护当前行的和。 于是这个 DP 的复杂度变成了 \(O(n)\)。 每一位预处理复杂度为 \(O(m)\)，所以总时间复杂度 \(O(k(n+m))\)。 我的做法好像比官方题解的做法复杂一万倍。 另：这题跟绍一新生考试的 F 好像差不多... 代码 12345678910111213141516171819202122232425262728const int N = 500005, P = 998244353;int n, k, m, a[N], l[N], r[N], x[N], f[N], pos[N];void inc(int &amp;a, int b)&#123; (a += b) &gt;= P ? a -= P : 0; &#125;void dec(int &amp;a, int b)&#123; a &lt; b ? a += P - b : a -= b; &#125;void solve()&#123; read(n), read(k), read(m); for (register int i = 1; i &lt;= m; ++i) read(l[i]), read(r[i]), ++r[i], read(x[i]); int ans = 1; for (register int p = 0; p &lt; k; ++p)&#123; for (register int i = 1; i &lt;= n + 1; ++i) pos[i] = 0, a[i] = 0; for (register int i = 1; i &lt;= m; ++i) if (x[i] &gt;&gt; p &amp; 1) ++a[l[i]], --a[r[i]]; // 差分实现区间加 else pos[r[i]] = std::max(pos[r[i]], l[i]); for (register int i = 2; i &lt;= n + 1; ++i) a[i] += a[i - 1], pos[i] = std::max(pos[i], pos[i - 1]); // a 预处理第 i 位是否强制选 1 // pos 预处理 i 之前第一个 0 至少选在哪里 for (register int i = 0; i &lt;= n + 1; ++i) f[0] = 0; f[0] = 1; int sum = 1, l = 0; for (register int i = 1; i &lt;= n + 1; ++i)&#123; while (l &lt; pos[i]) dec(sum, f[l]), f[l] = 0, ++l; // 把 &lt; pos[i] 的位置刷成 0 f[i] = a[i] ? 0 : sum, inc(sum, f[i]); // 修改第 i 个位置的 dp 值 &#125; ans = 1ll * ans * f[n + 1] % P; &#125; print(ans);&#125; G - Letters and Question Marks 题目传送门 题解 事实上这个题还是非常简单的。（别问我为什么现场没过 首先可以对所有模式串建个 AC 自动机，每个点的权值就是这个点在 \(fail\) 树上到根路径上所有点对应的字符串的权值和。 如果字符串 \(s\) 已经全部确定，那么我们只要把 \(s\) 在这个自动机上跑一遍，把经过节点的点权累加即可。 但是现在 \(s\) 有若干个字符不确定。我们考虑对于 \(s\) 的每段确定的极大子串，以及 AC 自动机上的点 \(u\)，预处理从 \(u\) 开始，按照这段子串跑，最终跑到的点以及沿路经过的点权和。 然后我们就可以 DP 了。记 \(f_{S,u}\) 表示当前问号的位置用了 \(S\) 这些字符，跑到自动机上的节点 \(u\) 时，最大的权值和。 转移只需要枚举下一个问号填的字符即可。 记 \(n\) 为字符串 \(s\) 的长度，\(m\) 为模式串的长度之和，\(c\) 为字符集大小，则复杂度为 \(O(nm+2^cmc)\)，可以通过本题。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100const long long INF = 0x3f3f3f3f3f3f3f3fll;const int N = 1005, C = 14;int n;char t[N], s[400005];std::pair&lt;int, long long&gt; go[N][C + 1];int bitcnt[1 &lt;&lt; C];long long f[1 &lt;&lt; C][N];struct AC_Automaton&#123; int rt, cnt, trans[N][C], fail[N]; long long w[N]; int new_node()&#123; int u = cnt++; w[u] = 0, fail[u] = -1; for (register int i = 0; i &lt; C; ++i) trans[u][i] = -1; return u; &#125; void init()&#123; cnt = 0, rt = new_node(); &#125; void insert(const std::vector&lt;int&gt; &amp;s, long long _w)&#123; int u = rt; for (register int i = 0; i &lt; (int)s.size(); ++i)&#123; if (trans[u][s[i]] == -1) trans[u][s[i]] = new_node(); u = trans[u][s[i]]; &#125; w[u] += _w; &#125; void build()&#123; std::vector&lt;int&gt; Q; fail[rt] = -1; for (register int i = 0; i &lt; C; ++i) if (~trans[rt][i]) Q.push_back(trans[rt][i]), fail[trans[rt][i]] = rt; else trans[rt][i] = rt; for (register int i = 0; i &lt; (int)Q.size(); ++i)&#123; int u = Q[i]; w[u] += w[fail[u]]; for (register int j = 0; j &lt; C; ++j) if (~trans[u][j]) Q.push_back(trans[u][j]), fail[trans[u][j]] = trans[fail[u]][j]; else trans[u][j] = trans[fail[u]][j]; &#125; &#125; std::pair&lt;int, long long&gt; run(int u, const std::vector&lt;int&gt; &amp;s)&#123; long long sum = 0; for (register int i = 0; i &lt; (int)s.size(); ++i) u = trans[u][s[i]], sum += w[u]; return &#123;u, sum&#125;; &#125;&#125;A;int main()&#123;#ifdef AT_HOME freopen("test.in", "r", stdin); freopen("test.out", "w", stdout);#endif read(n); A.init(); for (register int i = 0; i &lt; n; ++i)&#123; int m = reads(t), w; std::vector&lt;int&gt; tmp; read(w); for (register int j = 0; j &lt; m; ++j) tmp.push_back(t[j] - 'a'); A.insert(tmp, w); &#125; A.build(); int len = reads(s); std::vector&lt;int&gt; tmp; int cnt = 0; for (register int i = 0; i &lt;= len; ++i) if (i == len || s[i] == '?')&#123; for (register int j = 0; j &lt; A.cnt; ++j) go[j][cnt] = A.run(j, tmp); tmp.clear(), ++cnt; &#125; else tmp.push_back(s[i] - 'a'); bitcnt[0] = 0; for (register int i = 1; i &lt; (1 &lt;&lt; C); ++i) bitcnt[i] = bitcnt[i &gt;&gt; 1] + (i &amp; 1); for (register int i = 0; i &lt; (1 &lt;&lt; C); ++i) for (register int j = 0; j &lt; A.cnt; ++j) f[i][j] = -INF; f[0][go[A.rt][0].first] = go[A.rt][0].second; long long ans = -INF; for (register int S = 0; S &lt; (1 &lt;&lt; C); ++S)&#123; int k = bitcnt[S] + 1; if (k == cnt)&#123; for (register int u = 0; u &lt; A.cnt; ++u) ans = std::max(ans, f[S][u]); &#125; if (k &gt;= cnt) continue; for (register int u = 0; u &lt; A.cnt; ++u) if (f[S][u] != -INF)&#123; for (register int i = 0; i &lt; C; ++i) if (!(S &gt;&gt; i &amp; 1))&#123; int v = A.trans[u][i]; int S_ = S | (1 &lt;&lt; i), u_ = go[v][k].first; f[S_][u_] = std::max(f[S_][u_], f[S][u] + A.w[v] + go[v][k].second); &#125; &#125; &#125; print(ans);&#125; 我还是太菜了 /kk]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
        <tag>数学</tag>
        <tag>容斥原理</tag>
        <tag>模拟</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Global Round 7 上 IM 记]]></title>
    <url>%2Fcf1326%2F</url>
    <content type="text"><![CDATA[终于上 IM 了（ A - Bad Ugly Numbers 题目传送门 题解 为什么您们都能想到构造 \(2333\cdots 333\) 啊 QAQ 显然一个能被 \(p\) 整除的数，加或减一个不能被 \(p\) 整除的数后，不能被 \(p\) 整除。 我们考虑 \(777\cdots 777\) 能被 \(7\) 整除，而 \(777\cdots 77x\)（\(x &gt; 0\)）不能被 \(7\) 整除。 又根据小学数学知识，能被 \(4\) 整除的数的特征是最后两位能被 \(4\) 整除，由于 \(74\bmod 4\ne 0\)，所以我们构造 \(777\cdots 774\) 即可。 注意需要特判 \(n=1\)。 代码 1234567int n;void solve()&#123; read(n); if (n == 1) return print(-1), void(0); for (register int i = 1; i &lt; n; ++i) putchar('7'); putchar('4'), putchar('\n');&#125; B - Maximums 题目传送门 题解 由 \(c_i\) 的定义可得 \[\begin{aligned} b_i&amp;=a_i-c_i \\&amp;=a_i-\max\{0,\max\limits_{j=1}^{i-1} a_j\} \end{aligned}\] 移项后可得 \[a_i=b_i+\max\{0,\max\limits_{j=1}^{i-1}a_j\}\] 我们只要在递推的同时维护 \(a_1,a_2,\cdots,a_{i-1}\) 的最大值即可。 时间复杂度 \(O(n)\)。 代码 1234567891011const int N = 200005;int n, a[N];void solve()&#123; read(n); for (register int i = 1; i &lt;= n; ++i) read(a[i]); long long now = 0; for (register int i = 1; i &lt;= n; ++i) if (a[i] &gt; 0) now += a[i], print(now, ' '); else print(now + a[i], ' '); putchar('\n');&#125; C - Permutation Partitions 题目传送门 题解 考场上我看到本题一脸懵逼，我发现我好像不会第一问... 冷静一下，发现显然答案的上界是取最大的 \(k\) 个数，即 \((n-k+1)+(n-k+2)+\cdots+n=\frac{(2n-k+1)k}{2}\)。 我们可以在原排列中标记出这最大的 \(k\) 个数，记从左往右第 \(i\) 个被标记的位置为 \(x_i\)。 我们要把原排列划分成 \(k\) 段意味着我们要找到 \(k-1\) 个分界点，并且我们现在要求两个分界点之间恰好包含一个被标记的数。 那么显然第 \(i\) 个分界点应该选在 \(x_i\) 到 \(x_{i+1}\) 之间。 每个分界点的选择是独立的（即不会影响其他分界点的选择），所以根据乘法原理，把每个分界点的方案数相乘即可。 时间复杂度 \(O(n)\)。 代码 12345678910111213141516const int N = 200005, P = 998244353;int n, k, a[N];void solve()&#123; read(n), read(k); long long sum = 0; int lst = 0, ans = 1; for (register int i = 1; i &lt;= n; ++i)&#123; read(a[i]); if (a[i] &gt; n - k)&#123; sum += a[i]; if (lst) ans = 1ll * ans * (i - lst) % P; lst = i; &#125; &#125; print(sum, ' '), print(ans);&#125; D2 - Prefix-Suffix Palindrome (Hard version) 题目传送门 题解 考场上看到本题的第一想法是枚举前后缀匹配的长度 \(l\)，然后要求从 \(l+1\) 开始的最长回文串或者以 \(n-l\) 结尾的最长回文串。 刚打算去隔壁 最长双回文串 复制一个代码，意识到了不对... 如果求出来的回文串与前后缀有重叠怎么办？ 考虑上面这个想法用暴力怎么实现。在我们将原串中间插入 # 后，用 manacher 算法以 \(i\) 为回文中心的回文半径 \(d_i\)。 然后我们枚举前后缀匹配长度 \(l\)，分两种情况： 对于所有 \(l+1\le i\le \frac{|s|+1}{2}\) 且 \(i-d_i+1\le l+1\)，求出 \(i\) 的最大值； 对于所有 \(\frac{|s|+1}{2}\le i\le n-l\) 且 \(i+d_i-1\ge n-l\)，求出 \(i\) 的最小值。 可以发现，\(l\) 越大，越容易满足限制，越容易使得 \(i\) 取到极值。 所以我们求出最大的 \(l\) 以后用上面的暴力实现即可。 如果你不怕被 hack 的话 manacher 也可以用哈希实现。 时间复杂度 \(O(n)\)。 代码 12345678910111213141516171819202122232425262728293031323334353637383940const int N = 2000005; // 注意数组开大一倍int n, d[N];char s[N];void manacher(int *d, char *s, int n)&#123; for (register int i = 1, m = 0, r = 0; i &lt;= n; ++i)&#123; d[i] = i &gt; r ? 0 : std::min(r - i + 1, d[m - (i - m)]); while (i - d[i] &gt; 0 &amp;&amp; i + d[i] &lt;= n &amp;&amp; s[i - d[i]] == s[i + d[i]]) ++d[i]; if (i + d[i] - 1 &gt; r) m = i, r = i + d[i] - 1; &#125;&#125;void solve()&#123; n = reads(s + 1); for (register int i = n; i; --i) s[i &lt;&lt; 1] = s[i], s[i &lt;&lt; 1 | 1] = '#'; s[1] = '#', n = n * 2 + 1; manacher(d, s, n); // for (register int i = 1; i &lt;= n; ++i) debug("%d ", d[i]); debug("\n"); int len = 0; for (register int i = 1; i &lt;= n / 2; ++i) if (s[i] != s[n - i + 1]) break; else ++len; // debug("%d\n", len); int d1 = 0, d2 = 0; for (register int i = len + 1; i &lt;= (n + 1) / 2; ++i) if (i - d[i] + 1 &lt;= len + 1) d1 = std::max(d1, (i - len) * 2 - 1); for (register int i = (n + 1) / 2; i &lt;= n - len; ++i) if (i + d[i] - 1 &gt;= n - len) d2 = std::max(d2, (n - len - i + 1) * 2 - 1); if (d1 &gt; d2)&#123; for (register int i = 1; i &lt;= len + d1; ++i) if (s[i] != '#') putchar(s[i]); for (register int i = n - len + 1; i &lt;= n; ++i) if (s[i] != '#') putchar(s[i]); &#125; else&#123; for (register int i = 1; i &lt;= len; ++i) if (s[i] != '#') putchar(s[i]); for (register int i = n - len - d2 + 1; i &lt;= n; ++i) if (s[i] != '#') putchar(s[i]); &#125; putchar('\n');&#125; E - Bombs 题目传送门 题解 发现答案单调递减，可以考虑枚举答案 \(x\)。 将 \(&gt; x\)（即必须炸掉的数）的位置置为 \(1\)，炸弹置为 \(-1\)，其他位置置为 \(0\)。 则合法的条件是所有后缀和 \(\le 0\)。 用线段树维护即可。 时间复杂度 \(O(n\log n)\)。 别问我为什么对，感觉挺对的就行了（雾 代码 123456789101112131415161718192021222324252627282930const int N = 300005;int n, p[N], q[N], pos[N];struct Segment_Tree&#123; int mx[N &lt;&lt; 2], lz[N &lt;&lt; 2]; void add(int u, int v)&#123; mx[u] += v, lz[u] += v; &#125; void down(int u)&#123; add(u &lt;&lt; 1, lz[u]), add(u &lt;&lt; 1 | 1, lz[u]), lz[u] = 0; &#125; void modify(int u, int l, int r, int L, int R, int v)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return add(u, v), void(0); int md = (l + r) &gt;&gt; 1; down(u); if (L &lt;= md) modify(u &lt;&lt; 1, l, md, L, R, v); if (R &gt; md) modify(u &lt;&lt; 1 | 1, md + 1, r, L, R, v); mx[u] = std::max(mx[u &lt;&lt; 1], mx[u &lt;&lt; 1 | 1]); &#125;&#125;T;void solve()&#123; read(n); for (register int i = 1; i &lt;= n; ++i) read(p[i]), pos[p[i]] = i; for (register int i = 1; i &lt;= n; ++i) read(q[i]); print(n, ' '); int now = n; T.modify(1, 1, n, 1, pos[n], 1); for (register int i = 1; i &lt; n; ++i)&#123; T.modify(1, 1, n, 1, q[i], -1); while (T.mx[1] &lt;= 0) --now, T.modify(1, 1, n, 1, pos[now], 1); print(now, ' '); &#125;&#125; F1 - Wise Men (Easy Version) 题目传送门 题解 考场上看到 Easy Version \(n\le 14\)，Hard Version \(n\le 18\)，莫名就想到了 meet in middle... 可以预处理出 \(f_{S,T,i}\) 表示当前排列中数的集合为 \(S\)，导出的 01 字符串为 \(T\)，且排列中最后一个数为 \(i\) 的方案数。 然后考虑 meet in middle，合并两边的方案。 问题来了，我好像不会快速合并两边的方案 QAQ 但是问题不大，我们可以 暴力合并！ 直接枚举左边的数集 \(S\)，最后的 01 串 \(T\)，以及中间相邻的两个数，显然方案数可以利用 \(f\) 进行计算。 但是，你可能需要一些卡常技巧（设两边的大小分别为 \(B_1,B_2\)）： \(f\) 数组只需要预处理所有 \(|S|=B_1\) 或 \(|S|=B_2\) 的位置，可以直接枚举所有排列进行统计，不需要进行 DP。 显然 01 串反转以后答案是不变的，所以我们只计算 \(T\le \operatorname{rev}(T)\) 的位置即可。 可以预处理 \(2^n-1,2^{B_1-1}-1,2^{B_2-1}-1\) 的值来减少运算次数。 由于枚举 \(T\) 以后我们可以知道中间相邻两个数是否有边，我们可以预处理出与一个点有边/无边的点来快速枚举。 根据代码常数调整 \(B_1,B_2\) 的大小。 为了保险，你可以再加上 Ofast 和 O3 优化。 理论时间复杂度 \(O(C_{n}^{B_1}(B_1!+B_2!+2^n n^2))\)，事实上有好几个 \(\frac{1}{2}\) 的常数。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445int n, E[14][14], bitcnt[1 &lt;&lt; 14], rev[1 &lt;&lt; 14], p[14], f[1 &lt;&lt; 14][1 &lt;&lt; 6][14];long long ans[1 &lt;&lt; 14];std::vector&lt;int&gt; G[14][2];void solve()&#123; read(n); for (register int i = 0; i &lt; n; ++i) for (register int j = 0; j &lt; n; ++j)&#123; while (!isdigit(E[i][j] = getchar())) ; E[i][j] ^= '0'; G[i][E[i][j]].push_back(j); &#125; bitcnt[0] = 0; for (register int i = 1; i &lt; (1 &lt;&lt; n); ++i) bitcnt[i] = bitcnt[i &gt;&gt; 1] + (i &amp; 1); rev[0] = 0; for (register int i = 1; i &lt; (1 &lt;&lt; (n - 1)); ++i) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; (n - 2); int B1 = n &gt;&gt; 1, B2 = n - B1; for (register int S = 0; S &lt; (1 &lt;&lt; n); ++S) if (bitcnt[S] == B1 || bitcnt[S] == B2)&#123; int cnt = 0; for (register int i = 0; i &lt; n; ++i) if (S &gt;&gt; i &amp; 1) p[cnt++] = i; while (1)&#123; int T = 0; for (register int i = 0; i &lt; cnt - 1; ++i) if (E[p[i]][p[i + 1]]) T |= 1 &lt;&lt; i; ++f[S][T][p[cnt - 1]]; if (!std::next_permutation(p, p + cnt)) break; &#125; &#125; int U = (1 &lt;&lt; n) - 1, U1 = (1 &lt;&lt; (B1 - 1)) - 1, U2 = (1 &lt;&lt; (B2 - 1)) - 1; for (register int S = 0; S &lt; (1 &lt;&lt; n); ++S) if (bitcnt[S] == B1)&#123; for (register int T = 0; T &lt; (1 &lt;&lt; (n - 1)); ++T) if (T &lt;= rev[T])&#123; int T1 = T &amp; U1, T2 = rev[T] &amp; U2, t = (T &gt;&gt; (B1 - 1)) &amp; 1, _S = U ^ S; for (register int i = 0; i &lt; n; ++i) if (f[S][T1][i]) for (int j : G[i][t]) ans[T] += f[S][T1][i] * f[_S][T2][j]; &#125; &#125; for (register int T = 0; T &lt; (1 &lt;&lt; (n - 1)); ++T) if (T &lt;= rev[T]) print(ans[T], ' '); else print(ans[rev[T]], ' '); putchar('\n');&#125; 最后一分钟绝杀的感觉真的非常舒适（ F2 - Wise Men (Hard Version) 题目传送门 来了来了，来填坑了。 题解 发现既有有边又有没边的限制非常难搞，于是我们考虑容斥，即计算 \(ans_A\) 为对于所有 \(A\) 中为 \(1\) 的位置 \(i\)，满足 \(p_i\) 与 \(p_{i+1}\) 有边的排列 \(p\) 的数量（对于 \(0\) 的位置没有限制）。 计算出 \(ans_A\) 后，只要用类似于「逆高维前缀和」的方法，就可以在 \(O(2^nn)\) 求出真正的答案。 考虑如何计算 \(ans_A\)。发现 \(ans_A\) 的值只与 \(A\) 中 \(1\) 连续段的长度形成的可重集合有关。如 \(A=\{0,1,1,1,0,0,1\}\) 时，所有 \(1\) 连续段长度形成的集合就是 \(\{1,1,2,4\}\)（原长加 \(1\)）。 可以发现，对于任意 \(A\)，对应的 \(1\) 连续段长度形成的可重集合中所有元素的和一定恰好为 \(n\)。这意味着不同的集合数量等于 \(n\) 的划分数。 对于一个划分 \(P=\{a_1,a_2,\cdots,a_k\}\)，可以发现对应的方案数实质上是在原图中选出 \(k\) 条不相交的简单路径，满足第 \(i\) 条路径的点数为 \(a_i\) 的方案数。 那么我们先考虑选 \(1\) 条路径。可以用 DP 求出 \(f_{u,S}\) 表示当前在节点 \(u\)，经过的点集为 \(S\) 时的路径条数，进而求出 \(g_S\) 表示经过的点集为 \(S\) 的路径条数。 那么对于一个划分 \(P=\{a_1,a_2,\cdots,a_k\}\)，答案即为 \[\sum_{S_1,S_2,\cdots,S_k} \left[|S_i|=a_i\right]\left[\forall i\ne j:S_i\cap S_j=\varnothing\right]\left[\bigcup\limits_{i=1}^{k}S_i=U\right]\prod\limits_{i=1}^{k} g_{S_i}\] 其中 \(U\) 表示全集。 注意到由于 \(\sum\limits_{i=1}^{k} a_i=n\)，后面两个条件只需要保留一个即可。第二个条件很难处理，我们考虑保留第三个。若不考虑前两个条件，只考虑第三个条件，只需要用 FWT 即可方便地求出答案。 存在第一个条件时，我们只要将 \(g\) 加上一维，\(g_{l,S}\) 表示长度为 \(l\)，经过点集为 \(S\) 的简单路径数量。对于 \(|S|\ne l\) 的位置就置为 \(0\)。那么答案式子变成了 \[\sum_{S_1,S_2,\cdots,S_k} \left[\bigcup\limits_{i=1}^{k}S_i=U\right]\prod\limits_{i=1}^{k} g_{a_i,S_i}\] 直接将所有 \(g_i\) 进行一次 FWT 后，枚举划分时直接点乘。由于我们实际只需要卷积结果中 \(2^n-1\) 位置的值，所以我们不需要每次 IFWT，直接根据实际意义用容斥就可以 \(O(2^n)\) 求出这个值。 总时间复杂度 \(O(2^n(P(n)+n^2))\)，其中 \(P(n)\) 表示 \(n\) 的划分数。 实现得不好可能会变成 \(O(2^n(S(n)+n^2))\) 或 \(O(2^nn(P(n)+n))\)，其中 \(S(n)\) 表示 \(n\) 的所有划分的大小之和。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int n;std::vector&lt;int&gt; bitcnt;std::vector&lt;std::vector&lt;long long&gt;&gt; f;std::vector&lt;std::vector&lt;long long&gt;&gt; g;std::map&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt;&gt; part;std::vector&lt;long long&gt; ans;void dfs(int r, const std::vector&lt;int&gt; &amp;l, const std::vector&lt;long long&gt; &amp;s)&#123; if (!r)&#123; long long res = 0; int mask = (1 &lt;&lt; n) - 1; for (register int i = 0; i &lt; (1 &lt;&lt; n); ++i) if (bitcnt[mask ^ i] &amp; 1) res -= s[i]; else res += s[i]; const std::vector&lt;int&gt; &amp;p = part[l]; for (int v : p) ans[v] += res; return; &#125; int lst = l.empty() ? 1 : l.back(); for (register int k = lst; k &lt;= r; ++k)&#123; if (k &lt; r &amp;&amp; r - k &lt; k) continue; std::vector&lt;int&gt; nl(l); std::vector&lt;long long&gt; ns(s); nl.push_back(k); for (register int i = 0; i &lt; (1 &lt;&lt; n); ++i) ns[i] *= g[k - 1][i]; dfs(r - k, nl, ns); &#125;&#125;void solve()&#123; read(n); std::vector&lt;std::vector&lt;int&gt;&gt; E(n); for (register int i = 0; i &lt; n; ++i) for (register int j = 0; j &lt; n; ++j)&#123; char ch; while (!isdigit(ch = getchar())) ; if (ch == '1') E[i].push_back(j); &#125; bitcnt.resize(1 &lt;&lt; n); bitcnt[0] = 0; for (register int i = 1; i &lt; (1 &lt;&lt; n); ++i) bitcnt[i] = bitcnt[i &gt;&gt; 1] + (i &amp; 1); f.resize(n, std::vector&lt;long long&gt;(1 &lt;&lt; n, 0)); g.resize(n, std::vector&lt;long long&gt;(1 &lt;&lt; n, 0)); for (register int i = 0; i &lt; n; ++i) f[i][1 &lt;&lt; i] = 1; for (register int S = 1; S &lt; (1 &lt;&lt; n); ++S) for (register int i = 0; i &lt; n; ++i) if (f[i][S])&#123; g[bitcnt[S] - 1][S] += f[i][S]; for (int v : E[i]) if (!(S &gt;&gt; v &amp; 1)) f[v][S | (1 &lt;&lt; v)] += f[i][S]; &#125; for (register int k = 0; k &lt; n; ++k) for (register int i = 0; i &lt; n; ++i) for (register int S = 0; S &lt; (1 &lt;&lt; n); ++S) if (S &gt;&gt; i &amp; 1) g[k][S] += g[k][S ^ (1 &lt;&lt; i)]; for (register int S = 0; S &lt; (1 &lt;&lt; (n - 1)); ++S)&#123; std::vector&lt;int&gt; p; int x = 1; for (register int i = 0; i &lt; n - 1; ++i) if (S &gt;&gt; i &amp; 1) ++x; else p.push_back(x), x = 1; p.push_back(x); std::sort(p.begin(), p.end()); part[p].push_back(S); &#125; ans.resize(1 &lt;&lt; (n - 1), 0); dfs(n, std::vector&lt;int&gt;(), std::vector&lt;long long&gt;(1 &lt;&lt; n, 1)); for (register int i = 0; i &lt; n - 1; ++i) for (register int S = 0; S &lt; (1 &lt;&lt; (n - 1)); ++S) if (S &gt;&gt; i &amp; 1) ans[S ^ (1 &lt;&lt; i)] -= ans[S]; for (long long v : ans) print(v, ' '); putchar('\n');&#125; G - Spiderweb Trees 题目传送门 tourist 都没过的题，鸽了鸽了。]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>manacher</tag>
        <tag>线段树</tag>
        <tag>递推</tag>
        <tag>meet in middle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #628 (Div. 2) 爆蛋记]]></title>
    <url>%2Fcf1325%2F</url>
    <content type="text"><![CDATA[完全爆蛋，小号三场上橙无望 /kk 爆蛋链接 A - EhAb AnD gCd 题目传送门 题意 构造正整数 \(a,b\) 满足 \(\gcd(a,b)+\operatorname{lcm}(a,b)=x\)。 \(x\le 10^9\) 题解 构造 \(a=1,b=x-1\) 即可。 代码 12345int x;void solve()&#123; read(x); print(1, ' '), print(x - 1);&#125; B - CopyCopyCopyCopyCopy 题目传送门 题意 求将一个长度为 \(n\) 的序列 \(a\) 复制 \(n\) 次后的 LIS 长度。 \(n\le 10^5\) 题解 显然最优方案是在复制的第一份中选最小值，第二份中选次小值…… 所以 LIS 长度就是所有数去重后的数量。 代码 1234567int n, a[100005];void solve()&#123; read(n); for (register int i = 1; i &lt;= n; ++i) read(a[i]); std::sort(a + 1, a + 1 + n); print(std::unique(a + 1, a + 1 + n) - a - 1);&#125; C - Ehab and Path-etic MEXs 题目传送门 题意 给定一棵 \(n\) 个点的树，你需要给每条边定上互不相同的 \(0\sim n-2\) 的整数权值，使得 \(\max\limits_{u,v} \operatorname{mex}(\operatorname{path}(u,v))\) 最小。\(\operatorname{path}(u,v)\) 表示 \(u\) 到 \(v\) 路径上所有边边权组成的集合。 \(n\le 10^5\) 题解 对于 \(n&gt;2\) 时，我们始终可以找到一条包含 \(0,1\) 的路径，所以有答案 \(\ge 2\)。 我们只要找到一个度数 \(\ge 3\) 的点，把 \(0,1,2\) 放在这个点连出去的边中，就可以保证不存在某条路径同时包含 \(0,1,2\)，即达到了答案的下界。 若没有度数 \(\ge 3\) 的点，此时树的形态是一条链，答案显然为 \(n-1\)，任意构造即可。 代码 考场上想复杂了，尝试以某个叶子节点为根以后去考虑 \(0,1,2\) 的放置，于是罚时罚没了（成功搞炸心态）。 12345678910111213141516171819202122232425const int N = 100005;int n, ans[N];std::vector&lt;std::pair&lt;int, int&gt;&gt; E[N];void solve()&#123; read(n); for (register int i = 0, u, v; i &lt; n - 1; ++i) read(u), read(v), E[u].push_back(&#123;v, i&#125;), E[v].push_back(&#123;u, i&#125;), ans[i] = -1; int id = 0, cnt = 0; for (register int i = 1; i &lt;= n; ++i) if (E[i].size() == 1) ++cnt, id = i; if (cnt == 2)&#123; for (register int i = 0; i &lt; n - 1; ++i) print(i); return; &#125; ans[E[id][0].second] = 0; int u = E[id][0].first, lst = id, now = 0; while (E[u].size() == 2)&#123; int v = E[u][0].first ^ E[u][1].first ^ lst; lst = u, u = v; &#125; for (auto p : E[u]) if (p.first != lst) ans[p.second] = ++now; for (register int i = 0; i &lt; n - 1; ++i) if (ans[i] == -1) ans[i] = ++now; for (register int i = 0; i &lt; n - 1; ++i) print(ans[i]);&#125; D - Ehab the Xorcist 题目传送门 题意 构造一个最短的序列使得异或和为 \(u\)，和为 \(v\)。 \(u,v\le 10^{18}\) 题解 考场上尝试从高位到低位逐位构造，但是他先 WA9 然后 WA18 了。 神仙 Froggy 告诉我本题考查了 if 语句。 我离当场去世真的只差一点.jpg 代码 123456789101112long long u, v;void solve()&#123; read(u), read(v); if (v &lt; u || (v - u) &amp; 1) return print(-1), void(0); if (u == 0)&#123; if (v == 0) return print(0), void(0); else return print(2), print(v &gt;&gt; 1, ' '), print(v &gt;&gt; 1), void(0); &#125; if (u == v) return print(1), print(u), void(0); if (u &amp; ((v - u) &gt;&gt; 1)) return print(3), print(u, ' '), print((v - u) &gt;&gt; 1), print((v - u) &gt;&gt; 1), void(0); else return print(2), print(u + ((v - u) &gt;&gt; 1), ' '), print((v - u) &gt;&gt; 1), void(0);&#125; E - Ehab's REAL Number Theory Problem 题目传送门 题意 给定一个长度为 \(n\) 的序列 \(a\)，求出所有乘积为完全平方数的子序列（可以不连续）的最短长度。 保证 \(a_i\) 的因数个数不超过 \(7\)。 \(n\le 10^5,a_i\le 10^6\) 题解 由于包含三个不同质因子的数至少有 \((1+1)^3=8\) 个因数，所以因数个数不超过 \(7\) 说明不同质因子数量不超过 \(2\)。 并且，我们可以去掉 \(a_i\) 中包含的完全平方因子，这样处理后 \(a_i\) 只会包含至多两个次数为 \(1\) 的质因子。 于是我们可以把 \(a_i\) 表示成 \(p\times q\) 的形式，其中 \(p,q\) 为质数或 \(1\)。我们把这样的 \(a_i\) 看成一条连接 \(p,q\) 的无向边。 现在问题是在这样得到的图中选择最少数量的边（至少一条），使得只保留这些边后图中每个点的度数为偶数。 显然存在度数 \(&gt;2\) 的点是不优的，所以我们可以强制最后每个点的度数为 \(2\)（不考虑度数为 \(0\) 的点）。 这意味着我们要求新图的最小环。 考场上被人误导想了一个假算法，就是把 \(&gt;1000\) 的点扔掉，直接在他连的点之间互相连边以后跑 Floyd。 但是显然这样做是错的，会导致一个数被选多次。 考场上只想到了上面部分，于是当场去世了。 我们需要求出一个无向图的最小环。那么我们考虑枚举一个点 \(s\) 以及一条边 \((u,v)\)，得到以 \(s\) 为起点的最短路树，求出包含点 \(s\) 和非树边 \((u,v)\) 的最小环。 考虑最短路树上加入 \((u,v)\)，我们得到了一个包含 \((u,v)\) 但有可能不包含 \(s\) 的环。 可以发现，我们直接用 \(\operatorname{dist}(s,u)+\operatorname{dist}(s,v)\) 更新答案一定是对的，因为如果上面得到的环不包含 \(s\)，一定会在枚举其他起点时被计算入答案，并且一定优于 \(\operatorname{dist}(s,u)+\operatorname{dist}(s,v)\)，所以我们并不需要判断这个环是否包含 \(s\)。 我们仍然需要考虑的是上述算法是否能覆盖到最优解。考虑最优解环上任意一个点 \(s\)，环上一定存在一条边 \((u,v)\) 不在以 \(s\) 为起点形成的最短路树上。如果 \(u,v\) 在这棵树上的 LCA 不是 \(s\)，说明存在一个更小的环，与假设矛盾；否则此时 \(\operatorname{dist}(s,u)+\operatorname{dist}(s,v)\) 一定就是最优解的环长。由于我们枚举了所有 \(s,u,v\)，所以一定能覆盖到最优解。 然而上面的算法是 \(O(nm)\) 的。 设 \(m=\max \{a_i\}\)，可以发现我们需要求最小环的图与一般的图有一个很大的区别是，两个点 \(u,v\) 若 \(uv&gt;m\) 是不可能有边的，所以一定不会存在 \(u,v&gt;\sqrt{m}\) 的连边。 那么显然一个环内至少存在一个点的编号是 \(\le \sqrt{m}\) 的。根据上面算法能覆盖到最优解的证明过程，我们只要能够枚举到环上任意一个点作为 \(s\) 就可以覆盖到这个环。所以，我们只要将上面求最小环的算法中 \(s\) 的枚举范围缩小到 \(\sqrt{m}\) 即可。 时间复杂度根据实现为 \(O(n\frac{\sqrt{m}}{\log m})\) 或 \(O((n+\frac{m}{\log m})\frac{\sqrt{m}}{\log m})\)。 除以 \(\log m\) 是因为只需要考虑质数。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const int N = 1000005, M = 100005, INF = 0x3f3f3f3f;int n;int cnt, p[N], vis[N];void init(int n)&#123; // 欧拉筛预处理所有质数 for (register int i = 2; i &lt;= n; ++i)&#123; if (!vis[i]) p[++cnt] = i, vis[i] = cnt; for (register int j = 1; j &lt;= cnt &amp;&amp; p[j] * i &lt;= n; ++j)&#123; vis[p[j] * i] = 1; if (i % p[j] == 0) break; &#125; &#125;&#125;std::vector&lt;int&gt; v[M];std::vector&lt;std::pair&lt;int, int&gt;&gt; E[N];int ans, ont[M], tim[N], dis[N];void bfs(int S)&#123; // bfs 求出最短路树 for (register int i = 1; i &lt;= n; ++i) ont[i] = 0; std::vector&lt;int&gt; Q; Q.push_back(S), tim[S] = S, dis[S] = 0; // 将 tim 置为每次 bfs 的起点，可以避免每次需要重置 dis 数组导致复杂度变劣 for (register int i = 0; i &lt; (int)Q.size(); ++i)&#123; int u = Q[i]; for (auto p : E[u])&#123; int v = p.first, eid = p.second; if (tim[v] != S) Q.push_back(v), tim[v] = S, dis[v] = dis[u] + 1, ont[eid] = 1; &#125; &#125; for (register int i = 1; i &lt;= n; ++i) // 枚举每条非树边，更新答案 if (!ont[i] &amp;&amp; tim[v[i][0]] == S &amp;&amp; tim[v[i][1]] == S) ans = std::min(ans, dis[v[i][0]] + dis[v[i][1]] + 1);&#125;void solve()&#123; read(n); init(1000000), p[0] = 1, vis[1] = 0; for (register int i = 1, x; i &lt;= n; ++i)&#123; read(x); for (register int j = 1; j &lt;= cnt &amp;&amp; 1ll * p[j] * p[j] &lt;= x; ++j) if (x % p[j] == 0)&#123; int k = 0; while (x % p[j] == 0) x /= p[j], k ^= 1; if (k) v[i].push_back(j); &#125; if (x &gt; 1) v[i].push_back(vis[x]); while (v[i].size() &lt; 2) v[i].push_back(0); E[v[i][1]].push_back(&#123;v[i][0], i&#125;), E[v[i][0]].push_back(&#123;v[i][1], i&#125;); // 连边 &#125; for (register int i = 0; i &lt;= cnt; ++i) tim[i] = -1; ans = INF; for (register int i = 0; i &lt;= cnt; ++i) if (p[i] &lt;= 1000) bfs(i); else break; // 只需要考虑编号 &lt;=1000 且为质数的点 if (ans == INF) print(-1); else print(ans);&#125; F - Ehab's Last Theorem 题目传送门 咕咕咕...]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>BFS</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相关]]></title>
    <url>%2Fpolynomial-notes%2F</url>
    <content type="text"><![CDATA[太久没更新博客，开一篇多项式相关的博客记一下多项式的一些基础操作吧。 模域下的运算 12345678910void inc(unsigned &amp;a, const unsigned &amp;b)&#123; (a += b) &gt;= P ? a -= P : 0; &#125;void dec(unsigned &amp;a, const unsigned &amp;b)&#123; a &lt; b ? a += P - b : a -= b; &#125;unsigned plus(const unsigned &amp;a, const unsigned &amp;b)&#123; return a + b &gt;= P ? a + b - P : a + b; &#125;unsigned minus(const unsigned &amp;a, const unsigned &amp;b)&#123; return a &lt; b ? a + P - b : a - b; &#125;unsigned mul(const unsigned &amp;a, const unsigned &amp;b)&#123; return static_cast&lt;unsigned long long&gt;(a) * b % P; &#125;unsigned qpow(unsigned a, unsigned b)&#123; unsigned s = 1; for (; b; b &gt;&gt;= 1, a = mul(a, a)) if (b &amp; 1) s = mul(s, a); return s;&#125; 快速傅里叶变换与快速傅里叶逆变换 快速傅里叶变换 在这一节中，除特殊说明外，\(n\) 是 \(2\) 的幂次。 利用 FFT，我们可以在 \(O(n\log n)\) 的时间内求出 \(F(\omega_n^0),F(\omega_n^1),\cdots,F(\omega_n^{n-1})\) 的值，以及由这些值得到 \(F(x)\) 的系数，其中 \(\omega_n^{i}\) 表示单位根，这里不具体展开。 单位根具有一些优美的性质，如 \(\omega_{dn}^{dk}=\omega_n^k\)，\(\omega_{n}^{\frac{n}{2}}=\omega_2^1=-1\)，\(\omega_{n}^{k+\frac{n}{2}}=-\omega_{n}^{k}\)，\(\omega_n^a=\omega_n^{a \bmod n}\)。FFT 正是利用了这些性质加快速度。 假设原多项式为\(F(x)=\sum\limits_{i=0}^{n-1} f_ix^i\)，我们把 \(F(x)\) 按指数奇偶性拆成两部分，即 \(F_0(x)=\sum\limits_{i=0}^{\frac{n}{2}-1} f_{2i}x^i,F_1(x)=\sum\limits_{i=0}^{\frac{n}{2}-1} f_{2i+1}x^i\)，那么有 \(F(x)=F_0(x^2)+xF_1(x^2)\)。 我们把 \(x=\omega_n^k\ (0\le k &lt; \frac{n}{2})\) 代入 \(F(x)\)，得到 \(F(\omega_n^k)=F_0(\omega_{\frac{n}{2}}^k)+\omega_n^kF_1(\omega_{\frac{n}{2}}^k)\)。 同理，把 \(x=\omega_n^{k+\frac{n}{2}}\ (0\le k &lt; \frac{n}{2})\) 代入 \(F(x)\)，得到 \(F(\omega_n^k)=F_0(\omega_{\frac{n}{2}}^k)-\omega_n^kF_1(\omega_{\frac{n}{2}}^k)\)。 发现问题转化成了两个子问题，直接分治求解即可。时间复杂度 \(O(n\log n)\)。 直接做常数太大，我们发现分治到底层时下标是原下标的二进制翻转，于是直接翻转完后从下往上合并即可。 可以用 unsigned long long 减少取模次数优化常数。 快速傅里叶逆变换 记多项式 \(G(x)=\sum\limits_{i=0}^{n-1}F(\omega_n^i)x^i\)，考虑对 \(G(x)\) 做 FFT，得到 \[\begin{aligned}G(\omega_n^k)&amp;=\sum\limits_{i=0}^{n-1}F(\omega_n^i)(\omega_n^k)^i\\&amp;=\sum\limits_{i=0}^{n-1}\left(\sum\limits_{j=0}^{n-1} f_j(\omega_n^i)^j\right)(\omega_n^k)^i\\&amp;=\sum\limits_{j=0}^{n-1}f_j\sum\limits_{i=0}^{n-1}(\omega_n^{j+k})^i\end{aligned}\] 发现只有当 \(j+k\equiv 0\pmod n\) 时 \(\sum\limits_{i=0}^{n-1}(\omega_n^{j+k})^i=n\)，其他情况都为 \(0\)。于是 \[\begin{aligned}G(\omega_n^k)&amp;=\sum\limits_{j=0}^{n-1}f_j\sum\limits_{i=0}^{n-1}(\omega_n^{j+k})^i\\&amp;=f_{(n-k)\bmod n}\cdot n\end{aligned}\] 直接翻转后乘上 \(n\) 的逆元即可，时间复杂度同样为 \(O(n\log n)\)。 实现 \(\omega_{2^k}^{i}\) 只有 \(O(n)\) 个，可以在程序的一开始预处理（同时还预处理了逆元）。 12345678910111213#define MAX_LEN 262144 // 根据需要修改typedef std::vector&lt;unsigned&gt; poly;const unsigned P = 998244353, G = 3;unsigned omega[MAX_LEN], inv[MAX_LEN];void Init()&#123; // 在程序的一开始需要调用一次 Init() for (register int m = 1; m &lt; MAX_LEN; m &lt;&lt;= 1)&#123; unsigned _o = qpow(G, (P - 1) / (m &lt;&lt; 1)); omega[m] = 1; for (register int i = 1; i &lt; m; ++i) omega[m + i] = mul(omega[m + i - 1], _o); &#125; inv[1] = 1; for (register int i = 2; i &lt; MAX_LEN; ++i) inv[i] = mul(P - P / i, inv[P % i]);&#125; 每次需要预处理 \(rev[i]\)。 12345678910111213141516171819202122232425262728293031323334353637poly rev;int get(int n)&#123; int res = 1; while (res &lt; n) res &lt;&lt;= 1; return res;&#125;void init(int n)&#123; int k = 0; while ((1 &lt;&lt; k) &lt; n) ++k; rev.resize(n), rev[0] = 0, --k; for (register int i = 1; i &lt; n; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; k);&#125;void DFT(poly &amp;f, int n)&#123; f.resize(n); static unsigned long long ft[MAX_LEN]; // 用 unsigned long long 优化常数 for (register int i = 0; i &lt; n; ++i) ft[rev[i]] = f[i]; for (register int m = 1; m &lt; n; m &lt;&lt;= 1)&#123; if (m &amp; 262144)&#123; // P * P 约为 10^18，乘约 18 次会爆 unsigned long long for (register int i = 0; i &lt; n; ++i) ft[i] %= P; &#125; register int l = m &lt;&lt; 1; for (register int p = 0; p &lt; n; p += l)&#123; register unsigned *W = omega + m; register unsigned long long *F0 = ft + p, *F1 = ft + p + m; for (register int i = 0; i &lt; m; ++i, ++W, ++F0, ++F1)&#123; register unsigned t = (*F1) * (*W) % P; *F1 = (*F0) + P - t, *F0 += t; &#125; &#125; &#125; for (register int i = 0; i &lt; n; ++i) f[i] = ft[i] % P;&#125;void IDFT(poly &amp;f, int n)&#123; DFT(f, n), std::reverse(f.begin() + 1, f.end()); unsigned t = qpow(n, P - 2); for (register int i = 0; i &lt; n; ++i) f[i] = mul(f[i], t);&#125; 多项式加法与减法 对于每个 \(x_i\) 的系数直接相加/相减即可。 时间复杂度 \(O(n)\)。 1234567891011121314poly Plus(poly a, poly b)&#123; int n = std::max(a.size(), b.size()); a.resize(n), b.resize(n); poly res = a; for (register int i = 0; i &lt; n; ++i) inc(res[i], b[i]); return res;&#125;poly Minus(poly a, poly b)&#123; int n = std::max(a.size(), b.size()); a.resize(n), b.resize(n); poly res = a; for (register int i = 0; i &lt; n; ++i) dec(res[i], b[i]); return res;&#125; 多项式乘法 DFT 后把点值乘起来，在 IDFT 回去即可。 1234567891011121314151617poly Multiply(poly a, poly b, int _n = -1)&#123; if (!a.size() || !b.size() || !_n) return &#123;&#125;; if (_n == -1) _n = a.size() + b.size() - 1; if (a.size() &lt;= 30 || b.size() &lt;= 30)&#123; // 范围较小时暴力跑更快 poly res(a.size() + b.size() - 1); for (register int i = 0; i &lt; (int)a.size(); ++i) for (register int j = 0; j &lt; (int)b.size(); ++j) res[i + j] = (res[i + j] + 1ull * a[i] * b[j]) % P; for (register int i = _n; i &lt; (int)res.size(); ++i) inc(res[i % _n], res[i]); return res.resize(_n), res; &#125; int n = get(_n); init(n), DFT(a, n), DFT(b, n); for (register int i = 0; i &lt; n; ++i) a[i] = mul(a[i], b[i]); IDFT(a, n), a.resize(_n); return a;&#125; 可以把计算 \(F^2(x)\) 单独写一个函数，常数可以更小。 1234567poly Pow2(poly a)&#123; int _n = a.size() * 2 - 1, n = get(_n); init(n), DFT(a, n); for (register int i = 0; i &lt; n; ++i) a[i] = mul(a[i], a[i]); IDFT(a, n), a.resize(_n); return a;&#125; 多项式求逆 已知多项式 \(F(x)\)，求一个多项式 \(G(x)\) 满足 \(F(x)G(x)\equiv 1\pmod{x^n}\)。 假设我们已经求出 \(G_0(x)\) 满足 \(F(x)G_0(x)\equiv 1\pmod {x^{\frac{n}{2}}}\)，那么有 \(F(x)(G(x)-G_0(x))\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\)。 由于 \(G(x)-G_0(x)\) 是 \(n-1\) 次多项式，两边同时乘 \(G(x)-G_0(x)\)，有 \(F(x)(G(x)-G_0(x))^2\equiv 0\pmod{x^n}\)。 展开后整理得到 \(G(x)\equiv 2G_0(x)-F(x)G_0^2(x)\pmod {x^n}\)。于是迭代求出即可。 边界条件为求 \(F(x)G(x)\equiv 1\pmod{x}\)，直接求 \(f_0\) 的逆元即可。 时间复杂度 \(O(n\log n)\)。 123456789101112131415poly Inverse(poly f, int _n)&#123; int n = get(_n); f.resize(n); poly g(1); g[0] = qpow(f[0], P - 2); for (register int m = 2; m &lt;= n; m &lt;&lt;= 1)&#123; poly tmp(m); for (register int i = 0; i &lt; m; ++i) tmp[i] = f[i]; register int l = m &lt;&lt; 1; init(l), DFT(tmp, l), DFT(g, l); for (register int i = 0; i &lt; l; ++i) g[i] = mul(g[i], minus(2, mul(tmp[i], g[i]))); IDFT(g, l), g.resize(m); &#125; return g.resize(_n), g;&#125; 多项式除法 已知 \(n-1\) 次多项式 \(A(x)\) 和 \(m-1\) 次多项式 \(B(x)\)，求 \(n-m\) 次多项式 \(Q(x)\) 和小于 \(m-1\) 次的多项式 \(R(x)\) 满足 \(A(x)=B(x)Q(x)+R(x)\)。 下面我们强制 \(R(x)\) 为 \(m-2\) 次，不足则高位补 \(0\)。 用记号 \(F_r(x)\) 表示 \(F(x)\) 的系数翻转后的结果。有 \(F_r(x)=x^{\text{deg }F(x)}F(\frac{1}{x})\)，\(\text{deg }F(x)\) 表示 \(F(x)\) 的次数。 把 \(A(x)=B(x)Q(x)+R(x)\) 中的 \(x\) 用 \(\frac{1}{x}\) 代替，得到 \(A(\frac{1}{x})=B(\frac{1}{x})Q(\frac{1}{x})+R(\frac{1}{x})\)，两边同乘 \(x^{n-1}\) 得到 \(x^{n-1}A(\frac{1}{x})=x^{m-1}B(\frac{1}{x})x^{n-m}Q(\frac{1}{x})+x^{n-m+1}\cdot x^{m-2}R(x)\)。 即 \(A_r(x)=B_r(x)Q_r(x)+x^{n-m+1}R(x)\)，那么有 \(A_r(x)\equiv B_r(x)Q_r(x)\pmod{x^{n-m+1}}\)。由于 \(Q(x)\) 是一个 \(n-m\) 次多项式，所以 \(\bmod x^{n-m+1}\) 不会对 \(Q(x)\) 产生影响。 此时由于去掉了 \(R(x)\)，直接做多项式求逆即可求出 \(Q(x)\)。然后根据 \(R(x)=A(x)-B(x)Q(x)\) 求出 \(R(x)\)。 时间复杂度 \(O(n\log n)\)。 123456789101112std::pair&lt;poly, poly&gt; Divide(const poly &amp;a, const poly &amp;b)&#123; int n = a.size(), m = b.size(); poly Q, R; if (n &lt; m) return R = a, R.resize(m - 1), std::make_pair(Q, R); poly A(a), B(b); std::reverse(A.begin(), A.end()), A.resize(n - m + 1); std::reverse(B.begin(), B.end()), B.resize(n - m + 1); Q = Multiply(A, Inverse(B, n - m + 1)); Q.resize(n - m + 1), std::reverse(Q.begin(), Q.end()); R = Minus(a, Multiply(b, Q)), R.resize(m - 1); return std::make_pair(Q, R);&#125; 多项式求导与积分 求导有运算法则 \((u(x)+v(x))&#39;=u&#39;(x)+v&#39;(x)\)，\((u(x)\cdot v(x))&#39;=u&#39;(x)\cdot v(x)+u(x)\cdot v&#39;(x)\)，并且可以扩展到 \(n\) 个函数。同时有 \(C&#39;=0,(x^n)&#39;=nx^{n-1}\)。 那么 \(F&#39;(x)=\left(\sum\limits_{i=0}^{n-1} f_ix^i\right)&#39;=\sum\limits_{i=0}^{n-1}(f_ix^i)&#39;=\sum\limits_{i=1}^{n-1} f_i\cdot ix^{i-1}\)。 积分只要反着做一遍就好了。 时间复杂度 \(O(n)\)。 123456789101112poly Derivative(poly f)&#123; int n = f.size(); for (register int i = 1; i &lt; n; ++i) f[i - 1] = mul(f[i], i); return f.resize(n - 1), f;&#125;poly Integral(poly f)&#123; f.push_back(0); int n = f.size(); for (register int i = n - 1; i; --i) f[i] = mul(f[i - 1], inv[i]); // 逆元已经在 Init() 中预处理 return f[0] = 0, f;&#125; 泰勒展开 泰勒展开是将一个在 \(x=x_0\) 处具有 \(n\) 阶导数的函数 \(f(x)\) 利用关于 \(x-x_0\) 的 \(n\) 次多项式来逼近函数的方法。 当 \(n\) 趋向于无穷时，我们可以直接用下面这个式子表示泰勒公式： \[f(x)=\sum\limits_{i=0}^{\infty} \frac{f^{(i)}(x_0)}{i!}(x-x_0)^i\] 而麦克劳林级数就是上式 \(x_0=0\) 的特殊形式。 要对泰勒展开有更好地理解可以看怎样更好地理解并记忆泰勒展开式？- 知乎。 牛顿迭代 牛顿迭代法是一种用于解非线性方程 \(G(x)=0\) 的近似方法。 而在我们研究多项式相关时，我们一般用牛顿迭代法解关于无穷幂级数 \(F(x)\) 的非线性方程 \(G(F(x))=0\)，求 \(F(x)\) 在模 \(x^n\) 意义下得到的多项式，其中 \(G(F(x))\) 是一个自变量为多项式，应变量也为多项式的函数。 我们假设已经求出答案模 \(x^{\lceil\frac{n}{2}\rceil}\) 意义下的多项式 \(F_0(x)\)，我们要求出答案模 \(x^n\) 意义下的多项式 \(F_1(x)\)。即我们已经有 \[G(F_0(x))\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\] 我们把 \(G(F(x))\) 在 \(F(x)=F_0(x)\) 处泰勒展开，得到 \[\begin{aligned}G(F(x))&amp;=G(F_0(x))\\ &amp;+G&#39;(F_0(x))(F(x)-F_0(x))\\ &amp;+\frac{G&#39;&#39;(F_0(x))}{2}(F(x)-F_0(x))^2\\&amp;+\cdots\end{aligned}\] 因为有 \(F_1(x)-F_0(x)\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\)，所以有 \((F_1(x)-F_0(x))^2\equiv 0\pmod{x^n}\)。 由于 \(F_1(x)\) 是答案在模 \(x^n\) 意义下的多项式，所以上述泰勒展开式中除前两项外的部分代入 \(F_1(x)\) 后模 \(x^n\) 为 \(0\)。所以我们只需要考虑前两项。即 \(F_1(x)\) 只需要满足 \[G(F_0(x))+G&#39;(F_0(x))(F_1(x)-F_0(x))\equiv 0\pmod{x^n}\] 整理，得 \[F_1(x)\equiv F_0(x)-\frac{G(F_0(x))}{G&#39;(F_0(x))}\pmod{x^n}\] 于是我们可以在 \(O(n\log n)\) 的时间求出答案在模 \(x^n\) 意义下的多项式。 多项式对数函数 已知多项式 \(F(x)\)（常数项为 \(1\)），求多项式 \(G(x)\) 满足 \(G(x)\equiv \ln F(x)\pmod{x^n}\)。 注意多项式的对数函数可以认为是多项式和麦克劳林级数的复合。这意味着多项式对数函数是一个无穷级数。我们只能求他在模 \(x^n\) 意义下得到的多项式。 类似地，多项式求逆、多项式指数函数、多项式开根等我们都只能求出在模意义下的多项式。 注意 \(F(x)\) 常数项不为 \(1\) 时 \(\ln F(x)\) 无意义。 两边同时求导，得到 \(G&#39;(x)\equiv (\ln F(x))&#39;\pmod {x^{n-1}}\)。 由复合函数求导公式，得到 \(G&#39;(x)\equiv \frac{F&#39;(x)}{F(x)}\pmod {x^{n-1}}\)。 然后两边同时求积分，得到 \[\ln F(x)\equiv \int \frac{F&#39;(x)}{F(x)}\pmod {x^n}\] 时间复杂度 \(O(n\log n)\)，瓶颈在于多项式乘法和多项式求逆。 1234poly Ln(const poly &amp;a, int n)&#123; poly res = Integral(Multiply(Derivative(a), Inverse(a, n))); return res.resize(n), res;&#125; 多项式指数函数 已知多项式 \(F(x)\)（常数项为 \(0\)），求多项式 \(G(x)\) 满足 \(G(x)\equiv \exp {F(x)}\pmod{x^n}\)。 多项式 \(\exp\) 有两种做法，分别是 \(O(n\log n)\) 的牛顿迭代法与 \(O(n\log^2 n)\) 的分治法。但是，从实际运行效率上看，\(n\le 10^5\) 时两种方法的运行速度不相上下，甚至有时分治方法更快。并且，分治方法依赖的函数更少，代码更短。 牛顿迭代法 注意 \(F(x)\) 常数项不为 \(0\) 时 \(\exp F(x)\) 无意义。 两边同时求 \(\ln\)，得到 \(\ln G(x)\equiv F(x)\pmod{x^n}\)，即 \((\ln G(x))-F(x)\equiv 0\pmod{x^n}\)。 定义函数 \(H(G(x))=(\ln G(x))-F(x)\)，那么我们要求 \(G(x)\) 满足 \(H(G(x))\equiv 0\pmod{x^n}\)。 套用牛顿迭代的式子，即假设我们求出了在模 \(x^{\lceil\frac{n}{2}\rceil}\) 意义下的答案 \(G_0(x)\)，那么有 \[G(x)\equiv G_0(x)-\frac{H(G_0(x))}{H&#39;(G_0(x))}\pmod{x^n}\] 又因为有（要注意函数 \(H(G(x))\) 的自变量是 \(G(x)\) 而非 \(x\)） \[\begin{aligned}H&#39;(G(x))&amp;=\ln&#39; G(x)\\ &amp;=\frac{1}{G(x)}\end{aligned}\] 所以，经整理得 \[G(x)\equiv G_0(x)(1-(\ln G_0(x))+F(x))\pmod{x^n}\] 时间复杂度 \(O(n\log n)\)。常数较大。 12345678910111213141516poly Exp_Newton(poly f, int _n)&#123; int n = get(_n); f.resize(n); poly g(1); g[0] = 1; for (register int m = 2; m &lt;= n; m &lt;&lt;= 1)&#123; poly tmp = Ln(g, m); for (register int i = 0; i &lt; m; ++i) tmp[i] = minus(f[i], tmp[i]); inc(tmp[0], 1); register int l = m &lt;&lt; 1; init(l), DFT(tmp, l), DFT(g, l); for (register int i = 0; i &lt; l; ++i) g[i] = mul(g[i], tmp[i]); IDFT(g, l), g.resize(m); &#125; return g.resize(_n), g;&#125; 分治法 我们在 \(G(x)\equiv \exp F(x)\pmod{x^n}\) 两边同时求导，得到 \[G&#39;(x)\equiv (\exp F(x))F&#39;(x)\pmod{x^n}\] 即 \[G&#39;(x)\equiv G(x)F&#39;(x)\pmod{x^n}\] 两边同时求积分，得 \[G(x)\equiv \int G(x)F&#39;(x)\] 直接分治 NTT 求解即可。时间复杂度 \(O(n\log^2 n)\)。 关于卡常 在处理区间 \([l,r)\) 时我们需要将 \(f[0,r-l)\) 与 \(g[l,\lfloor\frac{l+r+1}{2}\rfloor)\) 作卷积，求积分以后再加到 \(g[\lfloor\frac{l+r+1}{2}\rfloor,r)\) 上（其中 \(f,g\) 分别是 \(F&#39;(x),G(x)\) 的系数数组）。 发现我们真正需要的部分是卷积后中间一部分，前后两部分是没有用的。而通过计算发现后面部分的长度一定不超过前面部分的长度，FFT 是循环卷积，我们只要把长度限定到 \(r-l-1\) 就可以把后面部分加到前面而不影响中间需要的部分。这样做对优化常数很有帮助。 12345678910111213void Exp_solve(const poly &amp;a, poly &amp;b, int l, int r)&#123; if (l + 1 == r) return l ? b[l] = 1ll * b[l] * inv[l] % P : b[l] = 1, void(0); int md = (l + r + 1) &gt;&gt; 1; Exp_solve(a, b, l, md); poly res = Multiply(poly(b.begin() + l, b.begin() + md), poly(a.begin(), a.begin() + r - l - 1), r - l - 1); for (register int i = md; i &lt; r; ++i) inc(b[i], res[i - l - 1]); Exp_solve(a, b, md, r);&#125;poly Exp(poly a, int _n)&#123; a = Derivative(a), a.resize(_n); poly res(_n); return Exp_solve(a, res, 0, _n), res;&#125; 多项式求任意次幂 给定多项式 \(F(x)\) 和正整数 \(k\)，求 \(G(x)\equiv F^k(x)\pmod{x^n}\)。 如果 \(F(x)\) 常数项为 \(1\)，那么有 \(G(x)=e^{k\ln F(x)}\)。 而 \(F(x)\) 常数项不为 \(1\) 时，我们可以把 \(F(x)\) 除以 \(ax^p\) 使得常数项为 \(1\)，最后再乘上 \(a^kx^{kp}\)。 理论上来说这个方法可以求任意实数幂次，但是系数在模意义下运算，\(k\) 为分数、无理数时很难求或者在模域下不存在答案。 时间复杂度 \(O(n\log n)\)。 12345678910111213141516171819202122poly Pow(poly a, int k, int n)&#123; a.resize(n); int t = n; for (register int i = 0; i &lt; n; ++i) if (a[i])&#123; t = i; break; &#125; if (t == n) return !k ? a[0] = 1 : 0, a; unsigned vi = qpow(a[t], P - 2), vk = qpow(a[t], k); for (register int i = 0; i &lt; n - t; ++i) a[i] = mul(a[i + t], vi); a.resize(n - t); t = std::min(1ll * t * k, 1ll * n); if (t == n)&#123; a.resize(n); for (register int i = 0; i &lt; n; ++i) a[i] = 0; return a; &#125; a = Ln(a, n - t); for (register int i = 0; i &lt; n - t; ++i) a[i] = mul(a[i], k); a = Exp(a, n - t), a.resize(n); for (register int i = n - t - 1; ~i; --i) a[i + t] = mul(a[i], vk); for (register int i = 0; i &lt; t; ++i) a[i] = 0; return a;&#125; 多项式开根 已知多项式 \(F(x)\)，求多项式 \(G(x)\) 满足 \(G^2(x)\equiv F(x)\pmod{x^n}\)。 定义函数 \(H(G(x))=G^2(x)-F(x)\)，那么我们要求 \(G(x)\) 使得 \(H(G(x))\equiv 0\pmod{x^n}\)。 仍然假设我们已经求出了 \(G_0(x)\) 满足 \(H(G_0(x))\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\)。根据牛顿迭代的式子，得到 \[\begin{aligned}G(x)&amp;\equiv G_0(x)-\frac{H(G_0(x))}{H&#39;(G_0(x))}\\&amp;=G_0(x)-\frac{G_0^2(x)-F(x)}{2G_0(x)}\\&amp;=\frac{G_0^2(x)+F(x)}{2G_0(x)}\pmod{x^n}\end{aligned}\] 在模意义下运算时，边界我们只要用 Cipolla 算法求二次剩余即可。 时间复杂度 \(O(n\log n)\)。 1234567891011121314poly Sqrt(poly f, int _n)&#123; int n = get(_n); f.resize(n); poly g(1); g[0] = Sqrt(f[0]); // 求二次剩余 for (register int m = 2; m &lt;= n; m &lt;&lt;= 1)&#123; poly tmp = Pow2(g); tmp.resize(m); for (register int i = 0; i &lt; m; ++i) inc(tmp[i], f[i]); g = Multiply(tmp, Inverse(g, m)), g.resize(m); for (register int i = 0; i &lt; m; ++i) g[i] = mul(g[i], inv[2]); &#125; return g.resize(_n), g;&#125; 多项式多点求值 给定多项式 \(F(x)\) 和 \(n\) 个点 \(a_i\)，对于每个 \(a_i\)，求 \(F(a_i)\) 的值。 记 \(k=\lfloor\frac{n}{2}\rfloor\)，构造多项式 \(G_0(x)=\prod\limits_{i=1}^{k}(x-a_i)\)，然后用多项式除法求出 \(D_0(x),R_0(x)\) 满足 \(F(x)=D_0(x)G_0(x)+R_0(x)\)。 发现对于 \(i\le k\) 的 \(a_i\)，代入后 \(D_0(x)G_0(x)=0\)，也就是说 \(F(a_i)=R_0(a_i)\)。 对于 \(i &gt; k\) 的部分也可以同理构造多项式 \(G_1(x)\) 求出 \(R_1(x)\) 使得 \(F(a_i)=R_1(a_i)\)。 于是我们把用 \(O(n\log n)\) 的复杂度把原问题分成了两个规模减半的子问题。 每次的 \(G_0(x),G_1(x)\) 可以一开始都预处理出来。 预处理部分复杂度 \(O(n\log^2n)\)，总复杂度 \(O(n\log^2 n)\)。 注意到暴力展开计算常数非常小，在问题规模减到一定数值时可以暴力计算。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct tree_node&#123; int ls, rs; poly g;&#125;;int _T_cnt;std::vector&lt;tree_node&gt; _T;int eval_inter_init(const poly &amp;x, int l, int r)&#123; int u = _T_cnt++; _T[u].ls = _T[u].rs = -1, _T[u].g.resize(r - l + 1); if (l + 1 == r)&#123; _T[u].g[0] = minus(0, x[l]), _T[u].g[1] = 1; return u; &#125; int md = (l + r + 1) &gt;&gt; 1; _T[u].ls = eval_inter_init(x, l, md); _T[u].rs = eval_inter_init(x, md, r); _T[u].g = Multiply(_T[_T[u].ls].g, _T[_T[u].rs].g); return u;&#125;void Evaluate_solve(const poly &amp;f, const poly &amp;x, poly &amp;y, int u, int l, int r)&#123; if (r - l &lt;= 256)&#123; register int n = f.size(); for (register int k = l; k &lt; r; ++k)&#123; register unsigned now = 0; register unsigned long long b[17], c1, c2, c3, c4; b[0] = 1; for (register int i = 1; i &lt;= 16; ++i) b[i] = b[i - 1] * x[k] % P; for (register int i = n - 1; i - 15 &gt;= 0; i -= 16)&#123; c1 = now * b[16] + f[i] * b[15] + f[i - 1] * b[14] + f[i - 2] * b[13]; c2 = f[i - 3] * b[12] + f[i - 4] * b[11] + f[i - 5] * b[10] + f[i - 6] * b[9]; c3 = f[i - 7] * b[8] + f[i - 8] * b[7] + f[i - 9] * b[6] + f[i - 10] * b[5]; c4 = f[i - 11] * b[4] + f[i - 12] * b[3] + f[i - 13] * b[2] + f[i - 14] * b[1]; now = (c1 + c2 + c3 + c4 + f[i - 15]) % P; &#125; for (register int i = n % 16 - 1; ~i; --i) now = (1ull * now * x[k] + f[i]) % P; y[k] = now; &#125; return; &#125; int md = (l + r + 1) &gt;&gt; 1; poly R; R = Divide(f, _T[_T[u].ls].g).second; Evaluate_solve(R, x, y, _T[u].ls, l, md); R = Divide(f, _T[_T[u].rs].g).second; Evaluate_solve(R, x, y, _T[u].rs, md, r);&#125;poly Evaluate(const poly &amp;f, const poly &amp;x)&#123; int m = x.size(), rt = -1; _T_cnt = 0, _T.resize(2 * m - 1), rt = eval_inter_init(x, 0, m); poly res(m); Evaluate_solve(f, x, res, rt, 0, m); return res;&#125; 多项式快速插值 有一个 \(n-1\) 次多项式 \(F(x)\)，给定 \(n\) 个点及对应的点值 \((x_i,y_i)\)，求 \(F(x)\)。 根据拉格朗日插值公式，有 \[\begin{aligned}F(x)&amp;=\sum_{i=1}^{n} y_i\prod_{i\ne j}\frac{x-x_j}{x_i-x_j}\\&amp;=\sum_{i=1}^{n}\frac{y_i}{\prod_{i\ne j}(x_i-x_j)}\prod_{i\ne j}(x-x_j)\end{aligned}\] 令 \(G(x)=\prod_{i=1}^{n}(x-x_i),H_i(x)=\frac{G(x)}{x-x_i}\)，那么 \(\prod_{i\ne j}(x_i-x_j)=H_i(x_i)\)。根据洛必达法则，有 \(H_i(x_i)=G&#39;(x_i)\)。 于是我们用多项式多点求值求出所有 \(G&#39;(x_i)\) 即可。 记 \(a_i=\frac{y_i}{G&#39;(x_i)}\)，那么有 \[F(x)=\sum_{i=1}^{n}a_i\prod_{i\ne j}(x-x_j)\] 然后我们分治求解。设当前区间为 \([l,r)\)，中点 \(m=\lfloor\frac{l+r+1}{2}\rfloor\)，我们要求 \[\begin{aligned}F_{l,r}(x)&amp;=\sum_{i=l}^{r-1}a_i\prod_{l\le j &lt; r,j\ne i}(x-x_j) \\ &amp;=\left(\prod_{i=m}^{r-1}(x-x_i)\right)\sum_{i=l}^{m-1}a_i\prod_{l\le j &lt; m,i\ne j}(x-x_j)+\left(\prod_{i=l}^{m-1}(x-x_i)\right)\sum_{i=m}^{r-1}a_i\prod_{m\le j &lt; r,i\ne j}(x-x_j) \\ &amp;=\left(\prod_{i=m}^{r-1}(x-x_i)\right)F_{l,m}(x)+\left(\prod_{i=l}^{m-1}(x-x_i)\right)F_{m,r}(x)\end{aligned}\] 时间复杂度 \(O(n\log^2 n)\)。 123456789101112131415161718192021222324252627282930313233343536poly Divide_2(poly a, int t)&#123; int n = a.size(); poly b(n - 1); for (register int i = n - 1; i; --i)&#123; b[i - 1] = a[i]; dec(a[i - 1], mul(a[i], t)); &#125; return b;&#125;poly Inter_solve(const poly &amp;x, const poly &amp;y, int u, int l, int r)&#123; if (r - l &lt;= 64)&#123; poly f(r - l), g = _T[u].g; for (register int i = l; i &lt; r; ++i)&#123; poly tmp = Divide_2(g, minus(0, x[i])); for (register int j = 0; j &lt; r - l; ++j) f[j] = (f[j] + 1ull * tmp[j] * y[i]) % P; &#125; return f; &#125; int md = (l + r + 1) &gt;&gt; 1; poly A = _T[_T[u].rs].g, B = Inter_solve(x, y, _T[u].ls, l, md); poly C = _T[_T[u].ls].g, D = Inter_solve(x, y, _T[u].rs, md, r); register int m = get(r - l); init(m), DFT(A, m), DFT(B, m), DFT(C, m), DFT(D, m); for (register int i = 0; i &lt; m; ++i) A[i] = (1ull * A[i] * B[i] + 1ull * C[i] * D[i]) % P; IDFT(A, m), A.resize(r - l); return A;&#125;poly Interpolation(poly x, poly y)&#123; int n = x.size(), rt = -1; _T_cnt = 0, _T.resize((n &lt;&lt; 1) - 1), rt = eval_inter_init(x, 0, n); poly g = Derivative(_T[rt].g); poly res(n); Evaluate_solve(g, x, res, rt, 0, n); for (register int i = 0; i &lt; n; ++i) y[i] = mul(y[i], qpow(res[i], P - 2)); return Inter_solve(x, y, rt, 0, n);&#125; 多项式三角函数 不会 多项式反三角函数 不会 MTT 不会 完整代码 完整代码可以见 Codes/Polynomial.cpp at master · AutumnKite/Codes。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1244E」Minimizing Difference]]></title>
    <url>%2Fcf1244e-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定一个长度为 \(n\) 的序列 \(a\)，一次操作可以将序列中的某个数 \(+1\) 或 \(-1\)。 定义一个序列的差值为序列的最大值减去最小值得到的数。 求进行至多 \(k\) 次操作后序列差值的最小值。 \(n\le 10^5,a_i\le 10^9,k\le 10^{14}\) 题解 显然可以二分答案 \(x\)，然后就是求使得差值 \(\le x\) 需要进行至少多少次操作。 将 \(a_i\) 排序，假设最后的序列中的数在 \([p,p+x]\) 中，记序列中最后一个 \(&lt; p\) 的数为 \(a_l\)，第一个 \(&gt;p+x\) 的数为 \(a_r\)，那么需要进行的操作数量是 \(p\times l-\sum_{i=1}^{l}a_i+\sum_{i=r}^{n}a_i-(p+x)\times (n-r+1)\)。根据这个式子我们可以发现 \(p\) 和 \(p+x\) 这两个数中一定有一个数是存在于原序列中的，否则可以进行调整使得操作次数更少。于是我们枚举所有情况进行判断即可。 时间复杂度 \(O(n\log \max a_i)\)。 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;long long read()&#123; register long long x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 100005int n;long long k, a[N], sum[N];bool check(int x)&#123; for (register int i = 1, j = 1; i &lt;= n; ++i)&#123; while (j &lt;= n &amp;&amp; a[j] - a[i] &lt;= x) ++j; if (a[i] * (i - 1) - sum[i - 1] + sum[n] - sum[j - 1] - (a[i] + x) * (n - j + 1) &lt;= k) return 1; &#125; for (register int i = 1, j = 1; i &lt;= n; ++i)&#123; while (a[i] - a[j] &gt; x) ++j; if ((a[i] - x) * (j - 1) - sum[j - 1] + sum[n] - sum[i] - a[i] * (n - i) &lt;= k) return 1; &#125; return 0;&#125;int main()&#123; n = read(), k = read(); for (register int i = 1; i &lt;= n; ++i) a[i] = read(); std :: sort(a + 1, a + 1 + n); for (register int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + a[i]; int l = 0, r = a[n] - a[1], md, ans = 0; while (l &lt;= r) if (check(md = (l + r) &gt;&gt; 1)) r = md - 1, ans = md; else l = md + 1; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1244F」Chips]]></title>
    <url>%2Fcf1244f-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 有一个大小为 \(n\) 的环，环上每个点有一个颜色（黑/白）。定义一次操作是，对于每个点 \(i\)，若他和他相邻的两个点中，白点多于黑点，则在新的环中， \(i\) 变成白色，否则变为黑色。 求进行 \(k\) 次操作后每个点的颜色。 \(n\le 2\times 10^5,k\le 10^9\) 题解 变色的条件相当于 \(i\) 相邻两个点的颜色都与 \(i\) 的颜色不同。对于一段长度 \(\ge 2\) 的颜色相同的段，显然颜色是永远不会变的。只有这样的段之间的这些颜色交替改变的点的颜色会发生变化。例如 WWWBWBWBWBBB -&gt; WWWWBWBWBBBB -&gt; WWWWWBWBBBBB -&gt; WWWWWWBBBBBB。 考虑中间的颜色交替改变的一段（如上例中 BWBWBW），发现每进行一次操作，两边的点会向两边的颜色相同的连续段合并，中间的点会改变颜色。记这样的段中某个点 \(i\) 到两边颜色相同连续段的距离是 \(a_i,b_i\)，那么他会在第 \(\min(a_i,b_i)\) 次操作被合并，颜色要看两边段的颜色和具体往哪边合并，被合并之后颜色就不会再变化，而在被合并之前颜色则是交替变化。所以只要根据 \(k\) 和 \(\min(a_i,b_i)\) 的大小进行讨论即可。 要注意的是，可能题目给定字符串的最前面一段和最后面一段是可以拼起来的，所以要对顺序进行一定的调整。 代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define N 400005int n, k, d, dis1[N], dis2[N];char a[N], b[N];bool check()&#123; if (n &amp; 1) return 0; for (register int i = 2; i &lt;= n; ++i) if (a[i] == a[i - 1]) return 0; return 1;&#125;int main()&#123; scanf("%d%d%s", &amp;n, &amp;k, a + 1); if (check())&#123; if (k &amp; 1) std :: reverse(a + 1, a + 1 + n); return printf("%s", a + 1), 0; &#125; for (register int i = 1; i &lt;= n; ++i) a[n + i] = a[i]; for (register int i = n + 2; i &lt; (n &lt;&lt; 1); ++i) if (a[i - 1] != a[i] &amp;&amp; a[i] != a[i + 1]) continue; else&#123; d = i - 1; break; &#125; if (!d) d = (n &lt;&lt; 1) - 1; for (register int i = d - n + 1; i &lt;= d; ++i) if (a[i - 1] != a[i] &amp;&amp; a[i] != a[i + 1]) dis1[i] = dis1[i - 1] + 1; else dis1[i] = 0; for (register int i = d; i &gt; d - n; --i) if (a[i - 1] != a[i] &amp;&amp; a[i] != a[i + 1]) dis2[i] = dis2[i + 1] + 1; else dis2[i] = 0; for (register int i = d - n + 1; i &lt;= d; ++i) if (a[i - 1] != a[i] &amp;&amp; a[i] != a[i + 1]) if (k &gt;= std :: min(dis1[i], dis2[i])) if (dis1[i] &lt; dis2[i]) b[i] = a[i - dis1[i]]; else b[i] = a[i + dis2[i]]; else b[i] = a[i] == 'B' &amp;&amp; (k &amp; 1) || (a[i] == 'W' &amp;&amp; (k &amp; 1 ^ 1)) ? 'W' : 'B'; else b[i] = a[i]; for (register int i = 1; i &lt;= d - n; ++i) putchar(b[i + n]); for (register int i = d - n + 1; i &lt;= n; ++i) putchar(b[i]);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1214H」Tiles Placement]]></title>
    <url>%2Fcf1214h-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定一棵 \(n\) 个点的树，你需要给每个点染一个 \(1\sim k\) 的颜色，使得树上所有长度为 \(k\) 的路径都恰好包含 \(k\) 种颜色。 \(n\le 2\times 10^5\) 题解 根本不会构造.jpg 我来翻译官方题解了 显然如果一个点出去有三条路径（长度记为 \(a,b,c\)）满足 \(a+b\ge k-1,a+c\ge k-1,b+c\ge k-1\)，则一定不满足条件。否则，存在以下一个构造方案。 拉出一条直径，从左到右染 \(1,2,3,\cdots,k,1,2,3,\cdots\) 。然后考虑直径外的部分，把直径分成两半，对于左边部分的某个染成 \(i\) 的点，我们把这个点多出去的部分按深度从小到大染成 \(i,i-1,i-2,\cdots,1,k,k-1,k-2\cdots\)；对于右边部分的某个染成 \(i\) 的点，我们把这个点多出去的部分按深度从小到大染成 \(i,i+1,i+2,\cdots,k,1,2,3\cdots\)。正确性可以参考官方题解。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;int read()&#123; register int x = 0; register char ch = getchar(), f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 200005int k, n;int mx[N], cmx[N];int rt, ed, dep[N], fa[N], cnt, p[N], on[N], col[N];int edge, to[N &lt;&lt; 1], pr[N &lt;&lt; 1], hd[N];void addedge(int u, int v)&#123; to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;&#125;std :: pair&lt;int, int&gt; dfs1(int u, int fa = 0)&#123; std :: pair&lt;int, int&gt; res(0, u), tmp; for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa) tmp = dfs1(v, u), ++tmp.first, res = std :: max(res, tmp); return res;&#125;void dfs2(int u)&#123; dep[u] = dep[fa[u]] + 1, mx[u] = cmx[u] = 0; for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa[u])&#123; fa[v] = u, dfs2(v); if (mx[v] + 1 &gt; mx[u]) cmx[u] = mx[u], mx[u] = mx[v] + 1; else if (mx[v] + 1 &gt; cmx[u]) cmx[u] = mx[v] + 1; &#125;&#125;void dfs3(int u, int c, int d)&#123; c = (c + d + k - 1) % k + 1, col[u] = c; for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa[u] &amp;&amp; !on[v]) dfs3(v, c, d);&#125;int main()&#123; n = read(), k = read(); for (register int i = 1, u, v; i &lt; n; ++i) u = read(), v = read(), addedge(u, v), addedge(v, u); dfs2(rt = dfs1(1).second); for (register int i = 1; i &lt;= n; ++i) if (cmx[i]) if (mx[i] + 1 &gt; dep[i]) if (dep[i] + cmx[i] &gt;= k &amp;&amp; k &gt; 2) return printf("No\n"), 0; else continue; else if (mx[i] + cmx[i] + 1 &gt;= k &amp;&amp; k &gt; 2) return printf("No\n"), 0; else continue; for (register int i = 1; i &lt;= n; ++i) if (!ed || dep[i] &gt; dep[ed]) ed = i; cnt = dep[ed]; for (register int i = ed; i; i = fa[i]) p[dep[i]] = i, on[i] = 1, col[i] = (dep[i] - 1) % k + 1; for (register int i = 1; i &lt;= cnt; ++i) for (register int j = hd[p[i]]; j; j = pr[j]) if (!on[to[j]]) dfs3(to[j], col[p[i]], i &lt;= cnt / 2 ? -1 : 1); printf("Yes\n"); for (register int i = 1; i &lt;= n; ++i) printf("%d ", col[i]); putchar('\n');&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>DP</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1214G」Feeling Good]]></title>
    <url>%2Fcf1214g-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 有一个 \(n\times m\) 的黑白矩阵，初始时是全白的。有 \(q\) 次操作，每次操作形如 \(a_i,l_i,r_i\)，表示把 \(a_i\) 行的 \(l_i\) 列到 \(r_i\) 列的格子反转颜色。 每次操作后，你要找出 \(x_1,y_1,x_2,y_2\)，满足 \(x_1 &lt; x_2,y_1 &lt; y_2, col(x_1,y_1)=col(x_2,y_2),col(x_1,y_2)=col(x_2,y_1),col(x_1,y_1)\ne col(x_1,y_2)\)。若不存在则输出 \(-1\)。 \(n,m\le 2000,q\le 5\times 10^5\) 题解 考虑如何判断是否有解。 记 \(S_i=\{j\mid col(i,j)=\text{black}\}\)。对于固定的两行 \(x_1,x_2\)，有解的条件是 \(S_{x_1}\) 不是 \(S_{x_2}\) 的子集且 \(S_{x_2}\) 不是 \(S_{x_1}\) 的子集。 我们把这些集合按大小从小到大排序，若 \(S_1\subseteq S_2\subseteq S_3\subseteq\cdots\subseteq S_n\)，则一定无解，否则一定存在一个 \(i\) 使得 \(S_{i}\) 不是 \(S_{i+1}\) 的子集，又因为是按集合大小从小到大排序的，\(S_{i+1}\) 也一定不是 \(S_i\) 的子集，那么这两行就是满足条件的。 然后考虑求出一组解，我们只要把所有满足条件的 \(i\) 都记下来。对于两个集合 \(S_{i},S_{i+1}\)，其中一个 \(y\) 一定是在 \(S_{i}\) 中是黑色的但在 \(S_{i+1}\) 中是白色的，另一个 \(y\) 反之。 用 bitset 维护这些集合，然后用位运算和 _Find_First 函数即可求出 \(y_1,y_2\)。 时间复杂度 \(O(q(\frac{m}{w}+\log n))\)。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;#include &lt;set&gt;int read()&#123; register int x = 0; register char ch = getchar(), f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 2005int n, m, q, x1, _y1, x2, _y2;std :: bitset&lt;N&gt; a[N], nw[N], tmp;std :: set&lt; std :: pair&lt;int, int&gt; &gt; S, ans;bool check(int i, int j)&#123; return (a[i] &amp; a[j]) != a[i];&#125;void add(std :: pair&lt;int, int&gt; p)&#123; if (check(p.first, p.second)) ans.insert(p);&#125;void del(std :: pair&lt;int, int&gt; p)&#123; if (check(p.first, p.second)) ans.erase(p);&#125;void Erase(std :: pair&lt;int, int&gt; x)&#123; int nx, i, pr; auto it = S.lower_bound(x), tmp = it; i = x.second, nx = (++tmp) -&gt; second, pr = (--it) -&gt; second; del(std :: make_pair(pr, i)), del(std :: make_pair(i, nx)), add(std :: make_pair(pr, nx)); S.erase(x);&#125;void Insert(std :: pair&lt;int, int&gt; x)&#123; int nx, i, pr; auto it = S.lower_bound(x); i= x.second, nx = it -&gt; second, pr = (--it) -&gt; second; add(std :: make_pair(pr, i)), add(std :: make_pair(i, nx)), del(std :: make_pair(pr, nx)); S.insert(x);&#125;int main()&#123; n = read(), m = read(), q = read(); nw[1] = 1; for (register int i = 2; i &lt;= m; ++i) nw[i] = nw[i - 1] &lt;&lt; 1 | nw[1]; a[n + 1] = nw[m], S.insert(std :: make_pair(0, 0)); for (register int i = 1; i &lt;= n; ++i) S.insert(std :: make_pair(0, i)); S.insert(std :: make_pair(m, n + 1)); for (register int i = 1; i &lt;= q; ++i)&#123; int k = read(), l = read(), r = read(); Erase(std :: make_pair(a[k].count(), k)); a[k] ^= nw[r - l + 1] &lt;&lt; (l - 1); Insert(std :: make_pair(a[k].count(), k)); if (ans.empty()) printf("-1\n"); else&#123; x1 = ans.begin() -&gt; first, x2 = ans.begin() -&gt; second; _y1 = ((a[x1] ^ a[x2]) &amp; a[x1])._Find_first(), _y2 = ((a[x1] ^ a[x2]) &amp; a[x2])._Find_first(); if (x1 &gt; x2) std :: swap(x1, x2); if (_y1 &gt; _y2) std :: swap(_y1, _y2); printf("%d %d %d %d\n", x1, _y1 + 1, x2, _y2 + 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1214F」Employment]]></title>
    <url>%2Fcf1214f-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 有一个大小为 \(m\) 的环，还上有 \(n\) 个点有工作单位，并且有 \(n\) 个点上住着一个人。你需要为每个人分配一个工作单位，使得所有人到工作单位的距离之和最短。输出一个方案。 \(m\le 10^9,n\le 2\times 10^5\) 题解 下面的数组都从 \(0\) 开始标号。先将 \(a,b\) 数组分别从小到大排序，然后把 \(b\) 数组变成 \(b_0,b_1,b_2,\cdots,b_{n-1},b_0+m,b_1+m,\cdots,b_{n-1}+m,b_0+2m,b_1+2m,\cdots,b_{n-1}+2m\)，把 \(a\) 数组变成 \(a_0+m,a_1+m,a_2+m,\cdots,a_{n-1}+m\)。 考虑贪心，显然两个人的路径不能“交叉”，所以一定是小的和小的匹配，大的和大的匹配。问题变成了求 \(\min\limits_{0\le x\le 2n} \sum\limits_{i=0}^{n-1} |a_i-b_{i+x}|\) 的值。 记 \(ans_x=\sum\limits_{i=0}^{n-1} |a_i-b_{i+x}|\)，把绝对值拆开，则变成了 \[\begin{aligned}ans_x&amp;=\sum\limits_{i=0}^{n-1} |a_i-b_{i+x}| \\ &amp;=\sum\limits_{i=0}^{n-1} ([a_i &gt; b_{i+x}]a_i-[a_i &lt; b_{i+x}]a_i-[a_i &gt; b_{i+x}]b_{i+x}+[a_i &lt; b_{i+x}]b_{i+x})\end{aligned}\] 记 \(sa_{x}=\sum\limits_{i=0}^{n-1} ([a_i &gt; b_{i+x}]a_i-[a_i &lt; b_{i+x}]a_i),sb_{x}=\sum\limits_{i=0}^{n-1} ([a_i &lt; b_{i+x}]b_{i+x}-[a_i &gt; b_{i+x}]b_{i+x})\)。考虑单独计算。 我们将 \(sa\) 差分，发现 \(sa_x-sa_{x-1}=\sum\limits_{i=0}^{n-1} ([a_i &gt; b_{i+x}]a_i-[a_i &lt; b_{i+x}]a_i-[a_i &gt; b_{i+x-1}]a_i+[a_i &lt; b_{i+x-1}]a_i)\)，发现若 \(a_i \le b_{i+x-1} \le b_{i+x}\) 或 \(b_{i+x-1} \le b_{i+x} \le a_i\) 时，这个式子恰好为 \(0\)，只有当 \(b_{i+x-1} &lt; a_i &lt; b_{i+x}\) 时，这个式子的值为 \(-2a_i\)，而这个 \(x\) 又是唯一的。于是对于每个 \(a_i\) 求出这个唯一的 \(x\)，在差分数组上直接修改即可。 我们依次考虑每个 \(b_i\)，发现当 \(x\) 小于某个值时，\(b_i\) 对 \(sb_x\) 的贡献是负的，否则是正的。于是我们求出这个值，然后区间加贡献即可。这个也可以用差分简单的实现。 发现求 \(sa_x,sb_x\) 在实现的过程中都需要差分，不需要分开计算。 时间复杂度 \(O(n\log n)\)。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;int read()&#123; register int x = 0; register char ch = getchar(), f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 200005int n, ansi, ansid[N];long long m, ans[N &lt;&lt; 1], Ans;struct node&#123; long long v; int id; bool operator &lt; (const node &amp;rhs) const &#123; return v &lt; rhs.v; &#125;&#125;a[N], b[N * 3];long long abs(long long a)&#123; return a &gt; 0 ? a : -a;&#125;void add(int l, int r, long long v)&#123; ans[l] += v, ans[r] -= v;&#125;int main()&#123; m = read(), n = read(); for (register int i = 0; i &lt; n; ++i) a[i].v = read(), a[i].id = i; for (register int i = 0; i &lt; n; ++i) b[i].v = read(), b[i].id = i; std :: sort(a, a + n), std :: sort(b, b + n); for (register int i = 0; i &lt; n; ++i) a[i].v += m; for (register int i = 0; i &lt; (n &lt;&lt; 1); ++i) b[i + n] = b[i], b[i + n].v += m; for (register int i = 0; i &lt; n; ++i) ans[0] += a[i].v; for (register int i = 0; i &lt; n; ++i)&#123; int j = std :: lower_bound(b, b + 3 * n, a[i]) - b; if (j &gt; i &amp;&amp; j &lt;= i + (n &lt;&lt; 1)) ans[j - i] -= 2 * a[i].v; &#125; for (register int j = 0; j &lt; 3 * n; ++j)&#123; if (j &lt; n)&#123; add(0, j + 1, -b[j].v); continue; &#125; if (j &gt;= (n &lt;&lt; 1))&#123; add(j - n + 1, (n &lt;&lt; 1) + 1, b[j].v); continue; &#125; int i = std :: upper_bound(a, a + n, b[j]) - a; add(j - i + 1, j + 1, b[j].v), add(j - n + 1, j - i + 1, -b[j].v); &#125; Ans = ans[0], ansi = 0; for (register int i = 1; i &lt;= (n &lt;&lt; 1); ++i)&#123; ans[i] += ans[i - 1]; if (ans[i] &lt; Ans) Ans = ans[i], ansi = i; &#125; for (register int i = 0; i &lt; n; ++i) ansid[a[i].id] = b[(i + ansi) % n].id; printf("%lld\n", Ans); for (register int i = 0; i &lt; n; ++i) printf("%d ", ansid[i] + 1);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1214E」Petya and Construction Set]]></title>
    <url>%2Fcf1214e-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 构造一个 \(2n-1\) 个节点的树，满足 \(\forall i\in [1,n] : dis(2i-1,2i)=d_i\)，\(dis(x,y)\) 表示树上 \(x\) 到 \(y\) 的距离，\(d_i\) 是给定的。 \(n\le 10^5\) 题解 将 \(d_i\) 从大到小排序，然后依次把所有奇数连成一条链（按对应的 \(d_i\) 从大到小的顺序）。 然后依次考虑链上每个点对应的偶数点的位置。假设这个点是链上第 \(k\) 个点，对应的 \(d_i\) 记为 \(D\)，那么显然只要把这个偶数点挂在链上第 \(k+D-1\) 个点下面即可。要注意的是，如果第 \(k+D-1\) 个点是链上最后一个点，那么再挂一个点要把链进行“扩充”。可以证明，在处理第 \(k\) 个点时，链上一定存在 \(k+D-1\) 个点（根据 \(d_i\) 从大到小进行证明）。 代码 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char ch = getchar(), f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;int n, cnt, id[100005];std :: pair&lt;int, int&gt; d[100005];int main()&#123; n = read(); for (register int i = 1; i &lt;= n; ++i) d[i].first = -read(), d[i].second = i; std :: sort(d + 1, d + 1 + n); for (register int i = 1; i &lt;= n; ++i)&#123; if (i &lt; n) printf("%d %d\n", 2 * d[i].second - 1, 2 * d[i + 1].second - 1); int x = i - d[i].first - 1; if (x &lt;= n) printf("%d %d\n", 2 * d[x].second - 1, 2 * d[i].second); else printf("%d %d\n", id[x - n], 2 * d[i].second); if (x - n == cnt) id[++cnt] = 2 * d[i].second; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1214D」Treasure Island]]></title>
    <url>%2Fcf1214d-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定一个 \(n\times m\) 的地图，每个格子要么是障碍，要么是空格。你可以把除 \((1,1)\) 和 \((n,m)\) 外的若干个格子变成障碍，求使得 \((1,1)\) 到 \((n,m)\) 没有路径最少需要把几个格子变成障碍。 \(3\le n\cdot m\le 10^6\) 题解 答案只可能是 \(0,1,2\) 中的一种。 \(0\) 可以直接判；\(1\) 就是 \((1,1)\) 能走到 \((n,m)\) 但必须都经过某个格子 \((x,y)\)；否则就是 \(2\)。 那么只要找出一条路径，若找不到就是 \(0\)；然后再找一条强制不经过第一条路径中的点的路径，若找不到就是 \(1\)；否则就是 \(2\)。 吐槽一句：我一开始写了个求起点、终点到某个点的路径数量，然后用乘法原理判断，只可惜这东西要取模，于是愉快地 WA on 233 了（Submission #60334654） 代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;int n, m, a[1000005];char t[1000005];int get(int *a, int i, int j)&#123; if (i &lt; 1 || j &lt; 1 || i &gt; n || j &gt; m) return 0; return a[(i - 1) * m + j];&#125;void set(int *a, int i, int j, int v)&#123; a[(i - 1) * m + j] = v;&#125;void GG(int x)&#123; printf("%d\n", x), exit(0);&#125;void dfs2(int i, int j)&#123; if (i &gt; n || j &gt; m) return; if ((i != 1 || (j != 1)) &amp;&amp; get(a, i, j)) return; if (i == n &amp;&amp; j == m) GG(2); set(a, i, j, 1); dfs2(i + 1, j), dfs2(i, j + 1);&#125;void dfs1(int i, int j)&#123; if (i &gt; n || j &gt; m) return; if ((i != 1 || (j != 1)) &amp;&amp; get(a, i, j)) return; if (i == n &amp;&amp; j == m) dfs2(1, 1), GG(1); set(a, i, j, 1); dfs1(i + 1, j), dfs1(i, j + 1);&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (register int i = 1; i &lt;= n; ++i)&#123; scanf("%s", t + 1); for (register int j = 1; j &lt;= m; ++j) if (t[j] == '#') set(a, i, j, 1); &#125; dfs1(1, 1), GG(0);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder」「JSC 2019 Qual F」Candy Retribution]]></title>
    <url>%2Fatcoder-jsc19qualF-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 求满足以下条件的长度为 \(n\) 的非负整数序列 \(a_1,a_2,a_3,\cdots,a_n\) 的方案数 \(\bmod 10^9+7\) 的值： \(l\le \sum_{i=1}^n a_i\le r\)； 将序列从大到小排序后，记为 \(a_1&#39;,a_2&#39;,a_3&#39;,\cdots,a_n&#39;\)，满足 \(a_m&#39;=a_{m+1}&#39;\)。 \(1\le m &lt; n\le 3\times 10^5,1\le l,r\le 3\times 10^5\) 题解 显然第一个条件可以差分，假设总和的上界为 \(S\)，用隔板法得到不考虑第二个条件的方案数为 \(C_{S+n}^n\)。直接算满足第二个条件的不好算，我们考虑算不满足第二个条件的方案数，然后用总方案数减去即可。 我们枚举从大到小排序后的第 \(m\) 个数为 \(x\)，那么不满足条件的方案数等于在 \(n\) 个位置中选出 \(m\) 个位置使得这 \(m\) 个位置的值 \(\ge x\)，其余 \(n-m\) 个位置的值 \(&lt; x\)，\(n\) 个数总和 \(\le S\) 的方案数，减去在 \(n\) 个位置中选出 \(m\) 个位置使得这 \(m\) 个位置的值 \(\ge x+1\)，其余 \(n-m\) 个位置的值 \(&lt; x\)，\(n\) 个数总和 \(\le S\) 的方案数。 于是问题变成了求在 \(n\) 个位置中选出 \(m\) 个位置使得这 \(m\) 个位置的值 \(\ge a\)，其余 \(n-m\) 个位置的值 \(&lt; b\)，\(n\) 个数总和 \(\le S\) 的方案数。 发现隔板法可以解决的问题的条件是形如 \(a_i\ge lim_i\) 这样的，于是我们把 \(&lt; b\) 的部分容斥成这个形式。于是我们强制 \(i\) 个位置 \(\ge b\)，其他位置随便选。 问题变成了求在 \(n\) 个位置中选出 \(m\) 个位置使得这 \(m\) 个位置的值 \(\ge a\)，在剩余 \(n-m\) 个位置中选 \(i\) 个，使得这 \(i\) 个位置的值 \(\ge b\)，其他 \(n-m-i\) 个位置的值 \(\ge 0\)，总和 \(\le S\) 的方案数。这个问题的答案就是 \(C_{n-m}^i\times C_{S-ma-ib+n}^n\)。再乘上容斥系数 \((-1)^i\) 即可。 由于需要保证 \(ix\le S\)，复杂度是一个调和级数的形式，所以复杂度是 \(O(S\log S)\)。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 600005#define P 1000000007int n, m, l, r, fac[N], inv[N];void inc(int &amp;a, int b)&#123; (a += b) &gt;= P ? a -= P : 0; &#125;void dec(int &amp;a, int b)&#123; (a -= b) &lt; 0 ? a += P : 0; &#125;int plus(int a, int b)&#123; return (a += b) &gt;= P ? a - P : a; &#125;int minus(int a, int b)&#123; return (a -= b) &lt; 0 ? a + P : a; &#125;int qpow(int a, int b = P - 2)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if (b &amp; 1) s = 1ll * s * a % P; return s;&#125;void init(int n)&#123; fac[0] = 1; for (register int i = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % P; inv[n] = qpow(fac[n]); for (register int i = n; i; --i) inv[i - 1] = 1ll * inv[i] * i % P;&#125;int C(int n, int m)&#123; if (n &lt; m) return 0; return 1ll * fac[n] * inv[m] % P * inv[n - m] % P;&#125;int get(int S, int r)&#123; if (S &lt; 0) return 0; int res = 0; for (register int i = 0, t = 0; i &lt;= n - m &amp;&amp; t &lt;= S; t += r, ++i)&#123; int s = 1ll * C(n - m, i) * C(S - t + n, n) % P; if (i &amp; 1) dec(res, s); else inc(res, s); &#125; return 1ll * res * C(n, m) % P;&#125;int solve(int S)&#123; int res = C(S + n, n); for (register int i = 1; i * m &lt;= S; ++i) dec(res, minus(get(S - i * m, i), get(S - (i + 1) * m, i))); return res;&#125;int main()&#123; n = read(), m = read(), l = read(), r = read(); init(n + r); printf("%d\n", minus(solve(r), solve(l - 1)));&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>JSC 2019 Qual</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder」「JSC 2019 Qual E」Card Collector]]></title>
    <url>%2Fatcoder-jsc19qualE-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 一个 \(H\times W\) 的矩阵，有 \(n\) 个位置有卡片，每张卡片上有个数字 \(a_i\)。你可以在每行拿走一张卡片，然后在每列拿走一张卡片，求拿走的卡片的 \(a_i\) 之和的最大值。 \(1\le H,W,n,a_i\le 10^5\) 题解 假设有 \(H+W\) 个点，第 \(1\sim H\) 个点表示行，第 \(H+1\sim H+W\) 个点表示列。第 \(i\) 行第 \(j\) 列的卡片对应一条 \(i\) 到 \(H+j\) 的边，边权为卡片上的数字。我们把所有拿走的卡片对应的边拿出来，显然会形成一个环套树森林。简单证明一下： 假设边是有向的，在第 \(i\) 行选了第 \(j\) 列的卡片，则选择 \(i\) 到 \(H+j\) 的有向边；在第 \(i\) 列选了第 \(j\) 行的卡片，则选择 \(H+i\) 到 \(j\) 的有向边。那么每个点有且仅有一条出边，所以这是一个环套内向树森林。忽略边的方向，则是环套树森林。 相当于我们要求出一个原图的边权之和最大的“生成环套树森林”。用类似于求最大生成树的 Kruskal 算法贪心选边即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;int n, h, w, fa[200005], g[200005];long long ans;struct node&#123; int r, c, v; bool operator &lt; (const node &amp;rhs) const &#123; return v &gt; rhs.v; &#125;&#125;a[100005];int find(int x)&#123; return fa[x] == x ? x : (fa[x] = find(fa[x]));&#125;bool merge(int x, int y)&#123; x = find(x), y = find(y); if (x == y) if (g[x]) return 0; else return g[x] = 1, 1; if (g[x] &amp;&amp; g[y]) return 0; return fa[y] = x, g[x] |= g[y], 1;&#125;int main()&#123; n = read(), h = read(), w = read(); for (register int i = 1; i &lt;= n; ++i) a[i].r = read(), a[i].c = read(), a[i].v = read(); std :: sort(a + 1, a + 1 + n); for (register int i = 1; i &lt;= h + w; ++i) fa[i] = i, g[i] = 0; for (register int i = 1; i &lt;= n; ++i) if (merge(a[i].r, a[i].c + h)) ans += a[i].v; printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>JSC 2019 Qual</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder」「JSC 2019 Qual D」Classified]]></title>
    <url>%2Fatcoder-jsc19qualD-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 有一张 \(n\) 个点的无向完全图 \(G=(V,E)\)，你需要给每条边定一个正整数权值，使得不存在一条回路满足这条回路上的所有边权相等且回路长度为奇数。 你需要最小化最大的权值。请你输出一个解。 \(n\le 500\) 题解 题目里的条件相当于对于每一个权值 \(x\)，记 \(E&#39;\) 为所有边权等于 \(x\) 的边组成的边集，满足 \(G&#39;=(V,E&#39;)\) 是二分图。我们把 \(G&#39;\) 叫做权值为 \(x\) 的子图。 先猜一个结论，假设边权的最大值为 \(k\)，则最大的有解的 \(n\) 为 \(2^k\)。用数学归纳法可以证明： 显然 \(k=1,n=2\) 是有解的，\(k=1,n=3\) 是无解的。 假设我们已经证明了 \(k=t-1,n=2^{t-1}\) 是有解的，\(k=t-1,n=2^{t-1}+1\) 是无解的，我们要证明 \(k=t,n=2^t\) 是有解的，\(k=t,n=2^t+1\) 是无解的。 \(k=t,n=2^t\) 是有解的很好证明，我们只要把这 \(n\) 个点分成两个大小为 \(2^{t-1}\) 的集合，两个集合之间的边边权为 \(t\)，然后只要使得两个集合内部的边边权最大值为 \(t-1\)，则权值为 \(t\) 的子图已经符合条件。而对于两个集合，变成了两个相同的子问题，即 \(k=t-1,n=2^{t-1}\)，我们已经证明了这是有解的，所以 \(k=t,n=2^t\) 也是有解的。 \(k=t,n=2^t+1\) 是无解的也很好证明。假设它是有解的，那么答案中权值为 \(t\) 的子图一定是二分图且这个二分图的两个集合分别有解。由于总点数是 \(2^t+1\)，那么这个二分图的两个集合中一定有一个集合大小 \(\ge 2^{t-1}+1\)。已经证明 \(k=t-1,n=2^{t-1}+1\) 是无解的，与“这个二分图的两个集合分别有解”矛盾，所以 \(k=t,n=2^t+1\) 是无解的。 所以答案为 \(\lceil \log_2 n\rceil\)。考虑构造一个解。我们只要按照一个点的编号二进制下从右往左的第 \(\lceil \log_2 n\rceil\) 位是 \(0\) 还是 \(1\) 分成两个集合，这两个集合之间的边边权设为 \(\lceil \log_2 n\rceil\)，然后递归处理。 我们发现，两个点 \(i,j\) 的边的边权其实就是 \(i\) 与 \(j\) 最高的不同的位从右往左的编号，也就是 \(\lfloor \log_2 (i \text{ xor }j)\rfloor+1\)。 时间复杂度 \(O(n^2)\)。 代码 12345678910#include &lt;cstdio&gt;int n, Log[1005];int main()&#123; scanf("%d", &amp;n); Log[1] = 0; for (register int i = 2; i &lt;= n * 2; ++i) Log[i] = Log[i &gt;&gt; 1] + 1; for (register int i = 0; i &lt; n; ++i) for (register int j = i + 1; j &lt; n; ++j) printf("%d", Log[i ^ j] + 1), putchar(" \n"[j == n - 1]);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>JSC 2019 Qual</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder」「JSC 2019 Qual C」Cell Inversion]]></title>
    <url>%2Fatcoder-jsc19qualC-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 有 \(2n\) 个格子，每个格子初始为黑色或白色。你需要执行恰好 \(n\) 次操作，使得最后所有格子变成白色。每次操作你可以选择两个从未选择过的格子 \(l,r (l &lt; r)\)，然后将区间 \([l,r]\) 的所有格子的颜色取反，即黑色的格子变成白色，白色的格子变成黑色。求方案数 \(\bmod 10^9+7\) 的值。 两个方案不同当且仅当存在一个 \(i\in [1,n]\)，满足第 \(i\) 次操作选择的两个格子至少有一个不同。 \(n\le 10^5\) 题解 我们发现，操作的顺序与最后结果无关，于是我们强制 \(l\) 从小到大，最后乘上 \(m!\) 即可。 从左往右对于每个格子 \(i\)，设 \(m\) 次操作中有 \(x\) 个操作 \(l &lt; r &lt; i\)，有 \(y\) 个操作 \(l &lt; i\le r\)，那么有 \(y=i-1-2x\)，所以 \(y\) 与 \(i-1\) 的奇偶性相同，于是可以直接判断 \(y\) 的奇偶性。若 \(y\) 是偶数，那么执行完所有 \(l &lt; i\) 的操作后，\(i\) 的颜色不会变化，此时若 \(i\) 是黑色，那么一定存在一个操作 \(l = i &lt; r\)，否则一定不存在，即一定存在一个操作 \(l &lt; i = r\)。\(y\) 为偶数同理。 经过上述处理，我们已经知道了每个格子是作为 \(l\) 被选择还是作为 \(r\) 被选择。 我们又发现，两个操作 \(l_1,r_1\) 和 \(l_2,r_2\)（\(l_1 &lt; r_2,l_2 &lt; r_1\)），变成 \(l_1,r_2\) 和 \(l_2,r_1\) 结果也是不变的。 那么我们只要把所有左端点和右端点任意匹配即可。对于每个作为右端点的 \(i\)，记 \([1,i-1]\) 中作为左端点的点的数量减去作为右端点的点的数量为 \(d\)，即多余的左端点个数，那么 \(i\) 可以与这 \(d\) 个左端点中的任意一个进行匹配，答案乘上 \(d\)。最后再乘上 \(m!\) 即可。 时间复杂度 \(O(n)\)。 代码 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define P 1000000007int n, d, ans;char s[200005];int main()&#123; scanf("%d%s", &amp;n, s + 1); for (register int i = 1; i &lt;= (n &lt;&lt; 1); ++i) if ((i &amp; 1) ^ (s[i] == 'B')) s[i] = 'R'; else s[i] = 'L'; ans = 1; for (register int i = 1; i &lt;= (n &lt;&lt; 1); ++i) if (s[i] == 'L') ++d; else&#123; if (!d) return printf("0\n"), 0; ans = 1ll * ans * d % P, --d; &#125; if (d) return printf("0\n"), 0; for (register int i = 1; i &lt;= n; ++i) ans = 1ll * ans * i % P; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>JSC 2019 Qual</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 6079」「2017 山东一轮集训 Day7」养猫]]></title>
    <url>%2Floj6079-sol%2F</url>
    <content type="text"><![CDATA[LOJ 6079 题解 \(n\le 1000\)，还要输出方案，容易想到网络流。首先我们假设每个时刻都选 S，记 \(a_i=s_i-e_i\)，那么问题变成了调整若干个时刻 \(j\)，对于每个长度为 \(k\) 的区间，调整的时刻数量 \(x\) 应该满足 \(me\le x\le k-ms\)，在这个前提下，使得 \(a_j\) 之和尽量小。 考虑这样一个建模方法：源点 \(S\) 向某个点 \(P\) 连 \((k-ms,0)\) 的边（\((x,y)\) 表示流量上界为 \(x\)，费用为 \(y\) 的边，下同），点 \(P\) 向 \([1,k]\) 的点连 \((\infty,0)\) 的边，点 \(i\) 向 \(i+1\) 连 \((k-ms-me,0)\) 的边，\(i\) 向 \(i+k\) 连 \((1,a_i)\) 的边（\(i+1,i+k&gt;n\) 时则向汇点 \(T\) 连边）。然后跑最小费用最大流的结果就是答案。 考虑这样建模为什么是对的。显然流只会从编号小的点流向编号大的点。我们假设从小到大处理每一个点 \(i\)，处理过的点已经满足流量平衡，未处理的点则把入流先“屯”着。有入流的点说明这个点需要调整。对于当前要处理的点 \(i\)，我们发现这个点“屯”着的流量就是 \([i,i+k-1]\) 这个区间中还能放的点数，已经有入流的点属于已经确定的点。由于总流量是 \(k-ms\)，而每个长度为 \(k\) 的区间只考虑 \(i\) 到 \(i+1\) 的边只能流出 \(k-ms-me\) 的流量，所以一定会有至少 \(me\) 个点被调整。（这一段是我自己yy的） 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;struct Graph&#123; const static int N = 2005, M = 10005, INF = 0x3f3f3f3f; int S, T, edge, to[M], pr[M], cap[M], cost[M], hd[N]; Graph()&#123; edge = 0, memset(hd, -1, sizeof hd); &#125; void addedge(int u, int v, int w, int c)&#123; to[edge] = v, cap[edge] = w, cost[edge] = c, pr[edge] = hd[u], hd[u] = edge++; to[edge] = u, cap[edge] = 0, cost[edge] = -c, pr[edge] = hd[v], hd[v] = edge++; &#125; int h, t, Q[1000005], vis[N], mn[N], pre[N]; long long dis[N]; bool SPFA()&#123; memset(dis, 0x3f, sizeof dis), memset(vis, 0, sizeof vis); h = 0, t = 1, Q[t] = S, dis[S] = 0, vis[S] = 1, pre[S] = 0, mn[S] = INF; while (h &lt; t)&#123; int u = Q[++h]; vis[u] = 0; for (register int i = hd[u], v; ~i; i = pr[i]) if (cap[i] &amp;&amp; dis[u] + cost[i] &lt; dis[v = to[i]])&#123; dis[v] = dis[u] + cost[i], mn[v] = std :: min(mn[u], cap[i]), pre[v] = i; if (!vis[v]) Q[++t] = v, vis[v] = 1; &#125; &#125; return dis[T] != dis[N - 1]; &#125; long long MinCostMaxFlow(int _S, int _T)&#123; long long res = 0; S = _S, T = _T; while (SPFA())&#123; res += mn[T] * dis[T]; for (register int i = T; i != S; i = to[pre[i] ^ 1]) cap[pre[i]] -= mn[T], cap[pre[i] ^ 1] += mn[T]; &#125; return res; &#125;&#125;G;int n, k, ms, me, a[1005], E[1005];long long sum;int main()&#123; n = read(), k = read(), ms = read(), me = read(); for (register int i = 1; i &lt;= n; ++i) a[i] = read(), sum += a[i]; for (register int i = 1; i &lt;= n; ++i) a[i] -= read(); for (register int i = 1; i &lt;= n; ++i)&#123; G.addedge(i, i + 1, k - ms - me, 0); E[i] = G.edge; G.addedge(i, std :: min(i + k, n + 1), 1, a[i]); &#125; for (register int i = 1; i &lt;= k; ++i) G.addedge(0, i, Graph :: INF, 0); G.addedge(n + 2, 0, k - ms, 0); printf("%lld\n", sum - G.MinCostMaxFlow(n + 2, n + 1)); for (register int i = 1; i &lt;= n; ++i) if (G.cap[E[i]]) putchar('S'); else putchar('E');&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 6068」「2017 山东一轮集训 Day4」棋盘]]></title>
    <url>%2Floj6068-sol%2F</url>
    <content type="text"><![CDATA[LOJ 6068 题解 这类棋盘上放棋子的问题，且根据这个数据范围，很容易想到网络流。 棋子的攻击方式有两种，我们先考虑同一行。我们把一行中极大的连续的 . 组成的区间叫做行连通块。显然不同的行连通块之间是互不影响的。对于同一个行连通块，假设当前已经有 \(x\) 个棋子，那么再放入一个棋子后就会对答案产生 \(x\) 的贡献。同理我们可以定义列连通块，也同样具有行连通块的性质。显然，每个 . 唯一地属于一个行连通块和列连通块。 那么就有一个初步的建模思路：建立两排点，左边是所有行连通块，右边是所有列连通块，源点 \(S\) 向行连通块连边，列连通块向汇点 \(T\) 连边，对于每个是 . 的位置，我们把包含它的行连通块向包含它的列连通块连边。 假设放入一个棋子对应 \(S\) 到 \(T\) 的一个单位的流量，那么这条路径上边上的费用之和应该是放入这个棋子对答案产生的贡献。对于一个行连通块 \(i\)，假设它的大小为 \(sz_i\)，那么应该从 \(S\) 向 \(i\) 连 \(sz_i\) 条边，第 \(j\) 条边的费用是 \(j-1\)，流量上界是 \(1\)，这样就能保证第 \(j\) 次在这个行连通块放旗子时贡献是 \(j-1\)。列连通块同理。行连通块向列连通块连的边费用为 \(0\)，流量上界为 \(1\)。 于是问题变成了求流量恰好为 \(k\) 时的最小费用。可以发现，在跑费用流时，每次跑 SPFA 增广流量只会恰好增加 \(1\)，于是在跑费用流时从小到大求出每个 \(k\) 的答案即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;struct Graph&#123; const static int N = 5005, M = 100005, INF = 0x3f3f3f3f; int S, T, edge, to[M], pr[M], cap[M], cost[M], hd[N]; Graph()&#123; edge = 0, memset(hd, -1, sizeof hd); &#125; void addedge(int u, int v, int w, int c)&#123; to[edge] = v, cap[edge] = w, cost[edge] = c, pr[edge] = hd[u], hd[u] = edge++; to[edge] = u, cap[edge] = 0, cost[edge] = -c, pr[edge] = hd[v], hd[v] = edge++; &#125; int h, t, Q[1000005], dis[N], vis[N], mn[N], pre[N]; bool SPFA()&#123; memset(dis, 0x3f, sizeof dis), memset(vis, 0, sizeof vis); h = 0, t = 1, Q[t] = S, dis[S] = 0, vis[S] = 1, pre[S] = 0, mn[S] = INF; while (h &lt; t)&#123; int u = Q[++h]; vis[u] = 0; for (register int i = hd[u], v; ~i; i = pr[i]) if (cap[i] &amp;&amp; dis[u] + cost[i] &lt; dis[v = to[i]])&#123; dis[v] = dis[u] + cost[i], mn[v] = std :: min(mn[u], cap[i]), pre[v] = i; if (!vis[v]) Q[++t] = v, vis[v] = 1; &#125; &#125; return dis[T] != INF; &#125; std :: vector&lt;int&gt; MinCostMaxFlow(int _S, int _T)&#123; std :: vector&lt;int&gt; res; res.push_back(0), S = _S, T = _T; while (SPFA())&#123; res.push_back(res[res.size() - 1] + dis[T]); for (register int i = T; i != S; i = to[pre[i] ^ 1]) cap[pre[i]] -= mn[T], cap[pre[i] ^ 1] += mn[T]; &#125; return res; &#125;&#125;G;int n, q, cnt, cntr, cntc, rbel[55][55], cbel[55][55], sz[5005];char a[55][55];std :: vector&lt;int&gt; ans;int main()&#123; n = read(); for (register int i = 1; i &lt;= n; ++i) scanf("%s", a[i] + 1); cntr = 1; for (register int i = 1; i &lt;= n; ++i)&#123; if (sz[cntr]) ++cntr; for (register int j = 1; j &lt;= n; ++j) if (a[i][j] == '.') rbel[i][j] = cntr, ++sz[cntr]; else if (sz[cntr]) ++cntr; &#125; cntc = cntr + 1; for (register int i = 1; i &lt;= n; ++i)&#123; if (sz[cntc]) ++cntc; for (register int j = 1; j &lt;= n; ++j) if (a[j][i] == '.') cbel[j][i] = cntc, ++sz[cntc]; else if (sz[cntc]) ++cntc; &#125; for (register int i = 1; i &lt;= cntr; ++i) for (register int j = 0; j &lt; sz[i]; ++j) G.addedge(0, i, 1, j); for (register int i = cntr + 1; i &lt;= cntc; ++i) for (register int j = 0; j &lt; sz[i]; ++j) G.addedge(i, cntc + 1, 1, j); for (register int i = 1; i &lt;= n; ++i) for (register int j = 1; j &lt;= n; ++j) if (a[i][j] == '.') G.addedge(rbel[i][j], cbel[i][j], 1, 0); ans = G.MinCostMaxFlow(0, cntc + 1); q = read(); while (q--) printf("%d\n", ans[read()]);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 6073」「2017 山东一轮集训 Day5」距离]]></title>
    <url>%2Floj6073-sol%2F</url>
    <content type="text"><![CDATA[LOJ 6073 题解 建议先做下这题的弱弱弱弱弱化版：LOJ #2558. 「LNOI2014」LCA。 设 \(dis_i\) 表示根到 \(i\) 的路径上的边权之和，\(dep_i\) 表示根到 \(i\) 的路径上的点数，答案可以表示成 \[\begin{aligned}\sum_{i\in \text{path}(u,v)}\text{dist}(p_i,k)&amp;=\sum_{i\in \text{path}(u,v)} \left(dis_{p_i}+dis_k-2dis_{\text{LCA}(p_i,k)}\right)\\&amp;=\left(dep_u+dep_v-2dep_{\text{LCA}(u,v)}+1\right)dis_k\\&amp;+\sum_{i\in \text{path}(u,v)} dis_{p_i}-2\sum_{i\in \text{path}(u,v)}dis_{\text{LCA}(p_i,k)}\end{aligned}\] 这个式子的第一项可以在预处理 \(dep_i,dis_i\) 后快速计算，第二项可以预处理根到 \(i\) 的路径上所有 \(dis_j\) 之和（记为 \(sumd_i\)）然后快速计算，关键是最后一项，即计算 \[\sum_{i\in \text{path}(u,v)}dis_{\text{LCA}(p_i,k)}\] 的值。 联系 LOJ #2558. 「LNOI2014」LCA 的做法，我们有了一个初步的暴力做法： 我们设 \(w_i\) 表示 \(i\) 与它父亲的边的边权，对于 \(u\) 到 \(v\) 路径上的每个点 \(i\)，我们把 \(p_i\) 到根的路径上所有点 \(j\) 的“点权”加 \(w_j\)，某个点的“点权”初始为 \(0\)。然后，我们查询根到 \(k\) 路径上所有点的“点权和”，这个值即为上面式子的值。 考虑优化这个暴力。与 LOJ #2558. 「LNOI2014」LCA 相似，我们可以差分。我们把 \(p_i\) 到根的路径上所有点 \(j\) 的“点权”加 \(w_j\) 这样的一次操作叫做对点 \(i\) 的一次操作。那么显然答案可以差分成对 \(u\) 到根路径上每个点进行一次操作后的 \(k\) 到根路径上的“点权”和，加上对 \(v\) 到根路径上每个点进行一次操作后的 \(k\) 到根路径上的“点权”和，减去对 \(\text{LCA}(u,v)\) 到根路径上每个点进行一次操作后的 \(k\) 到根路径上的“点权”和，减去对 \(\text{LCA}(u,v)\) 的父亲到根路径上每个点进行一次操作后的 \(k\) 到根路径上的“点权”和。注意上面四个操作都是在初始状态下进行的，并不是从上一个操作继承下来的。 四个操作我们可以对每个节点维护一棵线段树，第 \(i\) 个点的线段树维护对 \(i\) 到根路径上每个点进行一次操作后的区间的“点权”之和，注意这里的区间是指树剖后 DFS 序上的区间。求 \(k\) 到根路径上的点权和可以树链剖分后在线段树上 \(O(\log^2n)\) 得到。每个点的线段树可以从它父亲那里继承过来，即可持久化线段树，注意这里需要支持可持久化的区间修改、区间查询，线段树的写法与普通线段树有一些区别。 时间复杂度 \(O(n\log^2n)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;long long read()&#123; register long long x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 200005int type, n, q, p[N];int edge, to[N &lt;&lt; 1], tw[N &lt;&lt; 1], pr[N &lt;&lt; 1], hd[N];void addedge(int u, int v, int w)&#123; to[++edge] = v, tw[edge] = w, pr[edge] = hd[u], hd[u] = edge;&#125;long long dis[N], pre[N], sumd[N], ans;int fa[N], sz[N], dep[N], son[N], top[N], idx, dfn[N], id[N];void dfs(int u)&#123; dep[u] = dep[fa[u]] + 1, sz[u] = 1; for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa[u]) fa[v] = u, dis[v] = dis[u] + tw[i], dfs(v), sz[u] += sz[v], !son[u] || sz[v] &gt; sz[son[u]] ? son[u] = v : 0;&#125;void dfs(int u, int tp)&#123; top[u] = tp, dfn[u] = ++idx, id[idx] = u, pre[idx] = dis[u] - dis[fa[u]]; if (son[u]) dfs(son[u], tp); for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa[u] &amp;&amp; v != son[u]) dfs(v, v);&#125;struct Chairman_Tree&#123; int cnt, ls[N * 150], rs[N * 150], lz[N * 150]; long long sum[N * 150]; void modify(int &amp;u, int _u, int l, int r, int L, int R)&#123; u = ++cnt, ls[u] = ls[_u], rs[u] = rs[_u], sum[u] = sum[_u], lz[u] = lz[_u]; if (L == l &amp;&amp; r == R) return ++lz[u], void(0); sum[u] += pre[R] - pre[L - 1]; int md = (l + r) &gt;&gt; 1; if (R &lt;= md) modify(ls[u], ls[_u], l, md, L, R); else if (L &gt; md) modify(rs[u], rs[_u], md + 1, r, L, R); else modify(ls[u], ls[_u], l, md, L, md), modify(rs[u], rs[_u], md + 1, r, md + 1, R); &#125; long long query(int u, int l, int r, int L, int R)&#123; if (!u) return 0; if (L == l &amp;&amp; r == R) return sum[u] + 1ll * lz[u] * (pre[R] - pre[L - 1]); long long tmp = 1ll * lz[u] * (pre[R] - pre[L - 1]); int md = (l + r) &gt;&gt; 1; if (R &lt;= md) return tmp + query(ls[u], l, md, L, R); else if (L &gt; md) return tmp + query(rs[u], md + 1, r, L, R); else return tmp + query(ls[u], l, md, L, md) + query(rs[u], md + 1, r, md + 1, R); &#125;&#125;T;int rt[N];void update(int u)&#123; int _u = u; u = p[u]; while (top[u] != 1)&#123; T.modify(rt[_u], rt[_u], 1, n, dfn[top[u]], dfn[u]); u = fa[top[u]]; &#125; T.modify(rt[_u], rt[_u], 1, n, 1, dfn[u]);&#125;void build(int u)&#123; rt[u] = rt[fa[u]], update(u), sumd[u] = sumd[fa[u]] + dis[p[u]]; for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa[u]) build(v);&#125;int lca(int u, int v)&#123; while (top[u] != top[v])&#123; if (dep[top[u]] &lt; dep[top[v]]) std :: swap(u, v); u = fa[top[u]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;long long query(int rt, int u)&#123; long long res = 0; while (top[u] != 1)&#123; res += T.query(rt, 1, n, dfn[top[u]], dfn[u]); u = fa[top[u]]; &#125; res += T.query(rt, 1, n, 1, dfn[u]); return res;&#125;int main()&#123; type = read(); n = read(), q = read(); for (register int i = 1, u, v, w; i &lt; n; ++i) u = read(), v = read(), w = read(), addedge(u, v, w), addedge(v, u, w); for (register int i = 1; i &lt;= n; ++i) p[i] = read(); dfs(1), dfs(1, 1); for (register int i = 1; i &lt;= n; ++i) pre[i] += pre[i - 1]; build(1); while (q--)&#123; int u = read() ^ (type * ans), v = read() ^ (type * ans), k = read() ^ (type * ans); int l = lca(u, v); ans = sumd[u] + sumd[v] - sumd[l] - sumd[fa[l]]; ans += 1ll * (dep[u] + dep[v] - dep[l] - dep[fa[l]]) * dis[k]; ans -= 2 * (query(rt[u], k) + query(rt[v], k) - query(rt[l], k) - query(rt[fa[l]], k)); printf("%lld\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>可持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 6077」「2017 山东一轮集训 Day7」逆序对]]></title>
    <url>%2Floj6077-sol%2F</url>
    <content type="text"><![CDATA[LOJ 6077 题解 考虑已经有一个 \([1,i-1]\) 的排列，我们把 \(i\) 这个数插进去，会使得逆序对数量加 \(x_i\)，其中 \(x_i\in [0,i)\)。那么问题转化成求 \(\sum_{i=1}^n x_i=k\) 的解的数量，满足 \(\forall i\in [1,n]:0\le x_i &lt; i\)。 考虑容斥，枚举不满足条件的位置个数 \(i\) 和位置 \(p_1,p_2,p_3,\cdots,p_i\)，那么问题变成了有若干个有 \(n\) 个条件，其中有 \(i\) 个条件是 \(x_{p_j}\ge p_j\)，其他条件是 \(x_j\ge 0\)。我们让 \(k\) 减去 \(p_1+p_2+p_3+\cdots+p_i\) 的值，就变成了一个经典的隔板法求不定方程非负整数解的数量的问题。即答案是 \[ans=\sum_{i=0}^{n}(-1)^i\sum_{p_1 &lt; p_2 &lt; p_3 &lt; \cdots &lt; p_i} C_{n-1+k-\sum_{j=1}^i p_j}^{n-1}\] 我们发现后面的组合数式子不需要关心 \(p_j\) 具体的值，只需要知道 \(\sum_{j=1}^i p_j\) 即可。于是我们枚举这个值，式子变成了 \[ans=\sum_{i=0}^n(-1)^i\sum_{j=0}^{k}F_{i,j}C_{k-j+n-1}^{n-1}\] 其中 \(F_{i,j}\) 表示选 \(i\) 个互不相同的数，且这些数在 \([1,n]\) 的范围内，使得这 \(i\) 个数和为 \(j\) 的方案数。又可以注意到，因为 \(i\) 个数要互不相同，所以当 \(j &lt; \frac{i(i+1)}{2}\) 时，\(F_{i,j}=0\)。又因为 \(j\) 不能超过 \(k\)，所以 \(i\) 只需要枚举到 \(\lfloor\sqrt{2k}\rfloor\) 即可。而组合数可以 \(O(n+k)\) 预处理阶乘及阶乘的逆元，然后 \(O(1)\) 计算。那么关键问题是如何求 \(F_{i,j}\)。 这是经典的整数划分问题。假设当前有 \(i\) 个数，和为 \(j\)，那么有两种决策： 把所有数加 \(1\)，和变成了 \(i+j\)； 在最前面加上一个数 \(1\)，并把其他所有数加 \(1\)，个数变成 \(i+1\)，和变成 \(i+j+1\)。 可以证明所有方案都可以通过这两种变换唯一的遍历到。但是有些方案中会存在某个数大于 \(n\) 的情况，需要减去。又因为所有数互不相同，且变换之前的方案是合法的，所以这个不合法的方案一定只会存在一个大于 \(n\) 的数且这个数是 \(n+1\)。那么这种不合法的方案数一定与去掉 \(n+1\) 这个数后序列的方案数相等，直接减去即可。DP 的转移方程是 \[F_{i,j}=F_{i,j-i}+F_{i-1,j-i}-F_{i-1,j-n-1}\] 可以直接带上容斥系数，变成 \[F_{i,j}=F_{i,j-i}-F_{i-1,j-i}+F_{i-1,j-n-1}\] 处理完后直接计算即可。时间复杂度 \(O(n\sqrt{n})\)。 还有一种用生成函数推导答案式子的方法，可以参考 Trisolaris's Blog。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 100005#define P 1000000007int n, k, fac[N &lt;&lt; 1], inv[N &lt;&lt; 1], t, F[455][N], f[N], ans;void inc(int &amp;a, int b)&#123; (a += b) &gt;= P ? a -= P : 0;&#125;void dec(int &amp;a, int b)&#123; (a -= b) &lt; 0 ? a += P : 0;&#125;int qpow(int a, int b = P - 2)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if (b &amp; 1) s = 1ll * s * a % P; return s;&#125;void init(int n, int k)&#123; fac[0] = 1; for (register int i = 1; i &lt;= n + k; ++i) fac[i] = 1ll * fac[i - 1] * i % P; inv[n + k] = qpow(fac[n + k]); for (register int i = n + k; i; --i) inv[i - 1] = 1ll * inv[i] * i % P; t = std :: min(n, int(sqrt(2 * k)) + 1); F[0][0] = 1, f[0] = 1; for (register int i = 1; i &lt;= t; ++i) for (register int j = i * (i + 1) &gt;&gt; 1; j &lt;= k; ++j)&#123; dec(F[i][j], F[i - 1][j - i]), inc(F[i][j], F[i][j - i]); if (j &gt;= n + 1) inc(F[i][j], F[i - 1][j - n - 1]); inc(f[j], F[i][j]); &#125;&#125;int C(int n, int m)&#123; return 1ll * fac[n] * inv[m] % P * inv[n - m] % P;&#125;int main()&#123; n = read(), k = read(); init(n, k); for (register int i = 0; i &lt;= k; ++i) inc(ans, 1ll * f[i] * C(k - i + n - 1, n - 1) % P); printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 6066」「2017 山东一轮集训 Day3」第二题]]></title>
    <url>%2Floj6066-sol%2F</url>
    <content type="text"><![CDATA[LOJ 6066 题解 答案具有单调性，于是二分 \(k\)，问题转化成： 是否存在两个点 \(u,v\) 满足 \(u\) 的 \(k-\) 子树与 \(v\) 的 \(k-\) 子树形态相同。 解决这样的问题可以使用哈希，那么我们需要找到一种哈希的方式使得“形态”相同的树的哈希值相同，“形态”不同的树的哈希值不同。 由于节点标号与树的形态无关，儿子的顺序与树的形态有关，容易想到括号序列。于是问题变成： 在以 \(u\) 为根的子树对应的括号序列中，删去所有与 \(u\) 距离 \(k+1\) 的点为根的子树对应的括号序列后，求哈希值。 由于每个点只会在 \(k+1\) 级祖先处被遍历，所以求所有 \(k-\) 子树的哈希值是 \(O(n)\) 的。 求每个点的 \(k+1\) 级祖先可以使用倍增做到 \(O(n\log n)\) 或用长链剖分做到 \(O(n)\)。 总时间复杂度 \(O(n\log^2 n)\)。 代码 我使用了双哈希 + set 的方式进行判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;namespace Double_Hash&#123; static const int N = 200005, B1 = 233, P1 = 382538579, B2 = 331, P2 = 952959323; int pw1[N], pw2[N]; struct node&#123; int H1, H2; node(int _H1 = 0, int _H2 = 0)&#123; H1 = _H1, H2 = _H2; &#125; bool operator == (const node &amp;rhs) const &#123; return H1 == rhs.H1 &amp;&amp; H2 == rhs.H2; &#125; bool operator &lt; (const node &amp;rhs) const &#123; return H1 &lt; rhs.H1 || (H1 == rhs.H1 &amp;&amp; H2 &lt; rhs.H2); &#125; node operator + (const char ch) const &#123; return node((1ll * H1 * B1 + ch) % P1, (1ll * H2 * B2 + ch) % P2); &#125; node operator + (const node &amp;rhs) const &#123; return node((H1 + rhs.H1) % P1, (H2 + rhs.H2) % P2); &#125; node operator - (const node &amp;rhs) const &#123; return node((H1 - rhs.H1 + P1) % P1, (H2 - rhs.H2 + P2) % P2); &#125; node operator &lt;&lt; (const int x) const &#123; return node(1ll * H1 * pw1[x] % P1, 1ll * H2 * pw2[x] % P2); &#125; &#125;h[N]; void pre(int n = N - 1)&#123; pw1[0] = 1, pw2[0] = 1; for (register int i = 1; i &lt;= n; ++i) pw1[i] = 1ll * pw1[i - 1] * B1 % P1, pw2[i] = 1ll * pw2[i - 1] * B2 % P2; &#125; node hash(int l, int r)&#123; return h[r] - (h[l - 1] &lt;&lt; (r - l + 1)); &#125; void build(char *a, int n)&#123; for (register int i = 1; i &lt;= n; ++i) h[i] = h[i - 1] + a[i]; &#125;&#125;using namespace Double_Hash;#define N 100005int n, fa[N][20], idx, l[N], r[N], dis[N];char a[N &lt;&lt; 1];std :: vector&lt;int&gt; son[N], po[N];std :: set&lt;node&gt; S;void dfs(int u)&#123; dis[u] = 0, l[u] = ++idx, a[idx] = 23; for (register int i = 1; i &lt;= 18; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (register int i = 0, v; i &lt; son[u].size(); ++i) v = son[u][i], fa[v][0] = u, dfs(v), dis[u] = std :: max(dis[u], dis[v] + 1); r[u] = ++idx, a[idx] = 97;&#125;int kth_fa(int u, int k)&#123; for (register int i = 0; i &lt;= 18; ++i) if (k &gt;&gt; i &amp; 1) u = fa[u][i]; return u;&#125;bool check(int k)&#123; for (register int i = 1; i &lt;= n; ++i) po[i].clear(); for (register int i = 1; i &lt;= n; ++i) po[i].push_back(l[i]), po[i].push_back(r[i] + 1); for (register int i = 1; i &lt;= n; ++i)&#123; int p = kth_fa(i, k + 1); if (p) po[p].push_back(l[i]), po[p].push_back(r[i] + 1); &#125; for (register int i = 1; i &lt;= n; ++i) std :: sort(po[i].begin(), po[i].end()); S.clear(); for (register int i = 1; i &lt;= n; ++i) if (dis[i] &gt;= k)&#123; node tmp; for (register int j = 0; j &lt; po[i].size(); j += 2) tmp = (tmp &lt;&lt; (po[i][j + 1] - po[i][j])) + hash(po[i][j], po[i][j + 1] - 1); if (S.count(tmp)) return 1; S.insert(tmp); &#125; return 0;&#125;int main()&#123; n = read(); for (register int i = 1; i &lt;= n; ++i)&#123; int k = read(); for (register int j = 1; j &lt;= k; ++j) son[i].push_back(read()); &#125; dfs(1); pre(n &lt;&lt; 1), build(a, n &lt;&lt; 1); int l = 0, r = n, md, ans = 0; while (l &lt;= r) if (check(md = (l + r) &gt;&gt; 1)) l = md + 1, ans = md; else r = md - 1; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>括号序列</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 6074」「2017 山东一轮集训 Day6」子序列]]></title>
    <url>%2Floj6074-sol%2F</url>
    <content type="text"><![CDATA[LOJ 6074 题解 设字符集大小为 \(m\)，这里 \(m=9\)，假设字符从 \(0\) 开始标号。 显然可以 DP，设 \(dp_{i,j}\) 表示前 \(i\) 个字符中，以字符 \(j\) 结尾的本质不同的子序列个数。特殊地，\(j=m\) 表示子序列为空。有方程： \[dp_{i,j}=\begin{cases}dp_{i-1,j} &amp; \text{ if } j\ne S_i \\ \sum_{k=0}^{m} dp_{i-1,k} &amp; \text{ if }j=S_i\end{cases}\] 初始值是 \(dp_{0,m}=1\)。 发现 \(dp\) 数组可以写成行向量，记 \[F_i=\begin{pmatrix}dp_{i,0} &amp; dp_{i,1} &amp; dp_{i,2} &amp; \cdots &amp; dp_{i,m}\end{pmatrix}\] 而转移可以表示为一个行向量乘上转移矩阵 \(M_i\) 的形式： \[\begin{aligned}M_i &amp;= \begin{pmatrix}1 &amp; &amp; 1 &amp; &amp; \\ &amp; 1 &amp; 1 &amp; &amp; \\ &amp; &amp; 1 &amp; &amp; \\ &amp; &amp; \vdots &amp; \ddots &amp; \\ &amp; &amp; 1 &amp; &amp; 1 \end{pmatrix} \\ F_i &amp;= F_{i-1}M_i\end{aligned}\] \(M_i\) 是一个主对角线为 \(1\)，\(S_i\) 这一列为 \(1\)，其余为 \(0\) 的矩阵。 初始的行向量为 \[A=\begin{pmatrix}0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 1\end{pmatrix}\] 最后由于是求 \[\left(\sum_{i=0}^m dp_{n,i}\right)-1\] 所以最后需要乘上列向量 \[B=\begin{pmatrix}1 \\ 1 \\ 1 \\ \vdots \\ 1\end{pmatrix}\] 于是对于每个询问，答案可以表示成 \[\begin{aligned}ans&amp;=AM_lM_{l+1}M_{l+2}\cdots M_{r}B\\&amp;=AM_{l-1}^{-1}M_{l-2}^{-1}\cdots M_1^{-1}M_1M_2\cdots M_{r}B\end{aligned}\] 直接维护 \(M_i\) 和 \(M_i^{-1}\) 的前缀积（注意顺序），时间复杂度 \(O(nm^3+qm^3)\)。 在维护完 \(M_i\) 和 \(M_i^{-1}\) 后，分别右乘一个 \(B\) 和左乘一个 \(A\)，这样询问部分的复杂度可以降到 \(O(qm)\)。 预处理部分，我们来观察一些特殊性质。对于 \(M_i\) 的前缀积，我们发现每次要算 \[\begin{aligned}CM_i&amp;=\begin{pmatrix}C_{0,0} &amp; C_{0,1} &amp; C_{0,2} &amp; \cdots &amp; C_{0,m} \\ C_{1,0} &amp; C_{1,1} &amp; C_{1,2} &amp; \cdots &amp; C_{1,m} \\ C_{2,0} &amp; C_{2,1} &amp; C_{2,2} &amp; \cdots &amp; C_{2,m} \\ &amp; &amp; &amp; \ddots &amp; \\ C_{m,0} &amp; C_{m,1} &amp; C_{m,2} &amp; \cdots &amp; C_{m,m} \end{pmatrix}\begin{pmatrix}1 &amp; &amp; 1 &amp; &amp; \\ &amp; 1 &amp; 1 &amp; &amp; \\ &amp; &amp; 1 &amp; &amp; \\ &amp; &amp; \vdots &amp; \ddots &amp; \\ &amp; &amp; 1 &amp; &amp; 1 \end{pmatrix} \\ &amp;= \begin{pmatrix}C_{0,0} &amp; C_{0,1} &amp; \sum_{j=0}^m C_{0,j} &amp; \cdots &amp; C_{0,m} \\ C_{1,0} &amp; C_{1,1} &amp; \sum_{j=0}^m C_{1,j} &amp; \cdots &amp; C_{1,m} \\ C_{2,0} &amp; C_{2,1} &amp; \sum_{j=0}^m C_{2,j} &amp; \cdots &amp; C_{2,m} \\ &amp; &amp; &amp; \ddots &amp; \\ C_{m,0} &amp; C_{m,1} &amp; \sum_{j=0}^m C_{m,j} &amp; \cdots &amp; C_{m,m} \end{pmatrix}\end{aligned}\] 相当于把 \(C\) 的第 \(S_i\) 列改成对应行的 \(C_{k,j}\) 之和。且最后乘上 \(B\) 相当于求每行的和。那么只要维护 \(C\) 的每一行之和即可。于是维护 \(M_i\) 的前缀积乘上 \(B\) 的复杂度变成了 \(O(nm)\)。 对于 \(M_i^{-1}\) 的前缀积，我们先根据矩阵求逆的过程手动求出 \(M_i^{-1}\)，发现 \[M_i^{-1}=\begin{pmatrix}1 &amp; &amp; -1 &amp; &amp; \\ &amp; 1 &amp; -1 &amp; &amp; \\ &amp; &amp; 1 &amp; &amp; \\ &amp; &amp; \vdots &amp; \ddots &amp; \\ &amp; &amp; -1 &amp; &amp; 1 \end{pmatrix}\] 即 \(M_i^{-1}\) 是主对角线为 \(1\)，第 \(S_i\) 列除了第 \(S_i\) 行外是 \(-1\) 的矩阵。 维护 \(M_i^{-1}\) 的前缀积时，我们要算 \[\begin{aligned}M_i^{-1}C&amp;=\begin{pmatrix}1 &amp; &amp; -1 &amp; &amp; \\ &amp; 1 &amp; -1 &amp; &amp; \\ &amp; &amp; 1 &amp; &amp; \\ &amp; &amp; \vdots &amp; \ddots &amp; \\ &amp; &amp; -1 &amp; &amp; 1 \end{pmatrix}\begin{pmatrix}C_{0,0} &amp; C_{0,1} &amp; C_{0,2} &amp; \cdots &amp; C_{0,m} \\ C_{1,0} &amp; C_{1,1} &amp; C_{1,2} &amp; \cdots &amp; C_{1,m} \\ C_{2,0} &amp; C_{2,1} &amp; C_{2,2} &amp; \cdots &amp; C_{2,m} \\ &amp; &amp; &amp; \ddots &amp; \\ C_{m,0} &amp; C_{m,1} &amp; C_{m,2} &amp; \cdots &amp; C_{m,m} \end{pmatrix} \\ &amp;= \begin{pmatrix}C_{0,0}-C_{2,0} &amp; C_{0,1}-C_{2,1} &amp; C_{0,2}-C_{2,2} &amp; \cdots &amp; C_{0,m}-C_{2,m} \\ C_{1,0}-C_{2,0} &amp; C_{1,1}-C_{2,1} &amp; C_{1,2}-C_{2,2} &amp; \cdots &amp; C_{1,m}-C_{2,m} \\ C_{2,0} &amp; C_{2,1} &amp; C_{2,2} &amp; \cdots &amp; C_{2,m} \\ &amp; &amp; &amp; \ddots &amp; \\ C_{m,0}-C_{2,0} &amp; C_{m,1}-C_{2,1} &amp; C_{m,2}-C_{2,2} &amp; \cdots &amp; C_{m,m}-C_{2,m} \end{pmatrix}\end{aligned}\] 可以发现，每一列除了 \(S_i\) 这一行以外都减去的是同一个数，于是我们维护每一列减去的数，例如对于某一列 \[\begin{pmatrix}x_0-v \\ x_1-v \\ x_2-v \\ \vdots \\ x_m-v \end{pmatrix}\] 要变成 \[\begin{pmatrix}x_0-v-(x_2-v) \\ x_1-v-(x_2-v) \\ x_2-v \\ \vdots \\ x_m-v-(x_2-v) \end{pmatrix}==\begin{pmatrix}x_0-x_2 \\ x_1-x_2 \\ (2x_2-v)-x_2 \\ \vdots \\ x_m-x_2 \end{pmatrix}\] 于是只需要修改第 \(S_i\) 那一行的值，并且更新每一列减去的值即可。 最后左乘 \(A\) 相当于求最后一行的值。由于最后一行不会修改，始终是 \[\begin{pmatrix}0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 1\end{pmatrix}\] 所以直接减去对应列需要减的数即可。这一部分的时间复杂度也变成了 \(O(nm)\)。 总时间复杂度 \(O(nm+qm)\)。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 100005#define P 1000000007int n, q, a[10][10], av[10][10], f[N][10], fv[N][10];char s[N];int plus(int a, int b)&#123; return (a += b) &gt;= P ? a - P : a;&#125;int minus(int a, int b)&#123; return (a -= b) &lt; 0 ? a + P : a;&#125;void init(int n)&#123; for (register int i = 0; i &lt;= 9; ++i) a[i][i] = av[i][i] = f[0][i] = 1; for (register int i = 1; i &lt;= n; ++i)&#123; int t = s[i] - 'a'; for (register int j = 0; j &lt;= 9; ++j)&#123; f[i][j] = plus(minus(f[i - 1][j], a[j][t]), f[i - 1][j]); a[j][t] = f[i - 1][j]; fv[i][j] = av[t][j]; av[t][j] = minus(plus(av[t][j], av[t][j]), fv[i - 1][j]); &#125; &#125; for (register int i = 0; i &lt;= n; ++i) for (register int j = 0; j &lt;= 9; ++j) fv[i][j] = minus(j == 9, fv[i][j]);&#125;int main()&#123; while (islower(s[++n] = getchar())) ; --n; init(n); q = read(); while (q--)&#123; int l = read(), r = read(), ans = 0; for (register int i = 0; i &lt;= 9; ++i) ans = plus(ans, 1ll * fv[l - 1][i] * f[r][i] % P); printf("%d\n", minus(ans, 1)); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>矩阵乘法</tag>
        <tag>矩阵求逆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 6065」「2017 山东一轮集训 Day3」第一题]]></title>
    <url>%2Floj6065-sol%2F</url>
    <content type="text"><![CDATA[LOJ 6065 题解 总的分为两种情况：\(1+1+2+2\) 和 \(1+1+1+3\)。 对于第一种情况，我们假设边长为 \(k\)，\(6\) 根棒子长度为 \(k,k,x_1,k-x_1,x_2,k-x_2\)，并且强制 \(x_1\ge x_2\ge k-x_2\ge k-x_1\)。 我们记 \(cnt_i\) 表示长度为 \(i\) 的棒子的数量，我们从小到大枚举 \(x_1\)，同时维护 \(cntt_i\) 表示在长度小于 \(x_1\) 的棒子中选出两根拼成长度为 \(i\) 的方案数。 具体计算的时候，为了避免算重，我们分三种情况进行计算： \(x_1 &gt; x_2 &gt; k-x_2 &gt; k-x_1\)，枚举 \(k\)，方案数为 \(cnt_{x_1}\times cnt_{k-x_1}\times cntt_{k}\times C_{cnt_k}^2\)； \(x_1 = x_2 &gt; k-x_2 = k-x_1\)，同样枚举 \(k\)，方案数为 \(C_{cnt_{x_1}}^2\times C_{cnt_{k-x_1}}^2\times C_{cnt_k}^2\)； \(x_1 = x_2 = k-x_2 = k-x_1\)，此时 \(k=2x_1\)，方案数为 \(C_{cnt_{x_1}}^4\times C_{cnt_{2x_1}}^2\)。 对于第二种情况，假设棒子长度为 \(k,k,k,x_1,x_2,k-x_1-x_2\)，强制 \(x_1\ge x_2\ge k-x_1-x_2\)。 同样记录 \(cnt_i\)，然后从小到大枚举 \(x_1\)，同时记录 \(cntt_i\)。 也分为三种情况： \(x_1 &gt; x_2 &gt; k-x_1-x_2\)，枚举 \(k\)，方案数为 \(cnt_{x_1}\times cntt_{k-x_1}\times C_{cnt_k}^3\)； \(x_1 = x_2 &gt; k-x_1-x_2\)，枚举 \(k\)，方案数为 \(C_{cnt_{x_1}}^2\times cnt_{k-2x_1}\times C_{cnt_k}^3\)； \(x_1 = x_2 = k-x_1-x_2\)，此时 \(k=3x_1\)，方案数为 \(C_{cnt_{x_1}}^3\times C_{cnt_{3x_1}}^3\)。 时间复杂度 \(O(n^2)\)。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;int read()&#123; register int x = 0; register char ch = getchar(), f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 5005#define M 10000005int n, m, a[N], cnt[M], cntt[M];long long ans;long long C2(long long x)&#123; return x &lt; 2 ? 0 : x * (x - 1) / 2; &#125;long long C3(long long x)&#123; return x &lt; 3 ? 0 : x * (x - 1) * (x - 2) / 6; &#125;long long C4(long long x)&#123; return x &lt; 4 ? 0 : x * (x - 1) * (x - 2) * (x - 3) / 24; &#125;int main()&#123; n = read(); for (register int i = 1; i &lt;= n; ++i) a[i] = read(), ++cnt[a[i]]; std :: sort(a + 1, a + 1 + n); m = a[n]; n = std :: unique(a + 1, a + 1 + n) - a - 1; for (register int i = 1; i &lt;= n; ++i)&#123; for (register int j = i + 1; j &lt;= n &amp;&amp; a[j] - a[i] &lt; a[i]; ++j) ans += 1ll * cntt[a[j]] * cnt[a[i]] * cnt[a[j] - a[i]] * C2(cnt[a[j]]), ans += 1ll * C2(cnt[a[i]]) * C2(cnt[a[j] - a[i]]) * C2(cnt[a[j]]); if (a[i] * 2 &lt;= m) ans += 1ll * C4(cnt[a[i]]) * C2(cnt[a[i] * 2]); for (register int j = i + 1; j &lt;= n; ++j)&#123; ans += 1ll * C3(cnt[a[j]]) * cnt[a[i]] * cntt[a[j] - a[i]]; if ((a[i] &lt;&lt; 1) &lt; a[j] &amp;&amp; a[j] &lt; a[i] * 3) ans += 1ll * C3(cnt[a[j]]) * C2(cnt[a[i]]) * cnt[a[j] - (a[i] &lt;&lt; 1)]; if (a[j] == a[i] * 3) ans += 1ll * C3(cnt[a[j]]) * C3(cnt[a[i]]); &#125; for (register int j = 1; j &lt; i; ++j) if (a[i] + a[j] &lt;= m) cntt[a[i] + a[j]] += cnt[a[i]] * cnt[a[j]]; if ((a[i] &lt;&lt; 1) &lt;= m) cntt[a[i] &lt;&lt; 1] += C2(cnt[a[i]]); &#125; printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 6062」「2017 山东一轮集训 Day2」Pair]]></title>
    <url>%2Floj6062-sol%2F</url>
    <content type="text"><![CDATA[LOJ 6062 题解 我们令 \(c_i=h-b_i\)，并将序列 \(c\) 从小到大排序。我们遍历 \(a\) 的所有长度为 \(m\) 的区间，将这个区间中的数从小到大排序后的第 \(i\) 个数记为 \(d_i\)。一个区间满足题目中的条件当且仅当 \(d_i\ge c_i\)。 考虑离散，然后用权值线段树维护。记最大值为 \(t\)，对于所有 \(c_i\)，把线段树上 \([c_i,t]\) 这段区间加 \(1\)；对于当前区间中的所有 \(a_i\)，把线段树上 \([a_i,t]\) 这段区间减 \(1\)，判断是否满足条件只需要判断线段树上是否有 \(&lt; 0\) 的位置即可，这个可以维护最小值判断。正确性显然。 时间复杂度 \(O(n\log n)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 300005struct Segment_Tree&#123; int val[N &lt;&lt; 2], lz[N &lt;&lt; 2]; void up(int u)&#123; val[u] = std :: min(val[u &lt;&lt; 1], val[u &lt;&lt; 1 | 1]); &#125; void add(int u, int x)&#123; lz[u] += x, val[u] += x; &#125; void down(int u)&#123; if (lz[u]) add(u &lt;&lt; 1, lz[u]), add(u &lt;&lt; 1 | 1, lz[u]), lz[u] = 0; &#125; void modify(int u, int l, int r, int L, int R, int x)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return add(u, x), void(0); int md = (l + r) &gt;&gt; 1; down(u); if (L &lt;= md) modify(u &lt;&lt; 1, l, md, L, R, x); if (R &gt; md) modify(u &lt;&lt; 1 | 1, md + 1, r, L, R, x); up(u); &#125; bool query()&#123; return val[1] &gt;= 0; &#125;&#125;T;int n, m, h, a[N], b[N], t, c[N], ans;int main()&#123; n = read(), m = read(), h = read(); for (register int i = 1; i &lt;= m; ++i) b[i] = h - read(), c[++t] = b[i]; for (register int i = 1; i &lt;= n; ++i) a[i] = read(), c[++t] = a[i]; std :: sort(c + 1, c + 1 + t); t = std :: unique(c + 1, c + 1 + t) - c - 1; for (register int i = 1; i &lt;= m; ++i) b[i] = std :: lower_bound(c + 1, c + 1 + t, b[i]) - c; for (register int i = 1; i &lt;= n; ++i) a[i] = std :: lower_bound(c + 1, c + 1 + t, a[i]) - c; for (register int i = 1; i &lt;= m; ++i) T.modify(1, 1, t, b[i], t, 1), T.modify(1, 1, t, a[i], t, -1); ans = T.query(); for (register int i = m + 1; i &lt;= n; ++i) T.modify(1, 1, t, a[i], t, -1), T.modify(1, 1, t, a[i - m], t, 1), ans += T.query(); printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>离散</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 6060」「2017 山东一轮集训 Day1 / SDWC2018 Day1」Set]]></title>
    <url>%2Floj6060-sol%2F</url>
    <content type="text"><![CDATA[LOJ 6060 题解 我们发现，\(x_1\text{ xor }x_2\) 的值是固定的，也就是整个集合的异或和，我们记为 \(s\)。 很显然 \(x_1+x_2\ge s\)，我们把 \(x_1+x_2-s\) 的值叫做“差值”。显然我们需要使差值最大化。 考虑 \(s\) 第 \(i\) 位（从右往左，从 \(0\) 开始标号，下同），若是 \(1\)，则 \(x_1\) 和 \(x_2\) 的这一位上有且仅有一个 \(1\)，那么显然对差值的贡献为 \(0\)；否则，\(x_1\) 和 \(x_2\) 的这一位要么都是 \(0\)，要么都是 \(1\)，显然最好是两个都为 \(1\)，那么会对差值产生 \(2^{i+1}\) 的贡献。 题目同时又规定，需要在最大化 \(x_1+x_2\) 的前提下，最小化 \(x_1\)，也就是要最大化 \(x_2\)。 自然想到线性基。通常我们在线性基中插入、查询时直接从最高位遍历到最低位，因为我们可以认为高位的优先级高于低位。 但是，在本题中，由于要优先最大化差值，所以我们需要先最大化 \(x_2\) 的所有在 \(s\) 中为 \(0\) 的那些位置。 于是，我们在插入、查询时，强制这些位置的优先级高于其他位置，而内部仍然按照从高位到低位的顺序进行遍历。这样就能保证先最大化差值，在这个前提下最大化 \(x_2\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;long long read()&#123; register long long x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 100005int n;long long sum, a[N], b[65], ans;void insert(long long x)&#123; for (register int i = 60; ~i; --i) if (!(sum &gt;&gt; i &amp; 1)) if (x &gt;&gt; i &amp; 1)&#123; if (!b[i]) return b[i] = x, void(0); x ^= b[i]; &#125; for (register int i = 60; ~i; --i) if (sum &gt;&gt; i &amp; 1) if (x &gt;&gt; i &amp; 1)&#123; if (!b[i]) return b[i] = x, void(0); x ^= b[i]; &#125;&#125;int main()&#123; n = read(); for (register int i = 1; i &lt;= n; ++i) a[i] = read(), sum ^= a[i]; for (register int i = 1; i &lt;= n; ++i) insert(a[i]); for (register int i = 60; ~i; --i) if (!(sum &gt;&gt; i &amp; 1)) if (!(ans &gt;&gt; i &amp; 1)) ans ^= b[i]; for (register int i = 60; ~i; --i) if (sum &gt;&gt; i &amp; 1) if (!(ans &gt;&gt; i &amp; 1)) ans ^= b[i]; printf("%lld\n", sum ^ ans);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 6059」「2017 山东一轮集训 Day1」Sum]]></title>
    <url>%2Floj6059-sol%2F</url>
    <content type="text"><![CDATA[LOJ 6059 题解 一眼 DP。并且很显然可以倍增优化。\(dp_{i,j,k}\) 表示 \(2^i\) 位，数字之和恰好为 \(j\)，模 \(p\) 为 \(k\) 时的方案数。有如下转移： \[dp_{i,j,k}=\sum_{j_1+j_2=j}\sum_{k_1\times 10^{2^{i-1}}+k_2\equiv k\pmod p}dp_{i-1,j_1,k_1}\times dp_{i-1,j_2,k_2}\] 直接这样做是 \(O(p^2m^2\log n)\) 的。 只考虑 \(j\) 这一维，很显然可以用 FFT 优化，于是复杂度变为 \(O(p^2m\log m\log n)\)，但是常数较大，比较难卡过。 如果我们记 \[tmp_{j,k}=\sum_{t\times 10^{2^{i-1}}\equiv k\pmod p} dp_{i-1,j,t}\] 则原式变成了 \[dp_{i,j,k}=\sum_{j_1+j_2=j}\sum_{(k_1+k_2)\bmod p=k}tmp_{j_1,k_1}\times dp_{i-1,j_2,k_2}\] 然而这个 \(\bmod\) 还是不太舒服，我们考虑把第二维值域扩充到 \([0,2p)\)，然后再把 \([p,2p)\) 这部分加到 \([0,p)\)。则式子变得十分美观： \[dp_{i,j,k}=\sum_{j_1+j_2=j}\sum_{k_1+k_2=k}tmp_{j_1,k_1}\times dp_{i-1,j_2,k_2}\] 我们把 \(j,k\) 两维拍到一起，发现这个式子仍然是个卷积的形式。于是直接用 FFT 优化。 时间复杂度 \(O(mp\log (mp)\log n)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define N 70005#define P 998244353int n, p, m, pw[35], dp[35][N], s[N], tmp[N], len;void upd(int &amp;x, int y)&#123; (x += y) &gt;= P ? x -= P : 0;&#125;int add(int x, int y)&#123; return (x += y) &gt;= P ? x - P : x;&#125;int del(int x, int y)&#123; return (x -= y) &lt; 0 ? x + P : x;&#125;int qpow(int a, int b = P - 2, int p = P)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % p) if (b &amp; 1) s = 1ll * s * a % p; return s;&#125;struct Number_Theory_Transform&#123; int n, rev[N], omega[N]; void init(int m)&#123; n = m; register int k = 0; while ((1 &lt;&lt; k) &lt; n) ++k; for (register int i = 1; i &lt; n; ++i) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; k &gt;&gt; 1; &#125; void NTT(int* a, int o)&#123; for (register int i = 0; i &lt; n; ++i) i &lt; rev[i] ? std :: swap(a[i], a[rev[i]]), 0 : 0; for (register int m = 1; m &lt; n; m &lt;&lt;= 1)&#123; register int l = m &lt;&lt; 1, omega1 = qpow(o == 1 ? 3 : 332748118, (P - 1) / l); omega[0] = 1; for (register int i = 1; i &lt; m; ++i) omega[i] = 1ll * omega[i - 1] * omega1 % P; for (register int* p = a; p &lt; a + n; p += l) for (register int i = 0; i &lt; m; ++i)&#123; register int t = 1ll * omega[i] * p[m + i] % P; p[m + i] = del(p[i], t), upd(p[i], t); &#125; &#125; if (o == -1)&#123; register int _n = qpow(n); for (register int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * _n % P; &#125; &#125;&#125;T;void multiply(int na, int *A, int nb, int *B, int *C)&#123; int n; if (na &lt;= 20 &amp;&amp; nb &lt;= 20)&#123; n = std :: max(na, nb); for (register int i = 0; i &lt; n; ++i) C[i] = 0; for (register int i = 0; i &lt; na; ++i) for (register int j = 0; j &lt; nb; ++j) if (i + j &lt; n) upd(C[i + j], 1ll * A[i] * B[j] % P); return; &#125; int a[N], b[N]; n = 1; while (n &lt; na + nb - 1) n &lt;&lt;= 1; for (register int i = 0; i &lt; na; ++i) a[i] = A[i]; for (register int i = 0; i &lt; nb; ++i) b[i] = B[i]; for (register int i = na; i &lt; n; ++i) a[i] = 0; for (register int i = nb; i &lt; n; ++i) b[i] = 0; T.init(n), T.NTT(a, 1), T.NTT(b, 1); for (register int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * b[i] % P; T.NTT(a, -1); for (register int i = 0; i &lt; std :: max(na, nb); ++i) C[i] = a[i];&#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;p, &amp;m); len = (m + 1) * p * 2; for (register int i = 0; i &lt;= 9 &amp;&amp; i &lt;= m; ++i) ++dp[0][i * p * 2 + i % p]; pw[0] = 1; for (register int i = 1; i &lt;= 30; ++i) pw[i] = pw[i - 1] &lt;&lt; 1; for (register int i = 0; i &lt;= 30; ++i) pw[i] = qpow(10, pw[i], p); for (register int i = 0; i &lt; 30; ++i)&#123; for (register int j = 0; j &lt; len; ++j) tmp[j] = 0; for (register int j = 0; j &lt;= m; ++j) for (register int k = 0; k &lt; p; ++k) upd(tmp[j * p * 2 + 1ll * k * pw[i] % p], dp[i][j * p * 2 + k]); multiply(len, tmp, len, dp[i], dp[i + 1]); for (register int j = 0; j &lt;= m; ++j) for (register int k = 0; k &lt; p; ++k) upd(dp[i + 1][j * p * 2 + k], dp[i + 1][j * p * 2 + k + p]), dp[i + 1][j * p * 2 + k + p] = 0; &#125; s[0] = 1; for (register int i = 30; ~i; --i) if ((1 &lt;&lt; i) &lt;= n)&#123; for (register int j = 0; j &lt; len; ++j) tmp[j] = 0; for (register int j = 0; j &lt;= m; ++j) for (register int k = 0; k &lt; p; ++k) upd(tmp[j * p * 2 + 1ll * k * pw[i] % p], s[j * p * 2 + k]), s[j * p * 2 + k] = 0; multiply(len, tmp, len, dp[i], s); for (register int j = 0; j &lt;= m; ++j) for (register int k = 0; k &lt; p; ++k) upd(s[j * p * 2 + k], s[j * p * 2 + k + p]), s[j * p * 2 + k + p] = 0; n -= (1 &lt;&lt; i); &#125; int sum = 0; for (register int i = 0; i &lt;= m; ++i) upd(sum, s[i * p * 2]), printf("%d ", sum);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>倍增</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1067A」Array Without Local Maximums]]></title>
    <url>%2Fcf1067a-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定长度为 \(n\) 的序列 \(a\)，有些位置是 \(-1\)，其余位置是 \(1\) 到 \(200\) 的一个整数。你需要在 \(-1\) 的位置填上\(1\) 到 \(200\) 的一个整数，使得序列 \(a\) 是好的。一个序列 \(a\) 是好的当且仅当满足以下三个条件： \(a_1\le a_2\) \(a_n\le a_{n-1}\) \(\forall i\in [2,n-1],a_i\le \max(a_{i-1},a_{i+1})\) 求方案数 \(\bmod 998244353\) 的值。 \(n\le 10^5\) 题解 考虑 DP，\(dp_{i,j,0/1}\) 表示前 \(i\) 个数，\(a_i\) 为 \(j\)，\(a_{i-1}&lt; a_i\) / \(a_{i-1}\ge a_i\) 时的方案数。有转移 \[\begin{aligned} dp_{i,j,0}&amp;=\sum_{k=1}^{j-1} dp_{i-1,k,0}+dp_{i-1,k,1}\\ dp_{i,j,1}&amp;=dp_{i-1,j,0}+\sum_{k=j}^{200} dp_{i-1,k,1}\end{aligned}\] 可以发现这个式子可以用前缀和优化。 时间复杂度 \(O(nm)\)，其中 \(m=200\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cctype&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 100005#define P 998244353int n, a[N], dp[N][205][2], pre[N][205][2];int add(int x, int y)&#123; return (x += y) &gt;= P ? x - P : x;&#125;int del(int x, int y)&#123; return (x -= y) &lt; 0 ? x + P : x;&#125;int suf(int i, int j, int k)&#123; return del(pre[i][200][k], pre[i][j - 1][k]);&#125;int main()&#123; n = read(); for (register int i = 1; i &lt;= n; ++i) a[i] = read(); for (register int i = 1; i &lt;= 200; ++i)&#123; if (a[1] == -1 || i == a[1]) dp[1][i][0] = 1; pre[1][i][0] = add(pre[1][i - 1][0], dp[1][i][0]); &#125; for (register int i = 2; i &lt;= n; ++i) for (register int j = 1; j &lt;= 200; ++j)&#123; if (a[i] == -1 || a[i] == j)&#123; dp[i][j][0] = add(pre[i - 1][j - 1][0], pre[i - 1][j - 1][1]); dp[i][j][1] = add(dp[i - 1][j][0], suf(i - 1, j, 1)); &#125; pre[i][j][0] = add(pre[i][j - 1][0], dp[i][j][0]); pre[i][j][1] = add(pre[i][j - 1][1], dp[i][j][1]); &#125; printf("%d\n", pre[n][200][1]);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1204D2」Kirk and a Binary String (hard version)]]></title>
    <url>%2Fcf1204d2-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定一个长度为 \(n\) 的 \(01\) 字符串 \(s\)，求一个长度为 \(n\) 的 \(01\) 字符串 \(t\)，满足 \(\forall 1\le l\le r\le n:f(s[l,r])=f(t[l,r])\)，其中 \(f(s[l,r])\) 表示 \(s\) 中第 \(l\) 个字符到第 \(r\) 个字符组成的子串的最长不下降子序列的长度，\(f(t[l,r])\) 同理。 在满足以上条件的同时，你需要最大化 \(t\) 中 \(0\) 的数量。 \(n\le 10^5\) 题解 显然一定是把 \(s\) 中的若干个 \(1\) 改成 \(0\)，且每段连续的 \(1\) 一定是修改它的一个前缀。 我们发现，一个区间的最长不下降子序列一定可以表示成在区间的某个位置断开（特殊地，也可以在左端点的前面或右端点的后面），然后选断点左边的 \(0\) 和断点右边的 \(1\)，显然这个断点需要满足左边 \(0\) 的个数加上右边 \(1\) 的个数等于这个区间的最长不下降子序列长度。我们称这样的断点为这个区间的答案断点。显然答案断点必须满足右边 \(1\) 的个数大于等于 \(0\) 的个数，左边 \(0\) 的个数大于等于 \(1\) 的个数。但这个不是充要条件。 考虑一个 \(1\) 能变成 \(0\) 的条件，假设这个位置为 \(i\)，那就是所有 \(i+1\) 开始的所有区间必须存在一个最长不下降子序列是全为 \(1\) 的。 我们又发现，只要 \([i+1,n]\) 这个区间满足条件，所有区间就一定满足条件。 先给出做法：从后往前扫，记 \(cnt_i\) 表示 \(i\sim n\) 没有改变的位置中 \(0\) 的个数减去 \(1\) 的个数的值，那么 \(cnt_{i+1}=0\) 时把 \(i\) 这个位置改成 \(0\)。 考虑这样为什么是对的（以下内容纯属口胡）。对于 \([i+1,n]\) 的某个点 \(j\)，我们把 \(j\sim n\) 的所有位置中 \(0\) 的个数减去 \(1\) 的个数的值记为 \(sum_j\)。由于改变只会是 \(1\) 变成 \(0\)，所以有 \(cnt_j\le sum_j\)。又因为只要碰到 \(1\) 且 \(cnt_j=0\) 就会改变，所以 \(sum_j\ge cnt_j\ge 0\)。要 \(j\) 前面的位置要成为答案断点，必须有 \(sum_j\le 0\)，所以 \(sum_j\) 只能等于 \(0\)，即 \(0\) 的个数等于 \(1\) 的个数。因为 \(j\sim n\) 满足这个条件，当前的 \(cnt_{i+1}=0\)，所以 \(i+1\sim j-1\) 所有位置中 \(0\) 的个数一定小于等于 \(1\) 的个数，要符合答案断点的必要条件，又只能是取等于。于是我们可以把 \(i+1\sim j-1\) 的决策替换成 \(1\)，于是 \(i+1\sim n\) 就一定存在一个全为 \(1\) 的最长不下降子序列。 差不多口胡完了，直接做就可以了。 代码 12345678910111213#include &lt;cstdio&gt;#include &lt;cstring&gt;#define N 100005char s[N];int n;int main()&#123; scanf("%s", s + 1), n = strlen(s + 1); for (register int i = n, cnt = 0; i; --i) if (s[i] == '0') ++cnt; else if (cnt) --cnt; else s[i] = '0'; printf("%s\n", s + 1);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「模拟赛20190705 T1」第一题]]></title>
    <url>%2Fvc190705A-sol%2F</url>
    <content type="text"><![CDATA[题意 给定一棵 \(n\) 个点的有根树，每个点有一个正整数\(b_i\)，这个点的权值是 \([0,b_i]\) 的一个随机实数。 求每个点的权值严格小于这个点所有儿子的权值的概率，模 \(10^9+7\)。 \(n\le 300,b_i\le 10^9\)。 所谓题解 旺仔的方法 考虑暴力。实数显然不能直接枚举。然而 \(b_i\) 只有 \(n\) 个，我们考虑离散，枚举每个点的权值在哪一段内。 我们按权值所属段是否相同分出一些联通块。树上的联通块还是一棵树，我们考虑求出每个联通块内部的概率。 由于一个联通块内的权值都属于同一段，也就是权值取值范围相同，那么问题转化成了： 给定一棵树，每个点的权值是 \([0,1)\) 的随机实数，求每个点权值严格小于这个点每个儿子的权值的概率。 这个问题是一个经典问题，答案是 \(\prod\limits_{i=1}^{n} \frac{1}{sz_i}\)，可以感性理解一下。我不会证明 枚举每个点太慢，我们考虑 DP。用 \(dp_{i,j,k}\) 表示以 \(i\) 为根的子树，\(i\) 的取值范围为 \(j\)，以 \(i\) 为根的联通块大小为 \(k\) 时的概率。可以通过枚举每个儿子的取值范围是否与 \(i\) 相同，枚举每个儿子的联通块大小进行转移。 相当于 \(n\) 次树上背包，每次 \(O(n^2)\)，复杂度为 \(O(n^3)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); return f ? x : -x;&#125;#define N 305#define P 1000000007int n, m, a[N], b[N], fa[N], rt, inv[N], inva[N], sz[N], dp[N][N][N], tmp[N];std :: vector&lt;int&gt; E[N];int qpow(int a, int b)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if (b &amp; 1) s = 1ll * s * a % P; return s;&#125;void add(int &amp;x, int y)&#123; (x += y) &gt;= P ? x -= P : 0;&#125;void dfs(int u)&#123; sz[u] = 1; for (register int i = 0; i &lt; b[u]; ++i) dp[u][i][1] = 1ll * (a[i + 1] - a[i]) * inva[b[u]] % P; for (register int i = 0; i &lt; E[u].size(); ++i)&#123; int v = E[u][i], sum = 0; dfs(v); for (register int j = b[v] - 1; j &gt;= b[u]; --j) for (register int k = 1; k &lt;= sz[v]; ++k) add(sum, dp[v][j][k]); for (register int j = b[u] - 1; ~j; --j)&#123; for (register int k = 1; k &lt;= sz[u] + sz[v]; ++k) tmp[k] = 0; for (register int k = 1; k &lt;= sz[u]; ++k) for (register int l = 1; l &lt;= sz[v]; ++l) add(tmp[k + l], 1ll * dp[u][j][k] * dp[v][j][l] % P); for (register int k = 1; k &lt;= sz[u] + sz[v]; ++k) dp[u][j][k] = (1ll * dp[u][j][k] * sum + tmp[k]) % P; for (register int k = 1; k &lt;= sz[v]; ++k) add(sum, dp[v][j][k]); &#125; sz[u] += sz[v]; &#125; for (register int j = 0; j &lt; b[u]; ++j) for (register int k = 1; k &lt;= sz[u]; ++k) dp[u][j][k] = 1ll * dp[u][j][k] * inv[k] % P;&#125;int main()&#123; freopen("a.in", "r", stdin); freopen("a.out", "w", stdout); n = read(); for (register int i = 1; i &lt;= n; ++i)&#123; a[i] = b[i] = read(), fa[i] = read(); if (fa[i]) E[fa[i]].push_back(i); else rt = i; &#125; std :: sort(a + 1, a + 1 + n); m = std :: unique(a + 1, a + 1 + n) - a - 1; for (register int i = 1; i &lt;= n; ++i) b[i] = std :: lower_bound(a + 1, a + 1 + m, b[i]) - a; for (register int i = 1; i &lt;= n; ++i) inv[i] = qpow(i, P - 2); for (register int i = 1; i &lt;= m; ++i) inva[i] = qpow(a[i], P - 2); dfs(rt); int ans = 0; for (register int i = 0; i &lt; b[rt]; ++i) for (register int j = 1; j &lt;= n; ++j) add(ans, dp[rt][i][j]); printf("%d", ans);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AT1736」「Xmas Contest 2015」Destroy the Duplicated Poem]]></title>
    <url>%2Fatcoder-xmas15D-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 有 \(n+1\) 个字符串 \(S_0,S_1,S_2,\cdots,S_n\)。\(S_0\) 是空串，\(S_i\) 是 \(S_{a_i}\) 后加上字符 \(c_i\) 的字符串。\(a_i,c_i\) 都是给定的且 \(0\le a_i&lt; i\)，\(c_i\) 是小写字母。 定义字符串 \(T\) 的周期是所有满足 \(T\) 是 \(X\) 重复无穷多次后的字符串的前缀的字符串 \(X\) 中最短的。例如 abcabca 的周期是 abc。 求 \(S_1,S_2,S_3,\cdots,S_n\) 的周期的长度。 \(n\le 500\,000\) 题解 由题目给定的字符串生成方式，可以想到字典树。所有字符串对应字典树上根到某个点的路径。 可以发现，字符串的周期一定是字符串的某个前缀。且这个前缀的长度一定是 \(T[1,m-x]=T[m-x+1,m]\) 的 \(x\) 中的最小值（\(T[l..r]\) 表示 \(T\) 中 \(l\) 到 \(r\) 的子串，\(m\) 表示 \(T\) 的长度）。\(x\) 最小，那么 \(m-x\) 是最大的，所以这是一个求所有前缀=后缀中最长的前缀的形式，那么很自然地能想到 KMP。 在 trie 上做 KMP，不能直接跳 fail，如下图所示的情况就可以卡成 \(O(n^2)\) 的复杂度： 因为都是小写字母，所以用 \(go_{i,c}\)（在节点 \(i\) 表示的字符串后加入字符 \(c\) 后最长的前缀=后缀所在的节点） 记下这个跳 fail 的过程即可（有点像 AC 自动机，但不完全一样）。 时间复杂度 \(O(nk)\)，\(k\) 是字符集大小，这里为 \(26\)。 代码 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#define N 500005int n, dep[N], fail[N], go[N][26];char a[N];int edge, hd[N], to[N], pr[N];void addedge(int u, int v)&#123; to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;&#125;void dfs(int u, int fa = -1)&#123; int tmp; if (~fa)&#123; dep[u] = dep[fa] + 1, fail[u] = go[fa][a[u]]; for (register int i = 0; i &lt; 26; ++i) go[u][i] = go[fail[u]][i]; if (fail[u] == fa) go[u][a[u]] = u; tmp = go[fa][a[u]], go[fa][a[u]] = u; &#125; for (register int i = hd[u]; i; i = pr[i]) dfs(to[i], u); if (~fa) go[fa][a[u]] = tmp;&#125;int main()&#123; scanf("%d", &amp;n); for (register int i = 1, fa; i &lt;= n; ++i) scanf("%d", &amp;fa), addedge(fa, i); // 建树 scanf("%s", a + 1); for (register int i = 1; i &lt;= n; ++i) a[i] -= 'a'; dep[0] = 0, dfs(0); for (register int i = 1; i &lt;= n; ++i) printf("%d\n", dep[i] - dep[fail[i]]);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>Xmas Contest 2015</category>
      </categories>
      <tags>
        <tag>trie</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AT1735」「Xmas Contest 2015」Colored Tiles]]></title>
    <url>%2Fatcoder-xmas15C-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 这是一道交互题。 交互库中生成了一个 \(n\times m\) 的每个格子有颜色的矩阵。颜色可以有任意多种。给定的是 \(n,m\)。记矩阵中第 \(x\) 行第 \(y\) 列的颜色为 \(col(x,y)\)（矩阵的行列下标从 \(1\) 开始）。 你可以进行询问，询问的格式是 ? x1 y1 x2 y2，交互库会告诉你 \(col(x1,y1)=col(x2,y2)\) 并且 \(col(x1,y2)=col(x2,y1)\) 是否成立。询问次数不能超过 \(4\,500\)。 最后你应该输出 ! ans，\(ans\) 表示中心对称的子矩阵的数量。 \(n\le 5,m\le 100\) 题解 上图这个矩阵如果是中心对称的，那么 \(A\) 反转一下一定与 \(B\) 相等，且 \(C\) 也是中心对称的。 那么考虑 \(A,B\) 两行，设他们的行号分别为 \(i,j\)，中间位置为 \(k\)，两边为 \(l,r\)，那么 \(A\) 反转一下与 \(B\) 相等可以转化成 \(\forall 0\le x\le k-l,col(i,k-x)=col(j,k+x)\text{ and }col(i,k+x)=col(j,k-x)\)。这个与询问的格式就一样了。 并且可以发现，这是一个“类回文”的形式，所以可以用 manacher 解决，这样就可以减少询问次数。为了解决奇偶性问题，可以当作把每行扩展一倍，在相邻两个格子之间插入其他字符，注意询问时候要变回原来的下标。 就是说，对于任意两行 \(i,j(1\le i\le j\le n)\)，求出每列向左右可以扩展的最多的列数。然后枚举矩阵的上下两行和对称中心所在的列数，求出在该条件下的极大中心对称的矩阵的列数，然后直接统计。 可以用 map 减少一定量的询问次数。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;map&gt;int n, m, len[6][6][205];struct node&#123; int a, b, c, d; bool operator &lt; (const node &amp;res) const &#123; return a &lt; res.a || (a == res.a &amp;&amp; b &lt; res.b) || (a == res.a &amp;&amp; b == res.b &amp;&amp; c &lt; res.c) || (a == res.a &amp;&amp; b == res.b &amp;&amp; c == res.c &amp;&amp; d &lt; res.d); &#125;&#125;;std :: map&lt;node, int&gt; M;bool check(int x1, int y1, int x2, int y2)&#123; if (x1 &gt; x2 || y1 &gt; y2 || x1 &lt; 1 || x2 &gt; n || y1 &lt; 1 || y2 &gt; (m &gt;&gt; 1)) return 0; if (x1 == x2 &amp;&amp; y1 == y2) return 1; if (M.count((node)&#123;x1, y1, x2, y2&#125;)) return M[(node)&#123;x1, y1, x2, y2&#125;]; printf("? %d %d %d %d\n", x1, y1, x2, y2), fflush(stdout); char opt[5]; scanf("%s", opt); return M[(node)&#123;x1, y1, x2, y2&#125;] = (opt[0] == 'y');&#125;void manacher(int x, int y, int *hw)&#123; int mr = 0, mid = 0, n = m; hw[0] = 1; for (register int i = 1; i &lt;= n; ++i)&#123; hw[i] = i &lt;= mr ? std :: min(hw[(mid &lt;&lt; 1) - i], mr - i + 1) : 0; if (i + hw[i] &lt;= mr) continue; while ((i - hw[i]) % 2 == 0 || check(x, (i - hw[i] + 1) / 2, y, (i + hw[i] + 1) / 2)) ++hw[i]; if (i + hw[i] - 1 &gt; mr) mid = i, mr = i + hw[i] - 1; &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); m &lt;&lt;= 1; for (register int i = 1; i &lt;= n; ++i) for (register int j = i; j &lt;= n; ++j) manacher(i, j, len[i][j]); int ans = 0; for (register int i = 1; i &lt;= n; ++i) for (register int j = i; j &lt;= n; ++j) for (register int k = 1; k &lt;= m; ++k)&#123; int s = 1e9; for (register int l = i, r = j; l &lt;= r; ++l, --r) s = std :: min(s, len[l][r][k]); ans += s &gt;&gt; 1; &#125; printf("! %d\n", ans), fflush(stdout);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>Xmas Contest 2015</category>
      </categories>
      <tags>
        <tag>交互</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1156E」Special Segments of Permutation]]></title>
    <url>%2Fcf1156e-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定一个长度为 \(n\) 的排列 \(a\)，求有多少区间 \([l,r]\) 满足 \(a_l+a_r=\max\limits_{i=l}^{r}a_i\)。 \(n\le 200\,000\) 题解 用单调栈对每一个 \(a_i\) 求出 \(l_i=j+1\)，\(j\) 是从 \(i\) 向左第一个满足 \(a_j&gt;a_i\) 的位置，\(r_i\) 同理。 那么题目变为对于每个 \(i\) 求在 \([l_i,i-1]\) 和 \([i+1,r_i]\) 中各选出一个数使得这两个数之和为 \(a_i\) 的方案数。 结论是，我们只要枚举这两个区间中短的那个区间的每个数 \(a_j\)，然后在另一个区间中查询 \(a_i-a_j\) 是否存在即可。 看起来是 \(O(n^2)\)，其实是 \(O(n\log n)\) 的，因为每个数最多会被枚举到 \(\log n\) 次。假设某个数被枚举到的所有区间 \([l_i,r_i]\) 中，最大的区间长度为 \(m\)，那么由于枚举的是短的区间，短的区间长度不会超过 \(\frac{m}{2}\)。而如果这个数要被另一个区间枚举到，这个区间一定被之前那个短的区间包含，所以这个区间总长度不会超过 \(\frac{m}{2}\)，而且又是短的区间，所以变成了 \(\frac{m}{4}\)……感性理解一下，每个数枚举到的次数不会超过 \(\log n\)。 代码 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define N 200005int n, a[N], p[N], l[N], r[N], top, sta[N], ans;bool in(int x, int l, int r)&#123; return l &lt;= p[x] &amp;&amp; p[x] &lt;= r;&#125;int main()&#123; scanf("%d", &amp;n); for (register int i = 1; i &lt;= n; ++i) scanf("%d", a + i), p[a[i]] = i; for (register int i = 1; i &lt;= n; ++i)&#123; while (top &gt; 0 &amp;&amp; a[i] &gt; a[sta[top]]) --top; l[i] = sta[top] + 1; sta[++top] = i; &#125; sta[top = 0] = n + 1; for (register int i = n; i; --i)&#123; while (top &gt; 0 &amp;&amp; a[i] &gt; a[sta[top]]) --top; r[i] = sta[top] - 1; sta[++top] = i; &#125; for (register int i = 1; i &lt;= n; ++i)&#123; int l1 = l[i], r1 = i - 1, l2 = i + 1, r2 = r[i]; if (r1 - l1 &gt; r2 - l2) std :: swap(l1, l2), std :: swap(r1, r2); for (register int j = l1; j &lt;= r1; ++j) if (in(a[i] - a[j], l2, r2)) ++ans; &#125; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>复杂度分析</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AT1734」「Xmas Contest 2015」Broken Christmas Tree]]></title>
    <url>%2Fatcoder-xmas15B-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 \(n\) 个点的完全图中去掉给定的 \(m\) 条边后，问是否存在一个生成树。若是，求出一种方案。 \(n,m\le 2\times 10^5\) 题解 显然贪心。假定以 \(1\) 为根节点，把 \(1\) 能连的点都与 \(1\) 相连，然后对这些点进行同样的操作，直到所有点都相互连通。 用 set 记录每个点不能连的点，以及当前还有哪些点没有加入最小生成树（记做 \(num\)）。用队列记录已经加入的点，对于队列中的点 \(u\)，遍历 \(num\)，若可以连则连，加入队列，并且从 \(num\) 中删除；否则跳过。 关键是复杂度分析。对于遍历 \(num\) 时可以连的情况，这种情况一定不会超过 \(n-1\) 次，因为每次都会从 \(num\) 中删除一个点；对于不可以连的情况，一定不会超过 \(m\) 次，因为一条不能连的边不会重复遍历。所以总次数为 \(O(n+m)\) 次。由于判断一个点与另一个点能否连接需要 \(O(\log n)\)，所以总复杂度为 \(O((n+m)\log n)\)。 代码 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;set&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 200005int n, m, h, t, Q[N], cnt, x[N], y[N];std :: set&lt;int&gt; num, E[N];int main()&#123; n = read(), m = read(); for (register int i = 1; i &lt;= m; ++i)&#123; int x = read(), y = read(); E[x].insert(y), E[y].insert(x); &#125; for (register int i = 2; i &lt;= n; ++i) num.insert(i); h = 0, t = 1, Q[t] = 1; while (h &lt; t)&#123; int u = Q[++h]; for (auto it = num.begin(), It = it; it != num.end(); ) // 遍历，注意 auto 需要 C++11 if (!E[u].count(*it)) x[++cnt] = u, y[cnt] = *it, Q[++t] = *it, It = it, ++it, num.erase(It); else ++it; &#125; if (num.size()) printf("No\n"); else&#123; printf("Yes\n"); for (register int i = 1; i &lt;= cnt; ++i) printf("%d %d\n", x[i], y[i]); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>Xmas Contest 2015</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>复杂度分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AT1733」「Xmas Contest 2015」Accumulation]]></title>
    <url>%2Fatcoder-xmas15A-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 123456input ninput x, t, a, b, cfor i = 1 .. n : s_i = x for j = 1 .. t : x = (a * x + b) mod c 求 \(\sum\limits_{i=1}^{n} s_i\) 的值（不需要对 \(c\) 取模）。 \(n\le 10^6, t\le 10^9,0\le x,a,b&lt; c\le 10^9\) 题解 考虑快速进行 for j = 1 .. t : x = (a * x + b) mod c 这段操作。 \[\begin{aligned} j=1: &amp;\quad ax+b \\ j=2: &amp;\quad a(ax+b)+b=a^2x+ab+b \\ j=3: &amp; \quad a(a^2x+ab+b)+b=a^3x+a^2b+ab+b \\ j=4: &amp; \quad a^4x+a^3b+a^2b+ab+b\\ \vdots&amp; \\ j=t:&amp;\quad a^tx+\sum_{k=0}^{t-1} a^kb=a^tx+b\sum_{k=0}^{t-1}a^k\end{aligned}\] 如果 \(c\) 为质数，则这个式子可以直接用快速幂和等比数列求和公式进行计算。然而并没有保证 \(c\) 是质数，怎么办呢？可以发现，\(x\) 和 \(b\) 在这个式子中是常数，而 \(a^t\) 和 \(\sum\limits_{k=0}^{t-1}a^k\) 有某种联系…… 考虑用矩阵表示（记 \(f(t)=\sum\limits_{k=0}^{t-1}a^k\)） \[A=\begin{bmatrix} a^t &amp; f(t) \end{bmatrix},B=\begin{bmatrix} a^{t+1} &amp; f(t+1) \end{bmatrix}\] \(A\) 如何才能转化为 \(B\)，通过计算发现：\(a^{t+1}=a\cdot a^t,f(t+1)=a^t+f(t)\)，那么很显然转移矩阵为 \[C=\begin{bmatrix} a &amp; 1\\ 0 &amp; 1\end{bmatrix}\] 可以再验证一下 \(A\times C=B\)。于是直接用矩阵快速幂进行优化即可。 可以发现，最后 \(x\) 的转移一定可以表示为 \(px+q\) 的形式，所以只要一开始预处理 \(p,q\)，不需要每次进行矩阵快速幂。 时间复杂度 \(O(n+\log t)\)。 代码 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;int n, x, m, a, b, P;long long ans;struct Matrix&#123; int a[2][2]; Matrix operator * (const Matrix &amp;res) const &#123; Matrix ret; memset(ret.a, 0, sizeof ret.a); for (register int i = 0; i &lt; 2; ++i) for (register int k = 0; k &lt; 2; ++k) for (register int j = 0; j &lt; 2; ++j) ret.a[i][j] = (ret.a[i][j] + 1ll * a[i][k] * res.a[k][j]) % P; return ret; &#125;&#125;A, B;Matrix qpow(Matrix a, int b)&#123; // 矩阵快速幂 Matrix s = a; for (--b; b; b &gt;&gt;= 1, a = a * a) if (b &amp; 1) s = s * a; return s;&#125;int main()&#123; scanf("%d%d%d%d%d%d", &amp;n, &amp;x, &amp;m, &amp;a, &amp;b, &amp;P); A.a[0][0] = a, A.a[0][1] = 1; // 初始矩阵 B.a[0][0] = a, B.a[0][1] = 1, B.a[1][0] = 0, B.a[1][1] = 1; // 转移矩阵 if (m &gt; 1) A = A * qpow(B, m - 1); a = A.a[0][0], b = 1ll * b * A.a[0][1] % P; for (register int i = 1; i &lt;= n; ++i) ans += x, x = (1ll * a * x + b) % P; printf("%lld\n", ans);&#125; upd: 修复了代码中的一个漏洞]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>Xmas Contest 2015</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1119F」Niyaz and Small Degrees]]></title>
    <url>%2Fcf1119f-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定一棵 \(n\) 个节点的树，有边权，对于所有 \(x\ (0\le x &lt; n)\)，可以删去一些边，求使得所有节点的度数 \(\le x\) 的删掉的边的边权之和的最小值。 节点的度数指以该点为某一端点的边的数量。 \(n\le 250\,000\) 暴力——独立求解 显然是树形 DP，记 \(dp_{u,0/1}\) 表示 \(u\) 与父亲的连边不删/删时，以 \(u\) 为根的子树满足所有节点度数 \(\le x\) 的删掉的边的最小值。 不考虑度数限制，显然有 \(dp_{u,0}=dp_{u,1}=\sum \min(dp_{v,0},dp_{v,1}+w)\)（\(v\) 是 \(u\) 的儿子，\(w\) 表示对应边的边权）。记 \(d_i\) 表示 \(i\) 的度数，把 \(dp_{v,1}+w\le dp_{v,0}\) 的儿子 \(v\) 叫做好儿子，其余叫做坏儿子。考虑度数限制，假设求 \(dp_{u,0}\)（\(dp_{u,1}\) 同理），记 \(cnt\) 为好儿子数量，我们需要把 \(\max(0,d_i-x-cnt)\) 个坏儿子变成好儿子。 只需要维护一个堆，将所有坏儿子 \(dp_{v,1}+w-dp_{v,0}\) 的值压入堆中，将前 \(\max(0,d_i-x-cnt)\) 小的值之和记为 \(sum\)，则 \(dp_{u,0}=sum+\sum dp_{v,0}\)。 时间复杂度 \(O(n^2\log n)\)。 暴力代码 注意代码实现与上述有很大差别，但思想一致。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 250005#define INF 0x3f3f3f3f3f3f3f3fllint n;int edge, to[N &lt;&lt; 1], pr[N &lt;&lt; 1], tw[N &lt;&lt; 1], hd[N];void addedge(int u, int v, int w)&#123; to[++edge] = v, tw[edge] = w, pr[edge] = hd[u], hd[u] = edge;&#125;long long dp[N][2];void dfs(int X, int u, int fa = 0)&#123; std :: vector&lt;long long&gt; val; dp[u][0] = dp[u][1] = 0; for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa) dfs(X, v, u), val.push_back(dp[v][1] + tw[i] - dp[v][0]), dp[u][0] += dp[v][0]; dp[u][1] = dp[u][0]; std :: sort(val.begin(), val.end()); int d = val.size(); for (register int i = 0; i &lt; d &amp;&amp; (i &lt; d - X || val[i] &lt; 0); ++i) dp[u][1] += val[i]; if (!X) return dp[u][0] = INF, void(0); ++d; for (register int i = 0; i &lt; d - 1 &amp;&amp; (i &lt; d - X || val[i] &lt; 0); ++i) dp[u][0] += val[i];&#125;int main()&#123; n = read(); for (register int i = 1, u, v, w; i &lt; n; ++i) u = read(), v = read(), w = read(), addedge(u, v, w), addedge(v, u, w); for (register int i = 0; i &lt; n; ++i) dfs(i, 1), printf("%lld ", dp[1][1]);&#125; 正解 可以发现对于某个 \(x\)，若一个节点 \(u\) 的度数 \(\le x\)，那这个点本身就不需要考虑了，只需要将 \(w(u,v)\) 加入与 \(v\) 的堆中。 也就是说，我们把 \(u\) 当做叶子节点来看待，即： 1234 /\ /\/__\ /__\ \ / u 也相当于把 \(u\) “删去”，不同的是，与 \(u\) 相连的点的度数不会改变。 如果我们可以每次在把所有度数 \(\le x\) 的点删去后的森林中进行 DP（对每棵树进行 DP 然后把每棵树根节点的 \(dp\) 值加起来，具体是加 \(dp_{i,0}\) 还是 \(dp_{i,1}\) 要看写法），点数之和为 \(\sum_{x=0}^{n-1}\sum_{i=1}^{n} [d_i&gt;x]=\sum_{i=1}^{n} d_i=2n-2=O(n)\)，总时间复杂度就变为 \(O(n\log n)\) 了。 具体实现时，可以用两个普通堆实现一个支持删除的堆。每次“删去”一个点 \(u\) 时，在所有与该点相连的点 \(v\) 对应的堆中加入 \(w(u,v)\)；DP 时，假设需要把 \(cnt\) 个坏儿子变为好儿子，则我们强制使得堆中只有 \(cnt\) 个值，同时记录堆中所有值之和，这样 \(dp\) 值就可以很容易地求出；求出 \(dp\) 值之后，为了避免每次重新执行所有“删点操作”，我们需要将堆中由“删点”得来的值保留，即把强制删去的值重新插入堆中，把 DP 时得来的值从堆中删去。 正解代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 250005#define INF 0x3f3f3f3f3f3f3f3fllint n, d[N], X, vis[N];long long sum;std :: vector&lt; std :: pair&lt;int, int&gt; &gt; E[N];std :: pair&lt;int, int&gt; D[N];void addedge(int u, int v, int w)&#123; E[u].push_back(std :: make_pair(v, w)), ++d[u];&#125;bool cmp(std :: pair&lt;int, int&gt; x, std :: pair&lt;int, int&gt; y)&#123; return d[x.first] &gt; d[y.first];&#125;struct Normal_Heap&#123; // 普通大根堆 std :: vector&lt;long long&gt; a; void push(long long x)&#123; a.push_back(x), std :: push_heap(a.begin(), a.end()); &#125; long long top()&#123; return a[0]; &#125; void pop()&#123; std :: pop_heap(a.begin(), a.end()), a.pop_back(); &#125; long long popn()&#123; long long x; return std :: pop_heap(a.begin(), a.end()), x = a[a.size() - 1], a.pop_back(), x; &#125; int size()&#123; return a.size(); &#125;&#125;;struct Erase_Heap&#123; // 用两个普通堆实现的支持删除的大根堆 Normal_Heap a, b; int sz; long long sum; void push(long long x)&#123; a.push(x), ++sz, sum += x; &#125; void erase(long long x)&#123; b.push(x), --sz, sum -= x; &#125; void pre()&#123; while (a.size() &amp;&amp; b.size() &amp;&amp; a.top() == b.top()) a.pop(), b.pop(); &#125; long long top()&#123; return pre(), a.top(); &#125; void pop()&#123; pre(), --sz, sum -= a.top(), a.pop(); &#125; int size()&#123; return sz; &#125;&#125;H[N];void die(int u)&#123; // “删点”操作 for (auto to : E[u])&#123; register int v = to.first, w = to.second; if (d[v] &lt;= X) break; H[v].push(w); &#125;&#125;long long dp[N][2];std :: vector&lt;long long&gt; tmp, del;void dfs(int u, int fa = 0)&#123; vis[u] = X; int num = d[u] - X; long long res = 0; for (; H[u].size() &gt; num; H[u].pop()) ; for (auto to : E[u])&#123; register int v = to.first, w = to.second; if (v == fa) continue; if (d[v] &lt;= X) break; dfs(v, u); &#125; tmp.clear(), del.clear(); for (auto to : E[u])&#123; register int v = to.first, w = to.second; if (v == fa) continue; if (d[v] &lt;= X) break; long long x = dp[v][1] + w - dp[v][0]; if (x &lt;= 0)&#123; --num, res += dp[v][1] + w; continue; &#125; res += dp[v][0], H[u].push(x), del.push_back(x); &#125; for (; H[u].size() &amp;&amp; H[u].size() &gt; num; H[u].pop()) tmp.push_back(H[u].top()); // 强制弹堆 dp[u][0] = res + H[u].sum; for (; H[u].size() &amp;&amp; H[u].size() &gt; num - 1; H[u].pop()) tmp.push_back(H[u].top()); // 强制弹堆 dp[u][1] = res + H[u].sum; for (auto i : tmp) H[u].push(i); // 还原强制弹堆时删除的值 for (auto i : del) H[u].erase(i); // 删除 DP 得来的值&#125;int main()&#123; n = read(); for (register int i = 1, u, v, w; i &lt; n; ++i) u = read(), v = read(), w = read(), addedge(u, v, w), addedge(v, u, w), sum += w; printf("%lld", sum); for (register int i = 1; i &lt;= n; ++i) D[i] = std :: make_pair(d[i], i), std :: sort(E[i].begin(), E[i].end(), cmp); std :: sort(D + 1, D + 1 + n); register int i = 1; for (X = 1; X &lt; n; ++X)&#123; while (i &lt;= n &amp;&amp; D[i].first == X) die(D[i].second), ++i; long long ans = 0; for (register int j = i; j &lt;= n; ++j)&#123; register int v = D[j].second; if (vis[v] == X) continue; dfs(v), ans += dp[v][0]; &#125; printf(" %lld", ans); &#125; putchar('\n');&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AT1732」「CODE FESTIVAL 2015 OKINAWA OPEN」Jungle]]></title>
    <url>%2Fatcoder-cfoo15J-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 有 \(n\) 棵树，第 \(i\) 棵树高度为 \(a_i\)。你需要砍掉一些树，砍树规则如下： 只能砍最多 \(m\) 棵树。 对于每个 \(i\ (1\le i\le n-k+1)\)，满足 \([i,i+k-1]\) 中被砍掉的树的数量不超过 \(1\)。 被砍掉的树的位置的高度都变为 \(0\)。 求砍树后 \(\max\limits_{1\le i\le n-k+1}\sum\limits_{j=i}^{i+k-1} a_j\) 的最小值，即最小化所有长度为 \(k\) 的区间的树的高度之和的最大值。 \(n\le 10^5,a_i\le 10^9\) 一个错误但可以 AC 的贪心解法 求出 \(sum_i\) 表示以 \(i\) 结尾的长度为 \(k\) 的区间的 \(a_i\) 之和。然后求出 \(mx_i\) 表示所有包含 \(i\) 的长度为 \(k\) 的区间中，最大的 \(sum_j\) 减去 \(a_i\) 的值，即 \(mx_i=\max\limits_{i\le j&lt; i+k}sum_j-a_i\)。 显然可以二分。二分答案 \(x\) 后，问题变成了一个判定性问题。 是否存在一种砍树的方法，使得所有长度为 \(k\) 的区间的树的高度之和都不超过 \(x\)。 可以发现，若一棵树 \(i\) 能砍，必须满足 \(mx_i\le x\)。对于每个不符合要求的区间，选择该区间中最后一棵能砍的树砍掉。可以发现，优先选最后一棵有时候是不优的，例如 1[O X X O] X [O X X X] 这种情况（O 表示可以砍的树，X 表示不能砍的树，[...] 表示不符合条件的区间），显然方案是选两个区间的第一棵树。若优先选最后一棵，如果不考虑前后两个区间选择的树的距离，虽然也能得到“能”的答案，但方案是不满足要求的，可以用 [X X X O] X [O X X X] 的数据卡掉；如果考虑前后两个区间选择的树的距离，则会得到“不能”的答案，也是错误的。 我没有考虑前后两个区间选择的树的距离，所以 [X X X O] X [O X X X] 这种数据会得到一个偏小的答案，然而可以 AC。 附 hack 数据： 1210 5 42 2 2 5 1 5 1 1 2 10 答案是 \(9\)，我的代码会输出 \(8\)。 贪心算法代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define N 100005int n, m, k, a[N], h, t, Q[N];long long sum[N], id[N];void push(int x, long long *cp)&#123; // 单调队列 while (h &lt;= t &amp;&amp; cp[Q[t]] &lt;= cp[x]) --t; Q[++t] = x;&#125;bool check(long long x)&#123; h = 1, t = 1, Q[t] = k; for (register int i = 1; i &lt;= n; i + k &lt;= n ? push(i + k, sum) : void(0), ++i)&#123; if (Q[h] &lt; i) ++h; if (sum[Q[h]] - a[i] &lt;= x) id[i] = i; else id[i] = 0; &#125; h = 1, t = 0; for (register int i = 1; i &lt;= k; ++i) push(i, id); int s = 0; for (register int i = 1, p = 0; i &lt;= n - k + 1; push(i + k, id), ++i)&#123; if (Q[h] &lt; i) ++h; if (i &lt;= p) continue; if (sum[i + k - 1] &lt;= x) continue; p = int(id[Q[h]]), ++s; if (p == 0) return 0; &#125; return s &lt;= m;&#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (register int i = 1; i &lt;= n; ++i) scanf("%d", a + i); for (register int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + a[i] - (i &gt; k ? a[i - k] : 0); // 求 sum long long l = 0, r = 100000000000000ll, md, ans; while (l &lt;= r) if (check(md = (l + r) &gt;&gt; 1)) ans = md, r = md - 1; else l = md + 1; printf("%lld\n", ans);&#125; 正确的解法 一个正确但效率较低的二分 +DP 解法 仍然求出 \(sum_i,mx_i\)，考虑二分。 考虑用 \(O(nk)\) 的时间进行一个 DP 来判断。 首先考虑这样一个 DP 状态：\(dp_i\) 表示前 \(i\) 棵树（不包括 \(i\)），满足所有长度为 \(k\) 的区间的和都不超过 \(x\)，且第 \(i-k\) 棵树必砍时，最少需要砍多少棵树。 考虑主动转移，枚举下一棵砍的树 \(i+j\ (j\ge 0)\)，若可以砍 \(i+j\)（即满足 \(mx_{i+j}\le x\) 且 \(\max\limits_{i\le p&lt; i+j} sum_p\le x\)），则 \(dp_{i+j+k}\gets \min(dp_{i+j+k},dp_{i}+1)\)。 然而直接这样做是 \(O(n^2)\) 的。通过观察发现，若 \(j\ge k\)，则可以把 \(dp_i\) 先转移到 \(dp_{i+k}\)，再把 \(dp_{i+k}\) 向前转移。于是，我们只需要考虑 \(0\le j&lt; k\) 即可。时间复杂度优化为 \(O(nk)\)。 总的时间复杂度为 \(O(nk\log ans)\)。 另一个正确但效率较低的 DP 解法 仍然求出 \(sum_i,mx_i\)，但不二分，直接进行 DP。 \(dp_{i,j}\) 表示前 \(j\) 棵树，砍了 \(i\) 棵，\(j\) 必须砍时 \(\max\limits_{k\le p&lt; j+k}sum_p\) 的最小值。 当 \(i\) 确定时，记 \(Mx_j\) 表示前 \(j\) 棵树（不包括 \(j\)），砍了 \(i-1\) 棵树且最后一棵砍的树 \(t\) 满足 \(j-t\ge k\) 的 \(\max\limits_{k\le p&lt; j} sum_p\) 的最小值。 其实求 \(Mx_j\) 的过程相当于一个 DP 的过程，显然有两种决策：当 \(t&lt; j-k\) 时，\(Mx_j=\max(Mx_{j-1},sum_{j-1})\)；当 \(t=j-k\) 时，\(Mx_j=dp_{i-1,j-k}\)。所以有 \(Mx_j=\min(\max(Mx_{j-1},sum_{j-1}),dp_{i-1,j-k})\)。 求出 \(Mx_j\) 后，求 \(dp_{i,j}\) 就变得很显然：\(dp_{i,j}=\max(Mx_j,mx_j)\)，分别表示 \(\max\limits_{k\le p&lt; j}sum_p\) 的最小值，以及 \(\max\limits_{j\le p&lt; j+k}sum_p\) 的最小值，这两部分互不影响，所以可以独立计算。 求出 \(dp_{i,j}\) 后，求答案也变得很显然：由于 \(dp_{m,j}\) 并没有包括 \(\max\limits_{j+k\le p\le n}sum_p\)，把这部分与 \(dp_{m,j}\) 取 \(\max\) 即可。 可以使用滚动数组优化内存。时间复杂度为 \(O(nm)\)。 正解——两者之并 可以发现，\(m&gt; \lceil \frac{n}{k}\rceil\) 与 \(m= \lceil \frac{n}{k}\rceil\) 的情况答案是相同的。所以 \(m\) 最大为 \(\lceil \frac{n}{k}\rceil\)。 上面的两个 DP，可以发现当 \(k\le 50\) 时第一个 DP 是可以过的。而 \(k&gt;50\) 时，由于 \(m\) 的级别是 \(\frac{n}{k}\)，第二个 DP 可以过。 那么把两者合并一下就可以通过此题。 正解代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define N 100005int n, m, k, a[N], h, t, Q[N];long long sum[N], mx[N];void push(int x)&#123; // 单调队列维护 while (h &lt;= t &amp;&amp; sum[Q[t]] &lt;= sum[x]) --t; Q[++t] = x;&#125;namespace Subtask1&#123; // 二分+DP O(nk log ans) int dp[N]; void upd(int i, int j)&#123; if (i &gt; n + 1) i = n + 1; dp[i] = std :: min(dp[i], j); &#125; bool check(long long x)&#123; for (register int i = 1; i &lt;= n + 1; ++i) dp[i] = 1e9; dp[1] = 0; for (register int i = 1; i &lt;= n; ++i)&#123; long long Mx = 0; for (register int j = 0; j &lt; k &amp;&amp; i + j &lt;= n; ++j)&#123; if (Mx &lt;= x &amp;&amp; mx[i + j] &lt;= x) upd(i + j + k, dp[i] + 1); Mx = std :: max(Mx, sum[i + j]); &#125; // if (x == 0) printf("%d %lld\n", i, Mx); if (Mx &lt;= x) upd(i + k, dp[i]); &#125; return dp[n + 1] &lt;= m; &#125; void Main()&#123; long long l = 0, r = 1e14, md, ans; while (l &lt;= r) if (check(md = (l + r) &gt;&gt; 1)) ans = md, r = md - 1; else l = md + 1; printf("%lld\n", ans); &#125;&#125;namespace Subtask2&#123; // DP O(nm)=O(n^2/k) long long dp[2][N]; void Main()&#123; long long Mx = 0; for (register int i = 1; i &lt;= n; ++i)&#123; if (i &gt; k) Mx = std :: max(Mx, sum[i - 1]); dp[1][i] = std :: max(Mx, mx[i]); &#125; for (register int i = 2; i &lt;= m; ++i)&#123; int t = i &amp; 1; long long Mx = 0; for (register int j = 1; j &lt;= n; ++j)&#123; if (j &gt; k) Mx = std :: max(Mx, sum[j - 1]); if (j &gt; k) Mx = std :: min(Mx, dp[!t][j - k]); dp[t][j] = std :: max(Mx, mx[j]); &#125; &#125; long long ans = 0x3f3f3f3f3f3f3f3fll; Mx = 0; for (register int i = n; i; --i)&#123; if (i + k &lt;= n) Mx = std :: max(Mx, sum[i + k]); ans = std :: min(ans, std :: max(dp[m &amp; 1][i], Mx)); &#125; printf("%lld\n", ans); &#125;&#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); m = std :: min(m, n / k + 1); for (register int i = 1; i &lt;= n; ++i) scanf("%d", a + i); for (register int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + a[i] - (i &gt; k ? a[i - k] : 0); h = 1, t = 1, Q[t] = k; for (register int i = 1; i &lt;= n; i + k &lt;= n ? push(i + k) : void(0), ++i)&#123; if (Q[h] &lt; i) ++h; mx[i] = sum[Q[h]] - a[i]; &#125; if (m &lt;= 2005) return Subtask2 :: Main(), 0; if (k &lt;= 55) return Subtask1 :: Main(), 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>二分</tag>
        <tag>RMQ</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AT1731」「CODE FESTIVAL 2015 OKINAWA OPEN」Implementation Addict]]></title>
    <url>%2Fatcoder-cfoo15I-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 有 \(n\) 天，每天有一个值 \(a_i\)（未确定的值），其中 \(a_i=0\) 的天数称为“休息”，其他的称为“工作”。 若第 \(i\) 天为“工作”，设第 \(i\) 天之前（不包含第 \(i\) 天）连续“工作”的天数为 \(k\)，则 \(a_i=\max(0,A-kB)\)（\(A,B\) 给定）；若第 \(i\) 天为“休息”，则 \(a_i=0\)。 现已经确定 \(m\) 天为“休息”，求 \(\sum_{i=1}^{n} a_i\) 的最大值。 \(n,A,B\le 10^9,m\le 10^5\) 题解 \(m\) 天“休息”，相当于把 \(n\) 分成了 \(m+1\) 份，每份是独立的，所以可以分别进行计算。所以，现在不再需要考虑 \(m\) 天“休息”。假设当前子问题的天数为 \(n\)。 为了使得和最大，一定是等分更优。例如 \(n=7\)，分成 \(3\) 块（即“休息” \(2\) 天），则一定是分别工作 \(1,2,2\) 天。为方便处理，可以将 \(n\) 加 \(1\)，钦定最后一天为“休息”。 假设分成 \(x\) 块，设 \(t=\left\lfloor \frac{n}{x}\right\rfloor-1\)，则一定是 \(n\bmod x\) 块工作 \(t+1\) 天，\(x-n\bmod x\) 块工作 \(t\) 天。这个可以直接用等差数列求和公式进行计算。 至于如何确定 \(x\)，可以发现，答案是一个单峰函数，所以直接三分 \(x\) 即可。 代码 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int n, m, x[100005];long long A, B, ans;long long get(int n, int x)&#123; // 计算 n 天分成 x 块的答案 if (x &gt; n) return 0; int m = n / x - 1; return ((A + A - (m - 1) * B) * m &gt;&gt; 1) * x + (A - m * B) * (n % x);&#125;long long solve(int n)&#123; // 三分求 n 天的答案 int l = 1, r = n, ans = 0; while (l &lt;= r)&#123; int md = (l + r) &gt;&gt; 1; // 写的有点像二分，其实是三分 if (get(n, md) &gt;= get(n, md + 1)) ans = md, r = md - 1; else l = md + 1; &#125; return get(n, ans);&#125;int main()&#123; scanf("%d%lld%lld%d", &amp;n, &amp;A, &amp;B, &amp;m), x[m + 1] = n + 1; for (register int i = 1; i &lt;= m; ++i) scanf("%d", x + i); for (register int i = 0; i &lt;= m; ++i) ans += solve(x[i + 1] - x[i]); // n 在这里已经加 1 printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AT1730」「CODE FESTIVAL 2015 OKINAWA OPEN」Happy 2015]]></title>
    <url>%2Fatcoder-cfoo15H-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定 \(n\) 个区间 \((l_r,r_i]\)（注意原题中虽然写着 \([l_i,r_i]\)，但通过转化后相当于 \((l_i,r_i]\)），每个区间有存在和不存在两种状态。求所有 \(2^n\) 种方案中，本质不同的方案的数量 \(\bmod (10^9+7)\) 的值。 记一个方案的点集合为数轴上至少被一个区间覆盖的整数组成的集合，则两个方案本质不同当且仅当这两个方案的点集合不同。 \(n\le 2000,0\le l_i&lt; r_i\le 10^9\) 题解 为方便处理，我们把 \(l_i\) 加 \(1\) 使得区间变为闭区间。 显然，\(l_i,r_i\) 可以离散，所以坐标变为 \(O(n)\) 级别。 然后考虑一个 DP，\(dp_{i,0/1}\) 表示覆盖前 \(i\) 个点，且第 \(i\) 个点必须覆盖/不覆盖的本质不同的方案数。 那么可以写出一个 \(O(n^2)\) 的 DP，方程如下：\[dp_{i,j}=\begin{cases} dp_{i-1,0}+dp_{i-1,1} &amp; \text{ if } j=0 \\ \sum\limits_{cov(k,i)=1} dp_{k-1,0} &amp; \text{ if } j=1 \end{cases}\] 其中 \(cov(k,i)=0/1\) 表示是否存在一种区间覆盖方案使得刚好覆盖 \([k,i]\)。 \(cov(i,j)\) 可以用如下方式处理： 记 \(p_i\)（一个 vector） 表示所有右端点为 \(i\) 的区间的左端点。 枚举 \(i\)（被覆盖部分的左端点），首先枚举所有左端点为 \(i\) 的区间 \([i,r_j]\)，使得 \(cov(i,r_j)=1\)。 然后枚举所有右端点 \(j\)，再枚举所有右端点为 \(j\) 的区间（即 \([p_{j,k},j]\) ），若 \(p_{j,k}&gt; i\) 且存在一个 \(x\in [p_{j,k},j]\) 满足 \(cov(i,x)=1\)，则 \(cov(i,j)=1\)。 至于如何判断“存在一个 \(x\in [p_{j,k},j]\) 满足 \(cov(i,x)=1\)”，可以在枚举右端点求 \(cov(i,j)\) 的同时用前缀和进行判断，具体实现见代码。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define P 1000000007int n, m, pos[4005], sum[4005], dp0[4005], dp1[4005];bool cov[4005][4005];std :: vector&lt;int&gt; p[4005];struct node&#123; int l, r;&#125;a[2005];void add(int &amp;x, int y)&#123; (x += y) &gt;= P ? x -= P : 0;&#125;int main()&#123; scanf("%d", &amp;n); for (register int i = 1; i &lt;= n; ++i) scanf("%d%d", &amp;a[i].l, &amp;a[i].r), pos[++m] = a[i].l, pos[++m] = a[i].r; std :: sort(pos + 1, pos + 1 + m); m = std :: unique(pos + 1, pos + 1 + m) - pos - 1; for (register int i = 1; i &lt;= n; ++i)&#123; a[i].l = std :: lower_bound(pos + 1, pos + 1 + m, a[i].l) - pos + 1; a[i].r = std :: lower_bound(pos + 1, pos + 1 + m, a[i].r) - pos; p[a[i].r].push_back(a[i].l); &#125; // 以上分别为：转为闭区间、离散、处理 p for (register int i = 1; i &lt;= m; ++i)&#123; sum[i] = 0; for (register int j = 1; j &lt;= n; ++j) if (a[j].l == i) cov[i][a[j].r] = 1; for (register int j = i; j &lt;= m; ++j)&#123; for (register int k = 0; k &lt; p[j].size(); ++k) if (p[j][k] &gt; i &amp;&amp; sum[j] &gt; sum[p[j][k] - 1])&#123; cov[i][j] = 1; break; &#125; // 根据前缀和判断 sum[j + 1] = sum[j] + cov[i][j]; // 同时处理前缀和 &#125; &#125; // 以上为处理 cov dp0[0] = 1; for (register int i = 1; i &lt;= m; ++i)&#123; add(dp0[i], dp0[i - 1]), add(dp0[i], dp1[i - 1]); for (register int j = 1; j &lt;= i; ++j) if (cov[j][i]) add(dp1[i], dp0[j - 1]); &#125; // 以上为 dp add(dp0[m], dp1[m]), printf("%d\n", dp0[m]);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>离散</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AT1729」「CODE FESTIVAL 2015 OKINAWA OPEN」Gorgeous Vases]]></title>
    <url>%2Fatcoder-cfoo15G-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 有两个有序二元组 \((A,B),(C,D)\)，\(A,B\) 给定且保证 \(A\ge B\)，\(C,D\) 一开始为 \(0\)。另外给定 \(n\) 个有序二元组 \((p_i,q_i)\)，有两种操作： \(A\gets A-1,C\gets C+1\) \(B\gets B-1,D\gets D+1\) 不断执行这两种操作，直到二元组变为 \((0,0),(A&#39;,B&#39;)\)，其中 \(A&#39;,B&#39;\) 表示最初的 \(A,B\)。但任意时刻都需要满足： \(A\ge B,C\ge D\) \(\forall i\in [1,n],(A,B)\ne (p_i,q_i),(C,D)\ne (p_i,q_i)\)。 求方案数 \(\bmod (10^9+7)\) 的值。 记操作序列为由每次的操作编号组成的长度为 \(A&#39;+B&#39;\) 的序列，则两个方案不同当且仅当两个方案的操作序列不同。 \(1\le B\le A\le 10^5,0\le n\le 20\) 题解 可以发现，题目可以转化为： 从 \((0,0)\) 走到 \((A,B)\)，每次只能走 \((+1,0)\) 或 \((0,+1)\)（即只能向上、向右走），求满足以下条件的方案数： 1. 对于所有经过的点 \((x,y)\)，\(x\ge y,A-x\ge B-y\) 2. 不能经过点 \((p_i,q_i),(A-p_i,B-q_i)\)。 把 \((A,B)\) 和所有不能经过的点称为障碍点，把障碍点按一定顺序排序后，可以很轻松地写出一个 DP： \(dp_i\) 表示到达障碍点 \(i\) 的方案数，则 \(dp_i=solve(0,i)-\sum dp_j+solve(j,i)\)，其中 \(j\) 在 \(i\) 的左下方，\(solve(j,i)\) 表示 \(j\) 到 \(i\) 的方案数，\(solve(0,i)\) 表示 \((0,0)\) 到 \(i\) 的方案数。 发现关键在于如何求 \(solve(i,j)\) 的值。那么问题又转化为： 从 \((x_1,y_1)\) 走到 \((x_2,y_2)\)，只能向上、向右走，满足所有经过的点 \((x,y)\) 在直线 \(y=x\) 和 \(y=x-(A-B)\) 之间（包括这两条直线上的点），求方案数。 图 1 类似上图中的情况，求 \((x_1,y_2)\) 到 \((x_2,y_2)\) 的方案数。 首先，为方便起见，把两条直线分别向上、向下移动一个单位，这样我们就不能碰到这两条直线，碰到即算不符合。 考虑所有情况减去不符合要求的情况，所有情况可以用组合数直接计算，那么我们要计算下图中的两种情况的方案数。 图 2 我们先考虑左图的情况，可以发现，左图的情况可以把剩余部分按直线 \(y=x+1\) 对称，如下图所示： 图 3 此时 \((x_1,y_1)\) 到 \((x_2,y_2)\) 一定会碰到 \(y=x+1\)，即图 2 中左图的情况。 可是会发现，如果一个方案穿过了 \(y=x+1\)，然后又穿过了 \(y=x-(A-B)-1\)，则这个方案会被重复计算，需要减去。 可以发现，对称后，\(y=x-(A-B)-1\) 这条直线到了最上面，即此时的情况为（下图中的左图）： 图 4 那么同样，对称后计算（如上图右图所示）。 如果还有重复情况（即上下上、上下上下等情况），则继续对称即可。 具体实现及细节见代码。 代码 注意，代码并不是每次作对称然后判断正负的，而是把所有负的都减掉，再把所有正的加上，所以与上面的分析有所出入，请仔细理解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define P 1000000007int A, B, n, m, fac[200005], inv[200005], dp[50];struct node&#123; int x, y; bool operator &lt; (const node &amp;res) const &#123; return x &lt; res.x || x == res.x &amp;&amp; y &lt; res.y; &#125; bool operator == (const node &amp;res) const &#123; return x == res.x &amp;&amp; y == res.y; &#125;&#125;p[50];bool check(int m)&#123; return p[m].y &lt;= p[m].x &amp;&amp; p[m].y &gt;= p[m].x - A + B;&#125;int qpow(int a, int b)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if (b &amp; 1) s = 1ll * s * a % P; return s;&#125;void pre(int n)&#123; fac[0] = 1; for (register int i = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % P; inv[n] = qpow(fac[n], P - 2); for (register int i = n; i; --i) inv[i - 1] = 1ll * inv[i] * i % P;&#125;int F(node a, node b)&#123; if (a.x &gt; b.x || a.y &gt; b.y) return 0; return 1ll * fac[b.x - a.x + b.y - a.y] * inv[b.x - a.x] % P * inv[b.y - a.y] % P;&#125;void add(int &amp;x, int y)&#123; (x += y) &gt;= P ? x -= P : 0; &#125;void del(int &amp;x, int y)&#123; (x -= y) &lt; 0 ? x += P : 0; &#125;int calc(node a, node b)&#123; // 计算 a 到 b 的方案数，主要难在这个函数 int res = F(a, b), w = A - B + 2; for (register node c = (node)&#123;b.y - 1, b.x + 1&#125;; c.x &gt;= a.x; c.x -= w, c.y += w) del(res, F(a, c)); for (register node c = (node)&#123;b.x - w, b.y + w&#125;; c.x &gt;= a.x; c.x -= w, c.y += w) add(res, F(a, c)); for (register node c = (node)&#123;b.y + w - 1, b.x - w + 1&#125;; c.y &gt;= a.y; c.x += w, c.y -= w) del(res, F(a, c)); for (register node c = (node)&#123;b.x + w, b.y - w&#125;; c.y &gt;= a.y; c.x += w, c.y -= w) add(res, F(a, c)); return res;&#125;int main()&#123; scanf("%d%d%d", &amp;A, &amp;B, &amp;n), pre(A + B); if (A == B) return printf("0\n"), 0; for (register int i = 1, x, y; i &lt;= n; ++i)&#123; scanf("%d%d", &amp;x, &amp;y); if (!x &amp;&amp; !y) return printf("0\n"), 0; if (x == A &amp;&amp; x == B) return printf("0\n"), 0; p[++m] = (node)&#123;x, y&#125;, !check(m) ? --m : 0; p[++m] = (node)&#123;A - x, B - y&#125;, !check(m) ? --m : 0; &#125; p[0] = (node)&#123;0, 0&#125;, p[++m] = (node)&#123;A, B&#125;; std :: sort(p + 1, p + 1 + m); m = std :: unique(p + 1, p + 1 + m) - p - 1; for (register int i = 1; i &lt;= m; ++i)&#123; dp[i] = calc(p[0], p[i]); for (register int j = 1; j &lt; i; ++j) (dp[i] -= 1ll * dp[j] * calc(p[j], p[i]) % P) &lt; 0 ? dp[i] += P : 0; &#125; printf("%d\n", dp[m]);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AT1728」「CODE FESTIVAL 2015 OKINAWA OPEN」Falconry]]></title>
    <url>%2Fatcoder-cfoo15F-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定平面上 \(n\) 个点 \((x_i,y_i)\)，以及三只鸟的初始坐标 \((x_a,y_a),(x_b,y_b),(x_c,y_c)\)。现在三只鸟要从初始点开始，依次飞到一些点（不需要回到起点），要求每个点至少被一只鸟飞到。求三只鸟总飞行距离之和的最小值。 从一个点 \((x_s,y_s)\) 飞到另一个点 \((x_t,y_t)\) 的飞行距离为这两个点的欧几里得距离，即 \[\sqrt{(x_s - x_t)^2 + (y_s - y_t)^2}\] \(n\le 18\)，所有横纵坐标的绝对值 \(\le 10^4\)，时限 \(8s\)。 方法一 三只鸟很难考虑，考虑一只鸟飞遍某个点集所需的最少时间。 记 \(dp_{t,i,j}\) 表示第 \(t\) 只鸟，飞遍点集 \(i\)，最后停留在点 \(j\) 的最小距离和。 转移很显然，只要在点集 \(i\) 中枚举上一个点 \(k\)，然后直接转移即可。 最后枚举每只鸟飞到的点集即可，因为两只鸟飞到的点集不会有交，所以复杂度为 \(O(3^n)\)。具体实现时，可以枚举一个集合 \(A\)，再枚举这个集合的子集 \(B\)，假设全集为 \(C\)，则三个集合分别为 \(B,A-B,C-A\)。 时间复杂度 \(O(3n^22^n+3^n)\)，常数不大，最大点 \(2898ms\)（评测记录）。 方法二 发现上面的方法比较慢，且主要在于 \(3^n\) 的统计答案。考虑直接在第二只鸟、第三只鸟 DP 时，直接合并答案。 记 \(dp_{t,i,j}\) 表示前 \(i\) 只鸟，飞遍点集 \(i\)，第 \(i\) 只鸟停留在点 \(j\) 时的最小距离和。 主要转移方程与方法一差不多，但是有一些细节需要注意，例如飞到第一个点时需要特殊转移，具体参见代码。也许有更好的、细节更少的写法，欢迎分享。 时间复杂度 \(O(3n^22^n)\)，最大点 \(535ms\)（评测记录）。 代码 方法一 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int n;struct point&#123; int x, y;&#125;a[20], b[3];double Dp[3][300000][20];double dis(point a, point b)&#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;int main()&#123; scanf("%d", &amp;n); for (register int i = 0; i &lt; n; ++i) scanf("%d%d", &amp;a[i].x, &amp;a[i].y); for (register int i = 0; i &lt; 3; ++i) scanf("%d%d", &amp;b[i].x, &amp;b[i].y); for (register int t = 0; t &lt; 3; ++t)&#123; double (*dp)[20] = Dp[t]; for (register int i = 0; i &lt; (1 &lt;&lt; n); ++i) for (register int j = 0; j &lt;= n; ++j) dp[i][j] = 1e100; dp[0][n] = 0; for (register int i = 0; i &lt; n; ++i) dp[1 &lt;&lt; i][i] = dis(b[t], a[i]); for (register int i = 0; i &lt; (1 &lt;&lt; n); ++i) for (register int j = 0; j &lt; n; ++j) if (i &gt;&gt; j &amp; 1)&#123; for (register int k = 0; k &lt; n; ++k) if (i &gt;&gt; k &amp; 1 &amp;&amp; k != j) dp[i][j] = std :: min(dp[i][j], dp[1 &lt;&lt; j ^ i][k] + dis(a[k], a[j])); dp[i][n] = std :: min(dp[i][n], dp[i][j]); // 这个状态记录0~n-1的最小值 &#125; &#125; double ans = 1e100; for (register int i = 0; i &lt; (1 &lt;&lt; n); ++i) for (register int j = i; j &gt;= 0; j = (j - 1) &amp; i)&#123; int A = j, B = i ^ j, C = ((1 &lt;&lt; n) - 1) ^ i; ans = std :: min(ans, Dp[0][A][n] + Dp[1][B][n] + Dp[2][C][n]); if (!j) break; &#125; printf("%.12lf\n", ans);&#125; 方法二 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int n;struct point&#123; int x, y;&#125;a[20], b;double dp[3][300000][20], d[20][20];double dis(point a, point b)&#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;int main()&#123; scanf("%d", &amp;n); for (register int i = 0; i &lt; n; ++i) scanf("%d%d", &amp;a[i].x, &amp;a[i].y); for (register int t = 0; t &lt; 3; ++t)&#123; scanf("%d%d", &amp;b.x, &amp;b.y); for (register int i = 0; i &lt; (1 &lt;&lt; n); ++i) for (register int j = 0; j &lt;= n; ++j) dp[t][i][j] = 1e100; for (register int i = 0; i &lt; n; ++i) for (register int j = 0; j &lt; n; ++j) d[i][j] = dis(a[i], a[j]); dp[t][0][n] = 0; for (register int i = 0; i &lt; n; ++i) dp[t][1 &lt;&lt; i][i] = dis(b, a[i]); for (register int i = 0; i &lt; (1 &lt;&lt; n); ++i) for (register int j = 0; j &lt; n; ++j) if (i &gt;&gt; j &amp; 1)&#123; dp[t][i][n] = std :: min(t ? dp[t - 1][i][n] : 1e100, dp[t][i][n]); // 特殊转移 1 for (register int k = 0; k &lt; n; ++k) if (i &gt;&gt; k &amp; 1 &amp;&amp; k != j) dp[t][i][j] = std :: min(dp[t][i][j], dp[t][1 &lt;&lt; j ^ i][k] + d[k][j]); dp[t][i][j] = std :: min(dp[t][i][j], t ? dp[t - 1][1 &lt;&lt; j ^ i][n] + dis(b, a[j]) : 1e100); // 特殊转移 2 dp[t][i][n] = std :: min(dp[t][i][n], dp[t][i][j]); &#125; &#125; printf("%.12lf\n", dp[2][(1 &lt;&lt; n) - 1][n]);&#125; 有更好的写法或复杂度更优的做法请在评论中分享！]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AT1727」「CODE FESTIVAL 2015 OKINAWA OPEN」Enormous XOR Rectangle]]></title>
    <url>%2Fatcoder-cfoo15E-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 \(H\times W\) 的矩阵，第 \(i(0\le i&lt; H)\) 行第 \(j(0\le j&lt; W)\) 列的数为 \(iW+j\)。 选一个子矩阵，使得该子矩阵中所有元素 xor 的值最大。输出这个值。 \(H,W\le 10^9\) 分析 记 \(n\) 为满足 \(2^{n-1} \le H\times W-1 &lt; 2^n\) 的值。所以答案一定 \(&lt; 2^n\)。 当 \(2^{n-1}-1\) 与 \(2^{n-1}\) 左右相邻时，由于 \((2^{n-1}-1)\text{ xor }(2^{n-1})=2^n-1\)，所以答案显然为 \(2^n-1\)。 否则，此时的情况一定是 \(2^{n-1}-1\) 在某行的最后一列，\(2^{n-1}\) 在这一行下面一行的第一列，所以 \(W\) 此时一定能表示为 \(2^m(0\le m\le n-1)\)。例如： 12345678 0 1 2 3 4 5 6 7 8 9 10 1112 13 14 15-----------16 17 18 1920 21 22 2324 25 26 27 图中 \(n=5,2^{n-1}-1=15,2^{n-1}=16\)。 这种情况下，下界显然是 \(2^n-2^m=2^n-W\)，即 \((2^{n-1}-1)\text{ xor }(2^{n-1}-1+2^m)\)。记这个下界为 \(d\)，考虑是否有答案超过 \(d\) 的情况。 通过观察可以发现： 一行中所有数的最高 \(n-m\) 位都相同。 一列中所有数的最后 \(m\) 位都相同。 继续分析可以得到： 若选偶数行，xor 值的最后 \(m\) 位都是 \(0\)，答案 \(\le d\)。 若选偶数列，xor 值的最高 \(n-m\) 位都是 \(0\)，答案 \(\le d\)。 若选奇数列，考虑每一行，一定在该行中存在一个数与该行的 xor 值相等，且每一行的这个数一定在同一列，所以选奇数列的所有情况相当于选 \(1\) 列的所有情况。那么，为了得到最优的答案，一定选择最后一列。 综上，我们选择的范围变成了最后一列，选奇数行。并且，若存在这样的答案，答案最后的 \(m\) 位一定都为 \(1\)。那么超过 \(d\) 的答案只可能是 \(2^n-1\)。 所以，问题变成了以一个序列上的问题： \(H\) 个数，第 \(i(0\le i&lt; H)\) 个数为 \(i\)，问是否存在一个区间，使得这个区间的 xor 值为 \(2^{n-m}-1\)。 例如： 10 1 2 3 | 4 5 6 分界线左边最高位为 \(0\)，右边最高位为 \(1\)。由于要达到 \(2^{n-m}-1\)，分界线右边必须选奇数个，才能保证最高位为 \(1\)。 根据 \((2n)\text{ xor }(2n+1)=1\ (n\ge 0)\)，可以证明分界线左边的数不需要选择。 根据 \(0\text{ xor }1\text{ xor }2\text{ xor }\cdots\text{ xor }(2^n-1)=0 \ (n\ge 2)\)，可以证明右边若要选出 \(2^{n-m}-1\)，必须选择 \(2^{n-m-1}\sim 2^{n-m}-2\) 的所有数。 注意上述结论是一般情况，\(n-m\) 特别小时可以特殊处理，不过仍然可以证明下面总结中的结论是正确的。 结论 根据上面的分析、推导和转化，可以得到如下结论： 若 \(W\) 不是 \(2\) 的幂次，或者 \(H\) 是 \(2\) 的幂次，或者 \(H+1\) 是 \(2\) 的幂次，则答案为 \(2^n-W\)，否则答案为 \(2^n-1\)。 技巧 判断一个数是否是 \(2\) 的幂次，可以根据 \(lowbit\) 与该数本身是否相等来判断。 代码 12345678910#include &lt;cstdio&gt;bool check(int x)&#123; return (x &amp; -x) == x; &#125; // 技巧int H, W, n;int main()&#123; scanf("%d%d", &amp;H, &amp;W); long long tmp = 1ll * H * W - 1; while (tmp) ++n, tmp &gt;&gt;= 1; // 求 n if (!check(W) || check(H) || check(H + 1)) printf("%lld\n", (1ll &lt;&lt; n) - 1); else printf("%lld\n", (1ll &lt;&lt; n) - W);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LuoguP3846」「TJOI2007」可爱的质数 / BSGS 学习笔记]]></title>
    <url>%2Fluogu3846-sol-bsgs-notes%2F</url>
    <content type="text"><![CDATA[大步小步法（Baby Step Giant Step, BSGS），用于解决求形如 \(a^x\equiv b \pmod P\) 的最小非负整数解，其中\((a,P)=1\)。 求解 显然 \(x\) 可以表示为 \(i\cdot t-j\) 的形式，其中 \(t\) 是常数。那么原方程化为 \[\begin{aligned} a^{it-j} &amp;\equiv b &amp;\pmod P \\ \frac{a^{it}}{a^j} &amp;\equiv b &amp;\pmod P \\ a^{it}&amp;\equiv ba^j &amp;\pmod P \end{aligned}\] 又根据欧拉定理可得，\(a^b\equiv a^{b\bmod \varphi(P)}\pmod P\)，所以最小非负整数解一定满足 \(0\le x &lt; \varphi(P)\)。 那么 \(t\) 取 \(\lfloor \sqrt{\varphi(P)}\rfloor\) 时，\(i,j\) 的数量都是 \(\mathcal O(\sqrt{P})\) 的。所以我们只要对于所有的 \(i\) 求出 \(a^{it}\)，对于所有的 \(j\) 求出 \(ba^j\)，然后匹配即可。 具体实现时，可以用 map 或 hashmap 实现快速查找。 代码 「TJOI2007」可爱的质数 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;map&gt;int P, a, b;int BSGS(int a, int b)&#123; a %= P, b %= P; if (a == 0) return b == 0 ? 1 : -1; std :: map&lt;int, int&gt; M; int t = sqrt(P) + 1, x = 1, y; for (register int i = 0; i &lt; t; ++i, x = 1ll * x * a % P) M[1ll * x * b % P] = i; y = x; if (M.count(1) &amp;&amp; M[1] == 0) return 0; for (register int i = 1; i &lt;= t; ++i, x = 1ll * x * y % P) if (M.count(x)) return i * t - M[x]; return -1;&#125;void write_ans(int x)&#123; if (x &lt; 0) printf("no solution\n"); else printf("%d\n", x);&#125;int main()&#123; scanf("%d%d%d", &amp;P, &amp;a, &amp;b); write_ans(BSGS(a, b));&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>TJOI</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AT1726」「CODE FESTIVAL 2015 OKINAWA OPEN」Dictionary for Shiritori Game]]></title>
    <url>%2Fatcoder-cfoo15D-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定大小为 \(n\) 的字符集和 \(m\) 个单词，第 \(i\) 个单词以字符 \(a_i\) 开头，以字符 \(b_i\) 结尾。 Snuke 和 Sothe 轮流玩单词接龙游戏（Snuke 先手）。每次游戏那个人必须说出一个以上个单词的末尾字符开头的单词，第一个人必须说出一个以字符 1 开头的单词。若轮到该人进行游戏时，说不出符合条件的单词，则该人失败。 假设两人绝对聪明，判断谁是胜者或者游戏会永远进行下去。 \(n\le 10^5,m\le 2\times 10^5\) 题解 每个字符当作一个状态，建出游戏图（\(a_i\to b_i\)）。若游戏图中某个点的所有儿子都是必胜态，则当前点必败；若当前点的所有儿子中有一个状态是必败，则当前点必胜；否则为平局。 直接用 dfs 会因为有环而变得很难搞（求助路过的 dalao 帮蒟蒻看一下 代码，WA 3个点 QAQ），所以考虑建反图，倒着推。 代码 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;int read()&#123; register int x = 0, ch = getchar(); for (; !isdigit(ch); ch = getchar()) ; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x;&#125;#define N 100005#define M 200005int n, m, f[N], h, t, Q[N], d[N];int edge, to[M], pr[M], hd[N];void addedge(int u, int v)&#123; // 连边 to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;&#125;int main()&#123; n = read(), m = read(); for (register int i = 1, x, y; i &lt;= m; ++i) x = read(), y = read(), addedge(y, x), ++d[x]; // 倒推，反向连边 h = 0, t = 0; for (register int i = 1; i &lt;= n; ++i) if (!d[i]) Q[++t] = i, f[i] = 2; // 边界状态 while (h &lt; t)&#123; int u = Q[++h]; if (f[u] == 2) // 当前状态必败 for (register int i = hd[u]; i; i = pr[i]) !f[to[i]] ? Q[++t] = to[i] : 0, f[to[i]] = 1; // 则父状态必胜 else // 当前状态必胜 for (register int i = hd[u]; i; i = pr[i]) if (!(--d[to[i]])) Q[++t] = to[i], f[to[i]] = 2; // 所有后继状态都是必胜，则必败 &#125; if (f[1] == 0) printf("Draw\n"); else if (f[1] == 1) printf("Snuke\n"); else if (f[1] == 2) printf("Sothe\n");&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>建图</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AT1725」「CODE FESTIVAL 2015 OKINAWA OPEN」Cat versus Wolf]]></title>
    <url>%2Fatcoder-cfoo15C-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定一个初始状态如图所示的建筑，共 \(n\) 层（不包括 Daruma），自底向上编号 \(1\sim n\)。 下图分别表示建筑的初始状态、奇数层的放置和偶数层的放置。 Snuke 和 Sothe 轮流进行游戏，Snuke 先手，每次游戏可以拿走建筑中的任意一块砖头，但不允许拿走砖头后建筑变得不平衡。如果不存在砖头可以被拿走，那么该玩家输。 给定一个未结束的游戏，判断两人在绝对聪明的情况下，谁是必胜者（需要根据以拿走的砖块数量确定先手）。 不平衡的定义是，\(n\)层中，存在某层没有砖块，或只有一块砖且这块砖在两侧。 \(n\le 50000\) 题解 显然是个博弈问题。且层与层之间独立，所以可以看作是 \(n\) 个单独的游戏的和。那么我们只要求出每一层的 SG 函数值，然后 xor 起来即可。 每一层只有 \(2^3-3=5\) 种可能的情况，分类讨论每种情况的 SG 函数值即可。 游戏图如下（0 表示没有砖块，1 表示有砖块，括号内的数表示该状态的 SG 函数值）： 代码 12345678910111213141516#include &lt;bits/stdc++.h&gt;int n, S, ans;char s[3][3];int main()&#123; scanf("%d", &amp;n); for (register int i = 1; i &lt;= n; ++i)&#123; for (register int j = 0; j &lt; 3; ++j) scanf("%s", s[j]); if (s[0][0] == '#' &amp;&amp; s[1][1] == '#' &amp;&amp; s[2][2] == '#') ans ^= 2; if (s[0][0] == '.' &amp;&amp; s[1][1] == '#' &amp;&amp; s[2][2] == '#') ans ^= 1, ++S; if (s[0][0] == '#' &amp;&amp; s[1][1] == '#' &amp;&amp; s[2][2] == '.') ans ^= 1, ++S; if (s[0][0] == '.' &amp;&amp; s[1][1] == '#' &amp;&amp; s[2][2] == '.') S += 2; if (s[0][0] == '#' &amp;&amp; s[1][1] == '.' &amp;&amp; s[2][2] == '#') ++S; // 五种情况分类讨论 &#125; printf((!ans) == (S &amp; 1) ? "Snuke\n" : "Sothe\n"); // 注意判断先后手&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>SG函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AT1724」「CODE FESTIVAL 2015 OKINAWA OPEN」Beware of the Sogginess!]]></title>
    <url>%2Fatcoder-cfoo15B-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定 \(n\) 个二元组 \((a_i,b_i)\)。一个二元组 \((a,b)\) 可以变为 \((a+t,b-t)\ (0\le t\le b)\)。你现在可以选择一些二元组并将它们分别进行（即互相独立）一次变换，使得变换后你选择的所有二元组 \((a_j,b_j)\)，\(\sum a_j\ge A,\sum b_j\ge B\)。求最少需要选择并变换的二元组数量。 \(1\le n\le 50,1\le A,B,a_i,b_i\le 10^4\) 题解 转化题意：给定 \(n\) 个二元组 \((b_i,a_i+b_i)\)，选择最少的二元组使得所有选择的二元组 \(\sum b_j\ge B,\sum (a_j+b_j)\ge A+B\)。 于是就可以 DP 了。\(dp_{i,j}\) 表示选择 \(i\) 个二元组，\(\sum b_i=j\) 时，\(\sum (a_i+b_i)\) 的最大值。 考虑把 \(n\) 个二元组依次加入，DP 方程很容易写出。 发现直接写，第二维有百万级别，怎么办？\(j&gt;B\) 的状态都合并到 \(j=B\) 处即可。 代码 1234567891011121314#include &lt;bits/stdc++.h&gt;int n, A, B, a[55], b[55], dp[55][10005];void cmx(int &amp;x, int y)&#123; x = std :: max(x, y); &#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;B, &amp;A), B += A; // 与上面的 A,B 有区别，注意区分 for (register int i = 1; i &lt;= n; ++i) scanf("%d%d", b + i, a + i), b[i] += a[i]; // 与上面的 ai,bi 有区别，注意区分 memset(dp, -1, sizeof dp), dp[0][0] = 0; for (register int i = 1; i &lt;= n; ++i) // 依次加入 for (register int j = i - 1; ~j; --j) // 倒着做，与 01 背包同理 for (register int k = 0; k &lt;= A; ++k) if (~dp[j][k]) cmx(dp[j + 1][k + a[i] &gt; A ? A : k + a[i]], dp[j][k] + b[i]); for (register int i = 1; i &lt;= n; ++i) if (dp[i][A] &gt;= B) return printf("%d\n", i), 0; return printf("-1\n"), 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AT1723」「CODE FESTIVAL 2015 OKINAWA OPEN」Automatic Map Generator]]></title>
    <url>%2Fatcoder-cfoo15A-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 构造一张 \(H\times W\) 的由岛屿#、海洋.组成的地图，岛屿为八连通，满足恰好包含 \(K\) 个联通块。 \(1\le H,W\le 100,1\le K\le 10000\) 题解 为了放置更多的联通块，每个联通块恰好为一个单位时显然最优。 所以放一张类似于下图所示的地图即可（即在奇数行奇数列放置#，直到放满 \(K\) 个）。 123#.#.#.#.........#.#.#.#. 代码 1234567891011121314#include &lt;cstdio&gt;int n, m, t;char a[105][105];int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;t); for (register int i = 1; i &lt;= n; ++i) for (register int j = 1; j &lt;= m; ++j) if (t &amp;&amp; (i &amp; 1) &amp;&amp; (j &amp; 1)) a[i][j] = '#', --t; else a[i][j] = '.'; if (t) return printf("IMPOSSIBLE\n"), 0; for (register int i = 1; i &lt;= n; ++i)&#123; for (register int j = 1; j &lt;= m; ++j) putchar(a[i][j]); putchar('\n'); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
        <category>CODE FESTIVAL 2015 OKINAWA OPEN</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018 题解]]></title>
    <url>%2Fnoip2018-sol%2F</url>
    <content type="text"><![CDATA[蒟蒻写的 NOIP2018 题解，欢迎吐槽。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NOIP2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PKUWC2019 自闭记]]></title>
    <url>%2Fpkuwc2019%2F</url>
    <content type="text"><![CDATA[评（tu）价（cao）：如何评价PKUWC 2019？ - 知乎 Day -N 联赛没考好。不过最后还是能去PKUWC。于是就又去某强者聚集的高中被吊锤了。 Day -1 晚上。吃完晚饭以后就到了火车站，大概7点左右到的吧。然后就是等人、取票、进站…… 先乘高铁到杭州，然后在杭州转车（动卧）。在杭州也等了好一会吧，20:55，动车开了…… 基本就是整理行李、玩手机以及各种探索（大雾。 Day 0 凌晨2点醒了一次，好像是被冷醒的，因为房间里吹出来的风是冷的。盖好被子以后就又睡着了，早上5:10就被fy吵醒了……总的来说睡眠质量极差。 8点就到中山了，有专车来接，直接到中山纪念中学报到了。纪中占地面积是真的大，850亩，风景挺好的。 没事干，就去旁边的孙中山故居逛了一圈，fy和ykl都去参加了那个答题，得到了一个胸章。 天气很好，气温很高，穿着棉袄、线衫、加绒裤，热到不行。 回酒店，在旁边的餐馆吃中饭，可惜的是烧鹅没了，只能吃烧鸭。4点回学校，试机，吃晚饭。这里的食堂不是很好，饭没有浙江的好吃。试机T2都不会做。 晚上逛学校，还好袋子里有地图，差点迷路…… Day 1 上午开营仪式，看了一下宣传片，听了纪中的校长、北大的两个教授的讲话。门开得正可海星。然后是营员合影。 下午的上机爆炸。T1就是个状压，我想到正解感觉好麻烦就放弃了……最后还是只有35的暴力。 T2想了好一会\(m=2\)和链的做法，想了没多久也放弃了。 T3地主斗，写了2.5h一分未得。考后和同学的方法比较，感觉细节应该都判了啊。 最后35+0+0=35……自闭了，还是策略不对吧。 Day 2 早上突然想到地主斗那题，排的顺序是无关的，搜索的时候要判一下…… 上午数学考试，实质是提答十合一，貌似是py优势场。我这种菜鸡只会写暴力，大概只对了两道？ 下午的上机仍然爆炸，T1第一个包一眼，第二个包想了好久，不过还好搞出来了。 T2当时好像\(n,m\le 10\)都不会，最后40分钟感觉没事干就写了个很fake的dfs，竟然过了。 T3不说了，计算几何告辞（知道前两个包怎么做，不会实现）。 当场自闭，T1满分想不出来，T2根本不会，为了防止跟昨天一样，我果断（其实还是很犹豫地）放弃了T3。 最后得分48+21+0=69。自闭了。 Day 3 这种分数显然进不了面试，滚粗。还是太菜了啊。 于是我和zyk就在ll的带领下去珠海旅游了（另外两人比较颓，没来）。 ll说我们主要是因为数学考太差，然而我觉得我都考太差…… 先到海滨公园，看了珠海渔女。海岸线确实挺曲折的。然后就差不多要吃饭了，沿海岸线走到了一家海鲜餐厅，点了大概6碗菜吧，味道还不错。 饭吃完我们骑共享单车沿海岸线骑，一直骑到边防管理区（通往澳门的桥的桥头），大概骑了7km。发现那里离珠海站很近，就直接乘轻轨回到南朗，买了六点半的票。发现还早，于是提议去圆明新园逛一圈。 又骑了5km，在圆明新园里面逛了一圈，感觉就是个横店影视城的弱化版？去坐了一下缆车，但是观景体验极差，感觉浪费了150块钱。 差不多时间了就去珠海站附近，逛了一圈决定吃煲仔饭，吃完就去进站候车了。 基本一下午都在骑车、走路，心态崩。 Day 4 打算8点起床的，结果9点才醒，还是因为窗帘没拉好透出了光被亮醒的……起床之后去吃了早饭，然后洗了个澡，等ykl也完了以后就下去了。 退房，上大巴。大部分人都是去机场的，就我们四个人，变成包车了。一路上qq和司机聊得挺欢。 中饭吃车站里的麦当劳，高铁15:38开，就在车站里找了个位置玩手机。车站人很多，大概是因为春运？好不容易才找到位置。 晚饭在高铁上吃盒饭，拿了个鸡翅和鱼，竟然要￥60……而且不是很好吃…… 到义乌，fy爸爸来接，到家23:00，等睡着就00:00了。 还是太菜了，省选根本没戏，正月要恶补文化课了。班主任还强迫我把期末考试补起来，啥都没复习，还没有状态……凉凉。]]></content>
      <categories>
        <category>游记</category>
        <category>PKUWC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「LuoguP3723」「AHOI / HNOI2017」礼物]]></title>
    <url>%2Fluogu3723-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定两个长度为\(n\)的正整数序列\(a_0,a_1,a_2,\cdots,a_{n-1}\)和\(b_0,b_1,b_2,\cdots,b_{n-1}\)，满足\(a_i,b_i\le m\)。 求\[\sum_{i=0}^{n-1} ((a_i+c_0)-(b_{(i+k)\bmod n}+c_1))^2\]的最小值，其中\(k,c_0,c_1\)是非负整数。 \(n\le 5\times 10^4,m\le 100\)。 题解 观察上式，可以发现我们并不关心\(c_0,c_1\)具体的值，只关心\(c_0-c_1\)的值。记\(c=c_0-c_1\)，显然有\(-m\le c\le m\)。于是变成了求\[\sum_{i=0}^{n-1} (a_i-b_{(i+k)\bmod n}+c)^2\]的最小值，其中\(0\le k\le n-1,-m\le c\le m\)。 最朴素的做法是直接枚举\(k,c\)计算答案，时间复杂度\(O(n^2m)\)。 这个和的平方的形式很难优化，考虑把它展开： \[\begin{aligned} &amp;\quad \sum_{i=0}^{n-1}(a_i-b_{(i+k)\bmod n}+c)^2 \\ &amp;=\sum_{i=0}^{n-1}(a_i^2+b_{(i+k)\bmod n}^2+c^2-2a_ib_{(i+k)\bmod n}+2a_ic-2b_{(i+k)\bmod n}c) \\ &amp;=-2\sum a_ib_{(i+k)\bmod n}+\sum a_i^2+\sum b_i^2+2c\sum (a_i-b_i)+nc^2 \end{aligned}\] 然后我们发现，\(k,c\)并没有同时影响答案中的某一项。第一项为与\(k\)有关的式子，显然后面部分为关于\(c\)的一个二次函数。后面部分可以直接用二次函数的顶点公式计算（注意\(c\)是整数，需要讨论两种情况），也可以直接枚举\(c\)进行计算。 如果前面部分也直接枚举\(k\)进行计算的话，时间复杂度为\(\mathcal O(n^2)\)，仍不能通过。 先不考虑系数。\(\bmod\)很难处理，考虑把\(b\)倍长，原式变成了\(\sum a_ib_{i+k}\)。联系卷积的基本形式\(c_i=\sum_{j=0}^{i} a_jb_{i-j}\)，可以发现需要满足\(a,b\)的下标之和为\(c\)的下标，即一个与\(j\)无关的值。那么我们考虑把\(a\)翻转，原式变成了\(\sum a_{n-i-1}b_{i+k}\)，此时\(n-i-1+i+k=n+k-1\)，是一个与\(i\)无关的值。于是就可以FFT了。由于\(0\le k\le n-1\)，所以对应的答案（假设\(c=a*b\)）就是\(c_{n-1},c_{n},c_{n+1},\cdots,c_{2n-2}\)。 啥？FFT精度爆了？因为\(m\le 100\)，所以\(0\le c_i\le nm^2\le 5\times 10^8&lt; 998244353\)，直接用NTT即可。 时间复杂度\(O(n\log n)\)。 代码 评测记录，开O2，总时间170ms，目前在第一页。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 300005#define INF 0x3f3f3f3f3f3f3f3fllint n, m, a[N], b[N], c[N];namespace Polynomial&#123; #define P 998244353 int omega[N], rev[N]; int qpow(int a, int b)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if (b &amp; 1) s = 1ll * s * a % P; return s; &#125; void init(int n)&#123; int k = 0; while ((1 &lt;&lt; k) &lt; n) ++k; for (register int i = 0; i &lt; n; ++i) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; k &gt;&gt; 1; &#125; void add(int &amp;x, int y)&#123; (x += y) &gt;= P ? x -= P : 0; &#125; int sub(int x, int y)&#123; return (x -= y) &lt; 0 ? x + P : x; &#125; void NTT(int n, int *a, int o = 1)&#123; for (register int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) std :: swap(a[i], a[rev[i]]); for (register int m = 1, l; m &lt; n; m = l)&#123; l = m &lt;&lt; 1, omega[0] = 1, omega[1] = qpow(~o ? 3 : 332748118, (P - 1) / l); for (register int i = 2; i &lt; m; ++i) omega[i] = 1ll * omega[i - 1] * omega[1] % P; for (register int *p = a, t; p &lt; a + n; p += l) for (register int k = 0; k &lt; m; ++k) t = 1ll * p[k + m] * omega[k] % P, p[k + m] = sub(p[k], t), add(p[k], t); &#125; if (o == -1) for (register int _n = qpow(n, P - 2), i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * _n % P; &#125; void Multiply(int na, int *a, int nb, int *b, int nc, int *c)&#123; int n = 1; while (n &lt; nc) n &lt;&lt;= 1; init(n), NTT(n, a), NTT(n, b); for (register int i = 0; i &lt; n; ++i) c[i] = 1ll * a[i] * b[i] % P; NTT(n, c, -1); &#125;&#125;int main()&#123; long long s1 = 0, s2 = 0, s = INF, ans = INF; n = read(), m = read(); for (register int i = 0; i &lt; n; ++i) a[n - i - 1] = read(); for (register int i = 0; i &lt; n; ++i) b[i + n] = b[i] = read(); for (register int i = 0; i &lt; n; ++i) s1 += 1ll * a[i] * a[i] + 1ll * b[i] * b[i], s2 += (a[i] &lt;&lt; 1) - (b[i] &lt;&lt; 1); Polynomial :: Multiply(n, a, n &lt;&lt; 1, b, n &lt;&lt; 1, c); for (register int i = n - 1; i &lt; (n &lt;&lt; 1) - 1; ++i) s = std :: min(s, -2ll * c[i]); for (register int i = -m; i &lt;= m; ++i) ans = std :: min(ans, 1ll * n * i * i + s2 * i + s1); printf("%lld\n", ans + s);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>AHOI</tag>
        <tag>HNOI</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「模拟赛20190116 T3」MEX]]></title>
    <url>%2Fvc190116C-sol%2F</url>
    <content type="text"><![CDATA[题意 原题链接 给定一个长度为\(n\)的序列，\(q\)次询问\(l,r\)，求原序列\([l,r]\)中每个数的出现次数组成的集合\(S\)的\(\text{MEX}\)。 集合\(S\)的\(\text{MEX}\)是指最小的没有在集合\(S\)中出现的正整数。 \(n,q\le 1.5\times 10^5\)。 题解 一个简单的暴力实现 首先离散，对于每个询问，按题意求出每个数的出现次数，再求出每个出现次数是否出现，然后枚举求出答案即可。 时间复杂度\(\mathcal O(nq)\)。 基于暴力思想的分块做法 显然答案不会超过\(\sqrt{2n}\)，那么一个显然的优化是只需要记录所有\(\le \sqrt{2n}\)的出现次数。 于是就可以很自然地想到分块了。分成\(\sqrt{n}\)个块（在代码中为了卡常、卡内存可以作微调），直接暴力求出两块之间所有数的出现次数的出现次数（注意不是是否出现），记为\(V[x][y][i]\)，表示\(x\)块到\(y\)块中出现次数\(i\)的出现次数。这个可以很轻松的在扫的过程中求出来（--c[b[a[i]]],++b[a[i]],++c[b[a[i]]]，\(b[i]\)表示数\(i\)的出现次数，\(c[i]\)表示出现次数\(i\)的出现次数。即把原来的出现次数去掉，出现次数加一，把新的出现次数加入）。这一部分时间复杂度是\(\mathcal O(n\sqrt{n})\)的。 可是我们发现，只求出这个好像还是有点难回答询问。为什么？因为这只求出了整块的答案，而旁边的两小块没有被处理。 我们再求出\(L[x][y][i]\)表示\(x\)块到\(y\)块中，\(x\)块向左\(i\)个位置的数出现了多少次，同理\(R[x][y][i]\)表示\(x\)块到\(y\)块中，\(y\)块向右\(i\)个位置的数出现了多少次。这两个数组也很好求，可以与之前的\(V\)数组放在一起处理。 处理出这三个数组后，相当于持续了之前的\(b,c\)数组。直接在两边的小块扫一遍即可。对于\(l,r\)在同一块中的情况，直接暴力扫一遍即可。单次询问时间复杂度\(\mathcal O(\sqrt{n})\)。 注意\(b[i]\)的下标是\(\mathcal O(n)\)级别，不能每次清零，可以额外记一下\(vis[i]\)表示\(b[i]\)的使用情况，若\(vis[i]=0\)，则表示未使用，否则\(vis[i]\)表示\(b[i]\)在哪一次询问被使用，若是当前询问则可以直接加，否则需要用\(L\)或\(R\)数组中的值覆盖。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 150005const int B = 420, C = 360, P = 550;int n, q, k, a[N], b[N], c[N], vis[N];int L[365][365][425], R[365][365][425], V[365][365][555];void pre()&#123; for (register int i = 0; i &lt; n; i += B)&#123; for (register int j = 0; j &lt; n; ++j) b[j] = 0; for (register int j = 0; j &lt; P; ++j) c[j] = 0; for (register int j = i; j &lt; n; ++j)&#123; --c[b[a[j]]], ++b[a[j]], ++c[b[a[j]]]; if ((j + 1) % B == 0)&#123; register int bi = i / B, bj = j / B; for (register int k = 0; k &lt; P; ++k) V[bi][bj][k] = c[k]; for (register int k = 0; k &lt; B &amp;&amp; i - k - 1 &gt;= 0; ++k) L[bi][bj][k] = b[a[i - k - 1]]; for (register int k = 0; k &lt; B &amp;&amp; j + k + 1 &lt; n; ++k) R[bi][bj][k] = b[a[j + k + 1]]; &#125; &#125; &#125;&#125;int solve(int q, int l, int r)&#123; register int bl = (l - 1) / B + 1, br = (r + 1) / B - 1; register int pl = B * bl, pr = B * (br + 1) - 1; if (bl &lt;= br)&#123; for (register int i = 0; i &lt; P; ++i) c[i] = V[bl][br][i]; for (register int i = 0; i &lt; pl - l; ++i)&#123; register int j = pl - i - 1; if (vis[a[j]] != q) vis[a[j]] = q, b[a[j]] = L[bl][br][i]; --c[b[a[j]]], ++b[a[j]], ++c[b[a[j]]]; &#125; for (register int i = 0; i &lt; r - pr; ++i)&#123; register int j = pr + i + 1; if (vis[a[j]] != q) vis[a[j]] = q, b[a[j]] = R[bl][br][i]; --c[b[a[j]]], ++b[a[j]], ++c[b[a[j]]]; &#125; &#125; else&#123; for (register int i = 0; i &lt; P; ++i) c[i] = 0; for (register int i = l; i &lt;= r; ++i)&#123; if (vis[a[i]] != q) vis[a[i]] = q, b[a[i]] = 0; --c[b[a[i]]], ++b[a[i]], ++c[b[a[i]]]; &#125; &#125; for (register int i = 0; i &lt; P; ++i) if (!c[i]) return i; return -1;&#125;int main()&#123; freopen("mex.in", "r", stdin); freopen("mex.out", "w", stdout); n = read(), q = read(), k = read(); for (register int i = 0; i &lt; n; ++i) a[i] = b[i] = read(); std :: sort(b, b + n); int m = std :: unique(b, b + n) - b; for (register int i = 0; i &lt; n; ++i) a[i] = std :: lower_bound(b, b + m, a[i]) - b; pre(); int ans = 0, l, r; for (register int _ = 1; _ &lt;= q; ++_)&#123; l = (read() ^ (k * ans)) - 1, r = (read() ^ (k * ans)) - 1; ans = solve(_, l, r), printf("%d\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>MEX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「模拟赛20190116 T2」序列]]></title>
    <url>%2Fvc190116B-sol%2F</url>
    <content type="text"><![CDATA[题意 原题链接 给定一个序列的前\(n\)项（\(a_0,a_1,a_2,\cdots,a_{n-1}\)），保证对于所有\(0\le i\le n-1\)，\(a_i\in \{n-1,n,n+1\}\)。对于\(i\ge n\)，\(a_i\)的值为满足\(0\le j&lt; i\)且\(a_j\ge i-j\)的整数\(j\)的数量。 \(q\)个询问，每次询问一个\(x\)，求\(a_x\)的值。 \(1\le n,q\le 10^5,0\le x\le 10^{15}\)。 题解 首先，我们可以利用归纳法证明对于任意\(i\)，\(a_i\in \{n-1,n,n+1\}\)： 假设对于\(0\le j&lt; i\)都满足该性质，则有\[a_i=n-[a_{i-n}=n-1]+[a_{i-n-1}=n+1]\]显然仍有\(a_i\in \{n-1,n,n+1\}\)。 为方便讨论，用\(0,1,2\)分别代替\(n-1,n,n+1\)。 可以发现，假设初始时对于所有\(i\ge n\)，\(a_i=0\)。然后对于一个\(a_i\)，若\(a_i=0\)，则不产生贡献；若\(a_i=1\)，则对\(a_{i+n}\)产生\(1\)的贡献；若\(a_i=2\)，则对\(a_{i+n},a_{i+n+1}\)各产生\(1\)的贡献。 然后我们先考虑一些子问题。 若初始时\(a_i\in \{0,1\}\)，由于不存在\(2\)，一定有\(a_{i+n}=a_i\)，所以直接\(\bmod n\)即可。 若初始时\(a_i\in \{1,2\}\)，由于不存在\(0\)，即不存在没有贡献的情况，所以对于\(a_i=2\)，一定会导致\(a_{i+n}=1,a_{i+n+1}=2\)，观察一下可以发现，此时\(a_{i+n+1}=a_i\)，所以直接\(\bmod (n+1)\)即可。 考虑原问题，由于存在\(0\)，将会导致有些位置没有贡献，那么对于\(a_i=2\)，可能会导致\(a_{i+n}=1,a_{i+n+1}=1\)（即\(a_{i+1}=0\)时）。联系之前的两个问题，当不存在\(2\)时，这种情况下一定会导致\(a_{i+n+1}=0\)；当不存在\(0\)时，这种情况下一定会导致\(a_{i+n+1}=2\)。可是，当\(2,0\)同时存在时，就会导致\(a_{i+n+1}=1\)。 更形象一点地讲，把\(2\)当作石头，把\(1\)当作平地，把\(0\)当作洞，这种情况就是石头调入洞里形成平地的情况。 假设初始数组中第\(i\)个位置是洞，第\(j\)个位置是石头，石头\(j\)会在\(x\)位置与洞\(i\)重合，掉入洞中。又因为将会在所有满足\(p\equiv j\pmod{(n+1)}\)且\(p\le x\)的位置\(p\)出现石头，洞同理。所以\(x\)一定是满足下列同余方程组的最小正整数： \[\begin{cases} x\equiv i\pmod{n}\\x\equiv j\pmod{(n+1)} \end{cases}\] 这个求解想怎么做怎么做吧... 然后由于会首尾拼接，我们把初始数组想成一个环，显然对于每个洞\(i\)，一定是在环上与\(i\)有向距离最短的石子最终掉落在洞\(i\)。那么我们直接扫两遍，用栈维护当前的石子（第二遍不清空栈，就相当于成了环），每次遇到洞就取出栈顶元素——石头\(j\)（如果栈为空则跳过），算出\(x\)的值，记录\(mat[i]=mat[j]=x\)，一个点若没有\(mat\)值，则记为\(INF\)。 \(mat\)的定义显而易见，\(mat[i]\)表示与\(i\)有向距离最近的石子/洞与\(i\)抵消的位置。 有了\(mat\)以后对于询问就可以\(\mathcal O(1)\)求了，可以根据\(mat[x\bmod n],mat[x\bmod (n+1)]\)与\(x\)的大小关系来计算贡献，注意除了比较\(mat\)和\(x\)的大小外，还需判断初始是否为石子/洞。 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;long long read()&#123; register long long x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 200005int n, q, a[N], top, sta[N];long long x, mat[N]; // 注意long longint main()&#123; freopen("sequence.in", "r", stdin); freopen("sequence.out", "w", stdout); int T = 1; // CC原题是多组数据，为了方便修改 while (T--)&#123; n = read(), q = read(); for (register int i = 0; i &lt; n; ++i) a[i] = read(); for (register int i = 0; i &lt; n; ++i) mat[i] = 0x3f3f3f3f3f3f3f3fll; top = 0; for (register int k = 0; k &lt; 2; ++k) for (register int i = 0; i &lt; n; ++i) if (a[i] == n - 1 &amp;&amp; top)&#123; // 是洞，且栈非空 int j = sta[top--]; // 取出栈顶元素 mat[j] = mat[i] = (1ll * (i + n) * (n + 1) - 1ll * j * n) % (1ll * n * (n + 1)); // 根据中国剩余定理计算mat &#125; else if (a[i] == n + 1) sta[++top] = i; // 石子入栈 while (q--)&#123; x = read(); int ho = x % n, st = x % (n + 1); printf("%d ", n - (a[ho] == n - 1 &amp;&amp; mat[ho] &gt; x) + (a[st] == n + 1 &amp;&amp; mat[st] &gt; x)); // O(1)计算答案，注意特判 &#125; putchar('\n'); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>中国剩余定理</tag>
        <tag>栈</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LuoguP2042」「NOI2005」维护数列]]></title>
    <url>%2Fluogu2042-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 维护一个序列，支持插入序列、区间删除、区间覆盖、区间翻转、区间求和、求序列最大子段和（至少包含一个元素）。 插入总数\(\le 4\times 10^6\)，任意时刻序列长度\(\le 5\times 10^5\)。 题解 \(Splay\)板子题。 不会\(Splay\)的同学出门左转文艺平衡树。 由于插入数量太大，直接开4000000的数组显得不现实，我们考虑建立回收栈（雾），删除时遍历子树，回收被删除的节点，新建节点时优先从回收栈里取点，但是要注意各个数组都要初始化。 总体思路是，对每个节点维护：\(val,sz,sum,la,ra,ma\)，分别表示这个点本身的值、子树大小、子树的\(val\)之和、该区间（以这个点为根的子树所表示的区间，下同）中包含最左边元素的最长子段和（可以不包含元素）、包含最右边元素的最长子段和（可以不包含元素）、整个区间的最大子段和（至少包含一个元素，即答案）；懒标记\(cov=0/1,rev=0/1\)，分别表示该区间是否被覆盖、是否被翻转。 接下来我们仔细分析每一步操作。 新建节点 已经讲过，若回收栈里有点，则优先拿来用，否则新建节点。 123456int new_node(int _val)&#123; int x = top ? rb[top--] : ++cnt; // rb即回收栈 son[x][0] = son[x][1] = fa[x] = rev[x] = cov[x] = 0, sz[x] = 1; // 注意别忘记初始化 val[x] = ma[x] = sum[x] = _val, la[x] = ra[x] = std :: max(_val, 0); // la,ra可以不包含元素 return x;&#125; 上传 主要是\(la,ra,ma\)的更新。\(la\)和\(ra\)同理，以\(la\)为例，当前节点的\(la\)值就是max(左子树的la,左子树的sum+当前节点的val+右子树的la)，分别表示跨过当前节点和不跨过当前节点两种情况。对于\(ma\)，也差不多，不跨过的情况是max(左子树的ma,右子树的ma)，跨过的情况是左子树的ra+当前节点的val+右子树的la，在这两种情况中再取个\(max\)即可。 1234567void up(int u)&#123; int ls = son[u][0], rs = son[u][1]; sz[u] = sz[ls] + sz[rs] + 1, sum[u] = sum[ls] + sum[rs] + val[u]; la[u] = std :: max(la[ls], sum[ls] + val[u] + la[rs]); ra[u] = std :: max(ra[rs], sum[rs] + val[u] + ra[ls]); ma[u] = std :: max(std :: max(ma[ls], ma[rs]), ra[ls] + val[u] + la[rs]);&#125; 下传懒标记 比较简单，不需要考虑标记下传的顺序。 对于\(cov\)标记，直接把左右儿子的\(val\)设为当前节点的\(val\)，\(sum\)设为\(val\times sz\)。而\(la,ra,ma\)则需要分类讨论，若\(val&gt;0\)，显然直接把整个区间选上更优，否则\(la,ra\)不选，\(ma\)只选一个点。 对于\(rev\)标记，直接交换左右儿子的左右子树、左右儿子的\(la,ra\)（注意不是交换当前节点的左右子树、\(la,ra\)，这种写法在文艺平衡树可以过，但是在本题中会出错）。 12345678910111213141516171819202122void down(int u)&#123; int ls = son[u][0], rs = son[u][1]; if (cov[u])&#123; if (ls) val[ls] = val[u], cov[ls] = 1, sum[ls] = sz[ls] * val[u]; if (rs) val[rs] = val[u], cov[rs] = 1, sum[rs] = sz[rs] * val[u]; if (val[u] &gt; 0)&#123; // 分类讨论 if (ls) la[ls] = ra[ls] = ma[ls] = sum[ls]; if (rs) la[rs] = ra[rs] = ma[rs] = sum[rs]; &#125; else&#123; if (ls) la[ls] = ra[ls] = 0, ma[ls] = val[u]; if (rs) la[rs] = ra[rs] = 0, ma[rs] = val[u]; &#125; cov[u] = 0; &#125; if (rev[u])&#123; if (ls) rev[ls] ^= 1, std :: swap(son[ls][0], son[ls][1]), std :: swap(la[ls], ra[ls]); if (rs) rev[rs] ^= 1, std :: swap(son[rs][0], son[rs][1]), std :: swap(la[rs], ra[rs]); // 交换左右儿子的左右子树和la,ra rev[u] = 0; &#125;&#125; 建树 直接按照原序列的顺序建树（注意不是按数的大小建树）。 可是直接插入是\(\mathcal O(n\log n)\)的，且常数较大。我们直接取序列中点作为根，然后递归调用左边和右边，分别作为根的左儿子和右儿子。 这样我们可以做到\(\mathcal O(n)\)建树，\(n\)是序列长度。 123456789int build(int l, int r, int *a)&#123; if (l &gt; r) return 0; if (l == r) return new_node(a[l]); int mid = (l + r) &gt;&gt; 1, u = new_node(a[mid]); // 以mid为该子树的根，递归处理左右两边 son[u][0] = build(l, mid - 1, a), son[u][1] = build(mid + 1, r, a); fa[son[u][0]] = fa[son[u][1]] = u; return up(u), u; // 注意更新&#125; Splay的基本操作：\(rotate(x)\)和\(splay(x,g)\) \(rotate(x)\)表示将\(x\)向上旋转，\(splay(x,g)\)表示将\(x\)旋转到\(g\)的儿子。 注意\(rotate(x)\)时需要上传操作，且要注意操作顺序。\(splay(x,g)\)需要双旋。 123456789101112131415int dir(int x)&#123; return son[fa[x]][1] == x; &#125; // 返回x是他父亲的哪个儿子void set(int x, int k, int y)&#123; son[x][k] = y, fa[y] = x; &#125; // 将x的k儿子变成yvoid rotate(int x)&#123; int y = fa[x], d = dir(x); set(fa[y], dir(y), x), set(y, d, son[x][!d]), set(x, !d, y); up(y), up(x); // 注意上传以及上传的顺序&#125;void splay(int x, int g = 0)&#123; // g=0相当于旋转到根上 while (fa[x] != g)&#123; int y = fa[x]; if (fa[y] != g) dir(y) == dir(x) ? rotate(y) : rotate(x); rotate(x); // 双旋 &#125; if (!g) rt = x; // 更新rt&#125; 求当前序列中第\(k\)个位置在Splay中对应的节点 这是下面前五个操作中必需的一个操作，即把序列中的位置转化为树上的节点编号。 这是一个经典的求第\(k\)小的问题，直接按照左子树的\(sz\)和当前的\(k\)的大小关系决定往左、往右还是直接返回当前节点。 注意，此时由于需要用到儿子的信息，我们必须把\(u\)的标记下传。 且因为这样做会把根到要求的那个节点的路径上的所有节点都\(down\)一遍，所以在其余操作中不需要再进行\(down\)操作。 1234567int kth(int u, int k)&#123; down(u); // 下传标记 int ls = son[u][0], rs = son[u][1]; if (k == sz[ls] + 1) return u; // 直接返回 else if (k &lt;= sz[ls]) return kth(ls, k); // 向左走 else return kth(rs, k - sz[ls] - 1); // 向右走&#125; 插入操作 对于插入操作，我们直接把\(pos\)对应的节点\(splay\)到根上（记为\(u\)），把\(pos+1\)的位置旋转到根下面（记为\(v\)，即此时\(fa[v]=u\)）。此时\(v\)的左子树一定为空（不存在一个整数\(x\)满足\(pos&lt;x&lt;pos+1\)）。那么直接把需要插入的序列\(\mathcal O(n)\)建树，把根节点连到\(v\)上，作为\(v\)的左子树即可。 1234567void insert(int x, int tot, int *a)&#123; int t = build(1, tot, a); int u = kth(rt, x); splay(u); int v = kth(rt, x + 1); splay(v, u); son[v][0] = t, fa[t] = v, up(v), up(u); // 注意别忘记fa[t]=v和上传标记，不要习惯性打成up(u),up(v)&#125; 删除操作 假设我们要删除的是区间\([l,r]\)，那么同理，我们把\(l-1\)对应的节点旋转到根上（记为\(u\)），把\(r+1\)的位置旋转到根下面（记为\(v\)，即此时\(fa[v]=u\)）。 此时\(v\)的左子树所表示的区间即为\([l,r]\)，那么我们直接把\(v\)的左子树删除即可。 1234567891011void recycle(int u)&#123; // 回收以u为根的子树 int ls = son[u][0], rs = son[u][1]; if (ls) recycle(ls); if (rs) recycle(rs); rb[++top] = u;&#125;void erase(int l, int r)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); // 提区间操作 recycle(son[v][0]), son[v][0] = 0, up(v), up(u); // 更新&#125; 覆盖操作 与删除同理，提取区间\([l,r]\)，打上\(cov\)标记，更新即可。 123456789void cover(int l, int r, int c)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); int t = son[v][0]; // 提区间 val[t] = c, cov[t] = 1, sum[t] = sz[t] * c; if (c &gt; 0) la[t] = ra[t] = ma[t] = sum[t]; else la[t] = ra[t] = 0, ma[t] = c; // 打标记，与down中同理 up(v), up(u); // 更新&#125; 翻转操作 同理，提取区间后，打上\(rev\)标记并更新。 12345678void reverse(int l, int r)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); int t = son[v][0]; // 提区间 rev[t] ^= 1, std :: swap(son[t][0], son[t][1]), std :: swap(la[t], ra[t]); // 打标记，与down中同理 up(v), up(u); // 更新&#125; 求和操作 提取区间后直接输出\(sum\)值即可，不需要更新。 12345void query_sum(int l, int r)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); printf("%d\n", sum[son[v][0]]);&#125; 最大子段和 直接输出\(ma[rt]\)即可。 一些细节 由于\(pos,l-1\)可能会\(&lt;1\)，\(pos+1,r\)可能会\(&gt;n\)，所以要考虑边界问题。我的代码中是直接把整个数组向右移动一位，并且使\(a[1]=a[n+2]=-\text{INF}\)。个人觉得这个方法比较简单，只要在主程序中做一些简单的处理即可。 由于\(up\)中没有判断左儿子或右儿子为空的情况（判起来会变得很鬼畜），所以我们令\(ma[0]=-\text{INF}\)。 代码实现 总的再发一次吧。吸氧后最快的一次共1111ms。评测记录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0, f = 1; register char ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 500005#define INF 500000000int n, m, a[N];char opt[15];int k, x, tot, c[N];struct Splay&#123; int rt, cnt, son[N][2], fa[N], sz[N], val[N]; int rev[N], cov[N], sum[N], la[N], ra[N], ma[N]; int top, rb[5000005]; Splay()&#123; rt = 0, cnt = 0, top = 0; fa[0] = son[0][0] = son[0][1] = sz[0] = rev[0] = cov[0] = 0; val[0] = sum[0] = la[0] = ra[0] = 0, ma[0] = -INF; &#125; int new_node(int _val)&#123; int x = top ? rb[top--] : ++cnt; son[x][0] = son[x][1] = fa[x] = rev[x] = cov[x] = 0, sz[x] = 1; val[x] = ma[x] = sum[x] = _val, la[x] = ra[x] = std :: max(_val, 0); return x; &#125; void recycle(int u)&#123; int ls = son[u][0], rs = son[u][1]; if (ls) recycle(ls); if (rs) recycle(rs); rb[++top] = u; &#125; void up(int u)&#123; int ls = son[u][0], rs = son[u][1]; sz[u] = sz[ls] + sz[rs] + 1, sum[u] = sum[ls] + sum[rs] + val[u]; la[u] = std :: max(la[ls], sum[ls] + val[u] + la[rs]); ra[u] = std :: max(ra[rs], sum[rs] + val[u] + ra[ls]); ma[u] = std :: max(std :: max(ma[ls], ma[rs]), ra[ls] + val[u] + la[rs]); &#125; void down(int u)&#123; int ls = son[u][0], rs = son[u][1]; if (cov[u])&#123; if (ls) val[ls] = val[u], cov[ls] = 1, sum[ls] = sz[ls] * val[u]; if (rs) val[rs] = val[u], cov[rs] = 1, sum[rs] = sz[rs] * val[u]; if (val[u] &gt; 0)&#123; if (ls) la[ls] = ra[ls] = ma[ls] = sum[ls]; if (rs) la[rs] = ra[rs] = ma[rs] = sum[rs]; &#125; else&#123; if (ls) la[ls] = ra[ls] = 0, ma[ls] = val[u]; if (rs) la[rs] = ra[rs] = 0, ma[rs] = val[u]; &#125; cov[u] = 0; &#125; if (rev[u])&#123; if (ls) rev[ls] ^= 1, std :: swap(son[ls][0], son[ls][1]), std :: swap(la[ls], ra[ls]); if (rs) rev[rs] ^= 1, std :: swap(son[rs][0], son[rs][1]), std :: swap(la[rs], ra[rs]); rev[u] = 0; &#125; &#125; int dir(int x)&#123; return son[fa[x]][1] == x; &#125; void set(int x, int k, int y)&#123; son[x][k] = y, fa[y] = x; &#125; void rotate(int x)&#123; int y = fa[x], d = dir(x); set(fa[y], dir(y), x), set(y, d, son[x][!d]), set(x, !d, y); up(y), up(x); &#125; void splay(int x, int g = 0)&#123; while (fa[x] != g)&#123; int y = fa[x]; if (fa[y] != g) dir(y) == dir(x) ? rotate(y) : rotate(x); rotate(x); &#125; if (!g) rt = x; &#125; int build(int l, int r, int *a)&#123; if (l &gt; r) return 0; if (l == r) return new_node(a[l]); int mid = (l + r) &gt;&gt; 1, u = new_node(a[mid]); son[u][0] = build(l, mid - 1, a), son[u][1] = build(mid + 1, r, a); fa[son[u][0]] = fa[son[u][1]] = u; return up(u), u; &#125; int kth(int u, int k)&#123; down(u); int ls = son[u][0], rs = son[u][1]; if (k == sz[ls] + 1) return u; else if (k &lt;= sz[ls]) return kth(ls, k); else return kth(rs, k - sz[ls] - 1); &#125; void insert(int x, int tot, int *a)&#123; int t = build(1, tot, a); int u = kth(rt, x); splay(u); int v = kth(rt, x + 1); splay(v, u); son[v][0] = t, fa[t] = v, up(v), up(u); &#125; void erase(int l, int r)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); recycle(son[v][0]), son[v][0] = 0, up(v), up(u); &#125; void cover(int l, int r, int c)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); int t = son[v][0]; val[t] = c, cov[t] = 1, sum[t] = sz[t] * c; if (c &gt; 0) la[t] = ra[t] = ma[t] = sum[t]; else la[t] = ra[t] = 0, ma[t] = c; up(v), up(u); &#125; void reverse(int l, int r)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); int t = son[v][0]; rev[t] ^= 1, std :: swap(son[t][0], son[t][1]), std :: swap(la[t], ra[t]); up(v), up(u); &#125; void query_sum(int l, int r)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); printf("%d\n", sum[son[v][0]]); &#125; void query_max_sum()&#123; printf("%d\n", ma[rt]); &#125;&#125;T;int main()&#123; n = read(), m = read(), n += 2, a[1] = a[n] = -INF; for (register int i = 2; i &lt; n; ++i) a[i] = read(); // 整体右移 T.rt = T.build(1, n, a); while (m--)&#123; scanf("%s", opt); if (opt[0] == 'M' &amp;&amp; opt[2] == 'X') T.query_max_sum(); else x = read() + 1, tot = read(); // +1是因为数组整体右移 if (opt[0] == 'I')&#123; for (register int i = 1; i &lt;= tot; ++i) c[i] = read(); T.insert(x, tot, c); &#125; if (opt[0] == 'D') T.erase(x, x + tot - 1); if (opt[0] == 'M' &amp;&amp; opt[2] == 'K') T.cover(x, x + tot - 1, read()); if (opt[0] == 'R') T.reverse(x, x + tot - 1); if (opt[0] == 'G') T.query_sum(x, x + tot - 1); &#125;&#125; 如发现代码有问题请在评论中指出，谢谢！]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>NOI</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组 学习笔记]]></title>
    <url>%2Fsuffix-array-notes%2F</url>
    <content type="text"><![CDATA[后缀数组（Suffix Array, SA）是处理字符串的有力工具。它可以解决一些与字符串后缀LCP有关的问题。 一些记号和约定 在字符串\(S\)中，第\(i\)个字符到第\(j\)个字符（包括\(i,j\)）组成的子串记作\(S[i,j]\)。 在字符串\(S\)中，第\(i\)个字符开始的后缀记作\(\text{Suffix}(i)\)。 记\(SA[i]\)表示字符串\(S\)的所有后缀从小到大排序后，第\(i\)个后缀的开始位置。\(SA\)即后缀数组。 记\(rank[i]\)表示字符串\(S\)的第\(i\)个后缀从小到大的排名，即\(SA\)的逆数组。 下面给出一个例子（字符串下标从\(1\)开始）： 1234567891011String S: a a b a a a a b Rank: 4 6 8 1 2 3 5 7--------------------------SA[1]=4 -&gt; a a a a bSA[2]=5 -&gt; a a a bSA[3]=6 -&gt; a a bSA[4]=1 -&gt; a a b a a a a bSA[5]=7 -&gt; a bSA[6]=2 -&gt; a b a a a a bSA[7]=8 -&gt; bSA[8]=3 -&gt; b a a a a b 由于\(rank\)是\(SA\)的逆数组，在求出\(SA\)数组后，我们可以\(\mathcal O(|S|)\)求出\(rank\)数组，即rank[sa[i]]=i。 一个简单的实现 设字符串长度为\(n\)且下标从\(1\)开始。 我们直接把\(S\)的每个后缀求出，然后用任意一种排序方法，在比较时暴力\(\mathcal O(n)\)比较两个后缀的大小即可。 这种方法的复杂度太劣，我们尝试优化。 倍增算法 前置知识 倍增，基数排序。 由于基数排序较为简单，这里不详细讲。 算法思想 倍增算法的主要思想是：用倍增的方法对每个字符开始长度为\(2^k\)的子串进行排序，求出排名。\(k\)从\(0\)开始，直到\(2^k&gt;n\)时，这些子串就是\(S\)的所有后缀。 可以发现，如果我们能\(\mathcal O(n)\)求出每个字符开始长度为\(2^k\)的子串排序后的结果，那么此算法的复杂度就是\(\mathcal O(n\log n)\)的。 考虑利用\(k-1\)时的排序结果快速求出当前结果。 由于我们已经求出每个字符开始长度为\(2^{k-1}\)的子串的排名，那么字符串的比较变成了排名的比较。 这是一个双关键字排序，设当前字符为\(i\)，则第一关键字为\(i\)开始长度为\(2^{k-1}\)的子串的排名，第二关键字为\(i+2^k\)开始长度为\(2^{k-1}\)的子串的排名。 如果用快速排序，则总复杂度为\(\mathcal O(n\log^2 n)\)。 由于排名的值不会超过\(n\)，我们考虑用基数排序做到总复杂度为\(\mathcal O(n\log n)\)。 双关键字的基数排序只要先按照第二关键字从小到大排序，再按照第一关键字从小到大排序即可，都可以做到\(\mathcal O(n)\)的复杂度。 算法实现 技巧 直接基数排序的常数较大，我们考虑每次把排序后的结果暂存在\(SA\)数组中，即当前的\(SA[i]\)表示每个字符开始长度为\(2^k\)的子串进行排序后，排名为\(i\)的子串的起始位置。 这样一来，我们可以利用\(k-1\)时求出来的\(SA\)数组，直接按第二关键字排好序，再按第一关键字排序。 代码 123456789101112131415161718192021222324int sa[N], tx[N], ty[N], cnt[N];void Radix_Sort(int n, int m, int *x, int *y, int *sa)&#123; for (register int i = 0; i &lt;= m; ++i) cnt[i] = 0; for (register int i = 1; i &lt;= n; ++i) ++cnt[x[i]]; for (register int i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1]; for (register int i = n; i; --i) sa[cnt[x[y[i]]]--] = y[i];&#125;bool cmp(int *a, int x, int y, int l)&#123; return a[x] == a[y] &amp;&amp; a[x + l] == a[y + l];&#125;void Get_SA(int n, int m, int *a, int *sa)&#123; int *x = tx, *y = ty; for (register int i = 1; i &lt;= n; ++i) x[i] = a[i], y[i] = i; Radix_Sort(n, m, x, y, sa); for (register int j = 1, p = 0; p &lt; n; j &lt;&lt;= 1, m = p)&#123; p = 0; for (register int i = n - j + 1; i &lt;= n; ++i) y[++p] = i; for (register int i = 1; i &lt;= n; ++i) if (sa[i] &gt; j) y[++p] = sa[i] - j; Radix_Sort(n, m, x, y, sa); std :: swap(x, y), p = 1, x[sa[1]] = 1; for (register int i = 2; i &lt;= n; ++i) x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p : ++p; &#125;&#125; 代码解释 代码中的\(x[i]\)表示\(i\)开始长度为\(j=2^k\)的子串排序后的排名，\(y[i]\)在前半部分表示按第二关键字排序后，排名为\(i\)的子串的起始位置。 Radix_Sort函数即基数排序，不详细阐述。 123int *x = tx, *y = ty;for (register int i = 1; i &lt;= n; ++i) x[i] = a[i], y[i] = i;Radix_Sort(n, m, x, y, sa); 这三行是初始化，由于长度为\(1\)，直接按照字符本身为第一关键字进行排序，\(y[i]=i\)时表示没有第二关键字。 12345for (register int j = 1, p = 0; p &lt; n; j &lt;&lt;= 1, m = p)&#123; p = 0; for (register int i = n - j + 1; i &lt;= n; ++i) y[++p] = i; for (register int i = 1; i &lt;= n; ++i) if (sa[i] &gt; j) y[++p] = sa[i] - j; Radix_Sort(n, m, x, y, sa); \(j\)枚举的是\(\frac{2^k}{2}\)的值，即当前需要排序的子串长度的一半。首先把第二关键字为\(0\)的位置加入\(y\)。然后按第二关键字从小到大的加入\(y\)。为什么可以这样写？因为\(sa[i]\)表示排名为\(i\)的子串的初始位置，即\(sa[i]\)的排名一定是除\(0\)外第\(i\)小的，而以\(sa[i]\)的排名作为第二关键字的位置就是\(sa[i]-j\)，所以这样做就是把位置按第二关键字从小到大的加入\(y\)。 1234 std :: swap(x, y), p = 1, x[sa[1]] = 1; for (register int i = 2; i &lt;= n; ++i) x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p : ++p;&#125; 这一段代码中，由于前面的\(y\)数组毫无用处了，就交换\(x,y\)，使得\(y\)表示上一个\(j\)时的排名，把\(x\)更新为当前\(j\)时的排名。这里不能直接写x[sa[i]]=i的原因是有些子串可能会相等，那么它们的排名也应该相等。\(p\)记录的是排名不同的子串数量，如果\(p=n\)则直接退出循环。 另一种算法 还有一种求后缀数组的算法，叫做\(\text{DC3}\)。该算法可以做到复杂度\(\mathcal O(n)\)建立后缀数组，但由于常数较大且代码复杂度较高，不推荐使用。 有兴趣的同学可以查阅参考资料\([1]\)。 \(height\)数组 在具体应用中，\(SA\)数组的应用并不多，更多的是另一个可以利用\(SA,rank\)数组求出的数组——\(height\)数组。 定义 \(height[i]\)表示\(\text{Suffix}(SA[i])\)和\(\text{Suffix}(SA[i-1])\)的最长公共前缀（Longest Common Prefix, LCP）。即排名相邻的两个后缀的\(\text{LCP}\)。 性质 性质一 对于任意\(i,j(rank[i]&lt;rank[j])\)，\(\text{Suffix}(i)\)与\(\text{Suffix}(j)\)的\(\text{LCP}\)为\(\min\limits_{rank[i]&lt;k\le rank[j]} height[k]\)。 这个性质比较显然，证明略。 性质二 记\(H[i]=height[rank[i]]\)。对于任意\(i&gt;1\)，有\(H[i]\ge H[i-1]-1\)。 证明：当\(H[i-1]\le 1\)时显然。当\(H[i]&gt;1\)时，假设排\(\text{Suffix}(i-1)\)前一名的后缀是\(\text{Suffix}(k)\)，则\(\text{Suffix}(i)\)与\(\text{Suffix}(k+1)\)的\(\text{LCP}\)为\(H[i-1]-1\)（相当于都去掉了第一位），且\(\text{Suffix}(k+1)\)也排\(\text{Suffix}(i)\)前面，则根据性质一，\(H[i]\)不会小于这个值，得证。 求法及代码实现 根据性质二，直接按照\(height[rank[1]],height[rank[2]],\cdots,height[rank[n]]\)的顺序求即可。 123456void Get_Height(int n, int *a, int *sa, int *rank, int *height)&#123; for (register int i = 1; i &lt;= n; ++i) rank[sa[i]] = i; for (register int i = 1, k = 0, j; i &lt;= n; height[rank[i]] = k, ++i) if (rank[i] &gt; 1) for (k ? --k : 0, j = sa[rank[i] - 1]; a[i + k] == a[j + k]; ++k) height[1] = 0;&#125; 由于\(k\)最多减少\(n\)次，且不会超过\(n\)，所以时间复杂度为\(\mathcal O(n)\)。 例题 给定一个字符串，\(q\)次询问某两后缀的最长公共前缀的长度。 解法 建出\(height\)数组后，根据\(height\)数组的性质一，原问题可以转化为区间最小值问题，直接用\(\text{ST}\)表维护即可。 时间复杂度\(\mathcal O(n\log n+q)\)。 若使用\(\text{DC3}\)算法求\(\text{SA}\)，\(\text{RMQ}\)问题\(\mathcal O(n)\)预处理，则时间复杂度为\(\mathcal O(n+q)\)。 更多的例题可以查阅参考资料\([1]\)。 参考资料 IOI2009国家集训队论文《后缀数组——处理字符串的有力工具》，罗穗骞]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher 学习笔记]]></title>
    <url>%2Fmanacher-notes%2F</url>
    <content type="text"><![CDATA[问题形式 给定一个字符串，求该字符串的最长回文子串。 洛谷传送门 一个简单的暴力实现 由于回文串是对称的，我们枚举对称轴（注意奇偶分类讨论）。然后从该对称轴向左向右扩展，直到两字母不相等。此时的字符串长度一定是以当前对称轴作为中心的最长回文子串。 时间复杂度\(\mathcal O(n^2)\)。 Manacher - 暴力的优化 为了避免奇偶分类讨论，我们现在字符之间以及字符串两端插入一个特殊字符（与字符串中所有字符都不相等）。 例如：ababaab -&gt; #a#b#a#b#a#a#b#，显然，原来是回文串的还是回文串，原来不是回文串的仍然不是回文串，长度稍做处理即可。 通过观察发现，暴力主要慢在相同的状态被重复枚举，没有利用回文串的性质。 记\(hw_i\)表示以\(i\)为对称轴时，最长的回文串的右端距离\(i\)（包括最右端的字符和\(i\)）的长度为\(hw_i\)。栗子： 12345char: # a # b # a # hw : 1 2 1 4 1 2 1char: # a # b # b # a # hw : 1 2 1 2 5 2 1 2 1 如何快速求出\(hw_i\)？ 考虑根据回文串的性质，利用已经求出的\(hw\)值来求出当前的\(hw_i\)。 引入两个辅助变量\(MaxRight,Mid\)。\(MaxRight\)表示当前访问到的所有回文子串，所能触及的最右一个字符的位置，\(Mid\)表示对应的对称轴。 为方便观察，下面的图示中记\(x\)为\(MaxRight\)关于\(Mid\)对称的位置，\(r\)表示\(MaxRight\)，\(m\)表示\(Mid\)，\(*\)表示未触及的位置。 1| | | | |x| | | | | |m| | | | | |r|*|*|*| 当前要求\(hw_i\)的位置\(i\)一定在\(Mid\)右边。那么我们根据\(i\le MaxRight\)和\(i&gt;MaxRight\)讨论： 当\(i\le MaxRight\)时 1| | | | |x| | |j| | |m| | |i| | |r|*|*|*| 记\(j\)为\(i\)关于\(m\)的对称点。由于\(hw_j\)已知，我们尝试利用\(hw_j\)得出\(hw_i\)的下界。 又分成两种小情况： \(hw_j\)比较小，向左没有超过\(x\) 大概情况如图所示： 1| | | | |x| |-|j|-| |m| |-|i|-| |r|*|*|*| 此时显然\(hw_i\)的下界为\(hw_j\)。如图所示的情况一定也是上界，但如果\(i+hw_i-1\)刚好等于\(MaxRight\)，那么有可能可以继续扩展。由于不影响复杂度，为方便起见，无论哪一种情况都尝试扩展。 \(hw_j\)比较大，向左超过\(x\) 大概情况如图所示： 12345 | | /-------j----|--\ || | | | |x| | |j| | |m| | |i| | |r|*|*|*| \|------i------|/ | | 此时暂时只能确定两根较长的线之间的部分时回文的，所以\(hw_i\)的下界是\(MaxRight-i+1\)。然后同样地直接继续扩展即可。 实际实现中，这两种情况不需要特殊判断，只要在\(hw_j\)和\(MaxRight-i+1\)中取\(min\)即可。 当\(i&gt;MaxRight\)时 此时显然\(hw_i\)的求值不能利用之前的任意值，所以定下界为\(1\)，也直接扩展即可。 总结 步骤 综上所述，从左到右枚举\(i\)的过程中，对于每个\(i\)，算法步骤如下： 若\(i\le MaxRight\)，则令\(hw_i=min(hw_{2*Mid-i}, MaxRight-i+1)\)，否则令\(hw_i=1\)（显然，\(i\)关于\(Mid\)的对称点\(j\)为\(2*Mid-i\)）。 以\(i\)为中心扩展回文串，直到左右两边字符不同，或者到达边界。 更新\(MaxRight\)和\(Mid\)。 更新答案。扩展出来的子串在原串中的长度一定为\(hw_i-1\)。因为在添加字符后的串中该子串长度为\(2hw_i-1\)，由于首尾一定是特殊字符，所以特殊字符数量比其他字符多\(1\)，所以特殊字符数量为\(hw_i\)，其他字符为\(hw_i-1\)。 一个小技巧 如果你的字符串下标从\(1\)开始，你可以令\(s_0\)为那个特殊字符，这样就省去了判断边界的问题。 复杂度分析 根据上面三种情况的分析，在继续扩展\(hw_i\)时，每一次的扩展都可以更新\(MaxRight\)，而\(MaxRight\)最多变化\(n\)次，所以总的时间复杂度为\(\mathcal O(n)\)的。 代码实现 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;algorithm&gt;char buf[11000005], *ps = buf;int n, hw[22000005], mr = 0, mid = 0, ans = 0;char s[22000005];int main()&#123; buf[fread(buf, 1, 11000005, stdin)] = '\0', s[0] = '#'; // 小技巧 while (*ps &gt;= 'a' &amp;&amp; *ps &lt;= 'z') s[++n] = '#', s[++n] = *ps, ++ps; s[++n] = '#'; // 插入特殊字符 for (register int i = 1; i &lt;= n; ++i)&#123; hw[i] = i &lt;= mr ? std :: min(hw[(mid &lt;&lt; 1) - i], mr - i + 1) : 1; // 得出下界 while (s[i - hw[i]] == s[i + hw[i]]) ++hw[i]; // 继续扩展 if (i + hw[i] - 1 &gt; mr) mid = i, mr = i + hw[i] - 1; // 更新mr,mid ans = std :: max(ans, hw[i] - 1); // 更新答案 &#125; printf("%d\n", ans);&#125; 参考资料 最长回文子串——Manacher 算法]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「模拟赛20190105 T1」松]]></title>
    <url>%2Fvc190105A-sol%2F</url>
    <content type="text"><![CDATA[题意 给定两个长度为\(n\)的数组\(A,B\)，下标范围\([0,n-1]\)。 求所有整数\(k\in [0,n-1]\)，满足存在一个\(m\)次多项式\(C\)，使得对于所有\(i\in [0,n-1]\)，都有\(C(i)\equiv A_i-B_{(i+k)\bmod n} \pmod{998244353}\)。 题解 先附上PPT： 这完全看不懂啊 首先，\(B\)数组可以看成一个环，每次选环上的长度为\(n\)的一段。所以我们直接把B数组复制接在末尾，变为原来的两倍长度。 然后，我们来理解这个差分。 对于任意一个\(m\)次多项式\(f(x)\)，当\(x\)分别取\(0,1,2,\cdots,n(n\ge m+1)\)时，将会得到\(n+1\)个点值。将这\(n+1\)个点值不断差分，\(m+1\)次后会都变成\(0\)。 例如，当\(f(x)=x^3+x^2-2x+1\)时，分别取\(0,1,2,3,4,5\)代入，得到\(6\)个点值（第\(0\)行）。 123456x 0 1 2 3 4 50 1 1 9 31 73 1411 0 8 22 42 682 8 14 20 263 6 6 64 0 0 然后可以发现，按表格中的排列，\(t\)次差分以后（第\(k\)行第\(i\)列）\(c_i=\sum\limits_{j=0}^i (-1)^j C_k^j f(i-j)\) 例如，表中第二行第四个数\(20=(73-31)-(31-9)=73-2\times 31+9=C_2^0\times 73-C_2^1\times 31+C_2^2\times 9\)。 又可以发现，\(c_i=\sum\limits_{j=0}^i (-1)^j C_k^j f(i-j)\)是卷积的形式，所以直接用FFT/NTT优化。 这样，我们对\(A\)和\(B\)分别做一遍卷积，然后把\(A[m+1,n-1]\)与\(B[m+1,2n-1]\)做一次\(KMP\)即可。 由于数据较水，直接\(hash\)也能过。 注意特判\(m\ge n-1\)的情况，此时任意\(k\)都满足条件。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char ch = getchar(); for (; !isdigit(ch); ch = getchar()) ; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x;&#125;#define N 1100005#define P 998244353int n, m, a[N], b[N], c[N], fac[N], inv[N], cnt, ans[N];int qpow(int a, int b)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if (b &amp; 1) s = 1ll * s * a % P; return s;&#125;void pre(int n)&#123; fac[0] = 1; for (register int i = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % P; inv[n] = qpow(fac[n], P - 2); for (register int i = n; i; --i) inv[i - 1] = 1ll * inv[i] * i % P;&#125;int C(int n, int m)&#123; return n &lt; m ? 0 : 1ll * fac[n] * inv[m] % P * inv[n - m] % P;&#125;namespace Polynomial&#123; int omega[N], rev[N]; void init(int n)&#123; register int k = 0; while ((1 &lt;&lt; k) &lt; n) ++k; for (register int i = 0; i &lt; n; ++i) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; k &gt;&gt; 1; &#125; void NTT(int n, int *a, int o = 1)&#123; for (register int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) std :: swap(a[i], a[rev[i]]); for (register int m = 1, l; m &lt; n; m = l)&#123; l = m &lt;&lt; 1, omega[0] = 1, omega[1] = qpow(~o ? 3 : 332748118, (P - 1) / l); for (register int i = 2; i &lt; m; ++i) omega[i] = 1ll * omega[i - 1] * omega[1] % P; for (register int *p = a, t; p &lt; a + n; p += l) for (register int k = 0; k &lt; m; ++k) t = 1ll * omega[k] * p[m + k] % P, (p[m + k] = p[k] - t) &lt; 0 ? p[m + k] += P : 0, (p[k] += t) &gt;= P ? p[k] -= P : 0; &#125; if (o == -1) for (register int i = 0, _n = qpow(n, P - 2); i &lt; n; ++i) a[i] = 1ll * a[i] * _n % P; &#125; void Trans(int nt, int *a, int *b, int *c)&#123; int n = 1; while (n &lt; nt) n &lt;&lt;= 1; init(n), NTT(n, a), NTT(n, b), NTT(n, c); for (register int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * c[i] % P, b[i] = 1ll * b[i] * c[i] % P; NTT(n, a, -1), NTT(n, b, -1); &#125;&#125;int fail[N];int KMP(int n, int *S, int m, int *T)&#123; fail[1] = 0; for (register int i = 2, j = 0; i &lt;= m; ++i)&#123; while (j &amp;&amp; T[j] != T[i - 1]) j = fail[j]; fail[i] = j += (T[j] == T[i - 1]); &#125; for (register int i = 1, j = 0; i &lt;= n; ++i)&#123; while (j &amp;&amp; T[j] != S[i - 1]) j = fail[j]; j += (T[j] == S[i - 1]); if (j == m) ans[++cnt] = i - m, j = fail[j]; &#125;&#125;int main()&#123; freopen("pine.in", "r", stdin); freopen("pine.out", "w", stdout); n = read(), m = read() + 1; if (m &gt;= n)&#123; printf("%d\n", n); for (register int i = 0; i &lt; n; ++i) printf("%d\n", i); return 0; &#125; pre(n); for (register int i = 0; i &lt; n; ++i) a[i] = read(); for (register int i = 0; i &lt; n; ++i) b[i] = read(), b[i + n] = b[i]; for (register int i = 0; i &lt; n; ++i) c[i] = i &amp; 1 ? P - C(m, i) : C(m, i); Polynomial :: Trans(2 * n, a, b, c);// for (register int i = 0; i &lt; n; ++i) printf("%d ", a[i]); putchar('\n');// for (register int i = 0; i &lt; n; ++i) printf("%d ", b[i]); putchar('\n'); KMP(2 * n - 1 - m, b + m, n - m, a + m); printf("%d\n", cnt); for (register int i = 1; i &lt;= cnt; ++i) printf("%d\n", ans[i]);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>差分</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性递推求1~n的逆元 学习笔记]]></title>
    <url>%2Flinear-inv-notes%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 求\(1\sim n\)中所有整数在模\(p\)意义下的乘法逆元。 题解 设\(a=\left\lfloor\frac{P}{i}\right\rfloor,b=P\bmod i\)，则\(ai+b=P\) 即\(ai+b\equiv 0 \pmod P\) \[\begin{align*} &amp;\therefore \frac{ai+b}{ib}\equiv 0 \pmod P \\ &amp;\therefore ab^{-1}+i^{-1}\equiv 0 \pmod P \\ &amp;\therefore\ i^{-1}\equiv -ab^{-1} \pmod P \end{align*}\] 即\[inv(i)=\left(P-\left\lfloor\frac{P}{i}\right\rfloor\right)\cdot inv(P\bmod i)\bmod P\] 于是\(O(n)\)递推求一下就可以了。 代码 1234567891011#include &lt;cstdio&gt;int n, P, inv[3000005];void print(int x)&#123; if (x &lt; 10) putchar(x + 48); else print(x / 10), putchar(x % 10 + 48);&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;P); inv[1] = 1; for (register int i = 2; i &lt;= n; ++i) inv[i] = 1ll * (P - P / i) * inv[P % i] % P; for (register int i = 1; i &lt;= n; ++i) print(inv[i]), putchar('\n');&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 505E」Mr. Kitayuta vs. Bamboos]]></title>
    <url>%2Fcf505e-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 有\(n\)根竹子，竹子\(i\)初始高度为\(h_i\)，每天晚上会长高\(a_i\)。 每天白天，你可以选择\(k\)根竹子（同一根竹子在同一个白天可以多次选择），把他们的高度减少\(p\)，若竹子当前高度\(-p\)后\(&lt;0\)，则竹子高度变为\(0\)。 最小化\(m\)天后最高的竹子的高度。 题解 首先最小化最大的...这种问题，显然可以用二分答案。 二分\(m\)天后最高的竹子的高度\(H\)，然后问题就变成了判定性问题：是否存在一种方案，使得\(m\)天后竹子高度都\(\le H\)。 考虑怎么解决这个判定性问题。 如果按照题意一天一天模拟，就需要考虑把竹子高度减\(p\)后\(&lt;0\)的情况，会比较麻烦。 所以我们尝试倒着模拟这一过程。 即：竹子初始高度都设为\(H\)，每根竹子每天会减少\(a_i\)的高度，然后你可以选择\(k\)根竹子，把它们“拔高”\(p\)。问\(m\)天后竹子高度是否都\(\ge h_i\)。 此时你必须保证竹子减少\(a_i\)的高度后不会\(&lt;0\)。 这样就好做了。我们用一个堆维护 当前状态下继续减少高度而不“拔高”，第\(m\)天结束后竹子高度会\(&lt;h_i\)的竹子 一直减少高度 多少天后的高度会\(&lt;0\)。 （不理解这句话可以尝试看代码理解） 每次取出最快\(&lt;0\)的竹子，对它“拔高”即可。注意中间可能会出现无论怎么“拔高”还是会\(&lt;0\)的竹子，此时直接返回错误即可。 最后判断堆是否为空即可，因为堆中维护的是\(m\)天后竹子高度会\(&lt;h_i\)的竹子，所以堆空即代表所有竹子高度都\(\ge h_i\)。 时间复杂度\(O((n+mk)\log n\log mx)\)，其中\(mx\)表示\(\max\limits_{1\le i\le n} h_i+a_im\)（二分的上界）。 代码 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = 0; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;int n, m, k, c[100005];long long p, a[100005], h[100005], l = 0, r, mid, ans;struct node&#123; int day, id; // 表示当前状态下（二分的高度+c[id]*p）day+1天后竹子id的高度会&lt;0 bool operator &lt; (const node &amp;b) const &#123; // 默认大根堆，所以重载&lt;时写的是&gt; return day &gt; b.day; &#125;&#125;;struct Heap&#123; // 用algorithm中的堆相关的算法封装实现。 node h[200005]; int sz; void clear()&#123; sz = 0; &#125; bool empty()&#123; return !sz; &#125; void push(node x)&#123; h[++sz] = x, std :: push_heap(h + 1, h + 1 + sz); &#125; node pop()&#123; return std :: pop_heap(h + 1, h + 1 + sz), h[sz--]; &#125; node top()&#123; return h[1]; &#125;&#125;H;bool check(long long x)&#123; H.clear(), memset(c, 0, sizeof c); // c[i]表示竹子i被“拔高”了几次 for (register int i = 1; i &lt;= n; ++i) if (x - a[i] * m &lt; h[i]) H.push((node)&#123;x / a[i], i&#125;); // 初始堆的状态 for (register int i = 1; !H.empty() &amp;&amp; i &lt;= m; ++i) // i表示倒着的第几天 for (register int j = 1; !H.empty() &amp;&amp; j &lt;= k; ++j)&#123; // 拔高k根竹子 node u = H.pop(); if (u.day &lt; i) return 0; // 无论怎么“拔高”都不能满足条件 ++c[u.id]; // “拔高” if (x + c[u.id] * p - a[u.id] * m &lt; h[u.id]) // 还是不满足条件，就插入堆中 H.push((node)&#123;(x + c[u.id] * p) / a[u.id], u.id&#125;); &#125; return H.empty();&#125;int main()&#123; n = read(), m = read(), k = read(), p = read(); for (register int i = 1; i &lt;= n; ++i) h[i] = read(), a[i] = read(), r = std :: max(r, h[i] + a[i] * m); // 二分上界 while (l &lt;= r) check(mid = l + r &gt;&gt; 1) ? ans = mid, r = mid - 1 : l = mid + 1; printf("%lld", ans);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 295D」Greg and Caves]]></title>
    <url>%2Fcf295d-sol%2F</url>
    <content type="text"><![CDATA[标签：DP 题目传送门 题意 给定\(n,m\)，你需要对一个\(n\times m\)的矩阵黑白染色，满足： 存在一个区间\([l,r]\)，满足\(l\sim r\)这些行有且仅有两个黑色格子，其他行不存在黑色格子。 存在一个\(t\ (l\le t\le r)\)，使得对于所有的\(i,j\ (l\le i\le j\le t)\)，满足第\(i\)行以两个黑色格子为端点的区间（以下简称“区间”）被\(j\)行的区间包含；同样地，对于所有的\(i,j\ (t\le i\le j\le r)\)，第\(j\)行的区间被第\(i\)行的区间包含。 求染色方案数\(\bmod (10^9+7)\)的值。 题解 比较简单的\(\mathrm{DP}\)，设\(dp_{i,j}\)表示上半部分（即\(l\)到\(t\)部分）的高度至多为\(i\)，底边宽度（包含两个黑色格子）为\(j\)且底边位置固定时的方案数。 转移方程 \[dp_{i,j}=dp_{i,j-1}+\sum\limits_{k=2}^j dp_{i-1,k}\] 应该还是比较好理解的。初始值\(dp_{1,i}=dp_{i,1}=1\)。 直接转移是\(O(n^3)\)的，但是\(\sum\limits_{k=2}^j dp_{i-1,k}\)可以在枚举\(j\)的同时计算（即前缀和优化），时间复杂度可以做到\(O(n^2)\)。 答案 下半部分的方案与上半部分同理。 注意如果下半部分的底边长度和上半部分的底边长度相等，会有重复，所以应该减去。 \[ans=\sum\limits_{i=1}^n \sum\limits_{j=2}^m (dp_{i,j}-dp_{i-1,j})\times dp_{n-i+1,j}\times (m-j+1)\bmod 1000000007\] \(i\)枚举的是下半部分的起始位置，\(j\)枚举的是下半部分的底边宽度，第一项是上半部分减去长度相等的方案，第二项是下半部分的方案，第三项是计算底边在矩阵中的位移。 注意需要随时取模。 代码 Code 1234567891011121314151617#include &lt;cstdio&gt;#define P 1000000007int n, m, dp[2005][2005], ans;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (register int i = 1; i &lt;= m; ++i) dp[1][i] = 1; for (register int i = 2; i &lt;= n; ++i)&#123; int s = 0; dp[i][1] = 1; for (register int j = 2; j &lt;= m; ++j) (s += dp[i - 1][j]) %= P, dp[i][j] = (dp[i][j - 1] + s) % P; // 前缀和优化 &#125; for (register int i = 1; i &lt;= n; ++i) for (register int j = 2; j &lt;= m; ++j) (ans += 1ll * (dp[i][j] - dp[i - 1][j] + P) * dp[n - i + 1][j] % P * (m - j + 1) % P) %= P; // 计算答案，随时取模 printf("%d", ans);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 599E」Sandy and Nuts]]></title>
    <url>%2Fcf599e-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 有一棵\(n\)个节点的以1为根的树，有\(m\)条边已知，并且有\(q\)个限制\(a_i,b_i,c_i\)，需要满足\(\mathrm{LCA}(a_i,b_i)=c_i\)。求满足条件的树的数量。 \(m&lt; n\le 13,q\le 100\)。 题解 树形状压DP。DP状态很显然，\(dp_{u,mask}\)表示以\(u\)为根，由\(mask\)这些点组成的子树的方案数。\(mask\)是一个二进制状态。 为方便讨论，以下题解和代码节点编号从\(0\)开始。 转移方程 \[dp_{u,mask}=\sum dp_{v,submask}\times dp_{u,mask\oplus submask}\] \(\oplus\)表示的是异或(\(xor\))运算。 但是，我们直接枚举\(v,submask\)会有重复，例如一棵二叉树，根为\(root\)，左右儿子分别为\(leftson,rightson\)。当枚举\(v=leftson\)时会计算这棵树，\(v=rightson\)时又会计算这棵树，就会出现重复。 所以，我们规定一个点\(pos\in mask\ (pos\ne u)\)，强制\(pos\)在\(submask\)中才能转移。 转移条件 题目中有两种限制条件，分别为边和\(\mathrm{LCA}\)。 对于\(\mathrm{LCA}\)的限制： 1.1. 对于限制\((a,b,c)\)，如果\(c=u\)，但是\(a,b\in submask\)，那么\(\mathrm{LCA}\)一定不为\(c\)，不满足条件。 1.2. 对于限制\((a,b,c)\)， 如果\(c\in submask\)，但\(a,b\)中有至少一个不在\(submask\)中，则\(\mathrm{LCA}\)一定不为\(c\)，不满足条件。 对于边的限制： 2.1. 对于边\((x,y)\)，如果\(x,y\ne u\)，但是\(x,y\)其中一个在\(submask\)中，另一个不在，则这条边不可能在树上，不满足条件。 2.2. 如果\(u\)与\(i\)有边且\(i\in submask\)的\(i\)的数量大于1，则不可能有满足条件的树，不满足条件。 在2.2中，如果这样的\(i\)的数量等于1，则转移时\(v\)不用枚举，\(v\)只能是那个\(i\)。否则\(v\)需要在\(submask\)中枚举。 关于复杂度 子集枚举可以用for (register int submask = mask; submask; submask = (submask - 1) &amp; mask)。 此时复杂度并不是\(O(4^n)\)，而是\(O(3^n)\)，因为每次枚举到的\(submask\)一定是\(mask\)的子集。状态数为\(3^n\)。 因为此时\(n\)个数有三种状态：不在\(mask\)中，在\(mask\)但不在\(submask\)中，在\(submask\)中。所以是\(3^n\)。 所以复杂度为\(O(3^nn(n+q+m))\)。 观察代码可以发现这个复杂度非常不满，很多状态和子集是没用的。加上CF的评测机速度，还是可以过的。 代码 Code 实测93ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;int n, m, q, edge[15][15];struct Edge&#123; int x, y; &#125; E[15];struct node&#123; int x, y, z; &#125; a[105];long long dp[15][100005];bool in(int x, int s)&#123; return s &amp; (1 &lt;&lt; x); &#125;long long dfs(int u, int mask)&#123; // 用记搜实现 long long &amp;res = dp[u][mask]; if (~res) return res; res = 0, mask -= 1 &lt;&lt; u; int pos; for (pos = 0; pos &lt; n; ++pos) if (in(pos, mask)) break; // 强制pos在submask中 for (register int submask = mask; submask; submask = (submask - 1) &amp; mask) // 枚举子集 if (in(pos, submask))&#123; int flag = 1, v, cnt = 0; // 条件1.1 for (register int i = 1; i &lt;= q; ++i) if (a[i].z == u &amp;&amp; in(a[i].x, submask) &amp;&amp; in(a[i].y, submask)) &#123; flag = 0; break; &#125; if (!flag) continue; // 条件1.2 for (register int i = 1; i &lt;= q; ++i) if (in(a[i].z, submask) &amp;&amp; (!in(a[i].x, submask) || !in(a[i].y, submask))) &#123; flag = 0; break; &#125; if (!flag) continue; // 条件2.1 for (register int i = 1; i &lt;= m; ++i) if (E[i].x != u &amp;&amp; E[i].y != u &amp;&amp; (in(E[i].x, submask) ^ in(E[i].y, submask))) &#123; flag = 0; break; &#125; if (!flag) continue; // 条件2.2 for (register int i = 0; i &lt; n; ++i) if (edge[u][i] &amp;&amp; in(i, submask))&#123; ++cnt; v = i; &#125; if (cnt &gt; 1) continue; if (cnt == 1) res += dfs(v, submask) * dfs(u, mask ^ submask ^ (1 &lt;&lt; u)); else&#123; for (v = 0; v &lt; n; ++v) if (in(v, submask)) res += dfs(v, submask) * dfs(u, mask ^ submask ^ (1 &lt;&lt; u)); // 转移方程 &#125; &#125; return res;&#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); for (register int i = 1; i &lt;= m; ++i) scanf("%d%d", &amp;E[i].x, &amp;E[i].y), --E[i].x, --E[i].y, // 编号从0开始 edge[E[i].x][E[i].y] = edge[E[i].y][E[i].x] = 1; for (register int i = 1; i &lt;= q; ++i) scanf("%d%d%d", &amp;a[i].x, &amp;a[i].y, &amp;a[i].z), --a[i].x, --a[i].y, --a[i].z; // 同上 memset(dp, -1, sizeof dp); for (register int i = 0; i &lt; n; ++i) dp[i][1 &lt;&lt; i] = 1; // 初始化 printf("%lld", dfs(0, (1 &lt;&lt; n) - 1));&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状压DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ2753」「SCOI2012」滑雪与时间胶囊]]></title>
    <url>%2Fbzoj2753-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定一个\(n\)个点，\(m\)条边的有权无向图，每个点有一个高度，求一个以\(1\)为根的树，满足父亲的高度大于等于儿子的高度。在树的节点数最多的情况下，树上的边权之和最小。 题解 如果没有高度限制，直接\(Kruskal\)一遍就好了。 有了高度呢？其实变成了有向图，求一个点最多，边权值和最小的生成树。 第一问很好做，直接对这个有向图从\(1\)开始\(bfs/dfs\)一遍就好了。 \(bfs/dfs\)之后，原来的有向图就变成了从1开始能到达的所有点组成的一个有向图。 显然，如果两个点高度相同，那么这两个点之间连的边可以看成无向边，直接按边权排序做即可。 再考虑一个问题，两个点\(x,y\)需要在树上联通，一定不会通过另一个高度比它们小的点进行联通的。 所以我们对于新图中的每条边\(u\to v\)，优先按\(h_v\)从大到小，\(h_v\)相等按边权从小到大排序即可。 然后就是最简单的Kruskal了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/************************************************************** Problem: 2753 User: rill7747 Language: C++ Result: Accepted Time:6972 ms Memory:84612 kb****************************************************************/ #include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = 0; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 2000005int n, m, h[N], fa[N], cnt;int edge, to[N], tw[N], pr[N], hd[N], vis[N];void addedge(int u, int v, int w)&#123; to[++edge] = v, tw[edge] = w, pr[edge] = hd[u], hd[u] = edge;&#125;struct node&#123; int u, v, w; bool operator &lt; (const node &amp;res) const &#123; return h[v] &gt; h[res.v] || h[v] == h[res.v] &amp;&amp; w &lt; res.w; &#125;&#125;E[N];void dfs(int u)&#123; ++cnt, vis[u] = 1; for (register int i = hd[u], v; i; i = pr[i])&#123; if (!vis[v = to[i]]) dfs(v); E[++m] = (node)&#123;u, v, tw[i]&#125;; &#125;&#125;int find(int x)&#123; return x == fa[x] ? x : (fa[x] = find(fa[x]));&#125;int merge(int x, int y)&#123; int fx = find(x), fy = find(y); if (fx == fy) return 0; return fa[fy] = fx, 1;&#125;long long Kruskal()&#123; std :: sort(E + 1, E + 1 + m); for (register int i = 1; i &lt;= n; ++i) fa[i] = i; long long ans = 0; int sum = 0; for (register int i = 1; i &lt;= m; ++i)&#123; if (merge(E[i].u, E[i].v)) ans += E[i].w, ++sum; if (sum == cnt - 1) break; &#125; return ans;&#125;int main()&#123; n = read(), m = read(); for (register int i = 1; i &lt;= n; ++i) h[i] = read(); for (register int i = 1; i &lt;= m; ++i)&#123; int u = read(), v = read(), w = read(); if (h[u] &gt;= h[v]) addedge(u, v, w); if (h[v] &gt;= h[u]) addedge(v, u, w); &#125; m = 0, dfs(1); printf("%d %lld", cnt, Kruskal());&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>SCOI</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1568」「JSOI2008」Blue Mary开公司]]></title>
    <url>%2Fbzoj1568-sol-lcst-notes%2F</url>
    <content type="text"><![CDATA[题目传送门 李超线段树模板题。 题意 维护一个二维平面，支持两种操作：插入一条直线（\(y=kx+b\)）；询问当前插入的所有直线\(x=x_0\)时最大的纵坐标的值。 题解 李超线段树。 一个节点同样表示一个区间\([l,r]\)，记录的是一条直线\(id[u]\)，这条直线是\(x=mid\)时纵坐标最大的直线。 插入一条直线时，流程如下： 直线\(id[u]\)和\(i\)没有交点：直接取\(y\)值大的，退出。 如果当\(x=mid\)时，直线\(i\)的\(y\)值比\(id[u]\)大，那么交换\(id[u],i\)。 如果\(id[u]\)和\(i\)的交点在mid左边，即当\(x=l\)时，直线\(i\)的\(y\)值大于等于\(id[u]\)，那么递归处理\([l,mid]\)，这种情况下其实\([mid+1,r]\)的直线要改变，但因为询问时是从叶子节点到根节点取\(max\)的，所以没有必要更新。 如果\(id[u]\)和\(i\)的交点在mid右边，即当\(x=r\)时，直线\(i\)的\(y\)值大于等于\(id[u]\)，那么递归处理\([mid+1,r]\)，此时没有3中的情况。 至于询问，已经提过，只要从叶节点到根取max就好了。 代码 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define N 500005int n, m, x;double k[N], b[N];char opt[15];struct Li_Chao_Segment_Tree&#123; int id[N]; int check(int u, int v, int x)&#123; return k[u] * (x - 1) + b[u] &lt;= k[v] * (x - 1) + b[v]; &#125; void Insert(int u, int l, int r, int x)&#123; if (check(id[u], x, l) &amp;&amp; check(id[u], x, r)) return id[u] = x, void(0); if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (check(id[u], x, mid)) std :: swap(id[u], x); if (check(id[u], x, l)) Insert(u &lt;&lt; 1, l, mid, x); if (check(id[u], x, r)) Insert(u &lt;&lt; 1 | 1, mid + 1, r, x); &#125; double Query(int u, int l, int r, int x)&#123; if (l == r) return k[l] * (x - 1) + b[l]; int mid = (l + r) &gt;&gt; 1; double ans; if (x &lt;= mid) ans = Query(u &lt;&lt; 1, l, mid, x); else ans = Query(u &lt;&lt; 1 | 1, mid + 1, r, x); return std :: max(ans, k[id[u]] * (x - 1) + b[id[u]]); &#125;&#125;T;int main()&#123; for (scanf("%d", &amp;m); m--; )&#123; scanf("%s", opt); if (opt[0] == 'P') ++n, scanf("%lf%lf", b + n, k + n), T.Insert(1, 1, 50000, n); else scanf("%d", &amp;x), printf("%d\n", int(T.Query(1, 1, 50000, x) / 100)); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>JSOI</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ3083」遥远的国度]]></title>
    <url>%2Fbzoj3083-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 题意 给定一棵有点权的树和初始的根，支持三种操作：换根，修改路径上的权值，查询子树权值\(min\)。 题解 如果没有换根，这就是树剖+线段树裸题了。 那么有换根呢？首先我们一开始认定初始给定的根作为根进行树剖。 换根之后，路径修改显然不产生影响，直接用线段树维护就好了。假设现在的根为\(rt\)，查询子树的根节点为\(x\)，分以下三种情况（可以脑补一下或者画个图）： \(rt=x\) \(rt\)在\(x\)的子树外 \(rt\)在\(x\)的子树内（不包括\(x\)） 注意这里的子树是相对于以初始根为根时的树而言的。 对于1，相当于查询整棵树的min，直接在整棵线段树上查询就好了。 对于2，又有两种情况：一种是\(x\)在\(rt\)的子树内（不包括\(rt\)），另一种是\(x\)的子树和\(rt\)的子树互不包含。 画一下图即可知道，这两种情况是一样的，即不需要考虑换根，换根之后\(x\)子树中的节点没有变化，直接查询以初始根为根时\(x\)的子树min。 对于3，就有点麻烦了。我们设\(u\)是\(x\)到\(rt\)这条链上除\(x\)外的第二个点（\(x\)的儿子）。那么在纸上画一下即可得知，换根后的\(x\)的子树变为整棵树减去换根前\(u\)的子树（注意不是\(x\)的子树减去\(u\)的子树）。 那么问题在于求u。算法描述如下（设树剖后节点\(i\)所在重链的顶端节点为\(top[i]\)，节点\(i\)的父亲为\(fa[i]\)，节点\(i\)的重儿子是\(son[i]\)）： \(u\gets rt\) 如果\(fa[top[u]]\)在\(x\)的子树中并且不等于\(x\)，那么\(u\gets fa[top[u]]\)。不断执行这一过程直至条件不成立。 如果\(fa[top[u]]=x\)，那么\(u=top[u]\)，否则\(u=son[x]\) 解释一下第三步，因为最后如果\(fa[top[u]]=x\)那么\(top[u]\)刚好就是这条链上\(x\)的儿子了，否则说明\(fa[top[u]]\)是\(x\)的祖先，即\(x\)和\(u\)在同一条重链上，那么这条链上\(x\)的儿子就是\(x\)的重儿子。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/************************************************************** Problem: 3083 User: rill7747 Language: C++ Result: Accepted Time:3312 ms Memory:13452 kb****************************************************************/ #include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = 0; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return f ? x : -x;&#125;#define N 100005int n, m, a[N], rt;int edge, to[N &lt;&lt; 1], pr[N &lt;&lt; 1], hd[N];void addedge(int u, int v)&#123; to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;&#125;int dep[N], fa[N], sz[N], son[N];void dfs(int u)&#123; sz[u] = 1; for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa[u]) fa[v] = u, dep[v] = dep[u] + 1, dfs(v), sz[u] += sz[v], !son[u] || sz[v] &gt; sz[son[u]] ? son[u] = v : 0;&#125;int top[N], idx, st[N], id[N], ed[N];void dfs(int u, int tp)&#123; top[u] = tp, id[st[u] = ++idx] = u; if (son[u]) dfs(son[u], tp); for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa[u] &amp;&amp; v != son[u]) dfs(v, v); ed[u] = idx;&#125;int val[N &lt;&lt; 2], lz[N &lt;&lt; 2];void build(int u, int l, int r)&#123; if (l == r) return val[u] = a[id[l]], lz[u] = 0, void(0); int mid = (l + r) &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r); val[u] = std :: min(val[u &lt;&lt; 1], val[u &lt;&lt; 1 | 1]);&#125;void down(int u)&#123; if (lz[u]) val[u &lt;&lt; 1] = val[u &lt;&lt; 1 | 1] = lz[u &lt;&lt; 1] = lz[u &lt;&lt; 1 | 1] = lz[u];&#125;void modify(int u, int l, int r, int L, int R, int v)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return val[u] = lz[u] = v, void(0); int mid = (l + r) &gt;&gt; 1; down(u); if (L &lt;= mid) modify(u &lt;&lt; 1, l, mid, L, R, v); if (R &gt; mid) modify(u &lt;&lt; 1 | 1, mid + 1, r, L, R, v); val[u] = std :: min(val[u &lt;&lt; 1], val[u &lt;&lt; 1 | 1]);&#125;int query(int u, int l, int r, int L, int R)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return val[u]; int mid = (l + r) &gt;&gt; 1, ans = 2147483647; down(u); if (L &lt;= mid) ans = std :: min(ans, query(u &lt;&lt; 1, l, mid, L, R)); if (R &gt; mid) ans = std :: min(ans, query(u &lt;&lt; 1 | 1, mid + 1, r, L, R)); return ans;&#125;void Modify(int u, int v, int w)&#123; while (top[u] != top[v])&#123; if (dep[top[u]] &lt; dep[top[v]]) std :: swap(u, v); modify(1, 1, n, st[top[u]], st[u], w), u = fa[top[u]]; &#125; if (dep[u] &lt; dep[v]) std :: swap(u, v); modify(1, 1, n, st[v], st[u], w);&#125;int Query(int u)&#123; if (u == rt) return val[1]; if (st[rt] &lt; st[u] || st[rt] &gt; ed[u]) return query(1, 1, n, st[u], ed[u]); int v = rt; while (st[fa[top[v]]] &gt; st[u] &amp;&amp; st[fa[top[v]]] &lt;= ed[u]) v = fa[top[v]]; if (fa[top[v]] == u) v = top[v]; else v = son[u]; return std :: min(query(1, 1, n, 1, st[v] - 1), query(1, 1, n, ed[v] + 1, n));&#125;int main()&#123; n = read(), m = read(); for (register int i = 1, u, v; i &lt; n; ++i) u = read(), v = read(), addedge(u, v), addedge(v, u); for (register int i = 1; i &lt;= n; ++i) a[i] = read(); rt = read(); dfs(rt), dfs(rt, rt), build(1, 1, n); while (m--)&#123; int opt = read(), x, y, w; if (opt == 1) rt = read(); if (opt == 2) x = read(), y = read(), w = read(), Modify(x, y, w); if (opt == 3) printf("%d\n", Query(read())); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>分类讨论</tag>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018之前]]></title>
    <url>%2Fbefore-noip2018%2F</url>
    <content type="text"><![CDATA[好久没更新博客了。 10/14初赛，当时感觉凉凉……emmm不过后来答案出来以后感觉也还可以，选择题连蒙带猜地做竟然只错了1个？ 问题求解T2 想到根据二进制位分类讨论，但没往排列组合方面想。 估分93，ZJ提高，应该还可以吧。 坐等分数线。 虽然初赛还可以，但是ZJ提高组……感觉要凉啊。希望能拿一等。 只有20多天了，突然发现好像什么都不会了。]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>NOIP2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国剩余定理 学习笔记]]></title>
    <url>%2Fcrt-notes%2F</url>
    <content type="text"><![CDATA[问题 中国剩余定理用来解决如下问题： 求关于\(x\)的方程组 \[\begin{cases} x \equiv a_1 \pmod{p_1} \\ x \equiv a_2 \pmod{p_2} \\ \cdots \\ x \equiv a_n\pmod{p_n}\end{cases}\] 的最小非负整数解。 其中\(p_i\)两两互质。 前置技能 扩展欧几里得求乘法逆元 求解 设\(M=\prod_{i=1}^{n} p_i,d_i=\frac{M}{p_i}\)，即\(d_i\)表示除\(p_i\)外所有\(p\)的乘积。 记\(inv_i\)表示\(d_i\)在模\(p_i\)域下的逆元（因为\(p\)两两互质，所以\(d_i\)一定与\(p_i\)互质，所以一定存在逆元），即\(inv_i \times d_i \equiv 1 \pmod{p_i}\)。记\(x_i=inv_i\times d_i\)，则： 因为\(d_i\)能被除\(p_i\)外的所有\(p\)整除，所以\(x_i\)一定能被除\(p_i\)外的所有\(p\)整除，所以\(x_ia_i\)一定能被除\(p_i\)外的所有\(p\)整除。 \(x_i\equiv 1 \pmod{p_i}\)，所以\(a_ix_i\equiv a_i \pmod{p_i}\)。 根据以上两条推论可得，答案为\(\left( \sum_{i=1}^{n} a_ix_i \right) \bmod M\)。因为对于第\(i\)个方程，根据推论1，对于所有的\(j\ne i\)，\(a_jx_j\)不会对该方程组产生贡献，即\(a_jx_j\equiv 0 \pmod{p_i} (j\ne i)\)。只有\(a_ix_i\)会对第\(i\)个方程产生贡献，且根据推论2，恰好会产生\(a_i\)的贡献。又因为对于所有\(i\)，\(M\equiv 0\pmod{p_i}\)，所以答案加上或减去若干个\(M\)都满足方程组。求的是最小非负整数解，所以答案\(\bmod M\)。 代码 中国剩余定理模板题：[TJOI2009]猜数字 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;long long exgcd(long long a, long long b, long long &amp;x, long long &amp;y)&#123; if (!b) return x = 1, y = 0, a; long long x0, y0, g = exgcd(b, a % b, x0, y0); return x = y0, y = x0 - a / b * y0, g;&#125;int n, a[15], p[15];long long inv(long long a, long long p)&#123; long long x, y, g = exgcd(a, p, x, y); if (g != 1) return -1; return (x % p + p) % p;&#125;long long qmul(long long a, long long b, long long p)&#123; long long s = 0; for (a %= p, b %= p; b; b &gt;&gt;= 1, a = (a + a) % p) b &amp; 1 ? s = (s + a) % p : 0; return s; &#125;int main()&#123; scanf("%d", &amp;n); for (register int i = 1; i &lt;= n; ++i) scanf("%d", a + i); for (register int i = 1; i &lt;= n; ++i) scanf("%d", p + i); for (register int i = 1; i &lt;= n; ++i) a[i] = (a[i] % p[i] + p[i]) % p[i]; long long m = 1, ans = 0; for (register int i = 1; i &lt;= n; ++i) m = m * p[i]; for (register int i = 1; i &lt;= n; ++i)&#123; long long d = m / p[i], d_ = inv(d, p[i]); (ans += qmul(qmul(d, d_, m), a[i], m)) %= m; &#125; printf("%lld", ans);&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展欧几里得 学习笔记]]></title>
    <url>%2Fexgcd-notes%2F</url>
    <content type="text"><![CDATA[问题 形式1：求方程\(ax+by=c\)的任意一组整数解。 形式2：求同余方程\(ax\equiv c\pmod b\)的最小整数解。 可以发现两种形式的问题可以互相转化。 前置技能 辗转相除法求gcd 求解 根据裴蜀定理，当且仅当\(gcd(a,b)|c\)时，原方程有整数解。 所以我们考虑解决方程\(ax+by=gcd(a,b)\)，最后同乘\(\frac{c}{gcd(a,b)}\)即可。 为方便描述，我们用\(\%\)代替\(\bmod\)。 有性质\(gcd(a,b)=gcd(b,a\%b)\) 我们假设已经解出方程\(bx&#39;+(a\%b)y&#39;=gcd(b,a\%b)\)，即\(bx&#39;+(a\%b)y&#39;=gcd(a,b)\)。 将\(a\%b\)展开，得\(bx&#39;+(a-\lfloor \frac{a}{b}\rfloor\times b)y&#39;=gcd(a,b)\)。 即\(ay&#39;+b(x&#39;-\lfloor \frac{a}{b}\rfloor y&#39;)=gcd(a,b)\)。 令\(x=y&#39;,y=x&#39;-\lfloor \frac{a}{b}\rfloor y&#39;\)，我们得到了原方程得一组解。 所以可以递归求解，终止条件是\(b=0\)，此时\(gcd(a,b)=a\)，方程组的解是\(x=1,y=0\)。 求\(x\)最小的解： 因为如果\((x,y)\)是一组解，则\((x+\frac{b}{gcd(a,b)},y-\frac{a}{gcd(a,b)})\)也是一组解，可以根据这个求出最小解。 代码 1234567891011121314#include &lt;cstdio&gt;int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if (!b) return x = 1, y = 0, a; int x0, y0, g = exgcd(b, a % b, x0, y0); return x = y0, y = x0 - a / b * y0, g;&#125;int a, b, c;int main()&#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); int x, y, g = exgcd(a, b, x, y); if (c % g) return printf("Impossible"), 0; x *= c / g, y *= c / g; printf("%d %d", x, y);&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乘法逆元 学习笔记]]></title>
    <url>%2Finv-notes%2F</url>
    <content type="text"><![CDATA[问题 用来解决模域下的除法问题。 求解 乘法逆元的定义：\(ab\equiv 1 \pmod p\)，则\(b\)称为\(a\)在模\(p\)域下的乘法逆元。乘法逆元不一定存在，存在条件请参见下文。 这样我们就可以轻松解决模域下的除法问题。即假设我们要求\(\frac{a}{b} \bmod p\)的值，用\(inv(x)\)表示\(x\)在模\(p\)域下的乘法逆元，则\(\frac{a}{b} \bmod p=\frac{a\cdot b\cdot inv(b)}{b}\bmod p=a\cdot inv(b) \bmod p\)，所以我们把除法变成了乘法，就可以利用乘法在模域下的一些性质对原问题进行求解或转化。 问题在于如何求出\(inv(b)\)。求乘法逆元有许多方法。 扩展欧几里得 根据乘法逆元的定义，我们要求\(inv(a)\)，就是求同余方程\(ax\equiv 1 \pmod p\)的最小整数解。 考虑将该同余方程转化为一般形式，即\(ax+py=1\)。 很容易就能求出\(x\)的最小整数解。 根据裴蜀定理可知，方程\(ax+by=c\)只有当\(gcd(a,b)|c\)时才有整数解。所以只有当\(gcd(a,p)=1\)时，逆元才唯一存在。 费马小定理 费马小定理：当\(p\)是质数时，\(a^{p-1}\equiv 1 \pmod p\)。即\(a\cdot a^{p-2}\equiv 1\pmod p\)。所以\(inv(a)=a^{p-2}\)。 欧拉定理 欧拉定理：当\(a,p\)互质时，\(a^{\varphi(p)}\equiv 1 \pmod p\)。即\(a\cdot a^{\varphi(p)-1}\equiv 1\pmod p\)。所以\(inv(a)=a^{\varphi(p)-1}\)。 \(\varphi(p)\)即欧拉函数，表示小于等于\(p\)的正整数中，与\(p\)互质的数的个数。 因为当\(p\)是质数时，\(\varphi(p)=p-1\)，所以费马小定理是欧拉定理的特殊形式。 \(\varphi(p)\)的求法不详细介绍。 特例 还有一些奇怪的特例，例如求\(1\)到\(n\)所有数在模\(p\)域下的逆元，还有\(1\)到\(n\)所有数的阶乘在模\(p\)域下的逆元，这些可以\(O(n)\)求出。 不详细介绍。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 815D」Karen and Cards]]></title>
    <url>%2Fcf815d-sol%2F</url>
    <content type="text"><![CDATA[题目传送门 Karen and Cards Karen just got home from the supermarket, and is getting ready to go to sleep. img After taking a shower and changing into her pajamas, she looked at her shelf and saw an album. Curious, she opened it and saw a trading card collection. She recalled that she used to play with those cards as a child, and, although she is now grown-up, she still wonders a few things about it. Each card has three characteristics: strength, defense and speed. The values of all characteristics of all cards are positive integers. The maximum possible strength any card can have is \(p\), the maximum possible defense is \(q\) and the maximum possible speed is \(r\). There are \(n\) cards in her collection. The \(i\)-th card has a strength \(a_i\), defense \(b_i\) and speed \(c_i\), respectively. A card beats another card if at least two of its characteristics are strictly greater than the corresponding characteristics of the other card. She now wonders how many different cards can beat all the cards in her collection. Two cards are considered different if at least one of their characteristics have different values. Input The first line of input contains four integers, \(n,p,q\) and \(r\) (\(1 \le n,p,q,r \le 500000\)), the number of cards in the collection, the maximum possible strength, the maximum possible defense, and the maximum possible speed, respectively. The next \(n\) lines each contain three integers. In particular, the \(i\)-th line contains \(a_i,b_i\) and \(c_i\) (\(1\le a_i\le p,1\le b_i\le q,1\le c_i\le r\)), the strength, defense and speed of the \(i\)-th collection card, respectively. Output Output a single integer on a line by itself, the number of different cards that can beat all the cards in her collection. Examples Input 12343 4 4 52 2 51 3 44 1 1 Output 110 Input 1234565 10 10 101 1 11 1 11 1 11 1 11 1 1 Output 1972 Note In the first test case, the maximum possible strength is 4, the maximum possible defense is 4 and the maximum possible speed is 5. Karen has three cards: The first card has strength 2, defense 2 and speed 5. The second card has strength 1, defense 3 and speed 4. The third card has strength 4, defense 1 and speed 1. There are 10 cards that beat all the cards here: The card with strength 3, defense 3 and speed 5. The card with strength 3, defense 4 and speed 2. The card with strength 3, defense 4 and speed 3. The card with strength 3, defense 4 and speed 4. The card with strength 3, defense 4 and speed 5. The card with strength 4, defense 3 and speed 5. The card with strength 4, defense 4 and speed 2. The card with strength 4, defense 4 and speed 3. The card with strength 4, defense 4 and speed 4. The card with strength 4, defense 4 and speed 5. In the second test case, the maximum possible strength is 10, the maximum possible defense is 10 and the maximum possible speed is 10. Karen has five cards, all with strength 1, defense 1 and speed 1. Any of the 972 cards which have at least two characteristics greater than 1 can beat all of the cards in her collection. Problem 给定\(n\)个三元组\((a_i,b_i,c_i)\)，以及三元组中每个数的上限\(p,q,r\)，定义一个三元组能击败另一个三元组当且仅当这个三元组中有任意两个数严格大于另一个三元组对应的两个数。求有多少三元组能击败所有\(n\)个三元组。 Solution 记满足条件的三元组为\((x,y,z)\)。显然如果枚举\(x\)，则三元组可以分为两类：\(a_i&lt;x\)与\(a_i\ge x\)。对于\(a_i&lt;x\)的三元组，只需要满足\(y&gt;b_i\)或者\(z&gt;c_i\)。而对于\(a_i\ge x\)的三元组，需要满足\(y&gt;b_i\)并且\(z&gt;c_i\)。 记\(smx_j(j\in [1,q])\)表示\(b_i\ge j\)的三元组中最大的\(c_i\)，\(mx3\)表示\(a_i\ge x\)的三元组中最大的\(c_i\)。那么\(z\)的方案数就是\(r-max(smx_y,mx3)\)，即\(z\)需要满足\(z&gt;smx_y,z&gt;mx3\)，因为对于\(a_i\ge x\)的三元组，\(z\)一定大于\(c_i\)，且对于\(b_i\ge y\)的三元组，\(z\)也一定大于\(c_i\)。 记\(mx2\)表示\(a_i\ge x\)的三元组中最大的\(b_i\)，那么当\(x\)固定时，总方案可以用for (int i=mx2+1;i&lt;=q;i++) ans+=r-max(smx[i],mx3);进行统计。 这样的话，因为我们要统计\(a_i\ge x\)的三元组中最大的\(b_i\)（\(mx2\)），最大的\(c_i\)（\(mx3\)），所以我们应该倒着枚举\(x\)。 时间复杂度？\(\mathcal O(n^2)\)。显然不能过。 考虑优化for (int i=mx2+1;i&lt;=q;i++) ans+=r-max(smx[i],mx3);这段代码。 \(max\)很不好处理，我们考虑把它拆开分别计算。由\(smx_i\)的定义可得，\(\{smx_i\}\)单调不升，也就是\(i\)越小，\(smx_i\)越大。那么我们找到一个\(max\)分界线，记为\(k\)，使得\(i\ge k\)时，\(smx_i\le mx3\)，\(i&lt;k\)时，\(smx_i&gt;mx3\)。于是就可以\(\mathcal O(1)\)计算答案了，用前缀和维护\(\{smx_i\}\)的区间和即可。 显然，\(\{smx_i\},mx2,mx3\)很容易维护。那么\(k\)怎么办呢？因为\(x\)从大到小枚举，\(mx3\)会逐渐变大，而\(\{smx_i\}\)单调不升，所以\(k\)慢慢变小（向前），一直维护即可。 一些细节具体见代码。 Source 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int read()&#123; int x=0; int f=1,ch=getchar(); for (;!isdigit(ch)&amp;&amp;ch!=EOF;ch=getchar()) if (ch=='-') f=-1; for (;isdigit(ch);ch=getchar()) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); return x*f;&#125;const int N=500005;int n,La,Lb,Lc,smx[N];struct card&#123; int b,c;&#125;;vector&lt;card&gt; d[N];long long ans,sum[N];int main()&#123; n=read(),La=read(),Lb=read(),Lc=read(); //La,Lb,Lc分别代表p,q,r for (register int i=1;i&lt;=n;++i)&#123; int a=min(La,read()),b=min(Lb,read()),c=min(Lc,read()); d[a].push_back((card)&#123;b,c&#125;); smx[b]=max(smx[b],c); &#125; for (register int i=Lb-1;i;--i) smx[i]=max(smx[i],smx[i+1]); for (register int i=1;i&lt;=Lb;++i) sum[i]=sum[i-1]+smx[i]; //smx[i]的前缀和 int mxb=0,mxc=0,k=Lb+1; //初始值 for (register int x=La;x;--x)&#123; //从大到小枚举 for (register int i=0;i&lt;d[x].size();++i)&#123; int y=d[x][i].b,z=d[x][i].c; mxb=max(mxb,y),mxc=max(mxc,z); //维护mx2和mx3 while (k&gt;mxb+1&amp;&amp;smx[k-1]&lt;mxc) --k; //维护k &#125; k=max(k,mxb+1); //防止越界 ans+=1ll*(Lc-mxc)*(Lb-k+1)+1ll*Lc*(k-mxb-1)-sum[k-1]+sum[mxb]; //利用前缀和O(1)统计答案 &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>三维数点</tag>
        <tag>单调性</tag>
      </tags>
  </entry>
</search>
