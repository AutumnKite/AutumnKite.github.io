{"meta":{"title":"AutumnKite's Blog","subtitle":null,"description":"一个浙江蒟蒻的博客","author":"AutumnKite","url":"https://autumnkite.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-03-26T07:22:57.247Z","updated":"2020-03-26T07:22:57.247Z","comments":true,"path":"about/index.html","permalink":"https://autumnkite.github.io/about/index.html","excerpt":"","text":"这里是一个ZJ小蒟蒻的博客。 QQ: 1790397194，欢迎与我交流！"},{"title":"","date":"2021-08-23T06:48:44.391Z","updated":"2021-08-23T06:48:44.391Z","comments":true,"path":"404.html","permalink":"https://autumnkite.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在"},{"title":"分类","date":"2020-03-26T07:22:57.250Z","updated":"2020-03-26T07:22:57.250Z","comments":true,"path":"categories/index.html","permalink":"https://autumnkite.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2021-08-23T07:12:38.186Z","updated":"2021-08-23T07:12:38.186Z","comments":true,"path":"friends/index.html","permalink":"https://autumnkite.github.io/friends/index.html","excerpt":"","text":"如果你想与我互加友链，请在下方评论区留言~ 记得提供网站名称、头像和网站地址哦~"},{"title":"标签","date":"2021-08-23T07:18:11.020Z","updated":"2020-03-26T07:22:57.319Z","comments":true,"path":"tags/index.html","permalink":"https://autumnkite.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"NOI2021 RP 爆棚记","slug":"noi2021","date":"2021-07-31T05:44:03.000Z","updated":"2021-08-23T06:21:31.533Z","comments":true,"path":"noi2021/","link":"","permalink":"https://autumnkite.github.io/noi2021/","excerpt":"咕咕咕 Day -n PKUSC 考炸了，zyy 布置作业：两个月在 CF 上做 500 道 2300+。 于是开始了卷题生活。 Day -10 zyy 和 wzp 来讲课了。 zyy 的作业没做完，裂了。 wzp 的例题都不会，他说不会做的可以弃考了。我是不是该退役了 /kk Day -2 貌似晚上开着空调被子没盖感冒了。 有亿点危 /fad 打算第二天休息一天的，结果突然说报到提前了一天，我 **** Day -1 上午在家里休息了半天，下午因为感冒了，就没有坐大巴，自己去了余姚。 和 Froggy 一起换了下寝室，于是就开心地和 Froggy、wcr 一起住了 /cy 看了一下笔试，颓了一晚上。 食堂貌似不太行（？） Day 0 听说烟花要提前登陆了，有点慌 /fad 中饭变成自助餐了，貌似不错（","text":"咕咕咕 Day -n PKUSC 考炸了，zyy 布置作业：两个月在 CF 上做 500 道 2300+。 于是开始了卷题生活。 Day -10 zyy 和 wzp 来讲课了。 zyy 的作业没做完，裂了。 wzp 的例题都不会，他说不会做的可以弃考了。我是不是该退役了 /kk Day -2 貌似晚上开着空调被子没盖感冒了。 有亿点危 /fad 打算第二天休息一天的，结果突然说报到提前了一天，我 **** Day -1 上午在家里休息了半天，下午因为感冒了，就没有坐大巴，自己去了余姚。 和 Froggy 一起换了下寝室，于是就开心地和 Froggy、wcr 一起住了 /cy 看了一下笔试，颓了一晚上。 食堂貌似不太行（？） Day 0 听说烟花要提前登陆了，有点慌 /fad 中饭变成自助餐了，貌似不错（ 教练突然通知下午可能要笔试，赶紧再去看了看笔试。 笔试从三点变成了两点半，结果又鸽到了三点... 为啥笔试会出不在笔试题库里的题啊 /jk 不过还好拿了 100 /cy Day 0.5 没啥安排，在寝室颓废+睡觉。 做了一道题，发现因为感冒几天不敲代码码力有点不太行了 /kk 晚上突然通知明天八点半集合待命...这又是啥奇怪的操作... 晚上感冒竟然好了（ Day 1 八点半集合进场，八点四十说十点之前开始考，八点五十说九点开始考试。这 NOI 也太阴间了... 有亿点紧张。 开场一个小时看 T1 屁都不会，各种想法都想不通，有点自闭。 上了个厕所有了个比较复杂的想法，写写写。 到十一点半，终于把大样例调过了，结果第四个样例就跑了 3s /jk 自闭了，上了个（女）厕所冷静一下，看了看 T2，秒杀了 A 性质，再猜了猜结论大概半个小时把大样例过了。结果又跑了 3s /tuu 卡了 15min 常，变成了 0.3s，又开始卡 T1... 先把两棵线段树合并成了一棵，稍微快了一点，这时候已经一点了。想了一下 T3，看出来了题目里条件本质上是有用的边是一棵树，但是貌似不是很会建这棵树，就还是先去卡 T1 的常。 把线段树改成了 zkw 线段树，还 WA 掉了调了很久，一直在调 T1 和写 T3 暴力之间来回横跳。最后 T1 第四个样例跑了 1.5s，第五个样例跑了 0.8s，放弃了... 估分 60+100+24=184，问了一圈都是 250+ 还一车 AK，不过绍一的几个正式选手貌似都只有 200 出头？ 紧张刺激的查分时刻！我 T1 竟然过了，T3 的第二档竟然也过了，竟然有 100+100+36=236，虽然还是有点低，但是已经比我预期高了好多了。 绍一的其他几个正式选手竟然都比我还低，感觉绍一今年要 wei。Froggy 260，不是正式选手可惜了（ Day 1.5 上午颓废+睡觉，下午去参加了 NOI 嘉年华。掷骰子 16 分算是拿了个中规中矩的分，保龄球第一次歪了从背后弹回来倒了 7 个，第二次歪了直接一个都没有（暗示 Day2 要爆蛋），拿了 8 分。听说二等奖要 85 分，直接死透了。 后来好像又降到了 80 分，但是那个投壶太难了，只投中 1 个拿了 12 分，彻底没救了。 不过看飞镖还挺好玩的就去玩了一下，第一发只想着要用力没管方向飞到了墙上还弹回来插在了地上。第二发直接飞到了 16*3，貌似直接满分了。 还有一个乒乓但是时间差不多到了，就拿了盒榨菜回去了（ 晚上早点洗洗睡了。 Day 2 晚上貌似没睡好，早上还很早就醒了，有亿点困... 开场 1h 三道题都看了一遍想了想。T1 没啥思路；T2 那个分数没见过完全观察不出性质，还有 gcd 等于 1 也不知道咋保证，就先丢了；T3 样例解释里很好心地提示了容斥，不过好像复杂度有点高，只能拿一点点分。 上了个厕所，想到 T1 可以随机若干位置相等，离线下来好像可以做的样子。写了一发，样例都过了，但是随了一组极限数据大概 30 组询问就会错一个，有点裂开。输出了一下随机的轮数发现只跑了 7 次，要保证正确性大概要跑 30+ 次，泪目了。 T2 还是没什么想法，就跑去做 T3 了。 想着可以先写一下暴力一点的 DP 再优化。大概写了个 2^(max R 的个数)*n*m 的做法，过了前三个样例结果第四个样例跑了 7s 还 WA 了 /jk 自闭了，差不多只剩 1h 了，于是放弃了 T1T3，滚回去看 T2 了。 稍微分析了一下发现之前我在白给，分子分母一定互质，而且分子分母的规律还是挺好找的...但是时间来不及了，我还没分析出操作序列对应序列的性质，就算分析出来也不可能来得及写平衡树了，所以就冲了一发 50 分暴力。 泪目，估分 (50~80)+50+(0~20)，差不多 100 多一点。 没啥心情吃饭了，迫于教练压力随便吃了点，回寝室等查分。 查分查出来 T1 竟然过了，T3 也超出了我的预期！不过 T2 挂了点，最后得分 100+40+32=172。 不过 Froggy、zyk 都被卡常了，貌似有点泪目 /fad 这样总分就有 508 了，感觉按照以往的队线好像大概率能上了！ 感觉我 RP 爆棚了，这都能翻到 500+ 结果 QQ 群里一堆人说分数线 500+，还有说 510+、520 的，慌起来了 /kk 讲题一直没心思听，高校宣讲是线上的就鸽了，吃完晚饭就拉着 kmd 一直在贴成绩的地方晃，听两个教练说分数线 498，还当了两回工具人（给别人拍照）。 逛了一圈回来发现有一群人在贴成绩，赶紧跑过去看。结果还没看到自己人在哪里就有人说了分数线 498，算是安心了。不过也不知道为啥我好像心情挺平静的，貌似也没有太激动（ 晚上和 Froggy、kmd、zz、wcr 打了好久的牌，还吃了桶方便面（ Day 3 和 sys 一起上台领奖了（ 身高差有点小大（ 下午就回家了。 NOI 就这样结束了。 新的征程开始了。 祝我好运！ 不过我到现在还没搞清楚为啥我代码在最终测评的时候会快这么多，有点懵 /fad","categories":[{"name":"游记","slug":"游记","permalink":"https://autumnkite.github.io/categories/%E6%B8%B8%E8%AE%B0/"},{"name":"NOI","slug":"游记/NOI","permalink":"https://autumnkite.github.io/categories/%E6%B8%B8%E8%AE%B0/NOI/"}],"tags":[]},{"title":"AtCoder Grand Contest 030 题解","slug":"atcoder-agc030","date":"2020-11-06T11:13:26.000Z","updated":"2021-08-22T07:57:33.475Z","comments":true,"path":"atcoder-agc030/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc030/","excerpt":"比赛地址","text":"比赛地址 A - Poisonous Cookies 题意 有若干饼干，分别是 \\(A\\) 块带有解毒剂的不好吃的饼干、\\(B\\) 块带有解毒剂的好吃的饼干、\\(C\\) 块带有毒药的好吃的饼干。 你可以按任意顺序吃任意数量的饼干，但是需要满足不能连续吃两块带有毒药的饼干。 求最多能吃多少块好吃的饼干。 \\(A,B,C\\le 10^9\\) 题解 带有解毒剂的饼干一定全部都吃，这样带有毒药的饼干最多可以吃 \\(A+B+1\\) 块。 所以答案即为 \\(B+\\min(C,A+B+1)\\)。 代码 B - Tree Burning 题意 有一个周长为 \\(L\\) 的圆，你的起点在圆周上的某一位置，圆上的每个位置的坐标定义为从起点逆时针走到该点的距离，坐标范围为 \\([0,L)\\)。 有 \\(N\\) 棵树，第 \\(i\\) 棵树在坐标 \\(x_i\\)。你需要从起点出发，每次向左或向右走到第一棵树烧掉，直到树都被烧完。 求走的路程的最大值。 \\(N\\le 2\\times 10^5,L\\le 10^9\\) 题解 我们把 \\(N\\) 棵树的坐标放在数轴上，那么数轴上 \\([0,L)\\) 的区间被分成了 \\(N+1\\) 段。 考虑每一段的贡献，一定是存在一个分界点 \\(p\\)，\\(p\\) 前面部分是从前往后若干段连续递减到 \\(0\\) 的偶数，后面部分是从后往前连续递减到 \\(1\\) 的奇数，或者相反。同时需要保证第一段和最后一段的贡献差的绝对值为 \\(1\\)。 若前面部分和后面部分同时存在贡献相同的长度超过 \\(1\\) 的段，那么可以通过调整使得贡献更大，例如： \\[\\{5,3,3,3,1,0,2,4,4\\}\\to\\{7,5,3,3,1,0,2,4,6\\}\\] 并且如果存在这样的段，一定是贡献最大的段，否则也可以调整： \\[\\{7,5,3,3,1,0,2,4,6\\}\\to\\{7,7,5,3,1,0,2,4,6\\}\\] 于是枚举分界点后贡献就确定了，预处理 \\((x_i-x_{i-1})\\times i\\) 的前缀和即可。 时间复杂度 \\(O(N)\\)。 代码 C - Coloring Torus 题意 给定正整数 \\(K\\)，你需要选择一个 \\(1\\) 到 \\(500\\) 的整数 \\(n\\)，并构造一个 \\(n\\times n\\) 的网格，记行列标号分别为 \\(0,\\ldots,n-1\\)，满足： 每个格子为 \\(K\\) 种颜色之一且每种颜色都至少出现一次。 对于两种颜色 \\(i,j\\)，对于所有颜色为 \\(i\\) 的格子，与该格子相邻的颜色为 \\(j\\) 的格子数量相等。在这里，与 \\((r,c)\\) 相邻的格子为 \\(((r-1)\\bmod n, c), ((r+1)\\bmod n, c), (r, (c-1)\\bmod n), (r, (c+1)\\bmod n)\\)。 \\(1\\le K\\le 1000\\) 题解 先考虑 \\(n\\) 为偶数且 \\(K=2n\\) 的情况。有一种方案是将每行交替填上两种颜色，但是这样填并不能扩展。 考虑斜着填，对于所有 \\((i-j)\\bmod n\\) 相同的位置，按 \\(i\\) 从小到大的顺序交替填上两种颜色。 这样构造显然是正确的。 另外，若我们将某一斜线填上同种颜色，这样的方案仍然是正确的的，这样我们就可以将颜色数减小。 于是取 \\(n=2\\lceil\\frac{K}{4}\\rceil\\) 后按上述方法构造即可。 代码 D - Inversion Sum 题意 有一个序列 \\(A_1,A_2,\\ldots,A_N\\)，有 \\(Q\\) 次操作，第 \\(i\\) 次操作你可以交换 \\(A_{X_i}\\) 和 \\(A_{Y_i}\\) 或者什么都不干。 求所有 \\(2^Q\\) 个最终序列的逆序对之和，对 \\(10^9+7\\) 取模。 \\(N,Q\\le 3000\\) 题解 考虑对于每一对数计算贡献。 考虑 DP，令 \\(f_{k,i,j}\\) 表示从第 \\(k\\) 次操作开始，当前位置分别为 \\(i\\) 和 \\(j\\) 的两个数，在最终序列中第一个数在第二个数前面的方案数。 转移很简单，注意到除了第 \\(X_k,Y_k\\) 行和第 \\(X_k,Y_k\\) 列外，其他位置的 DP 值的操作只是乘了 \\(2\\)。 于是我们只需要记录当前 DP 数组实际需要乘上的值，每次就可以 \\(O(N)\\) 转移。 这本质上与方案数转概率相同。 时间复杂度 \\(O(N(Q+N))\\)。 代码 E - Less than 3 题意 若一个 \\(01\\) 字符串中不存在连续 \\(3\\) 个 \\(0\\) 或连续 \\(3\\) 个 \\(1\\)，那么称之为好的。 有两个长度为 \\(N\\) 的好的 01 字符串 \\(s,t\\)。你可以对 \\(s\\) 执行若干次以下操作： 选择一个位置取反，需要保证操作后字符串仍然是好的。 求使得 \\(s\\) 变为 \\(t\\) 的最少操作次数。 \\(N\\le 5000\\) 题解 考虑在相邻的 \\(01\\) 之间放一条红线，相邻的 \\(10\\) 之间放一条蓝线，并且前后交替放置无限条红线和蓝线。 那么一次操作相当于把一条线向左或向右移动一格。除了首尾，需要保证每个位置最多只有一条线，且相邻的线距离最多为 \\(2\\)。一个操作过程的例子如下图所示（来自官方题解）： 若我们得到了 \\(s\\) 和 \\(t\\) 线与线的对应关系，可以证明一定有解，且答案即为每一个对应关系中两条线的距离之和。一个例子如下图所示（来自官方题解）： 该例子的答案为 \\(\\cdots+0+0+0+1+0+1+2+3+2+1+0+\\cdots=10\\)。 对应关系只有 \\(O(N)\\) 种，枚举即可。 时间复杂度 \\(O(N^2)\\)。 代码 F - Permutation and Minimum 题意 给定一个未填完的 \\(1\\) 到 \\(2N\\) 的排列 \\(A_1,A_2,\\ldots,A_{2N}\\)，你需要填完该排列，然后得到一个新的序列 \\(B_1,B_2,\\ldots,B_N\\)，其中 \\(B_i=\\min(A_{2i-1},A_{2i})\\)。 求可以得到多少不同的序列 \\(B\\)。对 \\(10^9+7\\) 取模。 \\(N\\le 300\\) 题解 咕咕咕","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"枚举","slug":"枚举","permalink":"https://autumnkite.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"}]},{"title":"KEYENCE Programming Contest 2019 题解","slug":"atcoder-keyence2019","date":"2020-10-19T12:22:53.000Z","updated":"2021-08-22T07:54:56.648Z","comments":true,"path":"atcoder-keyence2019/","link":"","permalink":"https://autumnkite.github.io/atcoder-keyence2019/","excerpt":"比赛地址 ABC 就不写了。","text":"比赛地址 ABC 就不写了。 D - Double Landscape 题意 在一个 \\(N\\times M\\) 的网格中不重复地填入 \\(1\\) 到 \\(N\\times M\\) 的整数，使得第 \\(i\\) 行的最大值为 \\(A_i\\)，第 \\(j\\) 列的最大值为 \\(B_j\\)，求方案数。对 \\(10^9+7\\) 取模。 \\(N,M\\le 1000\\) 题解 将 \\(A,B\\) 从小到大排序，显然不影响答案。 从大到小填数，分为若干种情况： 若当前数是超过两行或超过两列的最大值，则一定无解。 若当前数是恰好一行和一列的最大值，则必然填在交界处。 若当前数是恰好一行或恰好一列的最大值，则必然填在该行或该列。 否则，该数可以填在最大值大于等于当前数的任意位置。 时间复杂度 \\(O(NM)\\)。 代码 E - Connecting Cities 题意 有一张 \\(N\\) 个点的无向完全图，第 \\(i\\) 个点有点权 \\(A_i\\)。定义一条边 \\((i,j)\\) 的边权为 \\(|i-j|\\times D+A_i+A_j\\)。求最小生成树权值。 \\(N\\le 2\\times 10^5\\) 题解 直接套用 Boruvka 算法。 每次合并时，对于每个点 \\(i\\)，可以对 \\(j &lt; i\\) 和 \\(j &gt; i\\) 两种情况分别求出不在同一连通块的最小边。 只需要正反扫一遍，维护最小值和与最小值不在同一连通块的最小值即可。 时间复杂度 \\(O(N\\alpha(N)\\log N)\\)。 代码 F - Paper Cutting 题意 有一个 \\((H+1)\\times (W+1)\\) 的网格，有 \\(H\\) 条水平线和 \\(W\\) 条垂直线。 你需要执行 \\(K\\) 次操作，每次沿一条水平线或垂直线将网格切开。定义一次操作的权值为做完该操作后网格被分成的块数。 定义一个操作序列的权值为 \\(K\\) 次操作的权值和。 求所有操作序列的权值之和。对 \\(10^9+7\\) 取模。 \\(H,W\\le 10^7\\) 题解 考虑求出第 \\(k\\) 次操作对答案的贡献，为 \\[k!(K-k)!\\binom{H+W-k}{K-k}\\sum_{i=0}^{k}\\binom{H}{i}\\binom{W}{k-i}(i+1)(k-i+1)\\] 考虑优化后面部分，有 \\[ \\begin{aligned} &amp; \\sum_{i=0}^{k}\\binom{H}{i}\\binom{W}{k-i}(i+1)(k-i+1) \\\\ =~&amp;(k+1)\\sum_{i=0}^{k}\\binom{H}{i}\\binom{W}{k-i}+\\sum_{i=0}^{k}i(k-i)\\binom{H}{i}\\binom{W}{k-i}\\\\ =~&amp;(k+1)\\binom{H+W}{k}+HW\\binom{H+W-2}{k-2} \\end{aligned} \\] 时间复杂度 \\(O(H+W)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"Boruvka","slug":"Boruvka","permalink":"https://autumnkite.github.io/tags/Boruvka/"}]},{"title":"NIKKEI Programming Contest 2019 题解","slug":"atcoder-nikkei2019-qual","date":"2020-10-19T06:43:33.000Z","updated":"2021-08-22T07:52:30.006Z","comments":true,"path":"atcoder-nikkei2019-qual/","link":"","permalink":"https://autumnkite.github.io/atcoder-nikkei2019-qual/","excerpt":"比赛地址 ABCD 就不写了。","text":"比赛地址 ABCD 就不写了。 E - Weights on Vertices and Edges 题意 给定一个 \\(N\\) 个点 \\(M\\) 条边的点带权、边带权无向连通图 \\(G\\)，你需要删除一些边，使得对于留下的每条边边权小于等于该边所在连通块的点权之和。 \\(N,M\\le 10^5\\) 题解 考虑一个 \\(O(NM)\\) 的做法，每次将边权大于当前连通块的边全部删除，然后分治处理每个连通块。 显然这个做法与从大到小判断每条边是否满足条件，不满足则删去的做法是一样的。 注意到一条边若满足条件，那么该条边当前所在的连通块中的任意一条边都不会被删除。 于是用带撤销并查集维护即可。 时间复杂度 \\(O(M\\log M)\\)。 代码 F - Jewels 题意 有 \\(N\\) 个珠宝，\\(K\\) 种颜色，第 \\(i\\) 个珠宝颜色为 \\(C_i\\)，价值为 \\(V_i\\)，保证每种颜色至少出现了两次。 你需要对于每个 \\(1\\le x\\le N\\)，求出满足以下条件时，选择恰好 \\(x\\) 个珠宝的最大价值和： 对于选择的任意一个珠宝，存在另一个与它颜色相同的珠宝也被选择。 \\(N\\le 2\\times 10^5\\) 题解 对于同种颜色价值最大的两个珠宝，一定会被同时选择。考虑将这样的两个珠宝捆在一起。 我们将所有珠宝按价值从大到小排序，特别地，对于两个捆在一起的珠宝，价值看成平均值，并且价值相等时强制排在其它珠宝前面。 对于一个 \\(x\\)，若前 \\(x\\) 个珠宝恰好可以被选择，那么答案一定为前 \\(x\\) 个珠宝的价值和。 否则，我们可以先选择前 \\(x-1\\) 个，然后考虑如何使数量增加 \\(1\\)。我们在选择前 \\(x-1\\) 个的基础上，定义以下集合（一种颜色使用过当且仅当选择的珠宝中存在该颜色的珠宝）： \\(P\\) 为被选择的珠宝中不是捆在一起的珠宝。 \\(Q\\) 为颜色使用过的珠宝中没有被选择的珠宝。 \\(R\\) 为颜色使用过的、捆在一起且其他该颜色的珠宝没有被选择的珠宝对。 \\(S\\) 为颜色没使用过的、捆在一起的珠宝对。 \\(T\\) 为颜色没使用过的、捆在一起的珠宝和其他该颜色的珠宝中价值最大的组成的三元组。 那么有三种情况： 添加一个 \\(Q\\) 中的珠宝。 删去一个 \\(P\\) 中的珠宝，添加一个 \\(S\\) 中的珠宝对。 删去一个 \\(R\\) 中的珠宝对，添加一个 \\(T\\) 中的珠宝三元组。 可以证明不可能存在这三种情况以外的调整方法。 于是我们使用 std::multiset 维护即可。 时间复杂度 \\(O(N\\log N)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"并查集","slug":"并查集","permalink":"https://autumnkite.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"set","slug":"set","permalink":"https://autumnkite.github.io/tags/set/"}]},{"title":"AtCoder Grand Contest 031 题解","slug":"atcoder-agc031","date":"2020-10-15T11:53:28.000Z","updated":"2021-05-29T10:26:33.964Z","comments":true,"path":"atcoder-agc031/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc031/","excerpt":"比赛地址","text":"比赛地址 A - Colorful Subsequence 题意 给定一个长度为 \\(N\\) 的字符串 \\(S\\)，求有多少非空子序列满足该子序列中的字符两两不同。对 \\(10^9+7\\) 取模。 子序列不要求连续。 \\(N\\le 10^5\\) 题解 令 \\(c_i\\) 为字符 \\(i\\) 的出现次数。则答案为所有 \\(c_i+1\\) 的乘积。 由于子序列非空，答案需要减 \\(1\\)。 代码 B - Reversi 题意 有 \\(N\\) 个石子，第 \\(i\\) 个石子颜色为 \\(C_i\\)。可以执行若干次以下操作： 选择两个颜色相同的石子，将这两个石子之间的石子的颜色都染成这两个石子的颜色。 求可以得到的不同序列数量。对 \\(10^9+7\\) 取模。 \\(N\\le 2\\times 10^5\\) 题解 最后的序列一定是若干段颜色相同的段组成的。 令 \\(f_i\\) 为以 \\(i\\) 作为最后一段结尾的序列数量。则有 \\[f_i=\\sum_{c_j=c_i,c_{j-1}\\ne c_j} f_{j-1}\\] 简单维护即可。 时间复杂度 \\(O(N)\\)。 代码 C - Differ by 1 Bit 题意 给定 \\(N,A,B\\)，求一个 \\(0\\) 到 \\(2^N-1\\) 的排列 \\(P\\)，满足： \\(P_0=A,P_{2^N-1}=B\\) 对于任意 \\(0\\le i &lt; 2^N-1\\)，\\(P_i\\) 和 \\(P_{i+1}\\) 二进制表示恰好有一位不同。 或输出无解。 \\(N\\le 17\\) 题解 显然 \\(A\\) 与 \\(B\\) 在二进制表示下有偶数位不同时一定无解。这是因为共修改了 \\(2^N-1\\) 次，而 \\(2^N-1\\) 是奇数，不可能最后有偶数位不同。否则我们可以构造证明有解。 记 \\(p\\) 为 \\(A\\) 与 \\(B\\) 的任意一位不同的二进制位。那么我们可以将第 \\(p\\) 位与 \\(A\\) 相同的数放在前半部分，与 \\(B\\) 相同的数放在后半部分。 我们可以枚举中间分界处的数 \\(S\\)，注意到一定存在这样的 \\(S\\) 满足 \\(S\\) 与 \\(A\\) 和 \\(B\\) 分别有奇数位不同。 于是我们可以递归到两个 \\(N-1\\) 位的子问题。 时间复杂度 \\(O(2^NN)\\)。 代码 D - A Sequence of Permutations 题意 令 \\(p,q\\) 为两个 \\(1\\) 到 \\(N\\) 的排列，定义 \\(f(p,q)\\) 为位置 \\(p_i\\) 为 \\(q_i\\) 的排列。 给定排列 \\(p,q\\)，定义序列 \\(\\{a_n\\}\\) 如下： \\(a_1=p,a_2=q\\) \\(a_{n+2}=f(a_n,a_{n+1})\\) 给定整数 \\(K\\)，求 \\(a_K\\)。 \\(N\\le 10^5,K\\le 10^9\\) 题解 根据题意，有 \\[ f(p,q)= \\begin{pmatrix} p_1 &amp; p_2 &amp; \\ldots &amp; p_N \\\\ q_1 &amp; q_2 &amp; \\ldots &amp; q_N \\end{pmatrix} \\] 根据置换乘法的定义，有 \\[ \\begin{pmatrix} 1 &amp; 2 &amp; \\ldots &amp; N \\\\ p_1 &amp; p_2 &amp; \\ldots &amp; p_N \\end{pmatrix} \\begin{pmatrix} p_1 &amp; p_2 &amp; \\ldots &amp; p_N \\\\ q_1 &amp; q_2 &amp; \\ldots &amp; q_N \\end{pmatrix} = \\begin{pmatrix} 1 &amp; 2 &amp; \\ldots &amp; N \\\\ q_1 &amp; q_2 &amp; \\ldots &amp; q_N \\end{pmatrix} \\] 即有 \\[p\\cdot f(p,q)=q\\] 即 \\[f(p,q)=p^{-1}q\\] 另外，置换乘法有性质 \\[(ab)^{-1}=b^{-1}a^{-1}\\] 于是可以得到 \\[ \\begin{aligned} a_1 &amp; = p \\\\ a_2 &amp; = q \\\\ a_3 &amp; = p^{-1}q \\\\ a_4 &amp; = q^{-1}p^{-1}q \\\\ a_5 &amp; = q^{-1}pq^{-1}p^{-1}q \\\\ a_6 &amp; = q^{-1}p^2q^{-1}p^{-1}q \\\\ a_7 &amp; = q^{-1}pqpq^{-1}p^{-1}q \\\\ a_8 &amp; = q^{-1}pqp^{-1}qpq^{-1}p^{-1}q \\end{aligned} \\] 令 \\(r=q^{-1}pqp^{-1}\\)，可以归纳证明有 \\[a_n=ra_{n-6}r^{-1}\\] 求一个置换的幂次可以通过求出该置换的每个循环 \\(O(N)\\) 实现。 时间复杂度 \\(O(N)\\)。 代码 E - Snuke the Phantom Thief 题意 平面上有 \\(N\\) 个点，第 \\(i\\) 个点在 \\((x_i,y_i)\\)，价值为 \\(v_i\\)。 你需要选择若干个点，有 \\(M\\) 个限制，第 \\(i\\) 个限制为横坐标/纵坐标小于等于/大于等于 \\(a_i\\) 的点最多只能选 \\(b_i\\) 个。 求选择的点的最大价值和。 \\(N\\le 80,M\\le 320,1\\le x_i,y_i,a_i\\le 100,1\\le v_i\\le 10^{15}\\) 题解 先考虑限制只有小于等于的情况。 考虑建立费用流模型，建立左右两排点。 对于左边第 \\(i\\) 个点，该点只有唯一一条入边，该入边的流量为横坐标小于等于 \\(i\\) 的点被选择的数量。 该点有若干出边，其中一条连向第 \\(i-1\\) 个点，流量表示横坐标小于等于 \\(i-1\\) 的点被选择的数量，其余边连向右边的点，流量表示是否选择一个横坐标为 \\(i\\)，纵坐标为右边对应点的编号的点。 另外，源点连向左边最后一个点，流量表示总共被选择的点数。 右边的点同理。 这样子建图相当于原题每个限制会对左边或右边某条边的流量上界产生限制，而每个点对应左边到右边的一条边。 回到原题，考虑枚举总点数 \\(s\\)，那么相当于每个坐标大于等于某个值的数量的上界限制可以转化为坐标小于等于某个值的数量的下界限制，也即会对左边或右边某条边的流量产生下界限制。 跑上下界费用流即可。 代码 F - Walk on Graph 题意 给定一个 \\(N\\) 个点 \\(M\\) 条边的边带权无向连通图 \\(G\\) 和一个奇数 \\(P\\)，回答 \\(Q\\) 次询问，第 \\(i\\) 个询问为： 判断 \\(S_i\\) 到 \\(T_i\\) 是否存在一条路径使得该路径的权值在模 \\(P\\) 意义下与 \\(R_i\\) 相等。 路径可以经过重复点、重复边。 路径的权值定义为，若一条路径依次经过的边的边权为 \\(L_0,L_1,L_2,\\ldots,L_{k-1}\\)，那么该路径的权值为 \\(\\sum_{i=0}^{k-1} L_i\\times 2^i\\)。 \\(N,M,Q\\le 50000,P\\le 10^6\\) 题解 若无注明，以下涉及权值有关运算均在模 \\(P\\) 意义下进行。 将路径反过来，这样相当于每经过一条边权为 \\(c\\) 的边，权值从 \\(x\\) 变为 \\(2x+c\\)。 记状态 \\((u,x)\\) 为当前在节点 \\(u\\)，权值为 \\(x\\)。那么询问相当于判断 \\((t,0)\\) 是否可以到达 \\((s,r)\\)。 令 \\(f(x)=2x+c\\)，由于 \\(P\\) 是奇数，\\(2\\) 有逆元，所以 \\(f\\) 是一个双射，若 \\(x\\) 向 \\(f(x)\\) 连边，最终一定会形成若干个环。 考虑一条边 \\((u,v,c)\\)，状态 \\((u,x)\\) 一定可以来回通过这条边最终回到 \\((u,x)\\)。这就意味着 \\((u,x)\\) 可以到达 \\((v,2x+c)\\)，\\((v,2x+c)\\) 也可以到达 \\((u,c)\\)，也即状态之间的边是双向的。接下来我们称两个状态等价当且仅当他们连通。 若同时存在边 \\((u,v,a)\\) 和 \\((u,w,b)\\)，那么有 \\((u,x)\\to (v,2x+a)\\to (u,4x+3a)\\) 和 \\((u,x)\\to (w,2x+b)\\to (u,4x+3b)\\)，即 \\((u,4x+3a)\\) 和 \\((u,4x+3b)\\) 是等价的。 \\(4\\) 也存在逆元，那么 \\(4x+3a\\) 可以取到任何值，所以有 \\((u,x)\\) 和 \\((u,x+3(b-a))\\) 等价。 我们求出任意两条边边权之差的 \\(\\gcd\\)，记为 \\(g\\)。由于图是连通的，我们可以从一个状态 \\((u,x)\\) 出发，走到每个点对 \\(x\\) 进行若干次变换，最终可以到达状态 \\((u,x+3g)\\)。也就是说 \\((u,x)\\) 与 \\((u,x+3g)\\) 是等价的。 于是我们可以将 \\(P\\) 置为 \\(\\gcd(P,3g)\\)。 注意到此时所有边边权模 \\(g\\) 相等，置为 \\(z\\)。我们可以把所有边边权减 \\(z\\)，状态中的第二维（即路径权值）增加 \\(z\\)。这样原来的状态 \\((u,x)\\) 对应现在的状态 \\((u,x+z)\\)。这样原来的转移 \\((u,x)\\to (v,2x+c)\\) 对应现在的转移 \\((u,x+z)\\to (v,2(x+z)+c-z)=(v,2x+c+z)\\)，仍然正确。 那么现在从状态 \\((u,x)\\) 出发能到达的状态一定都能表示成 \\((v,2^px+qg)\\) 的形式。由于 \\((u,x)\\) 和 \\((u,x+3g)\\) 等价，我们可以将 \\(q\\) 的运算在模 \\(3\\) 意义下进行而不影响答案。 另外，因为 \\((u,x)\\to (v,2x+c)\\to (u,4x+3c)=(u,4x)\\)，我们可以将 \\(p\\) 的运算在模 \\(2\\) 意义下进行而不影响答案。 由于是询问 \\((t,z)\\) 是否能到达 \\((s,r+z)\\)，那么我们只需要保留能表示成 \\((u,2^pz+qg)\\) 的状态，连边时将 \\(p,q\\) 分别在模 \\(2\\) 和模 \\(3\\) 意义下进行即可。 对于每个询问，我们可以通过预处理快速得到 \\(r+z\\) 对应的所有 \\(p,q\\) 分别在模 \\(2\\) 和模 \\(3\\) 意义下两两不同的二元组 \\((p,q)\\)，判断是否在同一连通块内即可。 连边和判断是否连通若用 DFS 和预处理的方法实现，时间复杂度 \\(O(N+M+Q+P)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"分治","slug":"分治","permalink":"https://autumnkite.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"网络流","slug":"网络流","permalink":"https://autumnkite.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"上下界费用流","slug":"上下界费用流","permalink":"https://autumnkite.github.io/tags/%E4%B8%8A%E4%B8%8B%E7%95%8C%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"图论","slug":"图论","permalink":"https://autumnkite.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"AtCoder Grand Contest 032 题解","slug":"atcoder-agc032","date":"2020-10-15T03:40:11.000Z","updated":"2021-05-29T10:26:33.965Z","comments":true,"path":"atcoder-agc032/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc032/","excerpt":"比赛地址","text":"比赛地址 A - Limited Insertion 题意 有一个初始为空的序列 \\(a\\)。 你需要执行 \\(N\\) 次操作，第 \\(i\\) 次操作需要选择一个 \\(j\\ (1\\le j\\le i)\\)，在 \\(a\\) 中的位置 \\(j\\) 插入 \\(j\\)（序列最开始为位置 \\(1\\)）。 给定一个长度为 \\(N\\) 的序列 \\(b\\)，构造一种操作序列使得最后 \\(a=b\\)，或输出无解。 \\(N\\le 100\\) 题解 显然若存在 \\(a_i &gt; i\\) 一定无解，否则可以通过构造证明一定有解。 考虑倒着做，每次找到最后一个 \\(a_i=i\\) 的位置删除，这样可以使得该序列仍然满足 \\(a_i\\le i\\)。 时间复杂度 \\(O(N^2)\\)。 代码 B - Balanced Neighbors 题意 构造一个 \\(N\\) 个点的简单无向连通图 \\(G\\)，满足存在一个 \\(S\\)，使得对于所有 \\(1\\le i\\le N\\)，与 \\(i\\) 相连的节点编号之和等于 \\(S\\)。 \\(N\\le 100\\) 题解 我们可以首先构造一个完全图，发现此时与 \\(i\\) 相连的节点编号之和为 \\(\\frac{n(n+1)}{2}-i\\)。 考虑去掉所有形如 \\((i,n-i)\\) 的边，那么与 \\(i\\) 相连的节点编号之和为 \\(\\frac{n(n+1)}{2}-i-(n-i)=\\frac{n(n+1)}{2}-n\\)，是一个定值。 但是这样构造在 \\(n\\) 为偶数时会有问题，于是当 \\(n\\) 是偶数时我们去掉所有形如 \\((i,n+1-i)\\) 的边即可。 代码 C - Three Circuits 题意 给定一个 \\(N\\) 个点 \\(M\\) 条边的简单无向连通图 \\(G\\)，判断是否可以在 \\(G\\) 中找出三个环使得每条边恰好被一个环覆盖。 这里的环是指每条边只能经过一次但点可以经过多次的环。 \\(N,M\\le 10^5\\) 题解 显然若存在度数为奇数的点一定不合法。 当存在度数大于 \\(4\\) 的点时，设该点为 \\(x\\)，考虑从 \\(x\\) 开始的一条欧拉回路，记录每次访问的节点编号，我们可以每次将两个 \\(x\\) 之间的部分作为一个环删去，可以至少删三次，所以一定有解。 当度数等于 \\(4\\) 的点数小于 \\(2\\) 时，那么一定不合法。 当度数等于 \\(4\\) 的点数等于 \\(2\\) 时，设这两个点为 \\(x,y\\)，若我们把度为 \\(2\\) 的点组成的链缩成一条边，那么要有解必须是 \\(x\\) 和 \\(y\\) 有两条边且 \\(x\\) 和 \\(y\\) 各自有一个自环的形式。可以简单判断。 当度数等于 \\(4\\) 的点数大于 \\(2\\) 时，根据类似于存在度数大于 \\(4\\) 点时的分析，我们可以从一个度数等于 \\(4\\) 的点 \\(A\\) 开始分成两个环。这两个环一定是以下两种情况之一（图来自官方题解）： 可以发现这两种情况都可以构造出三个环。于是这种情况也一定有解。 代码 D - Rotation Sort 题意 给定一个 \\(1\\) 到 \\(N\\) 排列 \\(p\\)，你可以执行若干次以下操作： 花费 \\(A\\) 的代价，将一个区间循环左移一格； 花费 \\(B\\) 的代价，将一个区间循环右移一格。 求使得排列 \\(p\\) 有序的最小代价。 \\(N\\le 5000\\) 题解 可以发现循环左移相当于将一个数插入到后面，循环右移相当于将一个数插入到前面。 那么没有被操作的数一定是一个上升子序列 \\(x_1 &lt; x_2 &lt; \\ldots &lt; x_k\\ (p_{x_1} &lt; p_{x_2} &lt; \\ldots &lt; p_{x_k})\\)，而对于 \\(x_{i-1}\\) 到 \\(x_i\\) 之间被操作的位置 \\(j\\)，若 \\(p_j &gt; p_{x_i}\\)，则需要花费 \\(A\\) 的代价，否则需要花费 \\(B\\) 的代价。 于是直接 \\(O(N^2)\\) DP 即可。可以用线段树优化到 \\(O(N\\log N)\\)。 代码 E - Modulo Pairing 题意 给定 \\(2N\\) 个整数 \\(a_1,a_2,\\ldots,a_{2N}\\)，以及一个整数 \\(M\\)。 我们需要将这 \\(2N\\) 个数划分成 \\(N\\) 个二元组，使得每个数恰好在一个二元组中出现。 一个二元组 \\((x,y)\\) 的权值为 \\((x+y)\\bmod M\\)，求 \\(N\\) 个二元组权值最大值的最小值。 \\(N\\le 10^5\\) 题解 考虑对于一个二元组 \\((x,y)\\)，若 \\(x+y &lt; M\\)，我们则将 \\(x,y\\) 和这条匹配边染成蓝色，否则染成红色。 将 \\(a\\) 从小到大排序，那么最后的匹配一定形如下图： 否则可以通过以下方式进行调整： 我们发现合法的分界点一定是一个区间，且越靠左越优。 于是二分答案即可。 代码 F - One Third 题意 在一个圆上沿半径等概率随机切 \\(N\\) 刀，选择连续若干块，假设占整个圆面积的 \\(x\\) 倍，求 \\(|x-\\frac{1}{3}|\\) 的最小值的期望。 \\(N\\le 10^6\\) 题解 考虑将每一刀切的半径标红，并对于每一条标红的半径，分别将该半径绕圆心逆时针 \\(120^{\\circ}\\) 和顺时针 \\(120^{\\circ}\\) 处的半径标成蓝色和绿色，那么 \\(|x-\\frac{1}{3}|\\) 的最小值等于两条不同颜色的半径形成的夹角与 \\(360^{\\circ}\\) 的比值的最小值。 注意到这个最小值一定会取在相邻的两条不同颜色半径上。 我们将第一刀对应的半径记为 \\(0^{\\circ}\\)，我们可以只保留 \\(0^{\\circ}\\) 到 \\(120^{\\circ}\\) 之间的半径，\\(120^{\\circ}\\) 到 \\(240^{\\circ}\\) 之间和 \\(240^{\\circ}\\) 到 \\(360^{\\circ}\\) 之间与这一部分等价，不需要考虑。 于是问题转化成：在一个数轴上，一开始在 \\(0\\) 和 \\(\\frac{1}{3}\\) 处分别有一个红点和蓝点。然后在 \\([0,\\frac{1}{3}]\\) 中随机放置 \\(N-1\\) 个随机颜色（红、蓝、绿）的点。求异色点距离最小值的期望。 我们可以求出 \\(f(k)\\) 表示有恰好 \\(k\\) 对相邻异色点的概率，\\(g(k)\\) 表示有恰好 \\(k\\) 对相邻异色点时异色点距离最小值的期望，那么最后答案为 \\(f(k)g(k)\\) 之和。 \\(f(k)\\) 可以通过 DP 或组合数计算。\\(g(k)\\) 可以考虑 \\(k\\) 对相邻异或点距离的总和为 \\(\\frac{k}{3n}\\)，而将一条线段随机分成 \\(k\\) 段，最小的一段的期望长度为总长的 \\(\\frac{1}{k^2}\\)，所以 \\(g(k)=\\frac{1}{3nk}\\)。 后面部分的具体计算过程可以参考曾加的回答 - 知乎。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"分类讨论","slug":"分类讨论","permalink":"https://autumnkite.github.io/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/"},{"name":"二分","slug":"二分","permalink":"https://autumnkite.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"概率","slug":"概率","permalink":"https://autumnkite.github.io/tags/%E6%A6%82%E7%8E%87/"},{"name":"期望","slug":"期望","permalink":"https://autumnkite.github.io/tags/%E6%9C%9F%E6%9C%9B/"}]},{"title":"Yahoo Programming Contest 2019 题解","slug":"atcoder-yahoo-procon2019-qual","date":"2020-10-14T07:05:23.000Z","updated":"2021-05-29T10:26:33.980Z","comments":true,"path":"atcoder-yahoo-procon2019-qual/","link":"","permalink":"https://autumnkite.github.io/atcoder-yahoo-procon2019-qual/","excerpt":"比赛地址","text":"比赛地址 ABC 就不写了。 D - Ears 题意 数轴上有 \\(L\\) 堆石头，第 \\(i\\) 堆石头在坐标 \\(i-0.5\\) 处，初始石子数量都为 \\(0\\)。 你可以从任意整数下标出发，每次向左或向右移动一个单位，并在经过一个石子堆时将该石子堆的石子数量加 \\(1\\)。你可以在任意位置结束移动。你不能移动到坐标小于 \\(0\\) 或大于 \\(L\\) 的位置。 给定 \\(A_1,A_2,\\ldots,A_L\\)，假设最后第 \\(i\\) 堆石头数量为 \\(x_i\\)，你需要最小化 \\[\\sum_{i=1}^{L} |A_i-x_i|\\] \\(L\\le 2\\times 10^5\\) 题解 最后的 \\(x\\) 一定形如 \\(\\{0,\\ldots,0,2,\\ldots,2,1,\\ldots,1,2,\\ldots,2,0,\\ldots,0\\}\\)，其中 \\(2\\) 和 \\(1\\) 分别可以替换成任意大于 \\(0\\) 的偶数和奇数（不同位置可以不同）。 于是直接 DP 即可。 时间复杂度 \\(O(L)\\)。 代码 E - Odd Subrectangles 题意 给定一个 \\(N\\times M\\) 的 01 矩阵，你可以从行集合中选出一个子集 \\(A\\)，从列集合中选出一个子集 \\(B\\)，取出相交的位置，可以得到一个 \\(|A|\\times |B|\\) 的子矩阵。 求使得这个子矩阵的和为奇数的方案数。对 \\(998244353\\) 取模。 \\(N,M\\le 300\\) 题解 注意到对原矩阵做初等行变换和初等列变换都不会改变答案。 我们可以通过做初等行变换和初等列变换（即类似高斯消元的过程）将原矩阵变成每行每列最多只有一个 \\(1\\)。 假设最后有 \\(K\\) 个 \\(1\\)，那么其余 \\(N-K\\) 行和 \\(M-K\\) 列可以任意选，最后乘上 \\(2^{N-K+M-K}\\) 即可。 而对于这 \\(K\\) 个 \\(1\\)，我们要选择奇数个。枚举选择的个数 \\(i\\)，那么其余 \\(K-i\\) 个 \\(1\\) 对应的行和列不能同时选，所以对答案的贡献为 \\(\\binom{K}{i}3^{K-i}\\)。 假设 \\(N\\) 与 \\(M\\) 同阶，时间复杂度 \\(O(N^3)\\)，可以用 bitset 优化到 \\(O(\\frac{N^3}{w})\\)。 代码 F - Pass 题意 有 \\(N\\) 个人从左到右排列，第 \\(i\\) 个人手上有 \\(2\\) 个球，其中 \\(A_i\\) 个是红球，\\(2-A_i\\) 个是蓝球。另外还有一个初始为空的序列 \\(S\\)。 需要执行 \\(2N\\) 次以下操作： 每个有球的人同时选择一个手上的球，并将该球给左边的人。特别地，第一个人会将这个球放到 \\(S\\) 的末尾。 求最后可以得到多少个不同的 \\(S\\)。注意相同颜色的球是相同的。对 \\(998244353\\)。 \\(N\\le 2000\\) 题解 考虑固定一个 \\(S\\) 后如何判断。 从前往后依次判断，假设前 \\(i-1\\) 个位置合法，那么第 \\(i\\) 个位置合法当且仅当初始时前 \\(\\min(i,N)\\) 个人手中的球去掉前 \\(i-1\\) 个球后存在一个球与第 \\(i\\) 个球相同。 于是直接 DP，\\(f_{i,j}\\) 表示 \\(S\\) 中前 \\(i\\) 个位置，有 \\(j\\) 个红球时的方案数。转移只要考虑下一个是红球还是蓝球即可。 时间复杂度 \\(O(N^2)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"高斯消元","slug":"高斯消元","permalink":"https://autumnkite.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"}]},{"title":"ExaWizards 2019 题解","slug":"atcoder-exawizards2019","date":"2020-10-14T01:12:38.000Z","updated":"2021-05-29T10:26:33.976Z","comments":true,"path":"atcoder-exawizards2019/","link":"","permalink":"https://autumnkite.github.io/atcoder-exawizards2019/","excerpt":"比赛地址","text":"比赛地址 AB 就不写了。 C - Snuke the Wizard 题意 有 \\(N\\) 个格子从左到右排列，第 \\(i\\) 个格子上有一个字符 \\(s_i\\)。 初始时，每个格子上有一个棋子。接下来进行 \\(Q\\) 次操作，第 \\(i\\) 次操作为： 将所有字符为 \\(t_i\\) 的格子上的棋子向 \\(d_i\\) 方向移动，\\(d_i\\) 为 L 或 R，分别表示向左和向右。 若一个棋子被移出格子，该棋子消失。求最后存在的棋子数量。 \\(N,Q\\le 2\\times 10^5\\) 题解 注意到棋子间的相对顺序不会改变。所以最后存在的棋子一定是原来的一个区间。 可以通过二分求出该区间的左右端点。 时间复杂度 \\(O(N+Q\\log N)\\)。 代码 D - Modulo Operations 题意 有 \\(N\\) 个互不相同的数 \\(S_i\\)，以及一个数 \\(X\\)。你需要求出对于所有 \\(S_i\\) 的排列，\\(X\\) 依次对所有 \\(S_i\\) 取模后的值之和。对 \\(10^9+7\\) 取模。 \\(N\\le 200,S_i,X\\le 10^5\\) 题解 显然对最后结果有影响的是所有等于前缀最小值的位置。 将 \\(S_i\\) 从大到小排序，考虑钦定若干数作为前缀最小值，那么其他数就必须插入到后面，也就是说，第 \\(i\\) 个数若没有被钦定为前缀最小值，则方案数需要乘上 \\(N-i\\)。 于是就可以简单 DP 了。时间复杂度 \\(O(NX)\\)。 代码 E - Black or White 题意 有 \\(B\\) 个黑球和 \\(W\\) 个白球，不断执行以下操作： 等概率选择黑白两种颜色之一，若存在该颜色的球，则取走一个。 对于每个 \\(i=1,\\ldots,B+W\\)，求第 \\(i\\) 个取走的球是黑色的概率。 \\(B,W\\le 10^5\\) 题解 题目中的操作相当于两种颜色同时存在时黑白颜色各有 \\(\\frac{1}{2}\\) 的概率，只有一种颜色时只能取走该颜色的球。 求出 \\(f_i,g_i\\) 分别表示前 \\(i\\) 个球把所有白球或所有黑球取完的概率，那么第 \\(i\\) 个球是黑球的概率即为 \\(f_{i-1}+\\frac{1}{2}(1-f_{i-1}-g_{i-1})\\)。 考虑如何求 \\(f_i,g_i\\)。显然有递推式 \\[f_i=f_{i-1}+\\binom{i-1}{W-1}\\frac{1}{2^i}\\] \\(g_i\\) 类似。 时间复杂度 \\(O(N)\\)。 代码 F - More Realistic Manhattan Distance 题意 有 \\(N\\) 条水平单向道路和 \\(M\\) 条竖直单向道路，相邻两条道路距离为 \\(1\\)。道路与道路之间有 \\(NM\\) 个交点。每条道路的方向是给定的。 \\(Q\\) 次询问，每次给定两个点 \\((a,b),(c,d)\\)，求最短路。 \\(N,M\\le 10^5,Q\\le 2\\times 10^5\\) 题解 注意到 \\((a,b)\\) 右边第二条向下的路是没有用的，其他方向同理。 于是我们只需要保留 \\((a,b)\\) 上下左右各方向的第一条道路即可，\\((c,d)\\) 同理。 这样最多只有 \\(6\\) 条水平道路和 \\(6\\) 条竖直道路，最多有 \\(36\\) 个交点，\\(72\\) 条边。 直接跑堆优化 Dijkstra 即可。 时间复杂度 \\(O(N+M+Q)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"图论","slug":"图论","permalink":"https://autumnkite.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"二分","slug":"二分","permalink":"https://autumnkite.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"概率","slug":"概率","permalink":"https://autumnkite.github.io/tags/%E6%A6%82%E7%8E%87/"},{"name":"模拟","slug":"模拟","permalink":"https://autumnkite.github.io/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"最短路","slug":"最短路","permalink":"https://autumnkite.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"AtCoder Regular Contest 105 题解","slug":"atcoder-arc105","date":"2020-10-13T00:51:51.000Z","updated":"2021-05-29T10:26:33.971Z","comments":true,"path":"atcoder-arc105/","link":"","permalink":"https://autumnkite.github.io/atcoder-arc105/","excerpt":"比赛地址","text":"比赛地址 A - Fourtune Cookies 题意 给定四个整数 \\(A,B,C,D\\)，判断是否可以选择一个或更多个数使得这些数之和等于剩下的数之和。 题解 排序，只有 \\(A+D=B+C\\) 和 \\(A+B+C=D\\) 两种情况。 代码 B - MAX-=min 题意 有 \\(N\\) 个数 \\(a_i\\)，不断执行以下操作，直到所有数相等： 将所有等于最大值的数减去最小值。 求最后每个数的值。 \\(N\\le 10^5,a_i\\le 10^9\\) 题解 显然执行题目中的操作不会改变所有数的 gcd。 于是求出所有数的 gcd 即可。 时间复杂度 \\(O(N+\\log a_i)\\)。 代码 C - Camels and Bridge 题意 有 \\(N\\) 个球，第 \\(i\\) 个球的重量为 \\(w_i\\)。你可以将这些球按任意顺序在数轴上排列，相邻两个球的距离为任意非负实数。 你需要满足 \\(M\\) 个限制，第 \\(i\\) 个限制为数轴上任意长度为 \\(l_i\\) 的开区间（即不包含左右端点）中的球重量之和不超过 \\(k_i\\)。 求最右边的球与最左边的球的距离的最小值，或输出无解。 \\(N\\le 8,M\\le 10^5\\) 题解 枚举球的顺序，令 \\(x_i\\) 为确定顺序后从左到右第 \\(i\\) 个球的坐标，那么可以根据限制得到 \\(x_i\\) 之间的若干限制。 根据这些限制跑差分约束即可。注意到每条边只会从前往后连，所以可以直接从前往后 DP。 时间复杂度 \\(O(M\\log M+N!\\cdot N^2\\log M)\\)。 代码 D - Let's Play Nim 题意 有 \\(N\\) 个包，第 \\(i\\) 个包有 \\(a_i\\) 个金币。另外还有无限个空盘子。 A 和 B 玩游戏，A 先手，两人轮流操作，每次操作如下： 若存在一个包有金币，那么选择一个有金币的包，将这个包的所有金币放到任意一个盘子上； 若不存在包有金币，那么选择一个有金币的盘子，取走一个或更多个金币。 不能操作的人输。判断先手是否有必胜策略。 \\(N\\le 10^5,a_i\\le 10^9\\) 题解 发现包为空以后是一个 Nim 游戏。Nim 游戏先手必胜的条件是异或和大于 \\(0\\)。 若干个数的最大值若超过这些数总和的一半，那么异或和一定大于 \\(0\\)。这是因为异或的本质是不进位加法，由于最大值大于其他数的和，那么最大值一定大于其他数的异或和，所以总异或和一定不为 \\(0\\)。 当 \\(N\\) 为奇数时，最后的 Nim 游戏 B 是先手，而 B 需要使得最大值超过总和的一半很简单，只需要不断将金币最多的包放到金币最多的盘子上即可，可以证明一定满足条件。所以 \\(N\\) 为奇数时一定是 B 获胜。 当 \\(N\\) 为偶数时，最后的 Nim 游戏 A 是先手。A 为了使得最大值最大，一定是每次选最大值放到一个固定的盘子上。而 B 为了使得 A 选的数之和尽量小，每次也会选择最大值放到其他盘子中。 在这样的策略下，假设 \\(a\\) 从大到小排序，若存在 \\(a_{2i-1}&gt;a_{2i}\\)，那么 A 一定可以达到目标；否则 B 只要每次做与 A 类似的操作可以保证异或和一直为 \\(0\\)。 时间复杂度 \\(O(N\\log N)\\)。 代码 E - Keep Graph Disconnected 题意 有一个 \\(N\\) 个点 \\(M\\) 条边的无向图 \\(G\\)。定义一个图是好的当且仅当 \\(1\\) 和 \\(N\\) 不连通且没有自环和重边。保证一开始的 \\(G\\) 是好的。 A 和 B 玩游戏，A 先手，两人轮流操作，每次操作为在保证 \\(G\\) 是好的前提下加入一条边。 不能操作的人输。判断先手是否有必胜策略。 \\(N,M\\le 10^5\\) 题解 显然最后两个图一定是两个分别包含 \\(1\\) 和 \\(N\\) 的完全图组成的。令两个完全图的大小分别为 \\(A,B\\)，那么新加的边数为 \\(\\frac{N(N-1)}{2}-M-AB\\)。也就是说，最后获胜的人与 \\(AB\\) 的奇偶性有关。 当 \\(N\\) 为奇数时，\\(A\\) 和 \\(B\\) 必有一个是偶数，那么 \\(AB\\) 一定为偶数，只需要判断 \\(\\frac{N(N-1)}{2}-M\\) 的奇偶性即可确定胜者。 当 \\(N\\) 为偶数时，记 \\(x\\) 和 \\(y\\) 为一开始 \\(1\\) 和 \\(N\\) 所在连通块的大小。 若 \\(x\\) 和 \\(y\\) 奇偶性不同，那么其他连通块中大小为奇数的一定有奇数个，先手可以先将 \\(x\\) 和 \\(y\\) 操作成同奇或同偶，然后跟着后手操作即可。 否则，若先手需要的 \\(AB\\) 奇偶性与 \\(xy\\) 奇偶性不同，那么后手一定必胜，否则先手必胜。 时间复杂度 \\(O(N+M)\\)。 代码 F - Lights Out on Connected Graph 题意 注意以下题意相较于原题意有一步简单的转化。 给定一个 \\(N\\) 个点 \\(M\\) 条边的无向图 \\(G=(V,E)\\)。你可以选择 \\(E\\) 的一个子集 \\(E&#39;\\) 得到无向图 \\(G&#39;=(V,E&#39;)\\)。 求有多少 \\(G&#39;\\) 是连通二分图。对 \\(998244353\\) 取模。 \\(N\\le 17\\) 题解 不妨令一个二分图的权值为黑白染色方案数，即 \\(2^c\\)，其中 \\(c\\) 是连通块数。 于是我们可以求出 \\(g(S)\\) 表示点集为 \\(S\\) 时所有二分图的权值之和。 接下来我们考虑求出 \\(f(S)\\) 表示点集为 \\(S\\) 时所有连通二分图的权值之和。 考虑用所有二分图的权值之和减去不连通的二分图权值之和。令 \\(x\\) 为 \\(S\\) 中任意一个点。考虑枚举 \\(x\\) 所在的连通块 \\(T\\)，那么权值之和即为 \\(f(T)g(S-T)\\)。 时间复杂度 \\(O(2^NM+3^N)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"枚举","slug":"枚举","permalink":"https://autumnkite.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"博弈","slug":"博弈","permalink":"https://autumnkite.github.io/tags/%E5%8D%9A%E5%BC%88/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"差分约束","slug":"差分约束","permalink":"https://autumnkite.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"}]},{"title":"AtCoder Grand Contest 033 题解","slug":"atcoder-agc033","date":"2020-10-10T07:09:26.000Z","updated":"2021-05-29T10:26:33.965Z","comments":true,"path":"atcoder-agc033/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc033/","excerpt":"比赛地址","text":"比赛地址 A - Darker and Darker 题意 有一个 \\(H\\times W\\) 的网格，每个格子有黑白两种颜色。初始颜色是给定的。 你需要不断执行以下操作，直到所有格子全黑（保证一开始有黑色格子）： 对于每个和黑色格子有公共边的白色格子，变成黑色。 求操作次数。 \\(H,W\\le 1000\\) 题解 直接将所有黑色格子作为起点进行 BFS 即可。 时间复杂度 \\(O(NM)\\)。 代码 B - LRUD Game 题意 有一个 \\(H\\times W\\) 的网格，有一个棋子，一开始在 \\((s_r,s_c)\\)。 A 和 B 玩游戏，执行 \\(N\\) 次操作。A 和 B 每人有一个长度为 \\(N\\) 的字符串，分别为 \\(S,T\\)。第 \\(i\\) 次操作如下： 首先，A 进行游戏。A 可以选择将棋子按 \\(S_i\\) 的方向移动一格，或不移动； 然后，B 进行游戏。B 可以选择将棋子按 \\(T_i\\) 的方向移动一格，或不移动。 A 的目标是在某一次操作将棋子走出棋盘，B 的目标则相反。 判断两个人采取最优策略时棋子是否会在某一次操作走出棋盘。 \\(H,W,N\\le 2\\times 10^5\\) 题解 倒着考虑，维护不能走出棋盘的所有起点，可以发现这些起点一定是棋盘的一个子矩形。 倒着考虑时，每次 B 进行游戏会使该矩形的某一边界向外移动，而 A 进行游戏会使该矩形的某一边界向内移动。 注意矩形边界不能移出棋盘，并且若中途矩形变空，那么就再也不能向外移动了。 时间复杂度 \\(O(N)\\)。 代码 C - Removing Coins 题意 给定一个 \\(N\\) 个点的树，每个点上有一个棋子。 A 和 B 轮流进行以下操作，A 先手： 选定一个有棋子的节点 \\(v\\)，取走 \\(v\\) 上的所有棋子； 将剩余的所有棋子向靠近 \\(v\\) 的方向移动一条边。 不能操作的人输。 求两人采取最优策略时的胜者。 \\(N\\le 2\\times 10^5\\) 题解 注意到操作相当于选择一个节点作为根，然后将叶子结点删去。 考虑对于一次操作，若选择的不是度为 \\(1\\) 的点，那么直径会减小 \\(2\\)；否则直径要么减 \\(1\\)，要么减 \\(2\\)。 于是我们只要在状态里记录直径上的点数即可。 时间复杂度 \\(O(N)\\)。 代码 D - Complexity 题意 定义一个黑白网格的 complexity 为： 若网格全黑或全白，则为 \\(0\\)。 否则，我们用一条水平的直线或竖直的直线将网格分成两个子网格，令两个子网格的 complexity 分别为 \\(c_1,c_2\\)，则原网格的 complexity 为 \\(\\max(c_1,c_2)+1\\) 的最小值。 给定一个 \\(H\\times W\\) 的网格，求该网格的 complexity。 \\(H,W\\le 185\\) 题解 考虑有两个简单的性质： 一个 \\(H\\times W\\) 的网格的 complexity 不超过 \\(\\lceil\\log_2 H\\rceil+\\lceil\\log_2 W\\rceil\\)。 一个网格在最后加入一行或最右边加入一列，complexity 不小于原网格的 complexity. 于是我们设计状态 \\(f_{c,i,j,k}\\) 表示操作次数为 \\(c\\)，左上角为 \\((i,j)\\)，下边界为 \\(k\\) 时，右边界的最大值。\\(g_{c,i,j,k}\\) 同理表示操作次数为 \\(c\\)，左上角为 \\((i,j)\\)，右边界为 \\(k\\) 时，下边界的最大值。 根据第二个性质，我们可以直接用双指针优化转移。 时间复杂度 \\(O(HW(H+W)\\log HW)\\)。 代码 E - Go around a Circle 题意 有一个 \\(N\\) 个点的环，点编号 \\(1\\) 到 \\(N\\)。给定一个长度为 \\(M\\) 的只包含 R 和 B 的字符串 \\(S\\)，你需要给环上每条边填上 R 或 B，使得对于任意 \\(1\\le i\\le N\\)： 假设初始有一个棋子在第 \\(i\\) 个点。你可以执行 \\(M\\) 次操作，每次沿一条边将棋子走到一个相邻的点。你需要满足存在一种操作方案使得第 \\(j\\) 条经过的边上的字符等于 \\(S_j\\)。 求方案数。对 \\(10^9+7\\) 取模。 \\(N\\le 2\\times 10^5\\) 题解 不妨假设 \\(S\\) 的第一个字符为 R。显然环上不能有连续两个 B 出现。 那么我们考虑根据 B 将环分成若干个 R 的连续段。若 \\(S\\) 中的字符不全是 R，那么一定有每个 R 的极长连续段长度一定是奇数。这个可以用反证法证明。 另外，显然每段连续段还会有一个长度的限制。 这样我们就可以每次去掉开头的一段 RR..RRBB..BB，转化成一个类似的子问题。 注意「类似」是因为这个子问题的起点一定是每段 R 的两个端点，所以若该子问题开头的 R 的长度是偶数，该段 R 的长度并不会对环上每段 R 连续段的长度产生限制。 可以发现环上 R 的连续段只需要满足奇数和每个子问题产生的长度限制，就一定满足原问题中的限制。 于是直接 DP 即可。注意由于是环，可以把分界点取在最后一段的任意位置，所以最后统计答案时需要乘上最后一段的长度。显然这样做不会算重。 代码 F - Adding Edges 题意 给定一个 \\(N\\) 个点的树 \\(T\\) 和 \\(N\\) 个点 \\(M\\) 条边的图 \\(G\\)，你需要不断执行以下操作： 选择三个点 \\(a,b,c\\) 满足 \\(G\\) 中存在边 \\((a,b),(b,c)\\) 但不存在边 \\((a,c)\\)，若 \\(T\\) 中存在一条同时包含 \\(a,b,c\\)（任意顺序）的简单路径，则在 \\(G\\) 中加入边 \\((a,c)\\)。 求最终 \\(G\\) 的边数。可以证明最终的 \\(G\\) 唯一。 \\(N,M\\le 2000\\) 题解 若题目中的条件为 \\(a,b,c\\) 必须按该顺序排列，设原图为 \\(G_0\\)，那么 \\((x,y)\\in G\\) 当且仅当存在序列 \\(x=v_1,v_2,v_3,\\ldots,v_k=y\\)，满足 \\((v_i,v_{i+1})\\in G_0\\) 且 \\(v_1,v_2,\\ldots,v_k\\) 按顺序被包含在树上的某条简单路径上。证明较为简单，不再展开。 现在的问题是原题目中 \\(a,b,c\\) 可以按任意顺序排列。考虑对于三个点 \\(a,b,c\\)，若这三个点在树上按该顺序被包含在同一条简单路径上，且 \\((a,b),(a,c)\\in G_0\\)，那么我们可以把 \\((a,c)\\) 删去，加入 \\((b,c)\\) 而不影响答案。我们把这样的操作称为压缩。 若我们不断对原图进行压缩，直到不能被压缩，那么可以证明最终的图一定满足以上 \\(a,b,c\\) 必须按顺序排列时的性质。 那么问题是如何压缩。考虑依次加入边，我们记录 \\(top(a,b)\\) 表示 \\(T\\) 以 \\(a\\) 为根时，\\(b\\) 的祖先中离 \\(b\\) 最近且在由当前 \\(G_0\\) 生成的最终的 \\(G\\) 中与 \\(a\\) 有边的点。 假设当前加入边 \\((a,b)\\)，若有 \\(top(a,b)=b\\)，那么无需再加入。若 \\(top(a,b)\\) 存在，则我们可以转化成加入边 \\((top(a,b),b)\\)。 否则，我们加入边 \\((a,b)\\)，更新 \\(top(a,b)\\)。然后我们需要 DFS 更新以 \\(a\\) 为根时 \\(b\\) 子树内点 \\(v\\) 的 \\(top(a,v)\\) 值。 假设当前更新到了点 \\(v\\)，若 \\(top(a,v)\\) 存在，由于是从上往下更新的，一定有 \\(top(a,v)=v\\)。此时我们需要将 \\((a,v)\\) 压缩，即我们需要再更新完后递归调用加边操作加入边 \\((b,v)\\)。这种情况下我们不需要再更新子树的 \\(top\\) 值，可以直接退出。 否则，我们将 \\(top(a,v)\\) 更新为 \\(b\\)，继续更新子树。 压缩完后，我们只要从每个点开始 DFS 统计以这个点为边的一个端点的边的数量即可。 我们每次更新时，若 \\(top\\) 值不存在，我们会更新并继续递归；若存在则会压缩边。\\(top\\) 值一共只有 \\(N^2\\) 条，而边一共只有 \\(M\\) 条，每条最多被缩 \\(N\\) 次，所以时间复杂度为 \\(O(N^2+NM)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"图论","slug":"图论","permalink":"https://autumnkite.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"BFS","slug":"BFS","permalink":"https://autumnkite.github.io/tags/BFS/"},{"name":"博弈","slug":"博弈","permalink":"https://autumnkite.github.io/tags/%E5%8D%9A%E5%BC%88/"},{"name":"树的直径","slug":"树的直径","permalink":"https://autumnkite.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"双指针","slug":"双指针","permalink":"https://autumnkite.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"DFS","slug":"DFS","permalink":"https://autumnkite.github.io/tags/DFS/"}]},{"title":"AtCoder Grand Contest 034 题解","slug":"atcoder-agc034","date":"2020-10-07T12:54:05.000Z","updated":"2021-05-29T10:26:33.966Z","comments":true,"path":"atcoder-agc034/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc034/","excerpt":"比赛地址","text":"比赛地址 A - Kenken Race 题意 有 \\(N\\) 个方格从左到右排列，编号 \\(1\\) 到 \\(N\\)。有些位置上有障碍。 有两个不同的棋子，分别在格子 \\(A,B\\)。你可以执行以下操作若干次： 选择其中一个棋子，向右跳一格或两格，要求目标位置不是障碍且没有其他棋子。 判断是否可以使得最后两个棋子分别在 \\(C,D\\)。 \\(N\\le 2\\times 10^5,A&lt;B\\) 题解 若 \\(C&lt;D\\)，那么我们显然可以先跳第二个棋子使得两个棋子互不影响。 此时显然只需要 \\(A\\) 到 \\(B\\) 和 \\(C\\) 到 \\(D\\) 之间都没有连续两个障碍即可。 若 \\(C&gt;D\\)，此时我们需要让第二个棋子在某个位置停留，将第一个棋子跳到终点，再将第二个棋子跳到终点。 为了使第一个棋子顺利跳到终点，我们需要让第二个棋子停留的位置满足把该位置当做障碍后 \\(A\\) 到 \\(C\\) 之间仍然不存在连续两个障碍。 那么只需要满足 \\(B\\) 到 \\(D\\) 之间（包含 \\(B\\) 和 \\(D\\)）存在左右两边都是非障碍格子即可。 时间复杂度 \\(O(N)\\)。 代码 B - ABC 题意 给定一个字符串 \\(S\\)，只包含 A，B 和 C。 你可以执行若干次以下操作： 选择一个 \\(s\\) 的一个等于 ABC 的子串，替换为 BCA。 求最多执行的操作次数。 \\(|S|\\le 2\\times 10^5\\) 题解 考虑对于一段 AA..AABC，假设 A 有 \\(c\\) 个，那么可以操作 \\(c\\) 次使得这一部分变为 BCAA..AA。 于是我们从前往后，有这样一段就操作。这样做一定是最优的，因为 A 仍然连续并且到了后面，可能会与后面的 AA..AABC 组成一个更长的段。 时间复杂度 \\(O(N)\\)。 代码 C - Tests 题意 A 和 B 参加 \\(N\\) 场考试。对于第 \\(i\\) 场考试，A 可以规定一个 \\(l_i\\) 到 \\(u_i\\) 之间的整数 \\(c_i\\) 作为该考试的价值。 已知 B 第 \\(i\\) 场考试的分数为 \\(b_i\\)。假设 A 第 \\(i\\) 场考试的分数为 \\(a_i\\)，A 的目标是使得 \\(\\sum_{i=1}^{N}a_ic_i\\ge \\sum_{i=1}^{N}b_ic_i\\)。 A 可以花费一单位的时间来使得自己某场考试的分数加 \\(1\\)。已知考试的满分为 \\(X\\)，A 不能将已经满分的考试分数加 \\(1\\)。 求 A 达到目标最少花费的时间。 \\(N\\le 10^5\\) 题解 假设 \\(c_i\\) 已经确定，那么 A 一定是按 \\(c_i\\) 从大到小依次加，直到比 B 的总分高。那么显然按 \\(c_i\\) 从大到小排序后一定是一个前缀满分，一个后缀没分，只有中间一个有部分分。 注意到对于 \\(a_i &gt; b_i\\) 的考试，我们可以把 \\(c_i\\) 调整成 \\(u_i\\) 使得自己比 B 的优势更大；对于 \\(a_i &lt; b_i\\) 的考试，我们可以把 \\(c_i\\) 调整成 \\(l_i\\) 使得自己与 B 的差距更小。 于是我们可以强制对于第 \\(i\\) 场考试，分数小于等于 \\(b_i\\) 的部分按价值 \\(l_i\\) 计算，大于 \\(b_i\\) 的部分按价值 \\(u_i\\) 计算，那么 B 的分数即为 \\(S=\\sum_{i=1}^{N}b_il_i\\)。 考虑二分答案 \\(M\\)，枚举不是满分也不是零分的考试，该考试的分数是已知的；而满分的考试数量也唯一确定，所以只需要把剩余的考试按满分得到的价值 \\(b_il_i+(X-b_i)u_i\\) 从大到小排序后选取即可。 时间复杂度 \\(O(N\\log NX)\\)。 代码 D - Manhattan Max Matching 题意 在平面上有若干个红球和蓝球。有 \\(N\\) 个位置有红球，第 \\(i\\) 个位置为 \\((RX_i,RY_i)\\)，有 \\(RC_i\\) 个红球；有 \\(N\\) 个位置有蓝球，第 \\(i\\) 个位置为 \\((BX_i,BY_i)\\)，有 \\(BC_i\\) 个蓝球。保证 \\(\\sum RC_i=\\sum BC_i\\)，令该值为 \\(S\\)。 你需要将这 \\(S\\) 个红球和 \\(S\\) 个蓝球匹配，每个球最多被匹配一次。一对匹配的权值为这两个球的曼哈顿距离。 求每对匹配的权值之和的最大值。 \\(N\\le 1000,RC_i,BC_i\\le 10\\) 题解 考虑曼哈顿距离的式子，把两个绝对值分别拆开，共有 \\(4\\) 种状态，然后两个球的贡献独立。 因为最后求的是最大值，所以最终一定会取到两个都为正的情况。 对于一个匹配，若我们确定了红球的两个坐标的正负性，我们就可以唯一确定蓝球坐标的正负性。 于是可以建立费用流模型，源点向红球连流量为 \\(RC_i\\)，费用为 \\(0\\) 的边，限制数量；在红球与蓝球中间建立四个点表示四种状态，每个红球向四种状态连对应流量为无穷大，费用为对应贡献的边。蓝球同理。 直接跑费用流即可。貌似可以用模拟费用流做到更优的复杂度。 代码 E - Complete Compress 题意 给定一个 \\(N\\) 个点的树，有些节点上有一个棋子。每次可以执行以下操作： 选择两个有棋子且距离不小于 \\(2\\) 的点 \\(u,v\\)，在这两个点上各取一个棋子向靠近另一个点的方向移动一条边。 求使得所有棋子到同一个点的最少操作次数。 \\(N\\le 2000\\) 题解 枚举最后棋子到达的点 \\(t\\)，将 \\(t\\) 作为该树的根。 显然对于两个棋子，如果操作这两个棋子后其中一个深度变大了，那么一定不优。所以若合法，操作次数一定是所有棋子深度之和除以 \\(2\\)。接下来考虑如何判断合法。 对于 \\(i\\) 的子树，我们分别维护 \\(L_i\\) 和 \\(R_i\\) 表示对 \\(i\\) 的子树内的棋子执行若干次操作后，这些棋子到 \\(i\\) 的距离之和的最小值和最大值。那么可以取到的距离之和一定是在 \\([L_i,R_i]\\) 之间与 \\(L_i,R_i\\) 奇偶性相同的数。为方便描述，我们令 \\(C_i\\) 为 \\(i\\) 子树内棋子数量。 显然最大值为子树内的棋子到 \\(i\\) 的距离之和。考虑如何求出最小值。 我们先把每个子树内部的操作处理完，然后考虑子树之间的操作。假设每个儿子子树内的棋子到 \\(i\\) 的距离之和分别为 \\(d_1,d_2,\\ldots,d_k\\)。现在的操作相当于每次选两个 \\(d_j\\) 减 \\(1\\)。我们要使得最终的 \\(\\sum d_j\\) 最小。 令最大的 \\(d_j\\) 为 \\(d_{\\max}\\)，\\(S\\) 为所有 \\(d_j\\) 之和减去 \\(d_{\\max}\\) 的值。那么可以证明最终 \\(\\sum d_i\\) 的最小值为 \\(\\max(d_{\\max}-S,0)\\)。 令 \\(i\\) 的儿子 \\(v\\) 中 \\(R_v+C_v\\) 最大的为 \\(x\\)。若 \\(L_x+C_x\\) 小于等于除 \\(x\\) 以外儿子的 \\(R_v+C_v\\) 最大值，那么我们可以将除 \\(x\\) 以外的 \\(d_j\\) 置为 \\(R_v+C_v\\)，将 \\(x\\) 对应的 \\(d_j\\) 置为除 \\(x\\) 以外的 \\(R_v+C_v\\) 最大值，此时显然有 \\(d_{\\max}-S\\le 0\\)，所以最小值就是 \\(0\\)。 否则，无论 \\(d\\) 取何值，\\(x\\) 对应的 \\(d_j\\) 一定是 \\(d_{\\max}\\)，那么我们一定会将 \\(x\\) 取 \\(L_x+C_x\\)，其他儿子 \\(v\\) 取 \\(R_v+C_v\\)，这样才能使 \\(d_{\\max}-S\\) 最小。 综上，最小值即为 \\(\\max(L_x+C_x-((\\sum (R_v+C_v))-(R_x+C_x)),0)\\)。注意判断该值与最大值奇偶性不同的情况。 最后只需要判断根节点的最小值是否是 \\(0\\) 即可。 时间复杂度 \\(O(N^2)\\)。 代码 F - RNG and XOR 题意 有一个随机数生成器，可以生成 \\(0\\) 到 \\(2^N-1\\) 之间的整数，其中生成 \\(i\\) 的概率为 \\(\\frac{A_i}{S}\\)，其中 \\(S=\\sum A_i\\)。 有一个变量 \\(x\\)，初始为 \\(0\\)，每次会异或一个用上述随机数生成器生成的整数。 对于每个 \\(0\\le i &lt; 2^N\\)，求 \\(x\\) 第一次变成 \\(i\\) 的期望次数。对 \\(998244353\\) 取模。 \\(N\\le 18\\)。 题解 考虑倒着做，求 \\(i\\) 第一次得到 \\(0\\) 的期望次数，显然与原答案相等。那么有 \\[ f_i= \\begin{cases} 1+\\sum\\limits_{j=0}^{2^N-1}f_jp_{i\\oplus j} &amp; \\text{ if }i&gt;0 \\\\ 0 &amp; \\text{ if }i=0 \\end{cases} \\] 我们可以把上式写成卷积的形式： \\[(f_0,f_1,\\ldots,f_{2^N-1})\\oplus(p_0,p_1,\\ldots,p_{2^N-1})=(c,f_1-1,f_2-1,\\ldots,f_{2^N-1}-1)\\] 其中 \\(c\\) 是一个未知的常数。 注意到上式要满足条件，必须有 \\[\\left(\\sum_{i=0}^{2^N-1} f_i\\right)\\left(\\sum_{i=0}^{2^N-1} p_i\\right)=c+\\sum_{i=1}^{2^N-1}(f_i-1)\\] 所以有 \\(c=f_0+2^N-1\\)。那么上面的卷积式子可以写成 \\[(f_0,f_1,\\ldots,f_{2^N-1})\\oplus(p_0,p_1,\\ldots,p_{2^N-1})=(f_0+2^N-1,f_1-1,f_2-1,\\ldots,f_{2^N-1}-1)\\] 可以把 \\(p_0\\) 减 \\(1\\) 去掉等式右边的 \\(f_i\\)，即 \\[(f_0,f_1,\\ldots,f_{2^N-1})\\oplus(p_0-1,p_1,\\ldots,p_{2^N-1})=(2^N-1,-1,-1,\\ldots,-1)\\] 那么只要将 \\((2^N-1,-1,-1,\\ldots,-1)\\) 和 \\(p\\) 做 FWT 后对应位置做除法，再 IFWT 回去即可。 注意 \\((2^N-1,-1,-1,\\ldots,-1)\\) 和 \\(p\\) 做 FWT 后有且只有 \\(0\\) 位置的值为 \\(0\\)，不能直接做除法。可以先取任意数，最后根据 \\(f_0=0\\) 对所有数整体加即可。 时间复杂度 \\(O(2^N(N+\\log P))\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"网络流","slug":"网络流","permalink":"https://autumnkite.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"二分","slug":"二分","permalink":"https://autumnkite.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"费用流","slug":"费用流","permalink":"https://autumnkite.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"集合幂级数","slug":"集合幂级数","permalink":"https://autumnkite.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"},{"name":"FWT","slug":"FWT","permalink":"https://autumnkite.github.io/tags/FWT/"}]},{"title":"Tenka1 Programmer Contest 2019 题解","slug":"atcoder-tenka1-2019","date":"2020-09-26T08:29:01.000Z","updated":"2021-05-29T10:26:33.980Z","comments":true,"path":"atcoder-tenka1-2019/","link":"","permalink":"https://autumnkite.github.io/atcoder-tenka1-2019/","excerpt":"比赛地址","text":"比赛地址 C - Stones 题意 给定一个只由 . 和 # 组成的字符串 \\(S\\)，你可以修改若干字符使得不存在子串 #.。求最少修改次数。 \\(|S|\\le 2\\times 10^5\\) 题解 显然最后 \\(S\\) 一定是形如 ...### 的。求出前缀 # 的数量和后缀 . 的数量后枚举分界线计算即可。 时间复杂度 \\(O(|S|)\\)。 代码 D - Three Colors 题意 有 \\(N\\) 个整数 \\(A_i\\)，将每个数染成红、绿、蓝三种颜色，记红、绿、蓝的数之和分别为 \\(R,G,B\\)，求使得 \\(R,G,B\\) 能组成一个面积为正数的三角形的染色方案数。对 \\(998244353\\) 取模。 \\(N\\le 300,A_i\\le 300\\) 题解 令 \\(S\\) 为所有数之和，那么染色方案合法当且仅当 \\(R,G,B &lt; \\frac{S}{2}\\)。 考虑容斥，用背包计算方案数即可。 时间复杂度 \\(O(NS)\\)。 代码 E - Polynomial Divisors 题意 给定一个多项式 \\(f(x)=\\sum_{i=0}^{N}a_ix^i\\)，求出所有的质数 \\(p\\) 满足对于任意整数 \\(x\\)，都有 \\(p\\mid f(x)\\)。 \\(N\\le 10^4,a_i\\le 10^9\\) 题解 假设已经确定 \\(p\\)，考虑判断是否合法。根据费马小定理，当 \\(x\\not\\equiv 0\\pmod{p}\\) 时，有 \\(x^a\\equiv x^{a\\bmod (p-1)}\\pmod{p}\\)，那么我们可以将原多项式化为以下形式： \\[ f(x)=\\sum_{i=0}^{p-2}b_ix^i \\] 那么 \\(p\\) 合法的充要条件是对于所有 \\(0\\le i &lt; p-1\\)，有 \\(b_i\\equiv 0\\pmod{p}\\)。充分性显然，必要性证明如下： 因为对于所有 \\(0\\le x &lt; p\\)，都有 \\(f(x)\\equiv 0\\pmod{p}\\)，相当于给定了多项式的 \\(p\\) 个点值 \\((x,0)\\)。由于 \\(p\\) 个点值可以唯一确定一个小于 \\(p\\) 次的多项式，而显然这个多项式一定是所有系数全 \\(0\\) 的多项式，所以必然有 \\(b_i\\equiv 0\\pmod{p}\\)。 于是我们枚举所有 \\(N\\) 以内的质数和所有系数的 \\(\\gcd\\) 的质因子作为 \\(p\\) 进行判断即可。 时间复杂度 \\(O(N(\\pi(N)+\\log a_i))\\)，其中 \\(\\pi(N)\\) 表示 \\(N\\) 以内质数数量。 代码 F - Banned X 题意 求只包含 \\(0,1,2\\) 的，长度为 \\(N\\) 的，满足以下条件的序列数量： 不包含和为 \\(X\\) 的连续子序列。 对 \\(998244353\\) 取模。 \\(N\\le 3000\\) 题解 令 \\(f_{i,j}\\) 表示长度为 \\(i\\)，和为 \\(j\\) 的方案数。\\(j &lt; X\\) 可以直接转移，而 \\(j=X\\) 则一定为 \\(0\\)。接下来考虑 \\(j &gt; X\\) 的情况。 注意到此时因为总和大于 \\(X\\)，若我们对该序列作前缀和，那么一定存在相邻两个前缀和分别为 \\(X-1\\) 和 \\(X+1\\)，假设位置为 \\(k\\) 和 \\(k+1\\)。此时第一个数和第 \\(k+1\\) 个数一定是 \\(2\\)，所以第 \\(2\\) 个数和第 \\(k+2\\) 个数也一定是 \\(2\\)……我们可以推出 \\(k+1\\) 到 \\(n\\) 和 \\(1\\) 到 \\(n-k\\) 这些数都是 \\(2\\)。 那么有 \\(2(n-k)=j-(X-1)\\)，我们可以唯一确定这个 \\(k\\)。于是就可以确定中间未填部分的长度与和，直接转移即可。 时间复杂度 \\(O(N^2)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"diverta 2019 Programming Contest 题解","slug":"atcoder-diverta2019","date":"2020-09-26T03:39:29.000Z","updated":"2021-05-29T10:26:33.975Z","comments":true,"path":"atcoder-diverta2019/","link":"","permalink":"https://autumnkite.github.io/atcoder-diverta2019/","excerpt":"比赛地址","text":"比赛地址 A - Consecutive Integers 题意 求在 \\(1\\) 到 \\(N\\) 的整数中选择连续的 \\(K\\) 个整数的方案数。 \\(N\\le 50\\) 题解 显然答案为 \\(N-K+1\\)。 代码 B - RGB Boxes 题意 求有多少非负整数三元组 \\((r,g,b)\\) 满足 \\[Rr+Gg+Bb=N\\] \\(N\\le 3000\\) 题解 枚举其中两个即可。 时间复杂度 \\(O(N^2)\\)。 代码 C - AB Substrings 题意 给定 \\(N\\) 个字符串 \\(s_i\\)，将这些字符串按任意顺序拼接，求 AB 作为子串的出现次数的最大值。 \\(N\\le 10^4,|s_i|\\le 10\\) 题解 先将每个字符串中间的 AB 计入贡献，那么剩余的字符串可以分为 xxx、xxA、Bxx、BxA 四种。 那么一定是用所有 BxA 和至多一个 xxA 和 Bxx 拼出 xxABxABxA...BxABxx 这样的字符串，再用剩下的 xxA 和 Bxx 拼 xxABxx 这样的字符串。 注意细节。 代码 D - DivRem Number 题意 给定正整数 \\(N\\)，求有多少正整数 \\(m\\) 满足 \\(\\lfloor\\frac{N}{m}\\rfloor=N\\bmod m\\)。 \\(N\\le 10^{12}\\) 题解 化一下式子，得到 \\(\\lfloor\\frac{N}{m}\\rfloor(m+1)=N\\)。那么 \\(m+1\\) 一定是 \\(N\\) 的因数，枚举即可。 时间复杂度 \\(O(\\sqrt{N})\\)。 代码 E - XOR Partitioning 题意 给定序列 \\(A_1,A_2,\\ldots,A_N\\)，将该序列划分成若干段，使得每段的异或和相等，求方案数。对 \\(10^9+7\\) 取模。 \\(N\\le 5\\times 10^5\\) 题解 对原序列作前缀和 \\(S_i\\)，假设每段的异或和为 \\(x\\)，那么一个合法的划分方案一定是选择 \\(S\\) 中一个 \\(x\\) 和 \\(0\\) 交替的子序列。 考虑枚举 \\(x\\)，然后 DP。令 \\(f_i\\) 表示前 \\(i\\) 个数，强制 \\(i\\) 选择且 \\(S_i=x\\) 时合法方案数。那么有 \\[f_i=1+\\sum_{j=0}^{i-1} f_j(c_i-c_j)\\] 其中 \\(c_i\\) 表示 \\(S_1,S_2,\\ldots,S_i\\) 中 \\(0\\) 的数量。 最终答案与段数的奇偶性有关，段数为奇数时为 \\(f_N\\)，段数为偶数时为所有 \\(f_i\\) 的和。段数的奇偶性可以通过 \\(S_N\\) 是否等于 \\(0\\) 确定。 用前缀和优化 DP 转移，时间复杂度 \\(O(N)\\)。注意特判 \\(x=0\\) 的情况。 代码 F - Edge Ordering 题意 给定一个 \\(N\\) 个点 \\(M\\) 条边的简单无向连通图 \\(G\\)，保证前 \\(N-1\\) 条边构成了 \\(G\\) 的一个生成树。 你需要给每条边确定一个 \\(1\\) 到 \\(M\\) 的整数边权，需要保证边权互不相同。 对于一个确定边权的方案，我们称该方案是好的当且仅当前 \\(N-1\\) 条边构成的生成树是最小生成树。 求所有好的方案的最小生成树边权和之和。对 \\(10^9+7\\) 取模。 \\(N\\le 20\\) 题解 假设原图如下图（重绘自官方题解）： 其中边上的数字为边的编号，黑边为树边，红边为非树边。 我们假设前 \\(N-1\\) 条边的边权按 \\(1\\) 到 \\(N-1\\) 的顺序递增，例如上图中有 \\(cost(1) &lt; cost(2) &lt; \\ldots &lt; cost(5)\\)。为了使这五条边成为最小生成树，我们需要保证其余非树边 \\((u,v)\\) 的边权需要大于树上 \\(u\\) 到 \\(v\\) 路径上最大的边权。例如图中 \\(cost(7) &gt; cost(3),cost(9) &gt; cost(4)\\)。 我们可以根据边权的大小关系建出一个拓扑关系图，例如上图对应的拓扑图如下图所示（来自官方题解）： 令 \\(a_i\\ (1\\le i\\le N-1)\\) 表示上图中 \\(i\\) 向下的连边数量，即点 \\(i\\) 向编号大于 \\(N-1\\) 的点的连边数量。 那么我们可以把问题转化为，有 \\(M\\) 个有标号的球，你有一个空的序列 \\(S\\)，球会按 \\(a_{N-1}\\) 个白球，一个黑球，\\(a_{N-2}\\) 个白球，一个黑球……这样的顺序给你，例如上图对应的球的序列为 \\(8,5,9,6,4,7,3,2,1\\)。每收到一个球，你可以执行以下操作： 若收到的球是黑球，则在 \\(S\\) 的最前面插入该球。 若收到的球是白球，则插入到 \\(S\\) 的任意位置。 求最终得到的所有 \\(S\\) 序列中黑球的位置编号和之和。 考虑在依次收到球的过程中，维护 \\(n\\) 表示当前序列 \\(S\\) 的长度，\\(b\\) 表示 \\(S\\) 中黑球的数量，\\(c\\) 表示不同的序列 \\(S\\) 的数量，\\(s\\) 表示所有序列 \\(S\\) 中黑球的位置编号之和的和。用 \\((n,b,c,s)\\) 表示当前的状态。 若收到一个黑球，那么新的状态为 \\((n+1,b+1,c,s+(b+1)c)\\)。 若收到一个白球，假设原来的序列中黑球的位置为 \\(p_1,p_2,\\ldots,p_b\\)，不妨假设 \\(p_0=0,p_{b+1}=n+1\\)，那么插入该白球时的总变化量（即每个位置的贡献之和）为 \\[ \\sum_{i=1}^{b+1}(p_i-p_{i-1})(b-i+1)=\\sum_{i=1}^{b}p_i \\] 所以新的状态为 \\((n+1,b,(n+1)c,(n+1)s+s)\\)，即 \\((n+1,b,(n+1)c,(n+2)s)\\)。 那么加入 \\(k\\) 个白球后新的状态为 \\((n+k,b,\\frac{(n+k)!}{n!}c,\\frac{(n+k+1)!}{(n+1)!}s)\\)。 对于原来的问题，我们并没有固定前 \\(N-1\\) 条边边权的大小关系，所以需要 DP。考虑到上面的问题是按边权从大到小进行转移的，那么这里的 DP 也从大到小确定边权的大小关系。 令 \\(f_S=(n,b,c,s)\\)，\\(S\\) 表示该集合中边权的大小关系仍未确定，不在该集合中的边的边权都大于在该集合中的边的边权。\\(n,b,c,s\\) 的定义与之前类似。转移只需要枚举下一条边，\\(c,s\\) 的转移与上面问题类似。 实现精细可以做到 \\(O(2^NN)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"枚举","slug":"枚举","permalink":"https://autumnkite.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"图论","slug":"图论","permalink":"https://autumnkite.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数论","slug":"数论","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"状压DP","slug":"状压DP","permalink":"https://autumnkite.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"}]},{"title":"AtCoder Grand Contest 035 题解","slug":"atcoder-agc035","date":"2020-09-25T03:38:37.000Z","updated":"2021-05-29T10:26:33.967Z","comments":true,"path":"atcoder-agc035/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc035/","excerpt":"比赛地址","text":"比赛地址 A - XOR Circle 题意 给定 \\(N\\) 个非负整数 \\(a_1,a_2,\\ldots,a_N\\)，判断是否可以将这 \\(N\\) 个数放入一个环中，使得每个数左右两边数的异或值等于该数。 \\(N\\le 10^5,a_i\\le 10^9\\) 题解 条件相当于连续三个数异或和等于 \\(0\\)。假设最后环上的数按顺序为 \\(b_0,b_1,\\ldots,b_{n-1}\\)，那么一个必要条件是 \\(b_i=b_{(i+3)\\bmod n}\\)。 当 \\(3\\nmid n\\) 时，该条件相当于所有数相等。又因为需要连续三个数异或和为 \\(0\\)，那么所有数必须都是 \\(0\\)。 当 \\(3\\mid n\\) 时，我们需要将所有数分成 \\(3\\) 组，每组有 \\(\\frac{n}{3}\\) 个数且都相等。同时为了满足连续三个数异或和为 \\(0\\)，这三组中各取一个数的异或和需要等于 \\(0\\)。直接判断即可。 时间复杂度 \\(O(n)\\) 或 \\(O(n\\log n)\\)。 代码 B - Even Degrees 题意 有一张 \\(N\\) 个点 \\(M\\) 条边的简单无向连通图，你需要给每条边定向，使得每个点的出度为偶数。构造一组方案，或输出无解。 \\(N,M\\le 10^5\\) 题解 当 \\(M\\) 是奇数时一定无解，\\(M\\) 是偶数时可以通过构造证明一定有解。 当图是一棵树时，我们只需要从叶子向上依次确定边的方向即可。 对于原问题，我们只需要任意取出一棵生成树，任意确定非树边的方向，再用类似树的方法确定树边的方向即可。 时间复杂度 \\(O(N+M)\\)。 代码 C - Skolem XOR Tree 题意 有 \\(2N\\) 个点，第 \\(i\\ (1\\le i\\le N)\\) 个点和第 \\(N+i\\) 个点的点权为 \\(i\\)。 将这 \\(2N\\) 个点连成一棵树，使得： 对于所有 \\(1\\le i\\le N\\)，\\(i\\) 和 \\(i+N\\) 路径上点权的异或和为 \\(i\\)（包括两个端点）。 \\(N\\le 10^5\\) 题解 当 \\(N=2^k\\) 时一定无解，因为除去 \\(N\\) 和 \\(2N\\) 两个点其他点权最高位都小于 \\(k\\)，不可能使得异或和为 \\(2^k\\)。 注意到 \\(2i\\) 和 \\(2i+1\\) 的异或值为 \\(1\\)。当 \\(N\\) 是奇数时，我们可以以节点 \\(1\\) 为中心构造一条链，每次将点权为 \\(2i\\) 和 \\(2i+1\\) 的点对分别放在两边。例如 \\(N=5\\) 时我们可以构造 \\[4-5-2-3-1-2-3-4-5\\] 然后将另一个点权为 \\(1\\) 的点连在第一对点对上即可，例如上面的例子中连在右边的 \\(3\\) 上即可。 当 \\(N\\) 是偶数时，我们一定可以找到一个 \\(x,y\\ (2\\le x,y &lt; N)\\) 使得 \\(N=x\\oplus y\\)。那么我们只要强制链的一边 \\(x,y\\) 有连边即可，例如 \\(N=6,x=2,y=4\\) 时，可以构造 \\[4-5-3-2-1-3-2-4-5\\] 然后将两个 \\(6\\) 分别连在右边的 \\(2\\) 和 \\(4\\) 上即可。 代码 D - Add and Remove 题意 有 \\(N\\) 张卡片，从左到右分别写着数字 \\(A_1,A_2,\\ldots,A_N\\)。执行以下操作若干次直到卡片数量为 \\(2\\)： 选择连续三张卡片 \\(x,y,z\\)； 将 \\(A_x\\) 和 \\(A_z\\) 各加上 \\(A_y\\)，然后删去第 \\(y\\) 张卡片。 求最后两张卡片上的数字之和的最小值。 \\(N\\le 18\\) 题解 考虑倒着做，令 \\(f_{l,r,x,y}\\) 表示只考虑 \\([l,r]\\) 中的卡片，其中 \\(l\\) 最后会对答案产生 \\(x\\) 倍的贡献，\\(r\\) 最后会对答案产生 \\(y\\) 倍的贡献时的最小值（不计入卡片 \\(l,r\\) 上原来的数的贡献）。那么有 \\[ f_{l,r,x,y}=\\min_{l &lt; k &lt; r} f_{l,k,x,x+y}+f_{k,r,x+y,y}+A_k(x+y) \\] 可以证明状态数为 \\(O(2^n\\operatorname{poly}(n))\\)。 时间复杂度 \\(O(2^n\\operatorname{poly}(n))\\)。 代码 E - Develop 题意 有一个集合 \\(S\\)，初始为所有整数。每次可以执行以下操作： 选择一个 \\(1\\) 到 \\(N\\) 且在 \\(S\\) 中的整数 \\(x\\)，在 \\(S\\) 中删除 \\(x\\)； 在 \\(S\\) 中加入 \\(x-2\\) 和 \\(x+K\\)。已经存在则不加入。 求通过若干次（可以是 \\(0\\) 次）操作可以得到的不同的集合数量。对 \\(M\\) 取模。 \\(N\\le 150\\) 题解 考虑 \\(x\\) 向 \\(x-2\\) 和 \\(x+K\\) 连有向边。我们可以将最终集合的数量转化为删去的数组成的集合的数量。显然一个环中的数不能都被删去，而删去的数构成的子图若不存在环那么一定合法。 当 \\(K\\) 为偶数时，图的形态如下图所示（图中 \\(N=11,K=6\\)）： 这相当于对于每一条链，不能连续选择超过 \\(\\frac{K}{2}\\) 个点，对每条链分别 DP 即可。 当 \\(K\\) 为奇数时，图的形态如下图所示（图中 \\(N=12,K=3\\)）： 图中的一个环一定是从左边的某个点向上，到某个点往右，然后再往上，最后回到原点。即在上图中形如一个三角形或一个八字形。 注意图中的每个简单环长度都为 \\(K+2\\)，那么相当于不能存在一条向上、向右、再向上的，长度为 \\(K+2\\) 的路径。 于是可以 DP，令 \\(f_{i,j,k}\\) 表示到图中的第 \\(i\\) 层，从第 \\(i\\) 层左侧点开始的向上、向右、再向上的最长的路径长度为 \\(j\\)，从右侧点向上的最长路径长度为 \\(k\\) 时的方案数。 注意当上一层的 \\(j\\) 为 \\(0\\) 且这一层右侧点没有选择时，这一层的 \\(j\\) 仍然是 \\(0\\)，因为要形成环必须要有一条向右的边。 时间复杂度 \\(O(N^3)\\)。 代码 F - Two Histograms 题意 有一个 \\(N\\times M\\) 的网格，初始都为 \\(0\\)。你需要执行一次以下操作： 对于每个 \\(1\\le i\\le N\\)，选择一个 \\(0\\le k_i\\le M\\)，将第 \\(i\\) 行的前 \\(k_i\\) 个格子中的数加 \\(1\\)。 对于每个 \\(1\\le j\\le M\\)，选择一个 \\(0\\le l_j\\le N\\)，将第 \\(i\\) 列的前 \\(l_j\\) 个格子中的数加 \\(1\\)。 求最后能得到多少本质不同的网格。对 \\(998244353\\) 取模。 \\(N,M\\le 5\\times 10^5\\) 题解 注意到对于一个 \\(\\{k_i\\},\\{l_j\\}\\)，若存在 \\(i,j\\) 满足 \\(k_i=j-1,l_j=i\\)，那么我们可以把 \\(k_i\\) 加 \\(1\\)，\\(l_j\\) 减 \\(1\\) 而不改变矩阵。由于每次改变会使 \\(k\\) 的总和增加，所以改变次数一定是有限的。我们称不存在这样 \\(i,j\\) 的 \\(\\{k_i\\},\\{l_j\\}\\) 为标准形式。 接下来我们证明一个合法的网格一定对应唯一的一个标准形式。 假设一个网格对应两个不同的标准形式，分别为 \\(\\{k_i\\},\\{l_j\\}\\) 和 \\(\\{k_i&#39;\\},\\{l_j&#39;\\}\\)。令 \\(j\\) 为第一个满足 \\(l_j\\ne l_j&#39;\\) 的位置。 不妨假设 \\(l_j &lt; l_j&#39;\\)。若 \\(j=1\\)，那么网格的第 \\(l_1&#39;\\) 行第 \\(1\\) 列一定为 \\(1\\)，所以有 \\(k_{l_1&#39;}&#39;=0\\)，与 \\(\\{k_i&#39;\\},\\{l_j&#39;\\}\\) 是标准形式矛盾。 若 \\(j&gt;1\\)，那么网格的第 \\(l_j&#39;\\) 行第 \\(j\\) 列一定为 \\(1\\)，所以有 \\(k_{l_j&#39;}\\ge j,k_{l_j&#39;}&#39; &lt; j\\)。又因为 \\(k_{l_j&#39;}&#39;\\ne j-1\\)，所以 \\(k_{l_j&#39;}&#39; &lt; j-1 &lt; k_{l_j&#39;}\\)，又因为 \\(l_{j-1}=l_{j-1}&#39;\\)，网格的第 \\(l_j&#39;\\) 行第 \\(j-1\\) 列一定不同，矛盾。 于是接下来我们只要统计不存在 \\(i,j\\) 满足 \\(k_i=j-1,l_j=i\\) 的 \\(\\{k_i\\},\\{l_j\\}\\) 的序列数量。考虑容斥，强制若干对 \\(i,j\\) 满足该条件，容斥式子为 \\[ \\sum_{i=0}^{\\min(n,m)}(-1)^i\\binom{n}{i}\\binom{m}{i}i!(m+1)^{n-i}(n+1)^{m-i} \\] 直接计算即可。 时间复杂度 \\(O(n)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"容斥原理","slug":"容斥原理","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"}]},{"title":"AtCoder Grand Contest 036 题解","slug":"atcoder-agc036","date":"2020-09-24T03:42:13.000Z","updated":"2021-05-29T10:26:33.967Z","comments":true,"path":"atcoder-agc036/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc036/","excerpt":"比赛地址","text":"比赛地址 A - Triangle 题意 构造三角形满足： 顶点坐标为整数，且在 \\(0\\) 到 \\(10^9\\) 之间。 面积为 \\(\\frac{S}{2}\\)。 \\(S\\le 10^{18}\\) 题解 可以令其中一个点 \\(A\\) 在原点，另外两点分别在 \\(B(x_1,y_1)\\) 和 \\(C(x_2,y_2)\\)，不妨令 \\(C\\) 在 \\(B\\) 的逆时针方向，那么有 \\[\\overrightarrow{AB}\\times \\overrightarrow{AC}=S\\] 其中 \\(\\times\\) 表示向量的叉积。代入 \\(x_1,y_1,x_2,y_2\\) 得到 \\[x_1y_2-x_2y_1=S\\] 我们可以将 \\(S\\) 表示成 \\(10^9a-b\\) 的形式，其中 \\(0\\le a,b\\le 10^9\\)。于是令 \\(x_1=10^9,y_2=a,x_2=1,y_1=b\\) 即可。 代码 B - Do Not Duplicate 题意 给定一个序列 \\(A_0,A_1,\\ldots,A_{N-1}\\)，将该序列复制 \\(K\\) 份得到序列 \\(X_0,X_1,\\ldots,X_{NK-1}\\)。 有一个初始为空的序列 \\(s\\)，按 \\(i\\) 从 \\(0\\) 到 \\(NK-1\\) 的顺序，依次执行以下操作： 若 \\(s\\) 中不包含 \\(X_i\\)，则在 \\(s\\) 的末尾加入 \\(X_i\\)。 否则，则不断删去 \\(s\\) 的末尾元素，直到 \\(s\\) 中不包含 \\(X_i\\)。此时不加入 \\(X_i\\)。 求最终得到的序列 \\(s\\)。 \\(N\\le 2\\times 10^5,K\\le 10^{12}\\) 题解 假设我们现在需要加入 \\(X_p,\\ldots,X_{NK-1}\\)，且 \\(s\\) 序列当前为空。我们令 \\(q\\) 为第一个满足 \\(X_q=X_p\\) 且 \\(q &gt; p\\) 的数。 若 \\(q\\) 存在，那么在加入 \\(X_q\\) 时一定会把 \\(s\\) 序列清空，所以我们可以直接递归操作 \\(X_{q+1},\\ldots,X_{NK-1}\\)，即执行 \\(p\\gets q+1\\)。 否则若 \\(p\\) 不存在，由于 \\(X\\) 是 \\(N\\) 个数复制若干份得到的，那么剩余部分的长度一定不超过 \\(N\\)，直接暴力模拟即可。 于是我们只要处理第一部分不断跳 \\(p\\) 的过程。注意到 \\(p\\bmod N\\) 的值会形成一个环，每次跳一步 \\(K\\) 可能会减少 \\(0,1,2\\)，这只需要将 \\(K\\) 对每次跳一个环会减少的值取模，最后再在环上跳若干步即可。 时间复杂度 \\(O(N+\\max A_i)\\) 或 \\(O(N\\log N)\\)。 代码 C - GP 2 题意 有一个长度为 \\(N\\) 个序列 \\(x_0,x_1,\\ldots,x_{N-1}\\)，初始都为 \\(0\\)。你需要求执行恰好 \\(M\\) 次以下操作后能得到多少不同的序列： 选择两个整数 \\(i,j\\ (0\\le i,j &lt; N,i\\ne j)\\)，将 \\(x_i\\) 加 \\(2\\)，将 \\(x_j\\) 加 \\(1\\)。 对 \\(998244353\\) 取模。 \\(N\\le 10^6,M\\le 5\\times 10^5\\) 题解 一个序列合法的充要条件是： \\(\\forall 0\\le i &lt; N,0\\le x_i\\le 2M\\) \\(\\sum\\limits_{i=0}^{N-1}x_i=3M\\) \\(x_i\\) 是奇数的 \\(i\\) 的数量不超过 \\(M\\)。 必要性显然，充分性可以考虑归纳证明，不再展开。 于是我们可以枚举奇数的数量 \\(d\\)，将所有奇数都减 \\(1\\)，再将所有数除以 \\(2\\)，就变成了一个经典的求不定方程整数解数量的问题。即，\\(N\\) 个整数变量，和为 \\(\\frac{3M-d}{2}\\)，其中 \\(d\\) 个变量的范围为 \\(0\\le x_i &lt; M\\)，\\(N-d\\) 个变量范围为 \\(0\\le x_i \\le M\\)。可以套用经典的容斥和隔板法的解法，即枚举哪些变量不满足上界的限制，可以得到答案为 \\[ \\sum_{i=0}^{d}\\sum_{j=0}^{n-d}(-1)^{i+j}\\binom{d}{i}\\binom{n-d}{j}\\binom{\\frac{3M-d}{2}-iM-j(M+1)+N-1}{N-1} \\] 由于 \\(i,j\\) 需要满足 \\(iM+j(M+1)\\le \\frac{3M-d}{2}\\)，合法的 \\(i,j\\) 只有常数个，所以总时间复杂度为 \\(O(N+M)\\)。 代码 D - Negative Cycle 题意 有一张 \\(N\\) 个点的图，边的状态为： 对于所有 \\(0\\le i &lt; N-1\\)，\\(i\\) 向 \\(i+1\\) 有一条边权为 \\(0\\) 的不可被删除的有向边。 对于所有 \\(0\\le i &lt; j &lt; N\\)，\\(i\\) 向 \\(j\\) 有一条边权为 \\(-1\\) 的可以用 \\(A_{i,j}\\) 的代价删除的有向边。 对于所有 \\(0\\le j &lt; i &lt; N\\)，\\(i\\) 向 \\(j\\) 有一条边权为 \\(1\\) 的可以用 \\(A_{i,j}\\) 的代价删除的有向边。 求使得图没有负环（即边权和为负数的环）的最小代价。 \\(N\\le 500\\) 题解 首先我们可以把问题转化为一个差分约束的模型，即有 \\(N\\) 个变量，需要满足以下限制： \\(\\forall 0\\le i &lt; N-1, x_i\\ge x_{i+1}\\) \\(\\forall 0\\le i &lt; j &lt; N, x_j-x_i\\le -1\\) \\(\\forall 0\\le j &lt; i &lt; N, x_j-x_i\\le 1\\) 我们需要删除后面两种限制中的一些限制使得问题有解。 满足第一条限制的 \\(x\\) 一定是 \\(d,d,\\ldots,d,d-1,\\ldots,d-1,d-2,\\ldots,d-2,\\ldots\\) 的形式。\\(x\\) 相同的连续段中两两之间的 \\(-1\\) 的边需要删去，而 \\(x\\) 相差超过 \\(1\\) 的两个连续段之间的 \\(+1\\) 边都需要删去。 考虑 DP，用 \\(f_{i,j}\\) 表示最后一段相同的连续段为 \\((j,i]\\) 时最少所需代价，转移时枚举下一段的结尾，用二维前缀和优化计算代价即可。 时间复杂度 \\(O(N^3)\\)。 代码 E - ABC String 题意 有一个只包含 A、B、C 的字符串 \\(S\\)，求出 \\(S\\) 的一个最长的子序列 \\(x\\) 满足： 相邻两个字符不同； A、B、C 出现次数相同。 构造一个方案。 \\(|S|\\le 10^6\\) 题解 首先可以把极长的相同字符的连续段缩成一个字符。 设 A,B,C 数量为 \\(cnt_A,cnt_B,cnt_C\\)，不妨假设 \\(cnt_A\\le cnt_B\\le cnt_C\\)。 由于最后需要使得 \\(cnt_A=cnt_B=cnt_C\\)，我们先尽量删 C 使得 \\(cnt_C=cnt_B\\)。 考虑贪心地删，那么一定是优先删除两边字符不同的 C，这样一定对答案没有影响。 若删完这些 C 后，仍然 \\(cnt_C &gt; cnt_B\\)，那么考虑两边字符相同的情况。若两边字符是 B，那么删除 C 会连带删除一个 B，不会对 \\(cnt_C-cnt_B\\) 产生影响；若两边字符是 A，则删除 C 会连带删除一个 A。 若删完后仍然 \\(cnt_C &gt; cnt_B\\)，那么一定无解。否则现在有 \\(cnt_C=cnt_B\\ge cnt_A\\)。我们需要同时删除 B 和 C 使得 \\(cnt_A=cnt_B=cnt_C\\)。 注意到一个连续的 BC 或 CB 若两边不同时是 A，那么一定可以删除。发现将可以删除的 BC 或 CB 删除后一定会变成形如 ABCACBABCABCA 的形式，一定有 \\(cnt_A &gt; cnt_B\\)，所以在中间删除的过程中一定会有一个时刻使得 \\(cnt_A=cnt_B=cnt_C\\)。 可以用链表维护，也可以每次删除后重构，时间复杂度 \\(O(|S|)\\)。 代码 F - Square Constraints 题意 求满足以下条件的 \\(0\\) 到 \\(2N-1\\) 的排列 \\(P_0,P_1,\\ldots,P_{2N-1}\\) 的数量： \\(\\forall 0\\le i &lt; 2N,N^2\\le i^2+P_i^2\\le (2N)^2\\) 对给定的模数 \\(M\\) 取模，不一定为质数。 \\(N\\le 250,M\\le 10^9\\) 题解 注意到题目相当于对排列的每个位置有一个 \\((l_i,r_i]\\) 的限制。 没有 \\(l_i\\) 的限制时，我们只需要按 \\(r_i\\) 从小到大填数即可。 有 \\(l_i\\) 的限制时，考虑容斥。注意到后 \\(N\\) 个位置的 \\(l_i=0\\)，可以不考虑。将前 \\(N\\) 个数的 \\(l_i,r_i\\) 和后 \\(N\\) 个位置的 \\(r_i\\) 共 \\(3N\\) 个数从小到大排序，注意到最后 \\(N\\) 个数一定是前 \\(N\\) 个数的 \\(r_i\\)，且一定是 \\(r_{N-1},r_{N-2},\\ldots,r_0\\)。 那么考虑枚举强制小于等于 \\(l_i\\) 的数的数量 \\(k\\)，那么前 \\(2N\\) 个数共选择了 \\(N+k\\) 个数。这个个数是确定的，于是可以 DP。 令 \\(f_{i,j}\\) 表示前 \\(i\\) 个数中，有 \\(j\\) 个数强制不合法时的方案数。 若当前数是后 \\(N\\) 个位置的上界，那么直接乘上贡献即可。 否则考虑该数是否强制不合法，两种情况都可以方便地计算贡献。 具体贡献式子可以参考代码。时间复杂度 \\(O(N^3)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"图论","slug":"图论","permalink":"https://autumnkite.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"计算几何","slug":"计算几何","permalink":"https://autumnkite.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"差分约束","slug":"差分约束","permalink":"https://autumnkite.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"模拟","slug":"模拟","permalink":"https://autumnkite.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"M-SOLUTIONS Programming Contest 题解","slug":"atcoder-m-solutions2019","date":"2020-09-23T05:30:20.000Z","updated":"2021-05-29T10:26:33.979Z","comments":true,"path":"atcoder-m-solutions2019/","link":"","permalink":"https://autumnkite.github.io/atcoder-m-solutions2019/","excerpt":"比赛地址","text":"比赛地址 AB 就不写了。 C - Best-of-(2n-1) 题意 A 和 B 玩游戏，每一轮有 \\(a\\) 的概率 A 获胜，\\(b\\) 的概率 \\(B\\) 获胜，\\(1-a-b\\) 的概率平局。他们会一直玩直到某个人获胜了 \\(n\\) 轮。 求期望轮数。 \\(n\\le 10^5\\) 题解 假设最后 A 获胜了 \\(n\\) 轮。考虑枚举 B 获胜的轮数 \\(i\\)，确定 A 和 B 获胜的轮的相对顺序后，那么还有 \\(i+n\\) 个空可以插入一段平局。一段平局加一轮不平局的期望轮数为 \\[ \\sum_{i=0}^{\\infty}\\left(1-a-b\\right)^i=\\frac{1}{a+b} \\] 所以答案为 \\[ \\sum_{i=0}^{n}\\binom{n-1+i}{i}\\left(\\frac{a}{a+b}\\right)^n\\left(\\frac{b}{a+b}\\right)^i(i+n)\\frac{1}{a+b} \\] 代码 D - Maximum Sum of Minimum 题意 给定一棵 \\(n\\) 个点的树，将 \\(c_1,c_2,\\ldots,c_n\\) 中的每个数填入树上的恰好一个点。定义一条边的边权为这条边连接的两个点上数字的较小值。 求所有边权之和的最大值，并构造一种填数方案。 \\(n\\le 10^4\\) 题解 考虑从小到大填数。为了使大的数字贡献更多，我们一定会使当前数字的贡献尽量小。 那么我们从小到大填数，每次将当前数填入一个叶子，将该叶子删去即可。 时间复杂度 \\(O(n\\log n)\\)。 代码 E - Product of Arithmetic Progression 题意 \\(Q\\) 次询问，每次询问给定 \\(x,d,n\\)，求 \\[ \\prod_{i=0}^{n-1} (x+id) \\] 对 \\(P=10^6+3\\) 取模。 \\(Q\\le 10^5,0\\le x,d &lt; P,n\\le 10^9\\) 题解 先考虑 \\(d=1\\) 的情况。若 \\(x+d-1\\ge P\\) 或 \\(x=0\\)，那答案一定是 \\(0\\)，否则答案就是 \\(\\frac{(x+d-1)!}{(x-1)!}\\)，直接预处理阶乘和阶乘逆元即可。 \\(d&gt;1\\) 时，我们可以将式子化为 \\[ d^n\\prod_{i=0}^{n-1}\\left(\\frac{x}{d}+i\\right) \\] 就与 \\(d=1\\) 的情况一样了。注意特判 \\(d=0\\) 的情况。 代码 F - Random Tournament 题意 有 \\(N\\) 个人参加比赛，给定两两之间比赛的输赢关系。 比赛规则是，先将 \\(N\\) 个人按 \\(1\\) 到 \\(N\\) 的顺序从左到右排列，每次随机相邻两个人进行比赛，输的人离开，直到剩下一个人，这个人就是冠军。 求有多少个人可能成为冠军。 \\(N\\le 2000\\) 题解 一个朴素的区间 DP 是，令 \\(f_{l,r,x}\\) 表示只考虑 \\([l,r]\\) 中的人，\\(x\\) 是否可能成为冠军。转移则需要考虑 \\([l,x-1]\\) 中的冠军和 \\([x+1,r]\\) 中的冠军。 注意到对于所有 \\(l &lt; x &lt; r\\)，\\(x\\) 能在 \\([l,r]\\) 中取得冠军的充要条件是他在 \\([l,x]\\) 中能取得冠军，\\([x,r]\\) 中也能取得冠军。即有 \\(f_{l,r,x}=f_{l,x,x}\\land f_{x,r,x}\\)。 于是我们只需要记录 \\(x\\in \\{l,r\\}\\) 的状态即可，转移枚举 \\([l+1,r]\\) 或 \\([l,r-1]\\) 中的冠军即可。 写出转移式子后发现可以 bitset 优化。 时间复杂度 \\(O(\\frac{N^3}{w})\\)。 代码 bitset 优化前的代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"概率","slug":"概率","permalink":"https://autumnkite.github.io/tags/%E6%A6%82%E7%8E%87/"},{"name":"期望","slug":"期望","permalink":"https://autumnkite.github.io/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"数论","slug":"数论","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"bitset","slug":"bitset","permalink":"https://autumnkite.github.io/tags/bitset/"},{"name":"区间DP","slug":"区间DP","permalink":"https://autumnkite.github.io/tags/%E5%8C%BA%E9%97%B4DP/"}]},{"title":"diverta 2019 Programming Contest 2 题解","slug":"atcoder-diverta2019-2","date":"2020-09-23T03:40:26.000Z","updated":"2021-05-29T10:26:33.974Z","comments":true,"path":"atcoder-diverta2019-2/","link":"","permalink":"https://autumnkite.github.io/atcoder-diverta2019-2/","excerpt":"比赛地址","text":"比赛地址 AB 就不写了。 C - Successive Subtraction 题意 有 \\(N\\) 个数，执行 \\(N-1\\) 次操作，每次选择两个数 \\(x,y\\)，删去这两个数，替换成 \\(x-y\\)。求最后结果的最大值并构造方案。 \\(N\\le 10^5\\) 题解 最后一定是给每个数一个正负号后加起来的结果。 显然，全部填正号或全部填负号一定不可行。而同时有正负时，记其中一个填正号的数是 \\(a\\)，填负号的数是 \\(b\\)，那么我们可以用 \\(b\\) 减去其他填正号的数，再用 \\(a\\) 减去该数，最后再减去其他填负号的数。 所以我们只要将所有正数填上正号，所有负数填上负号即可，需要注意全正和全负的情况。 代码 D - Squirrel Merchant 题意 一开始有 \\(N\\) 个球，有两个商店 A、B。在商店 \\(X\\) 交易时，可以按任意顺序执行任意次以下交换（交换是双向的）： 交换 \\(g_X\\) 个球与 \\(1\\) 单位的金。 交换 \\(s_X\\) 个球与 \\(1\\) 单位的银。 交换 \\(b_X\\) 个球与 \\(1\\) 单位的铜。 你可以按顺序在商店 A，商店 B，商店 A 进行交易。 求最后最多有多少球。 \\(N,g_A,s_A,b_A,g_B,s_B,b_B\\le 5000\\) 题解 我们可以把问题看成先用 \\(N\\) 个球依次在 A 和 B 交易，全部换成球，得到 \\(M\\) 个球，然后再用这 \\(M\\) 个球依次在 B 和 A 交易，再全部换成球，就是答案。 这两步的问题是一样且独立的，而每一步的问题相当于一个完全背包问题。直接 DP 即可。 时间复杂度 \\(O(N^2)\\)。 代码 E - Balanced Piles 题意 有 \\(N\\) 个初始为 \\(0\\) 的整数，每次可以执行以下操作： 记 \\(N\\) 个数中的最小值为 \\(m\\)，最大值为 \\(M\\)。选择任意一个等于 \\(m\\) 的数，加上一个正整数，使得该数在 \\([M,M+D]\\) 中。 你的目标是使所有数都变成 \\(H\\)。求操作方案数，对 \\(10^9+7\\) 取模。 \\(N,D,H\\le 10^6\\) 题解 令 \\(f_{i,j}\\) 表示当前最大值为 \\(i\\)，有 \\(j\\) 个时的操作方案数。 注意到此时转移与最小值有关，貌似并不能转移。 但是考虑到这 \\(j\\) 个最大值在接下来的某段操作中会变成最小值，而在这一段操作中，因为我们确定了每一次操作后的最大值，所以这 \\(j\\) 个最大值的贡献是 \\(j!\\)。 于是我们有 \\[ f_{i,j}= \\begin{cases} \\sum\\limits_{k=1}^d\\sum\\limits_{l=1}^{n} f_{i-k,l} &amp; \\text{ if }j=1\\\\ f_{i,j-1}\\cdot j &amp; \\text{ if }j&gt;1 \\end{cases} \\] 也就是说我们有 \\(f_{i,j}=f_{i,1}\\cdot j!,f_{i,1}=\\sum\\limits_{k=1}^{d}f_{i-k,1}\\sum\\limits_{l=1}^{n}l!\\)。 所以只记录 \\(f_{i,1}\\)，用前缀和优化转移即可。 注意 \\(i=0\\) 时，只有 \\(f_{i,n}=n!\\)，其他位置都是 \\(0\\)，所以最后答案需要乘上 \\(\\frac{n!}{\\sum\\limits_{i=1}^{n}i!}\\) 去掉其他位置的贡献。 代码 F - Diverta City 题意 给一个 \\(n\\) 个点的无向完全图的每条边确定一个权值，使得所有 \\(\\frac{n!}{2}\\) 条本质不同的哈密顿路权值不同。 \\(n\\le 10\\) 题解 构造一个序列 \\(f=\\{1, 2, 4, 7, 12, 20, 29, 38, 52\\}\\)，这个序列满足所有元素以及所有元素两两的和都互不相等。 考虑每次加入一个点 \\(i\\)，对于所有 \\(j &lt; i\\)，将 \\((i,j)\\) 这条边的边权置为 \\((M+1)f_j\\)，其中 \\(M\\) 表示前 \\(i-1\\) 个点的所有哈密顿路权值的最大值。 这样构造显然是正确的。证明可以考虑在任意两条哈密顿路中的任意位置插入 \\(i\\)，因为乘了 \\((M+1)\\)，原来哈密顿路的权值以及减去的边的权值都不需要考虑，而只需要考虑加入的两条边。因为乘了 \\(f_i\\)，这些边具有了 \\(f\\) 的性质，即所有元素以及所有元素两两的和都互不相等，所以这些新的哈密顿路权值一定都互不相等。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"图论","slug":"图论","permalink":"https://autumnkite.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"AtCoder Grand Contest 037 题解","slug":"atcoder-agc037","date":"2020-09-22T13:20:55.000Z","updated":"2021-05-29T10:26:33.968Z","comments":true,"path":"atcoder-agc037/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc037/","excerpt":"比赛地址","text":"比赛地址 A - Dividing a String 题意 给定一个字符串 \\(S\\)，求最多可以把该字符串分成多少份，使得相邻两份不相同。 \\(|S|\\le 2\\times 10^5\\) 题解 显然每一份的长度一定不超过 \\(2\\)。直接 DP 即可。 代码 B - RGB Balls 题意 有 \\(3N\\) 个球，编号 \\(1\\) 到 \\(3N\\)。每个球有红（R）、绿（G）、蓝（B）三种颜色，每种颜色的球恰好有 \\(N\\) 个。 你要将这些球分给 \\(N\\) 个人，每个人得到恰好一个红球、一个绿球、一个蓝球。令第 \\(i\\) 个人得到的球的编号按升序排列为 \\(a_i,b_i,c_i\\)，则分配方案需要最小化 \\[\\sum_{i=1}^{N} (c_i-a_i)\\] 求使得上式最小的分配方案数，对 \\(998244353\\) 取模。两种方案不同当且仅当存在某个人分到的球的集合不同。 题解 有一种贪心是，从左往右依次扫描每个球，记录单个的，两个的，以及三个球都配好的数量。那么加入一个球时，优先与已经有两个球的对配成三个球；若不行，再尝试与单个的球配成两个球；若仍然不行，则单独成为一个球。 可以通过调整证明这样贪心得到的方案一定恰好能覆盖所有最小的方案。 于是直接用乘法原理计算答案即可。 代码 C - Numbers on a Circle 题意 环上有 \\(N\\) 个正整数 \\(A_i\\)，你可以执行若干次以下操作： 选择环上的一个数，将该数加上与它相邻的两个数。 你的目标是使得 \\(A_i=B_i\\)。求最少操作次数，或输出无解。 \\(N\\le 2\\times 10^5\\) 题解 考虑倒着做，假设所有数中最大的为 \\(x\\)。那么在操作 \\(x\\) 之前不可能操作与 \\(x\\) 相邻的两个数，所以我们一定会先操作 \\(x\\)。 于是只要用堆模拟即可，因为每次相当于会对最大值取模，所以复杂度是 \\(O(N\\log N\\log A_i)\\) 的。 代码 D - Sorting a Grid 题意 给定一个 \\(N\\times M\\) 的矩阵，第 \\(i\\) 行第 \\(j\\) 列的数为 \\(A_{i,j}\\)。矩阵满足 \\(1\\) 到 \\(NM\\) 的每个数恰好出现一次。你需要按顺序执行以下操作： 对于矩阵 \\(A\\) 的每一行，重新排列该行的元素得到矩阵 \\(B\\)； 对于矩阵 \\(B\\) 的每一列，重新排列该列的元素得到矩阵 \\(C\\)； 对于矩阵 \\(C\\) 的每一行，重新排列该行的元素得到矩阵 \\(D\\)。 你的目标是使矩阵 \\(D\\) 第 \\(i\\) 行第 \\(j\\) 列的数为 \\((i-1)M+j\\)。 构造一种方案。可以证明一定有解。 \\(N,M\\le 100\\) 题解 对于矩阵 \\(C\\)，我们可以将每个数替换成最终矩阵中的行号，\\(C\\) 的每一列需要满足恰好是 \\(1\\) 到 \\(N\\)。 那么对于矩阵 \\(B\\)，每一列需要恰好是 \\(1\\) 到 \\(N\\) 的一个排列。 于是我们考虑从左到右填 \\(B\\) 的每一列。这可以直接跑二分图匹配。 我们可以用数学归纳法，根据霍尔定理证明一定有解。 时间复杂度 \\(O(MN^3)\\)。 代码 E - Reversing and Concatenating 题意 给定一个长度为 \\(N\\) 的字符串 \\(S\\)，你需要执行以下操作 \\(K\\) 次： 令 \\(T\\) 为 \\(S\\) 翻转后的串，令 \\(U\\) 为 \\(S\\) 与 \\(T\\) 按顺序拼接得到的串。 将 \\(S\\) 替换为 \\(U\\) 的一个长度为 \\(N\\) 的子串。 求最后得到的字典序最小的 \\(S\\)。 \\(N\\le 5000,K\\le 10^9\\) 题解 因为需要字典序最小，所以我们会尽量使最小的字符在开头的出现次数最多。 假设最小的字符为 \\(a\\)，假设初始字符串有一段长度为 \\(l\\) 的字符 \\(a\\)。那么我们可以执行以下若干次操作： \\(\\ldots aaa\\ldots\\to \\ldots aaa\\boxed{\\ldots\\ldots aaa}\\ldots\\) \\(\\ldots\\ldots aaa\\to \\ldots\\boxed{\\ldots aaaaaa}\\ldots\\ldots\\) \\(\\ldots aaaaaa\\to \\ldots aaaaaaaaaaaa\\ldots\\) \\(\\ldots\\) 使得最后得到的字符串最前面有 \\(l\\times 2^{k-1}\\) 个 \\(a\\)。 通过手动模拟可以得到后面部分一定是初始字符串中从这一段 \\(a\\) 的下一个字符开始，到末尾，再从末尾返回得到的字符串。 于是我们枚举每一段最长的 \\(a\\) 后暴力求出最后的字符串，暴力比较即可。 时间复杂度 \\(O(N^2)\\)。 代码 F - Counting of Subarrays 题意 定义一个序列 \\(S\\) 是属于 level \\((k,l)\\) 的当且仅当满足以下条件之一： \\(S\\) 的长度为 \\(1\\) 且元素为 \\(k\\)； \\(k&gt;1\\) 且存在属于 level \\((k,l-1)\\) 的序列 \\(T_1,T_2,\\ldots,T_m\\ (m\\ge l)\\) 满足 \\(T_1,T_2,\\ldots,T_m\\) 按顺序拼接得到 \\(S\\)。 给定整数 \\(L\\) 和一个序列 \\(A_1,A_2,\\ldots,A_N\\)，求 \\(A\\) 有多少个连续子序列满足，存在一个 \\(K\\) 使得该序列是属于 level \\((K,L)\\) 的。 \\(N\\le 2\\times 10^5\\) 题解 一个序列 \\(a_1,a_2,\\ldots, a_n\\) 合法当且仅当满足以下条件之一： \\(n=1\\) 令 \\(x\\) 为该序列的最小值，对于所有 \\(a_i=x\\) 的极长连续段，假设长度为 \\(l_1,l_2,\\ldots,l_m\\)，都有 \\(l_i\\ge L\\)，且将第 \\(i\\) 段连续段替换成 \\(\\lfloor\\frac{l_i}{L}\\rfloor\\) 个 \\(x+1\\)，得到一个新的序列 \\(b_1,b_2,\\ldots,b_k\\)，有 \\(b\\) 序列合法。 考虑将原序列不断地按上述过程进行变换，则原序列的一个区间对应新序列的一个区间，而新序列的一个区间对应原序列的若干个区间。 考虑在变换过程中维护 \\(L_i\\)，表示原序列中有多少个左端点对应到新序列中为 \\(i\\)，\\(R_i\\) 同理。 我们只要在变换时维护答案即可，注意计入答案的区间必须满足区间中包含至少一个不是通过收缩得到的点。 用链表和堆模拟变换过程，时间复杂度 \\(O(N\\log N)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"堆","slug":"堆","permalink":"https://autumnkite.github.io/tags/%E5%A0%86/"},{"name":"二分图匹配","slug":"二分图匹配","permalink":"https://autumnkite.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"},{"name":"链表","slug":"链表","permalink":"https://autumnkite.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"AtCoder Grand Contest 038 题解","slug":"atcoder-agc038","date":"2020-09-21T12:44:15.000Z","updated":"2021-05-29T10:26:33.969Z","comments":true,"path":"atcoder-agc038/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc038/","excerpt":"比赛地址","text":"比赛地址 A - 01 Matrix 题意 构造一个 \\(H\\times W\\) 的 01 矩阵，使得： 对于每一行，1 的个数和 0 的个数的较小值为 \\(A\\)； 对于每一列，1 的个数和 0 的个数的较小值为 \\(B\\)。 或输出无解。 \\(H,W\\le 1000,0\\le A\\le \\frac{W}{2},0\\le B\\le \\frac{H}{2}\\) 题解 只要将左上角的 \\(B\\times A\\) 的矩阵和右下角的 \\((H-B)\\times (W-A)\\) 的矩阵置为全 1 矩阵即可。 时间复杂度 \\(O(HW)\\)。 代码 B - Sorting a Segment 题意 给定一个 \\(0\\) 到 \\(N-1\\) 的排列 \\(P_0,P_1,\\ldots,P_{N-1}\\)。你需要求有多少本质不同的排列可以通过 \\(P\\) 通过恰好一次以下操作得到： 选择一个长度为 \\(K\\) 的区间，将该区间中的元素从小到大排序。 \\(N\\le 2\\times 10^5\\) 题解 考虑如何判断选择 \\([i,i+k-1]\\) 和选择 \\([j,j+k-1]\\) 得到的排列是否相同。 假设有 \\(i&lt;j\\)。先考虑两个区间有交的情况。此时充要条件是 \\([i,j-1]\\) 和 \\([i+k,j+k-1]\\) 分别有序，且 \\([i,j-1]\\) 中的元素小于相交部分的元素，\\([i+k,j+k-1]\\) 中的元素大于相交部分。 而两个区间不交时，充要条件则为两个区间分别有序。 注意到对于区间相交的情况，当 \\(j=k+1\\ (k&gt;i)\\) 时若满足条件，则 \\(j=k\\) 时一定满足条件。所以我们只需要判断 \\(j=i+1\\) 的情况，这可以用滑动窗口的方法判断。 判断某个区间是否有序可以通过预处理 \\([a_i&gt;a_{i-1}]\\) 的前缀和实现。 时间复杂度 \\(O(N)\\)。 代码 C - LCMs 题意 给定正整数序列 \\(a_0,a_1,\\ldots,a_{n-1}\\)，求 \\[\\sum_{i=0}^{n-2}\\sum_{j=i+1}^{n-1}\\operatorname{lcm}(a_i,a_j)\\] \\(n\\le 2\\times 10^5,a_i\\le 10^6\\) 题解 令 \\(c_j\\) 表示 \\(a_i=j\\) 的 \\(i\\) 数量，\\(m\\) 表示最大值，则有 \\[ \\begin{aligned} \\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1}\\operatorname{lcm}(a_i,a_j)&amp;=\\sum_{i=1}^{m}\\sum_{j=1}^{m}c_ic_j\\frac{ij}{\\gcd(i,j)}\\\\ &amp;=\\sum_{d=1}^{m}\\frac{1}{d}\\sum_{i=1}^{\\lfloor\\frac{m}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}c_{id}c_{jd}\\cdot id\\cdot jd\\cdot [\\gcd(i,j)=1]\\\\ &amp;=\\sum_{d=1}^{m}\\frac{1}{d}\\sum_{k=1}^{\\lfloor\\frac{m}{d}\\rfloor}\\mu(k)\\left(\\sum_{i=1}^{\\lfloor\\frac{m}{dk}\\rfloor}c_{idk}\\cdot idk\\right)^2 \\end{aligned} \\] 于是我们可以对于所有 \\(1\\le w\\le m\\)，预处理出 \\[ \\sum_{i=1}^{\\lfloor\\frac{m}{w}\\rfloor} c_{iw}\\cdot iw \\] 这一部分预处理和最后的计算都是调和级数的复杂度。最后只需要把答案减去 \\(i=j\\) 的情况再除以 \\(2\\) 即可。 时间复杂度 \\(O(m\\log m)\\)。 代码 D - Unique Path 题意 你需要判断是否存在 \\(N\\) 个点 \\(M\\) 条边的无向简单（无重边，无自环）连通图满足 \\(Q\\) 个限制，其中第 \\(i\\) 个限制为： 若 \\(C_i=0\\)，\\(A_i\\) 到 \\(B_i\\) 恰好有一条简单路径。 若 \\(C_i=1\\)，\\(A_i\\) 到 \\(B_i\\) 有两条及以上不同的简单路径。 \\(N\\le 10^5,N-1\\le M\\le \\frac{N(N-1)}{2},Q\\le 10^5\\) 题解 假设已经有一张图，考虑如何判断。 考虑建出圆方树，特别地，对于点数为 \\(2\\) 的点双，不建立方点，直接连边。于是限制条件想变成了： 若 \\(C_i=0\\)，圆方树上圆点 \\(A_i\\) 到圆点 \\(B_i\\) 的简单路径不经过方点。 若 \\(C_i=1\\)，圆方树上圆点 \\(A_i\\) 到圆点 \\(B_i\\) 的简单路径经过至少一个方点。 若我们只取出 \\(C_i=0\\) 的限制，将 \\(A_i\\) 与 \\(B_i\\) 连边，则这个图的一个生成森林一定是圆方树的一个子图。 于是我们可以取出该图的任意一个生成森林。若此时存在一个 \\(C_i=1\\) 的限制，有 \\(A_i\\) 与 \\(B_i\\) 连通，那一定无解。 假设当前连通块数为 \\(K\\)。注意到合法的 \\(M\\) 一定是一个区间。求上界时，我们一定会使方点尽量少，所以一定是只有一个方点与每个连通块中恰好一个点连边。所以上界为 \\(\\frac{K(K-1)}{2}+(N-K)\\)。 通过以上构造可以得到下界不超过 \\(K+(N-K)=N\\)。显然，\\(M=N-1\\) 可行当且仅当不存在 \\(C_i=1\\) 的限制。 注意需要特判 \\(K\\le 2\\) 的情况。 代码 E - Gachapon 题意 有一个生成器，每次会以 \\(\\frac{A_i}{S}\\) 的概率生成 \\(0\\le i &lt; N\\) 的整数 \\(i\\)，其中 \\(S=\\sum_{i=0}^{N-1} A_i\\)。 生成器会不断生成数直到满足以下条件： 对于每个 \\(0\\le i &lt; N\\)，\\(i\\) 被生成的次数大于等于 \\(B_i\\)。 求生成器生成的数的数量的期望，对 \\(998244353\\) 取模。 \\(N\\le 400,S\\le 400,\\sum B_i\\le 400\\) 题解 考虑 Min-Max 容斥，转化为确定一个集合 \\(T\\) 后，第一次满足以下条件的期望次数： 存在一个 \\(i\\in T\\)，满足 \\(i\\) 被生成的次数大于等于 \\(B_i\\)。 根据期望的线性性，第一次满足该条件的期望次数等于所有不满足该条件的状态的概率之和。 一个不满足该条件的状态，将生成的数按生成的顺序排列，一定可以看成一段不在 \\(T\\) 中的数（可能为空），加上一个在 \\(T\\) 中的数，再一段不在 \\(T\\) 中的数，加上一个在 \\(T\\) 中的数，最后再有一段不在 \\(T\\) 中的数。 那么所有这样的状态的概率之和就可以表示成每一段的概率之和的乘积。 对于一段不在 \\(T\\) 中的数，我们不关心这些数具体是什么，我们只需要关心在 \\(T\\) 中的数具体是什么。记 \\(S_T=\\sum_{i\\in T} A_i\\)，那么形如「一段不在 \\(T\\) 中的数，加上一个在 \\(T\\) 中的数 \\(x\\)」的所有状态的概率之和为 \\[\\sum_{i=0}^{\\infty}\\left(\\frac{S-S_T}{S}\\right)^i\\frac{A_x}{S}=\\frac{S}{S_T}\\cdot \\frac{A_x}{S}=\\frac{A_x}{S_T}\\] 假设确定了所有 \\(T\\) 中的数的出现次数 \\(c_i\\ (0\\le c_i &lt; B_i)\\)，那么所有强制以 \\(T\\) 中元素结尾的状态的概率之和，就是这些段的排列方案数乘上每一段的概率之和的乘积，即为 \\[\\frac{(\\sum c_i)!}{\\prod c_i!}\\cdot \\prod_{i\\in T}\\left(\\frac{A_i}{S_T}\\right)^{c_i}\\] 而不强制 \\(T\\) 中元素结尾的状态的概率之和还要再乘上最后「一段不在 \\(T\\) 中的数」的概率之和，即乘上 \\[\\sum_{i=0}^{\\infty}\\left(\\frac{S-S_T}{S}\\right)^i=\\frac{S}{S_T}\\] 于是我们就可以 DP 了，只需要在 DP 状态中记录 \\(S_T\\) 和 \\(\\sum c_i\\) 即可。注意要把容斥系数 \\((-1)^{|T|-1}\\) 也 DP 进去。 时间复杂度 \\(O(S(\\sum B_i)^2)\\)。 代码 F - Two Permutations 题意 有两个 \\(0\\) 到 \\(N-1\\) 的排列 \\(P_0,P_1,\\ldots,P_{N-1}\\)，\\(Q_0,Q_1,\\ldots,Q_{N-1}\\)。 求满足以下条件的两个排列 \\(A,B\\) 的最大距离： 对于所有 \\(0\\le i &lt; N\\)，\\(A_i=i\\) 或 \\(A_i=P_i\\)； 对于所有 \\(0\\le i &lt; N\\)，\\(B_i=i\\) 或 \\(B_i=Q_i\\)。 两个排列 \\(A,B\\) 的距离定义为 \\(A_i\\ne B_i\\) 的 \\(i\\) 的数量。 \\(N\\le 10^5\\) 题解 我们可以把问题转化为最小化 \\(A_i=B_i\\) 的 \\(i\\) 的数量。 我们先置 \\(A_i=i,B_i=i\\)，然后相当于对于 \\(P,Q\\) 的每个置换环，要么不变（即 \\(A_i=i\\) 或 \\(B_i=i\\)），要么在 \\(A\\) 或 \\(B\\) 的对应位置按环的顺序向前旋转一格（即 \\(A_i=P_i\\) 或 \\(B_i=Q_i\\)）。 分若干种情况讨论： \\(P_i=i,Q_i=i\\)，则一定有 \\(1\\) 的贡献； \\(P_i=i,Q_i\\ne i\\)，则此时若 \\(i\\) 在 \\(Q\\) 中所在的环没有旋转，即 \\(B_i=i\\)，那么会产生 \\(1\\) 的贡献； \\(P_i\\ne i,Q_i=i\\)，与上一种情况类似； \\(P_i\\ne i,Q_i\\ne i\\) 且 \\(P_i\\ne Q_i\\)，此时若 \\(i\\) 在 \\(P\\) 和 \\(Q\\) 中对应的环都没有旋转，则有 \\(1\\) 的贡献； \\(P_i\\ne i,Q_i\\ne i\\) 且 \\(P_i=Q_i\\)，此时若 \\(i\\) 在 \\(P\\) 和 \\(Q\\) 中对应的环都没有旋转或者都旋转了，则有 \\(1\\) 的贡献。 考虑建立一个最小割模型，将每个环看成一个点，对于排列 \\(P\\) 的每个环，若在 \\(S\\) 集合则旋转了，在 \\(T\\) 集合则不旋转；对于排列 \\(Q\\) 中的每个环，若在 \\(T\\) 集合则旋转了，在 \\(S\\) 集合则不旋转。对于上面的每种情况： \\(P_i=i,Q_i=i\\)，答案直接加 \\(1\\) 即可； \\(P_i=i,Q_i\\ne i\\)，\\(i\\) 在 \\(Q\\) 中的环向 \\(T\\) 连边权为 \\(1\\) 的边； \\(P_i\\ne i,Q_i=i\\)，\\(S\\) 向 \\(i\\) 在 \\(P\\) 中的环连边权为 \\(1\\) 的边； \\(P_i\\ne i,Q_i\\ne i\\) 且 \\(P_i\\ne Q_i\\)，\\(i\\) 在 \\(Q\\) 中的环向 \\(i\\) 在 \\(P\\) 中的环连边权为 \\(1\\) 的边； \\(P_i\\ne i,Q_i\\ne i\\) 且 \\(P_i=Q_i\\)，\\(i\\) 在 \\(Q\\) 中的环与 \\(i\\) 在 \\(P\\) 中的环双向连边权为 \\(1\\) 的边。 直接跑 Dinic 即可，由于图是二分图，复杂度可以证明是 \\(O(M\\sqrt{N})\\) 的。由于 \\(M=O(N)\\)，所以总复杂度为 \\(O(N\\sqrt{N})\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"网络流","slug":"网络流","permalink":"https://autumnkite.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"图论","slug":"图论","permalink":"https://autumnkite.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"单调队列","slug":"单调队列","permalink":"https://autumnkite.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"数论","slug":"数论","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://autumnkite.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"Min-Max容斥","slug":"Min-Max容斥","permalink":"https://autumnkite.github.io/tags/Min-Max%E5%AE%B9%E6%96%A5/"},{"name":"最小割","slug":"最小割","permalink":"https://autumnkite.github.io/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"}]},{"title":"AtCoder Grand Contest 039 题解","slug":"atcoder-agc039","date":"2020-09-18T02:32:37.000Z","updated":"2021-05-29T10:26:33.969Z","comments":true,"path":"atcoder-agc039/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc039/","excerpt":"比赛地址","text":"比赛地址 A - Connection and Disconnection 题意 给定字符串 \\(S\\) 和一个整数 \\(k\\)，令 \\(T\\) 为将 \\(S\\) 复制 \\(k\\) 份依次拼接得到的字符串。 求最少需要改变 \\(T\\) 中的几个字符使得 \\(T\\) 中任意两个相邻的字符不同。 \\(|S|\\le 100,k\\le 10^9\\) 题解 考虑 \\(k=1\\) 时如何求答案。设字符相同的连续段长度依次为 \\(l_1,l_2,\\ldots,l_m\\)，那么答案为 \\(\\sum\\limits_{i=1}^{m} \\lfloor\\frac{l_i}{2}\\rfloor\\)。 \\(k&gt;1\\) 时只要特殊处理一下首尾的两个连续段字符相同的情况。 时间复杂度 \\(O(|S|)\\)。 代码 B - Graph Partition 题意 给定一个 \\(n\\) 个点 \\(m\\) 条边的简单无向连通图。 判断是否将图分成若干层，使得任意一条边连接的点在相邻两层（不能是同一层）。若可行，求最大层数。 \\(n\\le 200\\) 题解 有解的充要条件是没有奇环。 我们钦定一个点 \\(u\\) 在第一层，那么剩下点的分层方式一定是按 BFS 树分。具体证明可以根据 BFS 树的性质进行证明。 时间复杂度 \\(O(N^3)\\)。 代码 C - Division by Two with Something 题意 给定一个整数 \\(n\\) 以及一个 \\(n\\) 位二进制数 \\(X\\)，求对于 \\(0\\le k\\le X\\)，执行若干次（不为 \\(0\\) 次）以下操作第一次变回原来的 \\(k\\) 的操作之和： 若 \\(k\\) 是奇数，则减 \\(1\\) 后除以 \\(2\\)；若 \\(k\\) 是偶数，则除以 \\(2\\) 后加 \\(2^{n-1}\\)。 对 \\(998244353\\) 取模。 \\(n\\le 2\\times 10^5\\) 题解 先不考虑 \\(X\\) 的限制。 执行题目中的一次操作相当于把最后一位取反后放到最前面。而执行不超过 \\(n\\) 次操作相当于把一段后缀取反后放到最前面。 即若把操作的数的二进制表示从高位到低位看成一个字符串 \\(S\\)，我们要求最小的 \\(p\\) 使得 \\(\\operatorname{not}(S[n-p+1,n])+S[1,n-p]=S\\)。注意到若操作次数大于 \\(n\\)，条件与上述条件相同，所以若不存在这样的 \\(p\\) 那么答案一定是 \\(2n\\)。 发现满足上述条件的字符串一定是由一个长度为 \\(d\\ (d\\mid n,d &lt; n)\\) 的字符串每次取反加入到 \\(S\\) 中，执行 \\(\\frac{n}{d}\\) 次后得到的结果。如 \\(n=9,d=3\\) 时，可以构造出形如 \\(000111000,001110001\\) 的字符串。而这样构造得到的字符串一定有最小的 \\(p=2d\\)。 于是考虑枚举 \\(d\\)，那么方案数为 \\(2^d\\)，操作次数为 \\(2d\\)，对答案的贡献为 \\(2^d\\times 2d\\)。 可是这样做会有问题，例如 \\(n=9,d=3\\) 时会构造出 \\(010101010\\) 这样的字符串，但这样的字符串的 \\(p\\) 应为 \\(2\\)，应该在 \\(d=1\\) 时被计算。所以容斥即可。 有 \\(X\\) 的限制时同理，前 \\(d\\) 位小于 \\(X\\) 的前 \\(d\\) 位时方案数就是 \\(X\\) 的前 \\(d\\) 位，等于时只有一种，直接构造出字符串判断是否小于等于 \\(X\\) 即可。 时间复杂度 \\(O(d(n)n)\\)，其中 \\(d(n)\\) 表示 \\(n\\) 的因子数量。 代码 D - Incenters 题意 给定单位圆上的 \\(N\\) 个点，求随机选择三个不同的点形成的三角形的内心的坐标的期望。 \\(N\\le 3000\\) 题解 假设三角形的三个顶点为 \\(A,B,C\\)，我们可以得到 \\(\\angle A,\\angle B,\\angle C\\) 的角平分线与圆的交点，分别记做 \\(A&#39;,B&#39;,C&#39;\\)。根据圆心角、圆周角的相关性质可以得到 \\(A&#39;,B&#39;,C&#39;\\) 分别是弧 \\(BC,CA,AB\\) 的中点。可以根据这一性质继而证明 \\(\\triangle ABC\\) 的内心与 \\(\\triangle A&#39;B&#39;C&#39;\\) 的垂心重合。 另外，根据欧拉线的相关性质，有三角形的重心 \\(G\\) 在外心 \\(O\\) 和垂心 \\(H\\) 的连线段上，且 \\(OH=3OG\\)，即 \\(\\overrightarrow{OH}=3\\overrightarrow{OG}\\)。 于是我们把垂心的计算转化成了重心的计算。 三个点 \\(A&#39;(x_1,y_1),B&#39;(x_2,y_2),C&#39;(x_3,y_3)\\) 形成的三角形的重心为 \\((\\frac{x_1+x_2+x_3}{3},\\frac{y_1+y_2+y_3}{3})\\)。此题由于 \\(A&#39;,B&#39;,C&#39;\\) 都在单位圆上，外心为原点，所以垂心即为 \\((x_1+x_2+x_3,y_1+y_2+y_3)\\)。 于是我们可以枚举 \\(N\\) 个点之间两两形成的弧，求出该弧的中点对答案的贡献即可。 时间复杂度 \\(O(N^2)\\)。 代码 E - Pairing Points 题意 有 \\(2N\\) 个点共圆，按逆时针编号 \\(1\\) 到 \\(2N\\)。保证任意六个不同的点形成的三条线段不经过同一个点。 这些点之间有一些线段相连，你需要选出 \\(N\\) 条线段，使得： 每个点恰好属于一条选出线段。 若把选出的线段之间的交点看做顶点，把线段看做边，则形成一棵树。 求方案数。 \\(N\\le 20\\) 题解 首先可以枚举与 \\(1\\) 相连的点，然后将环分成两部分。 令 \\(f_{l_1,r_1,l_2,r_2}\\) 表示 \\([l_1,r_1]\\) 与 \\([l_2,r_2]\\) 配对（中间已经有一条线段）的方案数。跨越中间的匹配一定是在 \\([l_1,r_1]\\) 中选一些点 \\(x_1,x_2,\\ldots,x_m\\ (x_i &lt; x_{i+1})\\)，在 \\([l_2,r_2]\\) 中选一些点 \\(y_1,y_2,\\ldots,y_m\\ (y_i &gt; y_{i+1})\\)，然后 \\(x_i\\) 与 \\(y_i\\) 匹配，如下图所示： 为了防止算重和方便转移，我们再引入 \\(g_{l_1,r_1,l_2,r_2}\\)，定义与 \\(f\\) 类似，但是强制跨越中间的线段只能选一条。 那么 \\(f\\) 的转移只需要枚举 \\(x_m,y_m\\) 所在的区间即可： \\[f_{l_1,r_1,l_2,r_2}=\\sum_{i,j} f_{l_1,i,j,r_1}\\cdot g_{i+1,r_1,l_2,j-1}\\] \\(g\\) 的转移则只需要枚举匹配边即可： \\[g_{l_1,r_1,l_2,r_2}=\\sum_{(i,j)\\in E} f_{l_1,i-1,i+1,r_1}\\cdot f_{l_2,j-1,j+1,r_2}\\] 时间复杂度 \\(O(N^6)\\)。 代码 F - Min Product Sum 题意 你需要在一个 \\(N\\times M\\) 的网格的每个格子中填上 \\(1\\) 到 \\(K\\) 的一个整数。 定义一个格子的权值为所在的行和所在的列中元素最小值。 定义一个方案的权值为所有格子的权值的乘积。 求所有填数方案的权值之和，对给定的大质数 \\(P\\) 取模。 \\(N,M,K\\le 100\\)。 题解 假设我们知道了每行的最小值 \\(r_i\\) 和每列的最小值 \\(c_j\\)，则答案即为 \\[\\prod_{i=1}^{N}\\prod_{j=1}^{M}\\min(r_i,c_j)\\] 而对于方案数，假设我们只考虑 \\(a_{i,j}\\ge r_i\\) 和 \\(a_{i,j}\\ge c_j\\) 的限制，则方案数为 \\[\\prod_{i=1}^{N}\\prod_{j=1}^{M}(K-\\max(r_i,c_j)+1)\\] 为了强制取到最小值，只需要容斥即可，即强制一些行一些列大于钦定的最小值后计算即可。 于是我们可以 DP。令 \\(f_{k,i,j}\\) 表示填了 \\(r_i,c_j\\) 中小于等于 \\(k\\) 的值，且已经填的行数为 \\(i\\)，列数为 \\(j\\) 时已填的位置对答案的贡献。 转移需要枚举加入的不被容斥的行数、不被容斥的列数、容斥的行数、容斥的列数，一起枚举复杂度过高，只要依次枚举，分四次转移即可。 时间复杂度 \\(O(KNM(N+M))\\)，有点略微卡常。","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"图论","slug":"图论","permalink":"https://autumnkite.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"BFS","slug":"BFS","permalink":"https://autumnkite.github.io/tags/BFS/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"AtCoder Grand Contest 040 题解","slug":"atcoder-agc040","date":"2020-09-16T11:49:20.000Z","updated":"2021-05-29T10:26:33.970Z","comments":true,"path":"atcoder-agc040/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc040/","excerpt":"比赛地址","text":"比赛地址 A - &gt;&lt; 题意 给定一个长度为 \\(N-1\\) 的只包含 &lt; 和 &gt; 的字符串 \\(S\\)。 一个非负整数序列 \\(a_1,a_2,\\ldots,a_N\\) 被称为好的当且仅当满足以下条件： 若 \\(S_i\\) 是 &lt;，则有 \\(a_i&lt;a_{i+1}\\)； 若 \\(S_i\\) 是 &gt;，则有 \\(a_i&gt;a_{i+1}\\)。 求一个好的序列的元素之和的最小值。 \\(N\\le 5\\times 10^5\\) 题解 显然 \\(a_i\\) 的下界为左边连续 &lt; 的数量与右边连续 &gt; 的数量的较大值。 当 \\(a_i\\) 都取这个下界时显然满足条件。 所以直接求出 \\(a_i\\) 后计算即可。 时间复杂度 \\(O(N)\\)。 代码 B - Two Contests 题意 给定 \\(N\\) 个区间 \\([l_i,r_i]\\)，将他们分成非空的两组。定义一个区间的权值为这个区间中包含的整点数量，定义一组区间的权值为这组区间的交的权值。 求两组区间的权值之和的最大值。 \\(N\\le 10^5\\) 题解 不妨将所有区间右端点加 \\(1\\)，将权值转化为区间长度。 首先考虑其中一组区间的交为空的情况。为了使得长度之和最大，另一组一定只有一个区间，并且是所有区间中最长的。 接下来考虑两组区间都非空的情况。假设第一组区间为 \\(S\\)，那么答案式子为 \\[\\min_{i\\in S}r_i-\\max_{i\\in S}l_i+\\min_{i\\not\\in S}r_i-\\max_{i\\not\\in S}l_i\\] 令 \\(R=\\min r_i,L=\\max l_i\\)，即全局右端点的最小值和全局左端点的最大值。 我们不妨强制 \\(\\min\\limits_{i\\in S} r_i=R\\)，此时又分两种情况。 当 \\(\\max\\limits_{i\\in S} l_i=L\\) 时，所有区间都可以被放入 \\(S\\) 中。所以我们一定会尽可能地把区间放入第一组，将最长的区间放入第二组。 当 \\(\\max\\limits_{i\\in S} l_i\\ne L\\) 时，考虑枚举 \\(\\max\\limits_{i\\in S} l_i=L&#39;\\)。由于 \\(\\min\\limits_{i\\in S}r_i=R\\)，是全局最小值，所以放入第一组的区间只需要满足 \\(l_i\\ge L&#39;\\) 即可。我们仍然会尽可能地把满足条件的区间都放入第一组，将其他区间放入第二组。 于是对于这种情况，我们只需要将区间按 \\(l_i\\) 排序，预处理出 \\(r_i\\) 的后缀 \\(\\min\\) 后枚举一个前缀放入第一组，可以 \\(O(1)\\) 计算答案。 时间复杂度 \\(O(N\\log N)\\)。 代码 C - Neither AB nor BA 题意 给定一个偶数 \\(N\\)，求通过若干次以下操作可以将字符串 \\(S\\) 变成空串的，长度为 \\(N\\) 且只包含 A、B 和 C 的字符串 \\(S\\) 的数量： 选择 \\(S\\) 中相邻两个字符，并将他们删去。但是不允许删除 AB 或 BA。 对 \\(998244353\\) 取模。 \\(N\\le 10^7\\) 题解 发现删除相邻两个字符有一些性质： 删除的两个位置奇偶性不同； 删除后其余位置的奇偶性不变。 于是我们可以考虑把所有奇数位的 A 变成 B，B 变成 A，这样我们的限制条件相当于变成了不能删除连续两个 A 或连续两个 B。 充要条件是 A 和 B 的数量都不超过 \\(\\frac{N}{2}\\)。必要性显然，充分性可以通过每次删除多的字符证明。 于是用容斥计算即可。时间复杂度 \\(O(N)\\)。 代码 D - Balance Beam 题意 有 \\(n\\) 条线段，每条线段长度都为 \\(1\\)。在第 \\(i\\) 条线段上，A 的速度为 \\(\\frac{1}{a_i}\\)，B 的速度为 \\(\\frac{1}{b_i}\\)。 A 会将 \\(n\\) 条线段按他想要的顺序排列形成一条长的线段，并以最左边的点作为起点。 然后 B 会在这条长度为 \\(n\\) 的线段上等概率随机一个实数点作为起点。 A 获胜的条件是，A 和 B 同时出发后，按给定速度行走，A 能在 B 到达最右边之前的某个时刻追到 B。 求 A 的最大胜率。以最简分数形式给出。 \\(n\\le 10^5\\) 题解 假设已经固定了线段的顺序，显然能使 A 获胜的点一定是一个前缀。 若我们以距最左边点的距离为 \\(x\\) 坐标，时间为 \\(y\\) 坐标，可以得到两条折线，其中 A 折线的终点为 \\((n,S)\\)，其中 \\(S=\\sum a_i\\)。 为了求出最远的能使 A 获胜的点，我们将 B 折线从 \\(x\\) 轴下方向上移，直到与 A 折线有交点。此时记 B 折线与 \\(x\\) 轴的交点为 \\((p,0)\\)，那么 \\(p\\) 就是最远能使 A 获胜的点。 我们考虑一条新的折线 C，在 A 与 B 的交点左边取折线 B，右边取折线 A，那么 C 是一条从 \\((p,0)\\) 开始到达 \\((n,S)\\) 的折线。注意到每个方案都可以对应这样的一条折线，所以我们接下来考虑所有这样的折线。 为了使 \\(p\\) 尽量大，我们一定会让折线 C 尽量“陡峭”。令 \\(k\\) 为包含 \\(p\\) 的线段，在 C 经过的线段中，除 \\(k\\) 的斜率为 \\(b_k\\) 以外，斜率上界为 \\(\\max(a_i,b_i)\\)。 事实上，我们可以达到这一上界。只要将 \\(a_i &lt; b_i\\) 的线段放在折线 A 与 B 的交点前面，\\(a_i \\ge b_i\\) 的线段放在后面即可。 于是我们考虑枚举 \\(k\\)，然后按 \\(\\max(a_i,b_i)\\) 从大到小依次加入线段，直到 \\(b_k+\\sum \\max(a_i,b_i)\\ge S\\)。这可以通过预处理前缀和实现。 时间复杂度 \\(O(n\\log n)\\)。 代码 E - Prefix Suffix Addition 题意 有一个初始为 \\(0\\) 的序列 \\(x_1,\\ldots,x_n\\)。 你可以执行若干次以下操作： 选择一个 \\(k\\ (1\\le k\\le n)\\) 和一个不降的非负整数序列 \\(c_1,\\ldots,c_k\\)，执行 \\(x_i\\gets x_i+c_i\\)。 选择一个 \\(k\\ (1\\le k\\le n)\\) 和一个不增的非负整数序列 \\(c_1,\\ldots,c_k\\)，执行 \\(x_{n-k+i}\\gets x_{n-k+i}+c_i\\)。 求使得 \\(x_i=a_i\\) 的最少操作次数。 \\(n\\le 2\\times 10^5\\) 题解 对于两次前缀加操作，若非零位置有交，一定可以通过调整仍然满足条件，并且不变劣。后缀加同理。 于是问题转化成了求两个序列 \\(\\{x_i\\},\\{y_i\\}\\)，满足： \\(x_0=y_0=x_{n+1}=y_{n+1}=0\\) \\(x_i,y_i\\ge 0\\) \\(x_i+y_i=a_i\\) 最小化 \\(\\sum [x_i&gt;x_{i+1}]+[y_i&lt;y_{i+1}]\\)。 令 \\(f_{i,j}\\) 表示前 \\(i\\) 个数，\\(x_i=j\\) 时上式的最小值。对于每个 \\(i\\)，有性质： \\(f_{i,j}\\) 单调不增； \\(0\\le f_{i,0}-f_{i,a_i}\\le 2\\)。 于是我们记录两个分界点，每次二分两个分界点进行转移即可。 时间复杂度 \\(O(n\\log n)\\)。 代码 F - Two Pieces 题意 数轴上有两个点，一开始都在原点。每次你可以执行以下两种操作之一： 选择一个点向右（正方向）移动一个单位； 将左边的点移动到右边的点的位置。 你需要执行 \\(N\\) 次操作。求最后左边的点在 \\(A\\)，右边的点在 \\(B\\) 的方案数。 两种方案被认为不同当且仅当某次操作之后两个点的坐标集合不同。 \\(N\\le 10^7\\)。 题解 考虑用 \\((x,d)\\) 来表示一个状态，其中右边的点在 \\(x\\)，两点距离为 \\(d\\)。相当于有以下三种操作： 将 \\(x,d\\) 同时加 \\(1\\)； 将 \\(d\\) 减 \\(1\\)，需要满足操作以后 \\(d\\ge 1\\)，即操作前 \\(d\\ge 2\\)； 将 \\(d\\) 置 \\(0\\)。 此时由于第二种操作限制了 \\(d\\ge 2\\)，每种操作一定互不相同，所以问题转化为求操作序列数量。 考虑确定前两个操作序列，然后插入第三种操作。 注意到第一种操作恰好执行 \\(B\\) 次，考虑枚举第二种操作的操作次数 \\(k\\)。这个方案数可以用折线法进行计算。 然后考虑插入第三种操作。注意到插入后需要满足以下两个条件： 最终 \\(d\\) 到达 \\(B-A\\)； 不会使第二种操作不合法。 注意到将一个第三种操作插入到 \\((x_i,d_i)\\) 后，会导致后面的 \\(d_j\\) 都减 \\(d_i\\)。 为了满足第一个条件，需要保证最后一个第三种操作满足 \\(d_i=A-k\\)。 为了满足第二个条件，需要保证每个第三种操作都满足 \\(d_i\\) 是后缀的严格最小值，即不存在 \\(j\\ge i\\) 满足 \\(d_j \\le d_i\\)。 也就是说，我们可以在最后一次 \\(d_i=0,1,2,\\ldots,A-k\\) 后面连续插入任意数量个第三种操作，并且需要保证 \\(d_i=A-k\\) 后面一定有一个第三种操作。用隔板法计算即可。 时间复杂度 \\(O(n)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"枚举","slug":"枚举","permalink":"https://autumnkite.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"二分","slug":"二分","permalink":"https://autumnkite.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"DISCO Presents Discovery Channel Code Contest 2020 Qual 题解","slug":"atcoder-ddcc2020-qual","date":"2020-09-15T12:45:05.000Z","updated":"2021-05-29T10:26:33.973Z","comments":true,"path":"atcoder-ddcc2020-qual/","link":"","permalink":"https://autumnkite.github.io/atcoder-ddcc2020-qual/","excerpt":"比赛地址","text":"比赛地址 A 就不写了。 B - Iron Bar Cutting 题意 有一个长度为 \\(n\\) 的序列 \\(A_1,A_2,\\ldots,A_n\\)，每次操作你可以将某个数加 \\(1\\) 或减 \\(1\\)，求使得序列满足以下条件的最小操作次数： 存在一个 \\(1\\le i &lt; n\\)，满足 \\(\\sum\\limits_{j=1}^{i}A_j=\\sum\\limits_{j=i+1}^{n}A_j\\)。 \\(n\\le 2\\times 10^5\\) 题解 当固定 \\(i\\) 时，由于可以任意加减，最小操作次数显然是前面部分的和与后面部分的和的差的绝对值。对所有 \\(i\\) 取 \\(\\min\\) 即可。 时间复杂度 \\(O(n)\\)。 代码 C - Strawberry Cakes 题意 在 \\(H\\times W\\) 的网格中有 \\(K\\) 个黑色格子，你需要构造一组将网格划分成 \\(K\\) 个矩形的方案，使得每个矩形内有恰好一个黑色格子。 \\(H,W\\le 300\\) 题解 只有一行时构造非常简单。 当每行都有至少一个黑色格子时，每行独立按只有一行的方式构造即可。 当存在一些行没有黑色格子时，只要将上一行或下一行的构造延伸到这一行即可，显然仍然是矩形。 时间复杂度 \\(O(HW)\\)。 代码 D - Digit Sum Replace 题意 有一个正整数 \\(N\\)，每次可以执行如下操作，直到 \\(N\\le 9\\)： 在 \\(N\\) 的十进制表示中，选择相邻的两位，并将这两位替换成他们的和。 如 \\(N=2378\\)，则可以执行一次操作变成 \\(578\\)，\\(2108\\) 或 \\(2315\\)。 求最多可以执行多少次操作。 \\(N\\) 的给定方式为，给定两个序列 \\(d_1,\\ldots,d_M\\) 和 \\(c_1,\\ldots,c_M\\)，\\(N\\) 的十进制表示为 \\(c_1\\) 个 \\(d_1\\)，紧接着 \\(c_2\\) 个 \\(d_2\\)，以此类推，最后有 \\(c_M\\) 个 \\(d_M\\)。 \\(M\\le 2\\times 10^5,\\sum c_i\\le 10^{15}\\) 题解 注意到一次操作会导致 \\(N\\) 的位数 \\(C\\) 和每位上的和 \\(S\\) 有以下两种变化： \\(C\\) 减 \\(1\\)，\\(S\\) 不变； \\(C\\) 不变，\\(S\\) 减 \\(9\\)。 由于最终一定有 \\(C=1,S\\le 9\\)，所以两种变化的数量是确定的，也即总操作次数是固定的，即 \\(C-1+\\lceil\\frac{S}{9}\\rceil-1\\)。 代码 E - Majority of Balls 题意 这是一个交互题。 有 \\(2N\\) 个球，编号 \\(1,\\ldots,2N\\)，其中 \\(N\\) 是奇数。每个球的颜色为红色或蓝色，红球和蓝球各有 \\(N\\) 个。 你可以询问不超过 \\(210\\) 次确定每个球的颜色。每次可以询问一个大小为 \\(N\\) 的球的子集中，红球数量是否比蓝球数量更多。 \\(N\\le 99\\) 题解 如果我们把红球看成 \\(+1\\)，蓝球看成 \\(-1\\)，每次相当于询问一个集合的和是否大于 \\(0\\)。 若 \\(1,\\ldots,N\\) 的和大于 \\(0\\)，那么 \\(N+1,\\ldots,2N\\) 的和一定小于 \\(0\\)。同理，若 \\(1,\\ldots,N\\) 的和小于 \\(0\\)，那么 \\(N+1,\\ldots,2N\\) 的和一定大于 \\(0\\)。 注意到从左往右扫描每个长度为 \\(N\\) 的区间时，和每次的变化只有 \\(+2,0,-2\\) 三种情况。那么中途一定会出现和从 \\(+1\\) 到 \\(-1\\) 的变化或从 \\(-1\\) 到 \\(+1\\) 的变化。此时我们就可以找到一个长度为 \\(N-1\\) 的，红蓝球数量相等的区间。 找到这样一个区间后，我们可以轻松地判断出每个不在该区间内球的颜色。而求出其余球的颜色后，我们又可以找到另一个大小为 \\(N-1\\) 的，不包含原区间内任意一个球的，红蓝球数量相等的集合，我们可以利用该集合确定原区间内每个球的颜色。 这样我们总共需要 \\(3N\\) 次询问，不能满足要求。 注意到对于第一部分，记 \\(S_i\\) 为 \\([i,i+N)\\) 这些球进行查询的结果，我们需要求出一个 \\(0\\le i &lt; N\\) 满足 \\(S_i\\ne S_{i+1}\\)。 假设当前我们要在 \\([L,R)\\) 中找出一个 \\(i\\) 使得 \\(S_i\\ne S_{i+1}\\)。考虑区间中点 \\(M=\\lfloor\\frac{L+R+1}{2}\\rfloor\\)。若 \\(S_M\\ne S_L\\)，那么我们可以将区间缩小到 \\([L,M)\\)；否则我们可以将区间缩小到 \\([M,R)\\)。 于是第一部分的查询数量就可以缩小到 \\(\\log_2 N\\)，可以通过本题。 代码 F - DISCOSMOS 题意 有一个 \\(H\\times W\\) 的网格。在第 \\(0\\) 秒，你需要在每个格子上放一个机器人。机器人有三种： Type-H，始终不移动。 Type-R，每一秒会向右移动，即从 \\((x,y)\\) 到 \\((x,y+1)\\)。特别地，若 \\(y=W\\)，则下一步到 \\((x,1)\\)。 Type-D，每一秒会向左移动，即从 \\((x,y)\\) 到 \\((x+1,y)\\)。特别地，若 \\(x=H\\)，则下一步到 \\((1,y)\\)。 同一时刻某个格子上可以有多个机器人。 求有多少种放置机器人的方案，使得在时刻 \\(0,T,2T,3T,\\ldots\\)（即所有 \\(T\\) 的倍数的时刻），每个格子上恰好有一个机器人。 \\(H,W,T\\le 10^9\\)。 题解 首先我们可以令 \\(n=\\frac{H}{\\gcd(H,T)},m=\\frac{W}{\\gcd(W,T)}\\)，转化成 \\(T=1\\) 的情况，只要最后将答案 \\(s\\) 变为 \\(s^{\\frac{H}{n}\\cdot\\frac{W}{m}}\\) 即可。 注意到有一些显然合法的情况： 选择若干行，这些行的每个格子都放 Type-R 的机器人。其余位置放 Type-H 的机器人。 选择若干列，这些列的每个格子都放 Type-D 的机器人。其余位置放 Type-H 的机器人。 这些情况有 \\(2^n+2^m-1\\) 种。接下来我们考虑同时有 Type-R 和 Type-D 的情况。 假设 \\(n=m\\)，下面的同余符号默认都在模 \\(n\\) 意义下同余。 对于所有 \\(i+j\\equiv k\\) 的位置 \\((i,j)\\) 的机器人，移动一步后，一定只有这些机器人可以移动到 \\(i+j\\equiv k+1\\) 的位置 \\((i,j)\\)。而这些位置上都只能有恰好一个机器人，所以 \\(i+j\\equiv k\\) 的位置 \\((i,j)\\) 上的机器人必须都是 Type-R 或都是 Type-D 的。 所以除去全部相等的两种情况，共 \\(2^n-2\\) 种情况。 对于 \\(n\\ne m\\) 的情况，可以类似说明所有 \\(i+j\\equiv k\\pmod{\\gcd(n,m)}\\) 的位置必须都是同一类型且会移动的机器人。 综上，总方案数为 \\(2^n+2^m+2^{\\gcd(n,m)}-3\\)。 时间复杂度 \\(O(\\log H+\\log W+\\log T)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"分治","slug":"分治","permalink":"https://autumnkite.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数论","slug":"数论","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"交互","slug":"交互","permalink":"https://autumnkite.github.io/tags/%E4%BA%A4%E4%BA%92/"}]},{"title":"Dwango Programming Contest 6th 题解","slug":"atcoder-dwacon6th-prelims","date":"2020-09-15T02:00:28.000Z","updated":"2021-05-29T10:26:33.975Z","comments":true,"path":"atcoder-dwacon6th-prelims/","link":"","permalink":"https://autumnkite.github.io/atcoder-dwacon6th-prelims/","excerpt":"比赛地址","text":"比赛地址 A 就不写了。 B - Fusing Slimes 题意 有 \\(N\\) 个史莱姆，从左到右第 \\(i\\) 个在 \\(x_i\\)。执行 \\(N-1\\) 次操作，对于第 \\(i\\) 次操作： 在 \\(1\\) 到 \\(N-i\\) 中等概率选择一个整数 \\(k\\)； 将从左到右第 \\(k\\) 个史莱姆向右移动到第 \\(k+1\\) 个史莱姆处，合并成一个新的史莱姆。 求期望移动距离乘 \\((N-1)!\\) 的值，对 \\(10^9+7\\) 取模。合并后的史莱姆只算一个。 \\(N\\le 10^5\\) 题解 令 \\(f_i\\) 表示初始有 \\(i+1\\) 个史莱姆时，执行 \\(i\\) 次操作后，最后一段的期望贡献。分两种情况： 第一次选择的是 \\(i\\)。此时最后一段被多贡献了一次，转化成 \\(i\\) 个史莱姆的子问题，所以贡献为 \\(\\frac{1}{i}(f_{i-1}+1)\\)。 第一次选择的不是 \\(i\\)。此时最后一段没有贡献，仍然转化成了 \\(i\\) 个史莱姆的子问题，所以贡献为 \\(\\frac{i-1}{i}f_{i-1}\\)。 将两种情况的贡献相加，得到 \\(f_i=f_{i-1}+\\frac{1}{i}\\)。 考虑如何计算 \\(x_i\\) 到 \\(x_{i+1}\\) 这一段的贡献。此时我们只需要考虑前 \\(i\\) 个史莱姆的相对操作顺序，而不需要考虑 \\(i+1\\) 到 \\(n\\) 这些史莱姆的操作顺序，所以期望贡献次数就是 \\(f_i\\)。 时间复杂度 \\(O(n)\\)。 代码 C - Cookie Distribution 题意 有 \\(N\\) 个数 \\(c_1,c_2,\\ldots,c_N\\)，初始为 \\(0\\)。有 \\(K\\) 次操作，第 \\(i\\) 次操作会选择 \\(N\\) 个数中的恰好 \\(a_i\\) 个加 \\(1\\)。求 \\(\\prod\\limits_{i=1}^{N} c_i\\) 的期望乘 \\(\\prod\\limits_{i=1}^{K}\\begin{pmatrix}N\\\\a_i\\end{pmatrix}\\) 的值。 \\(N\\le 1000,K\\le 20\\) 题解 考虑 \\(\\prod\\limits_{i=1}^{N} c_i\\) 的组合意义，即为对于每个 \\(i\\)，在所有选择到 \\(i\\) 的操作中选择一个的方案数。 那么我们可以考虑先对于每个 \\(i\\)，固定最终方案中选择的操作，记第 \\(j\\) 个操作被选择了 \\(x_j\\) 次。 此时方案数很好算，即 \\[\\prod\\limits_{i=1}^{K}\\begin{pmatrix}N-x_i\\\\a_i-x_i\\end{pmatrix}\\] 假设只固定 \\(x_i\\)，而没有固定选择的方案，那么需要乘上选择的方案数 \\[\\frac{N!}{\\prod\\limits_{i=1}^{K} x_i!}\\] 直接对 \\(x_i\\) 进行 DP 即可。 时间复杂度 \\(O(N^2K)\\)。 代码 D - Arrangement 题意 给定 \\(a_1,a_2,\\ldots,a_N\\)，求一个字典序最小的 \\(1\\) 到 \\(N\\) 的排列 \\(b_i\\)，满足以下条件： 对于所有 \\(1\\le i\\le N-1\\)，\\(a_{b_i}\\ne b_{i+1}\\)。 \\(N\\le 10^5,a_i\\ne i\\) 题解 \\(N=3\\) 时可以通过讨论各种可能情况证明一定有解，而 \\(N&gt;3\\) 时可以通过构造归纳证明。下面我们直接构造一组字典序最小的解。 考虑逐位确定，在逐位确定的过程中，若我们将 \\(i\\) 向 \\(a_i\\) 连边，当前还未填的数形成的图一定是一个包含基环内向树和树的森林。 若存在一个点的入度等于当前总点数减 \\(1\\)，即其他所有点都连向该点，那么此时必须选择这个点，否则我们选择能填的编号最小的点。 注意到这样填唯一会出问题的情况是剩下两个数没有填而这两个数形成了一个大小为 \\(2\\) 的环。但是因为我们证明了 \\(N=3\\) 时一定可行，此时限制比一般的 \\(N=3\\) 的情况更少，所以在剩下 \\(3\\) 个数时一定有合法解。 所以我们在剩下 \\(3\\) 个数时按字典序枚举所有 \\(3!\\) 种排列判断是否合法即可。 时间复杂度 \\(O(N)\\) 或 \\(O(N\\log N)\\)。 代码 E - Span Covering 题意 你需要在数轴上 \\([0,X)\\) 这段区间中放 \\(N\\) 个有标号的区间。 放第 \\(i\\) 个区间时，你需要选择一个 \\(0\\le j\\le X-L_i\\) 的整数 \\(j\\)，然后第 \\(i\\) 个区间为 \\([j,j+L_i)\\)。 求覆盖 \\([0,X)\\) 中每个点的方案数。 \\(N\\le 100,X\\le 500\\) 题解 有一个简单的容斥想法是，钦定 \\(k\\) 个位置 \\(x_1,x_2,\\ldots,x_k\\) 不被覆盖，假设 \\(x_0=-1,x_{k+1}=X\\)，那么贡献是 \\[(-1)^k\\prod_{j=1}^{N}\\left(\\sum_{i=1}^{k+1}\\max(0,x_i-x_{i-1}-L_j)\\right)\\] 假设 \\(L_j=i\\) 的 \\(j\\ (1\\le j\\le N)\\) 的数量为 \\(c_i\\)。记上述容斥中 \\(x_j-x_{j-1}-1=i\\) 的 \\(j\\ (1\\le j\\le k+1)\\) 的数量为 \\(a_i\\)，那么上面的贡献式子也可以写成 \\[(-1)^{X-\\sum a_i}\\prod_{i=1}^{X}\\left(\\sum_{j=i}^{X}a_j(j+1-i)\\right)^{c_i}\\] 我们考虑钦定 \\(a_1,a_2,\\ldots,a_X\\)，只需要在上述式子中再乘上 \\(x_1,x_2,\\ldots,x_k\\) 的方案数，即 \\[ \\left(\\sum_{i=1}^{X} a_i\\right)!\\prod_{i=1}^{X}\\frac{1}{a_i!}\\begin{pmatrix}X-\\sum ia_i+1\\\\\\sum a_i\\end{pmatrix} \\] 整理后得到贡献为 \\[ \\boxed{\\prod_{i=1}^{X}\\frac{1}{a_i!}\\left(\\sum_{j=i}^{X}a_j(j+1-i)\\right)^{c_i}}\\cdot\\left(\\sum_{i=1}^{X} a_i\\right)!\\cdot(-1)^{X-\\sum a_i}\\cdot \\begin{pmatrix}X-\\sum ia_i+1\\\\\\sum a_i\\end{pmatrix} \\] 考虑从后往前对序列 \\(a\\) DP。令 \\(f_{i,j,k}\\) 表示固定 \\(a_i,a_{i+1},\\ldots,a_X\\)，\\(\\sum a_i=j\\)，\\(\\sum ia_i=k\\) 时，画框部分式子的和。后面部分可以在最后计算答案是加入贡献。转移为 \\[ f_{i,j,k}=\\sum_{l=0}^{j} f_{i+1,j-l,k-i\\cdot l}\\cdot\\frac{1}{l!}\\cdot (k-(i-1)\\cdot j)^{c_i} \\] 注意到有 \\(k\\ge ij,l\\le j\\) 的限制，所以合法的 \\((i,j,k,l)\\) 四元组数量约为 \\[X\\sum_{i=1}^{X} \\frac{X^2}{i^2}=O(X^3)\\] 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"概率","slug":"概率","permalink":"https://autumnkite.github.io/tags/%E6%A6%82%E7%8E%87/"},{"name":"期望","slug":"期望","permalink":"https://autumnkite.github.io/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"AtCoder Grand Contest 041 题解","slug":"atcoder-agc041","date":"2020-09-13T23:52:48.000Z","updated":"2021-05-29T10:26:33.970Z","comments":true,"path":"atcoder-agc041/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc041/","excerpt":"比赛地址","text":"比赛地址 A - Table Tennis Training 题意 有 \\(n\\) 张桌子，编号 \\(1\\) 到 \\(n\\)，有两个人，一个在桌子 \\(A\\)，另一个在桌子 \\(B\\)。 每一个人每次可以向左或向右移动，但不能不动。特别地，如果在桌子 \\(1\\)，向左移动则仍留在桌子 \\(1\\)；如果在桌子 \\(n\\)，向右移动则仍留在桌子 \\(n\\)。 问最少多少次两个人可以移动到同一张桌子。 \\(n\\le 10^{18}\\) 题解 分两种情况： \\(A\\) 与 \\(B\\) 奇偶性相同。此时每个人往另一个人的方向移动即可。 \\(A\\) 与 \\(B\\) 奇偶性不同。又分两种情况： 两个人同时向 \\(1\\) 移动，当左边的人移动到 \\(1\\) 时，在 \\(1\\) 停留一次，然后向右移动；右边的人则保持向左移动。 两个人同时向 \\(n\\) 移动，情况同理。 代码 B - Voting Judges 题意 有 \\(N\\) 个数 \\(A_i\\)，执行恰好 \\(M\\) 次操作，每次操作选择恰好 \\(V\\) 个数加 \\(1\\)。然后降序排列，有相同时顺序任意。 求有多少个数有可能能进入最终的前 \\(P\\) 个。 \\(N\\le 10^5,M\\le 10^9\\) 题解 将 \\(A_i\\) 从大到小排序。前 \\(P\\) 个显然可以，考虑对于 \\(P &lt; i \\le N\\) 判断是否可以进入前 \\(P\\) 个。 首先每次加 \\(1\\) 的数中，前 \\(P-1\\) 个一定选，\\(i\\) 和 \\(i\\) 之后的数也一定选，但是此时可能仍然不足 \\(V\\) 个数。 此时我们每次需要选择一些中间的数补足 \\(V\\) 个。假设还需要 \\(R\\) 个数，则充要条件是 \\[\\sum_{j=P}^{i-1}(A_i+M-A_j)\\le MR\\] 必要性显然，充分性可以通过每次选最小的 \\(R\\) 个数证明。 时间复杂度瓶颈在于排序。 代码 C - Domino Quality 题意 在 \\(N\\times N\\) 的网格中放一些多米诺骨牌。至少放一个骨牌，每个格子最多只能被一个骨牌覆盖，可以不被覆盖。对于网格的每一行，定义质量为覆盖该行中至少一个格子的骨牌数量。列同理。 构造一组方案使得所有行、列的质量相等。 \\(N\\le 1000\\) 题解 发现 \\(N=4,5,6,7\\) 时都可以构造出行列质量为 \\(3\\) 的方案。于是我们在对角线上铺上这些方案即可。 \\(N=3\\) 的时候可以构造出质量为 \\(1\\) 的方案，需要特判。 代码 D - Problem Scores 题意 求满足以下条件的长度为 \\(N\\) 的序列 \\(A\\) 的数量： \\(1\\le A_1\\le A_2\\le A_3\\le \\ldots \\le A_N\\le N\\) 对于所有 \\(1\\le k &lt; N\\)，都满足序列 \\(A\\) 的任意一个大小为 \\(k\\) 的子集和严格小于任意一个大小为 \\(k+1\\) 的子集和。 对 \\(M\\) 取模。 \\(N\\le 5000,9\\times 10^8 &lt; M &lt; 10^9\\)，\\(M\\) 是质数。 题解 显然只要 \\(k=\\lfloor\\frac{n-1}{2}\\rfloor\\) 时满足条件即可。 令 \\(t=\\sum\\limits_{i=1}^{k+1} A_i-\\sum\\limits_{i=n-k+1}^{n}A_i\\)，即我们需要满足 \\(t&gt;0\\)。 于是考虑将原序列差分，设为 \\(x_1,x_2,\\ldots,x_n\\)，那么对 \\(t\\) 的贡献分别为 \\[w=\\{1,0,-1,-2,-3,\\ldots,-3,-2,-1\\}\\] 令 \\(A=\\sum\\limits_{i=2}^{n}x_i,B=-\\sum\\limits_{i=2}^{n}w_ix_i\\)，则 \\(B+1\\le x_1\\le n-A\\)，即贡献为 \\(n-A-B\\)。 于是我们只要考虑 DP \\(A+B=d\\) 的方案数。完全背包即可。 时间复杂度 \\(O(n^2)\\)。 E - Balancing Network 题意 一个网络中有水平的 \\(n\\) 根导线，以及 \\(m\\) 个竖直的平衡器。平衡器从左往右依次编号 \\(1\\) 到 \\(m\\)。第 \\(i\\) 个平衡器连接导线 \\(x_i\\) 和 \\(y_i\\)，其中 \\(x_i &lt; y_i\\)。 你可以为每个平衡器确定一个方向，向上或向下。 有一个点从某根导线，所有平衡器左边的某一位置开始，向右运动，当经过第 \\(i\\) 个平衡器时： 若该点在导线 \\(x_i\\) 且平衡器向下，则移动到导线 \\(y_i\\) 的对应位置，继续向右运动。 若该点在导线 \\(y_i\\) 且平衡器向上，则移动到导线 \\(x_i\\) 的对应位置，继续向右运动。 否则保持向右运动。 若从任意导线出发，最终都能到达同一根导线的无穷远处，则称该网络是均衡的，否则是不均衡的。 给定参数 \\(T\\)，若 \\(T=1\\) 你需要构造一个均衡的网络，\\(T=2\\) 你需要构造一个不均衡的网络。 \\(n\\le 5\\times 10^4,m\\le 10^5,T\\in \\{1,2\\}\\) 题解 对于 \\(T=1\\) 的情况，假设我们已经确定终点 \\(w\\)，我们从后往前依次加入平衡器，同时维护 \\(A_i\\) 表示第 \\(i\\) 个点是否可以到达终点 \\(w\\)。初始时 \\(A_w=1\\)。 对于当前的平衡器 \\((x,y)\\)，分四种情况： \\(A_x=1,A_y=1\\)，此时平衡器如何定向都不会改变状态。 \\(A_x=0,A_y=0\\)，同理不会改变状态。 \\(A_x=0,A_y=1\\)，此时将平衡器方向定为 \\(x\\to y\\) 可以使得 \\(A_x=1\\)。 \\(A_x=1,A_y=0\\)，同理将平衡器方向定为 \\(y\\to x\\) 可以使得 \\(A_y=1\\)。 发现这是一个将 \\(A_x,A_y\\) 都置为原来 \\(A_x,A_y\\) 的二进制或值的过程。 于是我们可以用 bitset 优化。时间复杂度 \\(O(\\frac{nm}{w})\\)。 对于 \\(T=2\\) 的情况，显然 \\(n\\le 2\\) 一定无解，否则可以通过构造证明一定有解。 仍然考虑从后往前考虑每个平衡器的方向。 记录 \\(P_x\\) 表示起点为 \\(x\\) 时的终点，\\(S_x\\) 表示终点为 \\(x\\) 的起点数量。我们可以保证任意时刻 \\(S_x &lt; n\\)。 对于当前平衡器 \\((x,y)\\)，若 \\(S_{P_x}=n-1\\)，那么如果此时将平衡器定向为 \\(y\\to x\\)，会导致 \\(S_{P_x}=n\\)。但是因为有 \\(\\sum S_i=n\\)，所以此时有 \\(S_{P_y}\\le 1 &lt; n-1\\)，于是定向为 \\(x\\to y\\) 即可。\\(S_{P_y}=n-1\\) 同理。 时间复杂度 \\(O(n+m)\\)。 代码 F - Histogram Rooks 题意 有一个 \\(n\\) 列的棋盘，第 \\(i\\) 列从底向上有 \\(h_i\\) 个格子。 你可以在棋盘上放一些车，使得对于棋盘上每个格子都能被某个车覆盖到。 一个车可以覆盖某个格子当且仅当它们在同一行或同一列，且中间的格子都存在。 求放置车的方案数。对 \\(998244353\\) 取模。 \\(1\\le h_i\\le N\\le 400\\) 题解 一个朴素的容斥是，我们可以求出钦定 \\(k\\) 个位置不被车覆盖，其他位置没有限制的方案数，乘上容斥系数 \\((-1)^k\\) 即为对答案的贡献。 考虑建出笛卡尔树后 DP。用 \\(f_{u,i}\\) 表示 \\(u\\) 表示的列区间中，有 \\(i\\) 列中有钦定不覆盖的位置时，对答案的贡献（即容斥系数乘方案数之和）。 转移时，先可以考虑第 \\(u\\) 列是否有钦定不覆盖的位置将左右子树合并，然后我们在底部加入若干行。当加入一行时，假设 \\(u\\) 表示的列区间长度为 \\(L\\)，则转移分两种情况： 当前行中没有格子被钦定。此时该行中可以任意放车而不会有影响，方案数为 \\(2^{L-i}\\)，容斥系数为 \\(1\\)。 当前行中有格子被钦定。此时该行中一定不能放车，且被钦定的格子一定是那 \\(i\\) 列的一个子集，所以方案数为 \\(1\\)，容斥系数为 \\(\\sum\\limits_{k=1}^{i} (-1)^k\\begin{pmatrix}i\\\\k\\end{pmatrix}=-[i\\ne 0]\\)。 然而，这样的 DP 状态设计和转移有一个问题，我们并不能保证这 \\(i\\) 列每一列都有被钦定的位置。 这仍然可以通过容斥解决。考虑加入一维 \\(j\\) 表示 \\(i\\) 列中有 \\(j\\) 列不存在被钦定的位置。DP 的转移第一种不变，第二种变为选择其余 \\(i-j\\) 列的一个子集，容斥系数变为 \\(-[i\\ne j]\\)。 注意到其实我们只需要在 DP 状态中记录 \\(j\\) 是否等于 \\(i\\)，并将容斥系数 \\((-1)^j\\) 压入 DP 值中，而不需要记录 \\(j\\) 的具体数值。 时间复杂度 \\(O(N^2)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"搜索","slug":"搜索","permalink":"https://autumnkite.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"背包","slug":"背包","permalink":"https://autumnkite.github.io/tags/%E8%83%8C%E5%8C%85/"},{"name":"bitset","slug":"bitset","permalink":"https://autumnkite.github.io/tags/bitset/"}]},{"title":"AtCoder Grand Contest 043 题解","slug":"atcoder-agc043","date":"2020-09-10T03:04:24.000Z","updated":"2020-09-13T05:52:04.547Z","comments":true,"path":"atcoder-agc043/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc043/","excerpt":"比赛地址","text":"比赛地址 A - Range Flip Find Route 题意 给定一个 \\(H\\times W\\) 的黑白矩阵 \\(A\\)，你需要执行若干次以下操作使得 \\((1,1)\\) 可以通过向下、向右且只走白色格子到达 \\((H,W)\\)（起点、终点也必须是白色）： 将一个连续子矩阵中每个格子反色。 求最少操作次数。 \\(H,W\\le 100\\) 题解 考虑一条 \\((1,1)\\) 到 \\((H,W)\\) 只向下、向右的路径。对于路径上一个黑色的连续段，由于路径是只向下、向右的，我们一定可以通过一次操作把改路径上的这个黑色连续段变成白色。 那么我们只需要选择黑色连续段数量最少的路径。DP 即可。 时间复杂度 \\(O(HW)\\)。 代码 B - 123 Triangle 题意 给定一个只有 \\(1,2,3\\) 的序列 \\(a_1,a_2,\\ldots,a_n\\)。定义 \\(x_{i,j}\\) 为 \\(x_{1,j}=a_j\\) \\(x_{i,j}=|x_{i-1,j}-x_{i-1,j+1}|\\ (i &gt; 1)\\) 求 \\(x_{n,1}\\)。 \\(n\\le 10^6\\) 题解 首先我们可以把 \\(a_i\\) 都减 \\(1\\) 变成 \\(0,1,2\\)，显然对答案没有影响。 考虑只有 \\(0,1\\) 时，显然中间过程也只有 \\(0,1\\)。而对于两个 \\(a,b\\in \\{0,1\\}\\)，有 \\(|a-b|=(a+b)\\bmod 2\\)。于是 \\(a_i\\) 对答案的贡献为 \\(\\begin{pmatrix}n-1\\\\i-1\\end{pmatrix}\\)，在模 \\(2\\) 意义下使用卢卡斯定理计算即可。 只有 \\(0,2\\) 时，发现我们可以把 \\(a_i\\) 都除以 \\(2\\)，转化成只有 \\(0,1\\) 的问题，最后乘 \\(2\\) 即可。 包含 \\(1\\) 时，在出现全 \\(1\\) 之前，所有状态都一定包含至少一个 \\(1\\)；而全 \\(1\\) 之后的所有状态一定是全 \\(0\\)。所以最终答案一定不可能是 \\(2\\)。于是我们把 \\(2\\) 变为 \\(0\\) 后用只有 \\(0,1\\) 的方法计算即可。 时间复杂度 \\(O(n\\log n)\\)。 代码 C - Giant Graph 题意 给定三个 \\(N\\) 个点分别为 \\(M_1,M_2,M_3\\) 条边的简单无向图 \\(X,Y,Z\\)，记每张图的点分别为 \\(x_1,\\ldots,x_n,y_1,\\ldots,y_n,z_1,\\ldots,z_n\\)。 定义 \\(X\\times Y\\times Z\\) 为一个由所有 \\(N^3\\) 个三元组 \\((x_i,y_j,z_k)\\) 作为节点的无向图，边的生成方式如下： 对于 \\(X\\) 中的所有边 \\((x_u,x_v)\\) 和所有 \\(w,l\\)，\\((x_u,y_w,z_l)\\) 和 \\((x_v,y_w,z_l)\\) 连边； 对于 \\(Y\\) 中的所有边 \\((y_u,y_v)\\) 和所有 \\(w,l\\)，\\((x_w,y_u,z_l)\\) 和 \\((x_w,y_v,z_l)\\) 连边； 对于 \\(Z\\) 中的所有边 \\((z_u,z_v)\\) 和所有 \\(w,l\\)，\\((x_w,y_l,z_u)\\) 和 \\((x_w,y_l,z_v)\\) 连边。 一个节点 \\((x_i,y_j,z_k)\\) 的权值为 \\((10^{18})^{i+j+k}\\)。 求 \\(X\\times Y\\times Z\\) 的最大带权独立集。 \\(N\\le 10^5,M_1+M_2+M_3\\le 10^5\\)。 题解 考虑一个 \\(N^3\\) 的做法，我们将 \\((x_i,y_j,z_k)\\) 按 \\(i+j+k\\) 从大到小排序，依次加入最大独立集。这样贪心显然是对的。 我们可以把这个贪心写成一个类似于 DP 的形式，即 \\(f_{i,j,k}\\) 表示 \\((x_i,y_j,z_k)\\) 是否被选入最大独立集。\\((x_i,y_j,z_k)\\) 被选入最大独立集当且仅当 \\((x_i,y_j,z_k)\\) 的后继状态都没有被选入最大独立集，其中后继状态是指与 \\((x_i,y_j,z_k)\\) 有边且权值大于该状态权值的状态。 观察 DP 的转移，发现这与博弈论的转移非常相似。于是我们可以把问题转化为一个游戏： 有三张无向图 \\(X,Y,Z\\)，初始时在 \\(x_1,y_1,z_1\\) 有一颗棋子。两个人轮流操作，每次选择一张图上的棋子移动到相邻的且编号更大的节点，若无法移动则输。 选入最大独立集的点恰好是所有后手必胜的状态。 注意到这一游戏是三个游戏的和，SG 函数值等于三个游戏的 SG 值异或的结果。而三个游戏各自的 SG 值可以 \\(O(N+M)\\) 求出。 我们现在需要对所有满足 \\(\\operatorname{SG}(x_i)\\oplus \\operatorname{SG}(y_j)\\oplus \\operatorname{SG}(z_k)=0\\) 的 \\(i,j,k\\)，对 \\(10^{18(i+j+k)}\\) 求和。 注意到单个游戏的 SG 函数值在 \\(O(\\sqrt{M})\\) 级别，所以我们枚举其中两个 SG 值就可以唯一确定另一个。时间复杂度 \\(O(N+M)\\)。 代码 D - Merge Triplets 题意 求可以通过以下方式构造的本质不同的 \\(1\\) 到 \\(3n\\) 的排列 \\(P\\) 的数量： 构造 \\(N\\) 个长度为 \\(3\\) 的序列 \\(A_1,A_2,\\ldots,A_n\\)，满足 \\(1\\) 到 \\(3n\\) 的每个数恰好出现一次。 求出所有非空序列第一个元素的最小值 \\(x\\)，将 \\(x\\) 从序列中删去，加入 \\(P\\) 的末尾。 \\(n\\le 2000\\) 题解 考虑对于一个序列 \\(x_1,x_2,x_3\\)，若 \\(x_1 &gt; x_2\\)，则选了 \\(x_1\\) 以后一定会立刻选 \\(x_2\\)；其他两对类似。 于是我们可以将这样的一个序列分成若干小块，每个小块满足块首元素是块内最大值，并且满足块首元素递增。 由于我们保证了单个序列中块首元素递增，那么最终排列一定是所有小块按块首元素递增排列的结果。 这就意味着，对于一个合法排列，我们一定可以把该排列分成若干块，满足： 每块元素数量不超过 \\(3\\)； 块首元素是块内最大值； 块首元素递增排列。 但是满足以上条件的排列不一定合法，因为不一定能还原出原来的 \\(n\\) 个序列。 但是我们发现，单个序列的分块方式一定只有 \\(3;1,2;2,1;1,1,1\\) 四种，可以发现 \\(2\\) 的数量一定不超过 \\(1\\) 的数量。同时我们发现，在满足以上三个条件的情况下，只要满足该条件，一定可以构造出原来的 \\(n\\) 个序列。 所以我们只要在上述三个条件的基础上加上这个条件就构成了一个排列合法的充要条件。 假设块大小依次为 \\(a_1,a_2,\\ldots,a_k\\)，我们考虑计算排列合法的概率。我们发现我们需要保证第 \\(k\\) 块的块首元素是整个排列的最大值，而每个位置成为排列最大值的概率是相同的，所以概率为 \\(\\frac{1}{n}\\)。然后我们发现剩下的位置形成的排列仍然是等概率的，所以我们可以把它变成一个 \\(n-a_k\\) 的子问题。于是，合法的概率为 \\[\\prod_{i=1}^{k}\\frac{1}{\\sum\\limits_{j=1}^{i}a_j}\\] 排列数量只要再乘上 \\(n!\\) 即可。 于是我们就可以 DP 了。用 \\(f_{i,j}\\) 表示前 \\(i\\) 个位置，\\(1\\) 的数量与 \\(2\\) 的数量的差为 \\(j\\)。转移只要考虑下一块长度即可。 时间复杂度 \\(O(n^2)\\)。 代码 E - Topology 题意 平面上有 \\(n\\) 个点，第 \\(i\\ (0\\le i &lt; n)\\) 个点在 \\((i+0.5,0.5)\\)。对于这 \\(n\\) 个点的每一个子集 \\(S\\) 都给出了 \\(A_S\\in \\{0,1\\}\\)。 你需要构造一个闭合曲线 \\(C\\) 满足对于所有 \\(n\\) 个点的子集 \\(S\\)，都有： \\(C\\) 能在不经过点集 \\(S\\) 的情况下连续移动到 \\(x\\) 轴下方当且仅当 \\(A_S=1\\)。 对「闭合曲线」、「不经过点集 \\(S\\) 的连续移动」的形式化定义以及输出方式参见原题。 \\(n\\le 8\\) 题解 如果存在一个集合 \\(S\\) 满足 \\(A_S=1\\) 但存在它的一个子集 \\(S&#39;\\) 满足 \\(A_{S&#39;}=0\\)，那么一定不合法。我们可以通过构造证明其余情况一定合法。 考虑从第 \\(i\\) 个点向上射出一条射线 \\(u_i\\)，向下射出一条射线 \\(d_i\\)。 于是我们可以把一条曲线依次经过的射线编号顺次连接生成一个字符串，同样我们也可以根据这样的字符串生成一条曲线。 如样例 2 中的曲线在 \\(S=\\{0,1\\}\\) 时可以记为 \\(d_1u_1u_0d_0\\)。 我们可以发现曲线能移动到 \\(x\\) 轴下方当且仅当生成的字符串满足： 你可以通过不断删除连续两个相同的字符使得字符串成为空串。 接下来我们考虑 \\(A=11\\ldots 110\\) 的情况，即只有 \\(S\\) 为全集时不能移动到 \\(x\\) 轴下方。我们可以递归地构造这样的字符串，记为 \\(a_n\\)： 当 \\(n=1\\) 时，\\(a_n=u_0d_0\\)。 当 \\(n\\ge 2\\) 时，令 \\(s\\) 为 \\(a_{n-1}\\) 中所有字符的下标加 \\(1\\) 得到的字符串，构造 \\(a_n=u_0su_0d_0s^{-1}d_0\\)，其中 \\(s^{-1}\\) 表示 \\(s\\) 翻转后得到的字符串。 例如： \\(a_1=u_0d_0\\) \\(a_2=u_0(u_1d_1)u_0d_0(d_1u_1)d_0\\) \\(a_3=u_0(u_1(u_2d_2)u_1d_1(d_2u_2)d_1)u_0d_0(d_1(u_2d_2)d_1u_1(d_2u_2)u_1)d_0\\) 证明可以通过归纳证明，分别考虑 \\(0\\not\\in S\\) 和 \\(0\\in S,\\exists 1\\le i &lt; n,i\\not\\in S\\) 两种情况进行证明即可。 对于一般情况，我们只要对于所有满足 \\(A_S=0\\) 且对于所有 \\(S&#39;\\in S\\) 都有 \\(A_{S&#39;}=1\\) 的集合 \\(S\\) 进行类似构造得到的字符串拼接起来即可。 一个非常宽的上界是 \\(4n\\cdot 3^n\\)，可以通过。 代码 F - Jewelry Box 题意 有 \\(N\\) 个商店，第 \\(i\\) 个商店卖 \\(K_i\\) 种珠宝，第 \\(i\\) 个商店的第 \\(j\\) 个珠宝重量为 \\(S_{i,j}\\)，价格为 \\(P_{i,j}\\)，数量为 \\(C_{i,j}\\)。 一个珠宝盒被称为好的当且仅当满足以下条件： 对于每个商店，珠宝盒中都恰好包含一颗该商店的珠宝。 对于所有 \\(1\\le i\\le M\\)，满足珠宝盒中商店 \\(V_i\\) 的珠宝重量小于等于商店 \\(U_i\\) 的珠宝重量加 \\(W_i\\)。 \\(Q\\) 次询问，每次询问 \\(A_i\\)，表示制作 \\(A_i\\) 个好的珠宝盒的最小总价格。 \\(N,K_i\\le 30,S_{i,j},M\\le 50,Q\\le 10^5,W_i\\le 10^9,P_{i,j}\\le 30,C_{i,j}\\le 10^{12},A_i\\le 3\\times 10^{13}\\) 题解 首先考虑只有一组询问的情况，即询问制作 \\(A\\) 个好的珠宝盒的最小价格。 假设对于每个商店我们已经选出了 \\(A\\) 个珠宝。那么我们贪心地考虑，一定是最小的放在第一个珠宝盒内，第二小的放在第二个珠宝盒内，以此类推。 于是我们可以对每个商店的珠宝按重量从小到大排序，然后记 \\(x_{i,j}\\) 为第 \\(i\\) 个商店中前 \\(j\\) 个物品选了几个。 对于一个限制 \\((u,v,w)\\)，对于 \\(1\\le j\\le K_v\\)，令 \\(k\\) 为 \\(S_{u,k}+W_i\\ge S_{v,j}\\) 的最小的 \\(k\\)，不存在则令 \\(k=K_u+1\\)。那么这一限制等价于对于所有 \\(j\\) 都满足 \\(x_{v,j-1}\\ge x_{u,k-1}\\)。 于是我们把问题转化成了一个线性规划问题： minimize \\(\\sum P_{i,j}(x_{i,j}-x_{i,j-1})\\) subject to \\[ \\begin{cases} x_{i,j}\\ge x_{i,j-1}\\\\ x_{i,j}\\le x_{i,j-1}+C_{i,j}\\\\ x_{i,0}=0\\\\ x_{i,K_i}=A\\\\ x_{u,k}\\le x_{v,j}\\\\ x_{i,j}\\ge 0 \\end{cases} \\] 注意到求价格时是相邻两项作差，那么我们无需保证 \\(x_{i,0}=0,x_{i,K_i}=A\\)，只需要保证 \\(x_{i,K_i}-x_{i,0}=A\\) 即可，于是可以拆成 \\(x_{i,K_i}-x_{i,0}\\le A\\) 和 \\(x_{i,K_i}-x_{i,0}\\ge A\\) 两个限制。注意到 \\(x_{i,K_i}-x_{i,0} &gt; A\\) 时一定不优，所以我们可以前一个限制。 于是我们可以把问题转化成标准型： minimize \\(\\sum x_{i,j}(P_{i,j}-P_{i,j+1})\\) subject to \\[ \\begin{cases} x_{i,j}-x_{i,j-1}\\ge 0\\\\ x_{i,j-1}-x_{i,j}\\ge -C_{i,j}\\\\ x_{i,K_i}-x_{i,0}\\ge A\\\\ x_{v,j}-x_{u,k}\\ge 0\\\\ x_{i,j}\\ge 0 \\end{cases} \\] 注意到系数矩阵的每行都有恰好一个 \\(+1\\) 和一个 \\(-1\\)，于是我们可以把问题对偶，系数矩阵的每一列都有恰好一个 \\(+1\\) 和一个 \\(-1\\)。 由于左边的和为 \\(0\\)，右边的和也为 \\(0\\)，而每个限制都是小于等于，那么所有限制一定都是取到等于。 于是我们可以根据网络流的流量守恒建立费用流模型。 图中的一个点对应对偶后的一个方程，也就是原问题的一个变量；图中的一条边对应对偶后的一个变量，也就是原问题的一个限制。对于原问题中 \\(x-y\\ge w\\) 的限制，则从 \\(x\\) 向 \\(y\\) 连一条流量为 \\(\\infty\\)，费用为 \\(w\\) 的边；对于原问题最小化的式子中变量 \\(x\\) 的系数 \\(c\\)，若 \\(c&gt;0\\)，则从源点向 \\(x\\) 连一条流量为 \\(c\\)，费用为 \\(0\\) 的边，否则从 \\(x\\) 向汇点连一条流量为 \\(c\\)，费用为 \\(0\\) 的边，特别地，这些边必须满流。 我们可以首先利用所有 \\(x_{i,j}\\) 向 \\(x_{i,j-1}\\) 连的 \\((\\infty,0)\\) 的边，将所有需要满流的边满流。可以发现这一定可以做到，并且流完以后得到的反向边为 \\(x_{i,j-1}\\) 向 \\(x_{i,j}\\) 的流量为 \\(P_{i,j}\\)，费用为 \\(0\\) 的边。 于是我们可以把源汇点去掉，只保留这些反向边，变成一个无源汇最大费用可行流的问题。 注意到边权与 \\(A\\) 有关的只有 \\(x_{i,K_i}\\) 向 \\(x_{i,0}\\) 连的流量为 \\(\\infty\\)，费用为 \\(A\\) 的边。考虑将所有 \\(x_{i,0}\\) 缩成一个点 \\(S\\)，\\(x_{i,K_i}\\) 缩成一个点 \\(T\\)，就只有一条 \\(T\\) 到 \\(S\\) 的 \\((\\infty,A)\\) 的边了。 为了使费用最大，每一次增广一定是从 \\(S\\) 流到 \\(T\\) 再经过这条费用为 \\(A\\) 的边流回 \\(S\\)。条件是 \\(S\\) 到 \\(T\\) 的这条增广路的费用 \\(\\ge -A\\)。 根据费用流每次增广的凸性，我们可以直接二分得到增广次数。 时间复杂度 \\(O(\\operatorname{MCMF}(\\sum K_i,\\sum K_i+\\sum K_{V_i})+Q\\log \\sum P_{i,j})\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"网络流","slug":"网络流","permalink":"https://autumnkite.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"博弈","slug":"博弈","permalink":"https://autumnkite.github.io/tags/%E5%8D%9A%E5%BC%88/"},{"name":"二分","slug":"二分","permalink":"https://autumnkite.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"费用流","slug":"费用流","permalink":"https://autumnkite.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"Lucas定理","slug":"Lucas定理","permalink":"https://autumnkite.github.io/tags/Lucas%E5%AE%9A%E7%90%86/"},{"name":"SG函数","slug":"SG函数","permalink":"https://autumnkite.github.io/tags/SG%E5%87%BD%E6%95%B0/"},{"name":"线性规划","slug":"线性规划","permalink":"https://autumnkite.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"},{"name":"对偶","slug":"对偶","permalink":"https://autumnkite.github.io/tags/%E5%AF%B9%E5%81%B6/"},{"name":"凸包","slug":"凸包","permalink":"https://autumnkite.github.io/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"Keyence Programming Contest 2020 题解","slug":"atcoder-keyence2020","date":"2020-09-10T02:00:48.000Z","updated":"2021-05-29T10:26:33.979Z","comments":true,"path":"atcoder-keyence2020/","link":"","permalink":"https://autumnkite.github.io/atcoder-keyence2020/","excerpt":"比赛地址","text":"比赛地址 来不及了，ABC 不写了。 D - Swap and Flip 题意 有 \\(n\\) 张卡片从 \\(1\\) 到 \\(n\\) 排列，第 \\(i\\) 张正面写着 \\(A_i\\)，反面写着 \\(B_i\\)，一开始都正面朝上。 你每次操作可以交换相邻两张卡片的位置并将这两张卡片翻面。 求使得朝上那面的数字不降的最小操作次数，或输出无解。 \\(n\\le 18\\) 题解 假设最终序列中第 \\(i\\) 张卡片是原来的第 \\(p_i\\) 张卡片，那么如果 \\(i\\) 与 \\(p_i\\) 奇偶性相同，则朝上的是 \\(A_{p_i}\\)，否则是 \\(B_{p_i}\\)。另外，由于每次交换相邻的两张卡片，所以最小交换次数就是 \\(p_i\\) 的逆序对数量。 于是我们可以考虑枚举奇数位置的卡片集合，然后我们就可以确定奇数位置和偶数位置的朝上的数的可重集合。由于我们最终求的是逆序对数量，所以如果两个数相等那一定是位置靠前的仍然靠前。所以我们可以确定一个 \\(p_i\\)。直接求逆序对即可。 时间复杂度 \\(O(2^nn^2)\\)。 代码 E - Bichromization 题意 给定一个 \\(n\\) 个点 \\(m\\) 条边的无向连通图，每个点还有一个额外的值 \\(D_i\\)。 你需要对每个点黑白染色，给每条边赋一个 \\(1\\) 到 \\(10^9\\) 的整数权值，使得： 至少有一个点是黑色，至少有一个点是白色。 对于每个点 \\(u\\)，满足与它最近的异色点 \\(v\\) 到 \\(u\\) 的最短路为 \\(D_u\\)。 \\(n\\le 10^5,m\\le 2\\times 10^5,D_i\\le 10^9\\)。 题解 首先如果存在一个点 \\(u\\) 满足 \\(\\forall (u,v)\\in E,D_v&gt;D_u\\)，此时 \\(v\\) 如果与 \\(u\\) 异色，则 \\((u,v)\\) 的权值一定不小于 \\(D_v\\)；如果 \\(v\\) 与 \\(u\\) 同色，则 \\(D_v\\) 也无法更新 \\(D_u\\)。所以此时 \\(D_u\\) 不会被任何一个 \\(v\\) 更新到，一定无解。 接下来我们考虑按照 \\(D_u\\) 从小到大依次染色。 如果 \\(u\\) 相连的点中已经存在被染色的点，那么我们任取其中一个 \\(v\\)，将 \\(u\\) 染成与 \\(v\\) 异色的点，将 \\((u,v)\\) 的边权置为 \\(D_u\\)，此时 \\(u\\) 一定会被 \\(v\\) 更新到，而 \\(v\\) 因为 \\(D_v \\le D_u\\)，不会被更新到。 如果不存在，则此时一定存在至少一个 \\(v\\) 满足 \\(D_v=D_u\\)，任取其中一个，将 \\(u,v\\) 染不同颜色，将 \\((u,v)\\) 的边权置为 \\(D_u\\)，此时 \\(u,v\\) 能互相被更新到。 可以发现，上述染色过程中，每次都可以保证当前被染色的点 \\(u\\) 满足 \\(D_u\\) 的限制。 剩下没有被赋权值的边全部赋成 \\(10^9\\) 即可。 时间复杂度 \\(O(n+m)\\)。 代码 F - Monochromization 题意 有一个 \\(H\\times W\\) 的黑白矩阵 \\(A\\)，求有多少个 \\(H\\times W\\) 的黑白矩阵可以通过 \\(A\\) 按任意顺序执行任意次以下几种操作得到： 选择一行，全部染成黑色或白色； 选择一列，全部染成黑色或白色。 对 \\(998244353\\) 取模。 \\(H,W\\le 10\\) 题解 首先我们考虑 \\(A\\) 全白的情况。 对于一个矩阵，定义可移除行为颜色全相同的行，可移除列为颜色全相同的列。那么一个矩阵能得到当且仅当重复执行若干轮以下操作后变为空矩阵： 将所有可移除行删除（剩下的行重新按顺序排列形成一个新的矩阵）； 将所有可移除列删除（剩下的列重新按顺序排列形成一个新的矩阵）。 可以发现由于这两个操作交替地、重复地执行，且每次把能删除的都删除，一个矩阵对应的操作序列一定是唯一的。 这样我们避免了算重，只需要统计合法操作序列数量即可。 我们发现，需要关注的不仅仅是当前矩阵的行数和列数，上次删除的是行还是列，我们还需要关注上一次删除的行或列的颜色是否全部相等。 假设上一次删的全部是列，现在需要删除行。如果上次删的列颜色不全相等，那么再上一次删行时一定已经把能删的都删完了。 如果上次删的列颜色全部是黑色，那么如果有全黑色的行，那么我们把之前删的黑色的列重新加回去时，这一行仍然是全黑色的，我们可以在上一次删行时把这一行删掉。所以这一次删行时删的行一定都是白色，这样才能保证之前把能删的都删完了。 于是 \\(f_{i,j,k}\\) 表示上一次删的是行，当前矩阵大小为 \\(i\\times j\\)，上一次删的行有 \\(k\\) 种不同的颜色（\\(k\\in \\{1,2\\}\\)）。\\(g_{i,j,k}\\) 类似，表示上一次删的是列。 转移比较简单，具体可以参考代码。要注意设置初始值是，应该把删除的行是同种颜色的方案也计入 \\(f_{i,m,2}\\)，这是因为第一次删除列时没有再上一次的删除列操作，仍然可以删除不同颜色的列。 接下来回到原问题。此时一个矩阵能得到的条件是通过上述移除操作，直到无法移除后，每个位置的颜色与 \\(A\\) 中对应位置（即没有进行移除操作前的位置）的颜色相同。 若最后的矩阵为空，与之前的问题相同，需要特殊处理。 否则，我们枚举最后保留的行和列，合法的条件是保留的行和列组成的矩阵不存在可移除行和可移除列。然后把方案数直接加上即可。注意此时由于固定了行和列，需要除以两个组合数。 时间复杂度 \\(O(2^{H+W}(H+W))\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"枚举","slug":"枚举","permalink":"https://autumnkite.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"Social Infrastructure Information Systems Division, Hitachi Programming Contest 2020 题解","slug":"atcoder-hitachi2020","date":"2020-09-09T03:31:07.000Z","updated":"2020-09-13T05:45:32.026Z","comments":true,"path":"atcoder-hitachi2020/","link":"","permalink":"https://autumnkite.github.io/atcoder-hitachi2020/","excerpt":"比赛地址","text":"比赛地址 A - Hitachi String 题意 判断一个字符串 \\(S\\) 是否由若干个 hi 拼接而成。 \\(|S|\\le 10\\) 题解 条件为： \\(n\\) 是偶数； 奇数位为 h； 偶数位为 i。 时间复杂度 \\(O(|S|)\\)。 代码 B - Nice Shopping 题意 有 \\(A\\) 种 A 商品，第 \\(i\\) 种价格为 \\(a_i\\)；有 \\(B\\) 种 B 商品，第 \\(i\\) 种价格为 \\(b_i\\)。 有 \\(M\\) 张优惠券，第 \\(i\\) 张优惠券是同时买 A 商品的第 \\(x_i\\) 种和 B 商品的第 \\(y_i\\) 种时可以优惠 \\(c_i\\) 元。 你需要买恰好一种 A 商品和恰好一种 B 商品，求在最多只能用一张优惠券时的最小花费。 \\(A,B,C\\le 10^5\\) 题解 有两种情况： 不使用优惠券，则花费为 \\(\\min\\{a_i\\}+\\min\\{b_i\\}\\)； 使用优惠券，则花费为 \\(\\min \\{a_{x_i}+b_{y_i}-c_i\\}\\)。 两种情况取 \\(\\min\\) 即可。 时间复杂度 \\(O(A+B+M)\\)。 代码 C - ThREE 题意 给定一棵 \\(n\\) 个点的树，构造一个排列 \\(p\\) 满足： 对于所有 \\(i\\) 到 \\(j\\) 的简单路径边数为 \\(3\\) 的 \\((i,j)\\)，满足 \\(p_ip_j\\) 和 \\(p_i+p_j\\) 中至少有一个是 \\(3\\) 的倍数。 \\(n\\le 2\\times 10^5\\) 题解 假设 \\(n\\) 为 \\(3\\) 的倍数。其他情况类似。 相当于我们要给每个点赋 \\(0,1,2\\) 中的一个数，每个数都恰好出现 \\(\\frac{n}{3}\\) 次。 首先我们可以从任意点开始 DFS，将深度为奇数的点填 \\(1\\)，深度为偶数的点填 \\(2\\)。显然这样已经能满足题目中的条件。 考虑如何满足出现次数的条件。记填 \\(1\\) 和 \\(2\\) 的数量分别为 \\(c_1,c_2\\)，那么分两种情况： \\(c_1,c_2\\ge \\frac{n}{3}\\)。此时只要将多余的 \\(1,2\\) 填成 \\(0\\) 即可。 \\(\\exists i\\in \\{1,2\\},c_i &lt; \\frac{n}{3}\\)。此时将 \\(i\\) 全部替换成 \\(3\\)，剩下的节点任意填即可。 时间复杂度 \\(O(n)\\)。 代码 D - Manga Market 题意 有 \\(n\\) 个商店，从时刻 \\(0\\) 开始，每次你可以花费 \\(1\\) 个单位的时间走到任意一个商店。 若你在时刻 \\(t\\) 到达商店 \\(i\\) 并在商店 \\(i\\) 购物，那么你需要花费 \\(a_i\\times t+b_i\\) 单位的时间。 所有商店会在时刻 \\(T+0.5\\) 关门，也就是说，如果你走到某个商店时的时刻加上需要花费的时间大于 \\(T\\)，那么你就无法在该商店购物。 每个商店只能购物一次。 求最多可以在多少商店购物。 \\(n\\le 2\\times 10^5,T\\le 10^9\\) 题解 首先我们可以把 \\(b_i\\) 加上 \\(a_i+1\\)，这样就可以认为走路不需要时间。 然后我们可以把 \\(a_i\\) 加上 \\(1\\)，这样 \\(a_it+b_i\\) 就是购物结束的时刻。 假若我们依次在 \\(i_1,i_2,\\ldots,i_k\\) 这些商店购物，这是在这些商店购物的最优顺序当且仅当对于所有 \\(1\\le j &lt; k\\) 都满足 \\[b_{i_j}a_{i_{j+1}}\\prod_{l=j+2}^{k}a_{i_l}+b_{i_{j+1}}\\prod_{l=j+2}^{k}a_{i_l}\\le b_{i_{j+1}}a_{i_j}\\prod_{l=j+2}^{k}a_{i_l}+b_{i_j}\\prod_{l=j+2}^{k}a_{i_l}\\] 化简得到 \\[\\frac{b_{i_j}}{a_{i_j}-1}\\le \\frac{b_{i_{j+1}}}{a_{i_{j+1}}-1}\\] 所以我们可以首先把原序列按这个式子排序。 然后我们可以 DP。用 \\(f_{i,j}\\) 表示前 \\(i\\) 个商店，去了 \\(j\\) 个的最小时间。 注意到若忽略 \\(a_i=1\\) 的商店，那么 \\(j\\) 只有 \\(O(\\log T)\\) 个。 而 \\(a_i=1\\) 的商店一定排在最后，可以最后贪心按 \\(b_i\\) 从小到大依次购物。 所以时间复杂度 \\(O(n\\log T)\\)。 代码 E - Odd Sum Rectangles 题意 构造一个 \\((2^n-1)\\times (2^m-1)\\) 的 01 矩阵，使得和为奇数的连续子矩阵数量最多。 \\(n,m\\le 10\\) 题解 假设 \\(n\\ge m\\)。令 \\(H=2^n,W=2^m\\)。考虑枚举 \\(1\\le j_1\\le j_2&lt; W\\)，令 \\(f(i)=S(1,i,j_1,j_2)\\ (0\\le i&lt; H)\\)。那么和为奇数的子矩阵数量为 \\(f(i)\\) 中 \\(0\\) 的数量乘 \\(1\\) 的数量。于是我们可以得到数量的上界为 \\(\\frac{H^2}{4}\\times \\frac{W(W-1)}{2}\\)。 接下来我们证明这个上界是可以达到的。 假设 \\(n=m\\)。我们考虑用归纳证明。 当 \\(n=1\\) 时，我们只需要构造一个元素为 \\(1\\) 的 \\(1\\times 1\\) 矩阵即可。 假设我们已经构造出了 \\(n=k\\) 的矩阵，我们可以按如下方式构造一个 \\((2^{k+1}-1)\\times (2^{k+1}-1)\\) 的矩阵： 左上角、左下角、右上角、右下角分别用 \\(n=k\\) 的矩阵填充。 第 \\(2^k\\) 行 \\(2^k\\) 列填 \\(1\\)。 其他位置填 \\(0\\)。 以没有跨过第 \\(2^k\\) 列的两列作为 \\(j_1,j_2\\) 时证明比较容易。而对于跨过第 \\(2^k\\) 列的两列，由于构造的矩阵具有对称性，我们可以转化成第 \\(2^k\\) 列加上没有跨过第 \\(2^k\\) 列的两列之间的部分。这一部分证明也比较容易。 \\(n&gt;m\\) 的情况先构造 \\((2^n-1)\\times (2^n-1)\\) 再取前 \\(2^m-1\\) 列即可。因为我们证明了任意两列之间都能卡到上界，所以这样构造一定仍然能够卡到上界。 时间复杂度 \\(O(2^{2\\max(n,m)})\\)。 代码 F - Preserve Diameter 题意 给定一棵 \\(n\\) 个点的树 \\(G\\)。求在树 \\(G\\) 中加入若干条边得到的满足以下条件的图 \\(H\\) 的数量： 不存在重边和自环。 \\(H\\) 的直径与 \\(G\\) 相等。 对于所有在 \\(H\\) 中没有直接的边相连的点对 \\((u,v)\\ (u\\ne v)\\)，满足加入边 \\((u,v)\\) 后会使直径长度减小。 对 \\(998244353\\) 取模。 \\(n\\le 2\\times 10^5\\) 题解 首先不难发现 \\(H\\) 的直径是唯一的，否则一定可以继续加入边。假设这条唯一的直径两个端点为 \\(x,y\\)。 我们考虑以 \\(x\\) 为根建立 BFS 树，令 \\(dis_i\\) 为 \\(x\\) 到 \\(i\\) 的最短路长度，那么两个点 \\(u,v\\) 在 \\(H\\) 中有边当且仅当 \\(|dis_u-dis_v|\\le 1\\)。 直接对 \\(dis_i\\) 计数由于需要确定 \\(x\\) 而不好计数。考虑继续转化。 假设 \\(G\\) 的直径长度为 \\(L\\)。我们首先考虑 \\(L\\) 是偶数的情况，此时我们可以得到直径的中点 \\(c\\)。 可以发现 \\(x,y\\) 在 \\(G\\) 上的路径一定经过 \\(c\\)，这是因为 \\(x,y\\) 一定也是 \\(G\\) 的直径端点，而树上任意一条直径一定都经过直径中点。 于是我们考虑以 \\(c\\) 为根，给每个点赋一个标号 \\(d_i\\)，满足： \\(d_c=0\\)。 恰好存在一个点 \\(x\\) 满足 \\(d_x=-\\frac{L}{2}\\)。 恰好存在一个点 \\(y\\) 满足 \\(d_y=\\frac{L}{2}\\)。 对于在 \\(G\\) 中有边的点对 \\((u,v)\\)，满足 \\(|d_u-d_v|\\le 1\\)。 可以发现一个合法的 \\(H\\) 一定恰好对应两种满足以上条件的标号方案。 于是我们可以 DP，记以 \\(c\\) 到 \\(u\\) 的距离为 \\(dep_u\\)，则我们用 \\(f_{u,i,j}\\) 表示对 \\(u\\) 的子树进行标号，\\(d_v-d_u=\\frac{L}{2}-dep_u\\) 的点 \\(v\\) 数量为 \\(i\\)，\\(d_u-d_v=\\frac{L}{2}-dep_u\\) 的点 \\(v\\) 数量为 \\(j\\) 时的方案数。 注意 \\(i,j\\) 可以与 \\(2\\) 取 \\(\\min\\)。 \\(L\\) 为奇数时类似，只需要将直径中间的边断开后对两边分别 DP 后合并即可。 时间复杂度 \\(O(n)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"}]},{"title":"AtCoder Grand Contest 044 题解","slug":"atcoder-agc044","date":"2020-09-08T04:05:42.000Z","updated":"2020-09-13T05:42:35.532Z","comments":true,"path":"atcoder-agc044/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc044/","excerpt":"比赛地址","text":"比赛地址 A - Pay to Win 题意 你要通过以下操作将 \\(0\\) 变成 \\(N\\)： 乘 \\(2\\)，花费 \\(A\\)； 乘 \\(3\\)，花费 \\(B\\)； 乘 \\(5\\)，花费 \\(C\\)； 加 \\(1\\) 或减 \\(1\\)，花费 \\(D\\)。 求最少操作次数。 \\(N\\le 10^{18},A,B,C,D\\le 10^9\\) 题解 考虑倒着做。假设当前的 \\(N\\) 要除以 \\(v\\)，那么一定是转移到 \\(\\lfloor\\frac{N}{v}\\rfloor\\) 或 \\(\\lceil\\frac{N}{v}\\rceil\\)。 注意到这样子转移遇到的状态一定是 \\(\\lfloor\\frac{N}{2^a3^b5^c}\\rfloor\\) 或 \\(\\lceil\\frac{N}{2^a3^b5^c}\\rceil\\)，所以状态数是 \\(O(\\log^3 N)\\) 的。 注意转移时需要考虑 \\(N\\to N/v\\) 时可能直接减的花费更小，需要与直接减的花费取 \\(\\min\\)。 时间复杂度 \\(O(\\log^3 N)\\)，如果使用 map 则复杂度为 \\(O(\\log^3 N\\log \\log N)\\)。 代码 B - Joker 题意 有一个 \\(N\\times N\\) 的矩阵，每个位置上有一个人，编号从上到下从左到右依次是 \\(1,\\ldots,N^2\\)。 人会一个一个地离开（即从所在位置每次向上下左右移动直到走出矩阵），第 \\(i\\) 个离开的人编号为 \\(P_i\\)。 当一个人离开时，一条路径的权值为路径上还没有离开的人的数量。每个人会选择权值最小的路径离开。 求最小权值之和。 \\(N\\le 500\\) 题解 考虑模拟这个过程，并同时维护 \\(f(i,j)\\) 表示 \\((i,j)\\) 走到矩阵外的最小路径权值。 每次当 \\((x,y)\\) 位置的人离开后，\\(f(x,y)\\) 减 \\(1\\)，会连带其他位置的 \\(f\\) 值改变。 但是注意到开始时 \\(\\sum f(i,j)\\le N^3\\)，所以我们只要每次暴力把需要更新的 \\(f\\) 修改即可。 时间复杂度 \\(O(N^3)\\)。 代码 C - Strange Dance 题意 有一个长度为 \\(3^N\\) 的序列 \\(P_0,\\ldots,P_{3^N-1}\\)。有 \\(|T|\\) 次操作，操作有两种： \\(T_i=\\mathtt{R}\\)，对于所有 \\(0\\le i &lt; 3^N\\)，执行 \\(P_i\\gets (P_i+1)\\bmod 3^N\\)。 \\(T_i=\\mathtt{S}\\)，对于所有 \\(0\\le i &lt; 3^N\\)，将 \\(P_i\\) 的三进制表示下的 \\(1\\) 改成 \\(2\\)，\\(2\\) 改成 \\(1\\)。 求最后的序列 \\(P\\)。 \\(N\\le 12,|T|\\le 2\\times 10^5\\) 题解 考虑从低位到高位建立 Trie。 对于 \\(\\mathtt{R}\\) 操作，可以从 Trie 的根节点开始，将 \\(0\\) 改成 \\(1\\)，将 \\(1\\) 改成 \\(2\\)，将 \\(2\\) 改成 \\(0\\)，然后递归原来 \\(2\\) 的子树即可。 对于 \\(\\mathtt{S}\\) 操作，可以直接在根节点打上标记，在需要递归时下传即可。 时间复杂度 \\(O(3^N+|T|N)\\)。 代码 D - Guess the Password 题意 这是一个交互题。交互库有一个长度不超过 \\(L=128\\) 的字符串 \\(S\\)。你可以每次询问交互库不超过 \\(Q=850\\) 次以下询问来得到 \\(S\\)： 给出一个长度不超过 \\(L\\) 的字符串 \\(T\\)，交互库会返回支持插入字符、删除字符、修改字符时 \\(S\\) 到 \\(T\\) 的最少操作次数（即编辑距离）。 字符集为所有大写字母、小写字母和 \\(0\\) 到 \\(9\\) 的数字。 题解 首先我们可以通过询问形如 \\(\\underbrace{aa\\ldots a}_{L}\\) 的字符串求出字符 \\(a\\) 的出现次数，即设返回值为 \\(x\\)，则 \\(a\\) 的出现次数为 \\(L-x\\)。 然后我们假设 \\(S_1,S_2\\) 是 \\(S\\) 的两个不相交的子序列，考虑如何合并成一个长度为 \\(|S_1|+|S_2|\\) 的子序列。 我们可以将 \\(S_2\\) 中的字符依次插入 \\(S_1\\) 中，询问次数约为 \\(|S_1|+|S_2|\\)。 于是我们可以对字符集分治，然后每次合并，询问次数约为 \\(L\\log_2 |\\Sigma|\\)，可以通过。 代码 E - Random Pawn 题意 有一个长度为 \\(N\\) 的环，环上的点顺时针编号为 \\(1\\) 到 \\(N\\)。 初始时会在所有点中等概率随机一个位置放一个棋子。 假设当前棋子在 \\(p\\)，可以执行两种操作： 获得 \\(A_p\\) 的收益，结束游戏。 花费 \\(B_p\\)，将棋子等概率移动到相邻两个位置之一（即各 \\(\\frac{1}{2}\\)）。 求最大的期望收益，精度要求 \\(10^{-10}\\)。 \\(N\\le 2\\times 10^5\\) 题解 如果我们到达 \\(A_i\\) 最大的位置，那么可以直接结束游戏，所以我们可以断环成链。 考虑 \\(B_i=0\\) 的情况，令 \\(f_i\\) 为从 \\(i\\) 出发的最大期望收益。 假设我们钦定到达 \\(S=\\{x_1,x_2,\\ldots,x_k\\}\\ (x_i &lt; x_{i+1})\\) 集合中的点时结束游戏，到达其他点则继续移动，那么对于 \\(i\\not\\in S\\) 的情况，有 \\[ f_i=\\frac{f_{i-1}+f_{i+1}}{2} \\] 移项后得 \\[f_{i+1}-f_i=f_i-f_{i-1}\\] 也就是说，对于 \\(u=x_j\\le i\\le x_{j+1}=v\\)，这些 \\(f_i\\) 组成了一个等差数列。那么我们有 \\[\\sum_{i=u}^{v} f_i=\\frac{(A_u+A_v)(v-u+1)}{2}\\] 那么所有 \\(f_i\\) 之和可以看做是 \\((x_i,A_{x_i})\\) 这些点顺次相连的折线下方的若干梯形面积之和加上一个定值。 为了使这个和最大，这些点一定是 \\((i,A_i)\\) 的上凸壳上的顶点。 接下来我们一般情况。 考虑令 \\(f_i&#39;=f_i-C_i\\)，那么有 \\[ f_i&#39;= \\begin{cases} A_i-C_i &amp; \\text{if } i\\in S\\\\ \\frac{f_{i-1}+f_{i+1}}{2}-B_i-C_i=\\frac{f_{i-1}&#39;+f_{i+1}&#39;}{2}-B_i-C_i+\\frac{C_{i-1}+C_{i+1}}{2} &amp; \\text{otherwise} \\end{cases} \\] 我们只要使得 \\(C_i\\) 满足 \\(\\frac{C_{i-1}+C_{i+1}}{2}-C_i=B_i\\) 即可转化为 \\(B_i=0\\) 的情况。 这样的 \\(C_i\\) 可以很简单的递推构造。 时间复杂度 \\(O(N)\\)。 代码 F - Name-Preserving Clubs 题意描述较为复杂，请直接查看原题面 Formal Statement 部分。 题解 首先我们强制 \\(L\\) 中的集合互不相同。 考虑建立一个 \\(k\\times n\\) 的矩阵，每一位填 \\(0\\) 或者 \\(1\\)。称一个矩阵是好的当且仅当行与行之间互不相同，并且任意打乱列后得到的矩阵都不能通过原矩阵打乱行得到。 显然好的矩阵和题目中的 name-preserving configuration 一一对应。 假设一个矩阵 \\(A\\) 是好的，我们可以观察到下面两个性质： \\(A\\) 的转置是好的。 考虑 \\(2^k\\) 种不同的列，由其中所有不在 \\(A\\) 中的列任意排列构成的矩阵也是好的。 那么如果我们设 \\(c(k,n)\\) 表示本质不同的 \\(k\\times n\\) 的好的矩阵数量，那么有 \\(c(k,n)=c(n,k)=c(k,2^k-n)\\)。 令 \\(g(n)\\) 表示最小的 \\(k\\) 满足 \\(c(k,n)&gt;0\\)。 令 \\(G(n)\\) 满足 \\(G(1)=0\\)，\\(G(n)\\) 表示最小的正整数 \\(k\\) 满足 \\(2^k-n\\ge G(k)\\)。 我们可以用 \\(G(n)\\) 的若干性质，通过归纳和构造证明 \\(G(n)=g(n)\\)。 另外，我们还可以用构造证明对于 \\(6\\le k\\le n\\) 时有 \\(c(k,n)&gt;1000\\)。 于是我们只需要考虑 \\(k\\le 5,n\\le 2^{k-1}\\) 的情况。暴搜后打表即可。 对于原题 \\(L\\) 中的集合可以互不相同的情况，可以证明只有当 \\(N=4\\) 和 \\(N=7\\) 时分别会额外增加 \\(1\\) 种方案和 \\(2\\) 种方案，特判即可。 上述结论的证明可以参考官方题解。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"分治","slug":"分治","permalink":"https://autumnkite.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"搜索","slug":"搜索","permalink":"https://autumnkite.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"凸包","slug":"凸包","permalink":"https://autumnkite.github.io/tags/%E5%87%B8%E5%8C%85/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://autumnkite.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"trie","slug":"trie","permalink":"https://autumnkite.github.io/tags/trie/"},{"name":"交互","slug":"交互","permalink":"https://autumnkite.github.io/tags/%E4%BA%A4%E4%BA%92/"}]},{"title":"AtCoder Grand Contest 045 题解","slug":"atcoder-agc045","date":"2020-09-06T12:23:30.000Z","updated":"2020-09-13T05:38:31.550Z","comments":true,"path":"atcoder-agc045/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc045/","excerpt":"比赛地址","text":"比赛地址 A - Xor Battle 题意 有 Person 0 和 Person 1 两个人玩游戏，有一个长度为 \\(n\\) 的 01 字符串 \\(S\\)、一个长度为 \\(n\\) 的序列 \\(A_1,A_2,\\ldots,A_n\\) 和一个初始为 \\(0\\) 的变量 \\(x\\)。 游戏有 \\(n\\) 轮。第 \\(i\\) 轮 Person \\(S_i\\) 会执行以下两种操作之一： \\(x\\gets x\\oplus A_i\\)，其中 \\(\\oplus\\) 表示异或运算。 不做任何修改。 游戏结束时，若 \\(x=0\\)，则 Person 0 获胜，否则 Person 1 获胜。 判断两个人都采用最优策略时的胜者。 \\(T\\) 组数据，\\(T\\le 200,n\\le 200,A_i\\le 10^{18}\\)。 题解 我们说一个数能被一个集合表示当且仅当这个数可以通过选择这个集合内的若干个数异或得到。 考虑从后往前依次考虑。 若 \\(S_i=0\\)，则我们将 \\(A_i\\) 加入到一个初始为空的集合 \\(B\\) 中。 若 \\(S_i=1\\)，则又分为两种情况： \\(A_i\\) 能被 \\(B\\) 表示。此时无论 Person 1 是否选择将 \\(x\\) 异或上 \\(A_i\\)，Person 0 都可以通过选择 \\(B\\) 中的数将这次选择抵消。所以我们直接忽略这一轮即可。 \\(A_i\\) 不能被 \\(B\\) 表示。此时 \\(x\\) 和 \\(x\\oplus A_i\\) 中一定有一个不能被 \\(B\\) 表示。那么 Person 1 只要选择那个不能被表示的数，最终 \\(x\\) 就一定不可能是 \\(0\\)，所以此时 Person 1 一定获胜。 现在我们只需要能够快速判断一个数能否被一个集合表示即可。使用线性基即可。 时间复杂度 \\(O(Tn\\log A_i)\\)。 代码 B - 01 Unbalanced 题意 给定一个含有 ? 的 01 串 \\(S\\)。 定义一个 01 串 \\(S\\) 的不平衡度为所有区间中，0 和 1 数量的差的绝对值的最大值。 求将 \\(S\\) 中的 ? 替换成 0 或 1（每个 ? 独立选择）的最小不平衡度。 \\(|S|\\le 10^6\\) 题解 对于一个 01 串 \\(S\\)，如果把 0 看成 \\(-1\\)，1 看成 \\(+1\\)，我们可以求出前缀和 \\(a_i\\)，那么不平衡度即为 \\(\\max a_i-\\min a_i\\)。 考虑枚举 \\(\\min a_i=x\\)，那么我们要在满足 \\(a_i\\ge x\\) 的前提下最小化 \\(a_i\\) 的最大值。 一个做法是，先将所有 ? 替换成 1，这样可以求出 \\(\\min a_i\\) 的最大值 \\(M\\)。 如果 \\(x&gt;M\\)，则显然无解。否则我们从前往后依次考虑每一个可以被替换的位置，如果替换 0 后仍然能满足 \\(\\min a_i\\ge x\\)，则替换。这样贪心显然是最优的，因为在后面替换一定不如前面替换更优。 根据该贪心算法，可以发现 \\(x=k\\) 时的答案一定不劣于 \\(x=k-2\\) 的答案，因为 \\(x=k-2\\) 时相比于 \\(x=k\\) 时最多多替换一个 ?，最大值最多减小 \\(2\\)，所以一定不会更优。 于是只要分别求出 \\(x=M\\) 和 \\(x=M-1\\) 时的答案即可。 时间复杂度 \\(O(|S|)\\)。 代码 C - Range Set 题意 求有多少个不同的 01 串可以通过对长度为 \\(N\\) 的全 \\(0\\) 字符串按任意顺序执行任意次以下两种操作得到： 选择一个长度为 \\(A\\) 的子段，将该子段的所有字符替换成 \\(0\\)。 选择一个长度为 \\(B\\) 的子段，将该子段的所有字符替换成 \\(1\\)。 答案对 \\(10^9+7\\) 取模。 \\(N\\le 5000\\) 题解 显然我们交换 \\(A,B\\) 答案不会变化。所以我们接下来假设有 \\(A\\le B\\)。 一个字符串 \\(S\\) 可以得到的充要条件是，如果将 \\(S\\) 中所有长度不小于 \\(A\\) 的全 \\(0\\) 极长子段中的所有字符替换为 \\(1\\)，那么 \\(S\\) 中需要存在一个长度不小于 \\(B\\) 的全 \\(1\\) 子段。 充分性：将所有长度不小于 \\(A\\) 的全 \\(0\\) 极长子段中的所有字符替换为 \\(1\\) 后，把那段长度不小于 \\(B\\) 的全 \\(1\\) 子段左右两边的部分全部替换成正确的字符（分别从左往右和从右往左），然后把这个子段替换为 \\(1\\)，再把开始替换的 \\(0\\) 重新替换回去。 必要性：考虑倒着还原，把所有长度不小于 \\(A\\) 的全 \\(0\\) 极长子段中的所有字符替换为 \\(1\\) 可以使得 \\(1\\) 的连续段尽量长。此时如果还是不存在长度不小于 \\(B\\) 的全 \\(1\\) 子段，那么我们无论如何都无法将原来的 \\(1\\) 变成 \\(0\\)。 接下来我们用总方案数减去不合法的方案数。 下面为了方便，我们将一个只包含长度不小于 \\(A\\) 的极长全 \\(0\\) 子段的串称为广义全 \\(1\\) 串。 首先我们考虑求出 \\(f_{i,0/1}\\) 表示长度为 \\(i\\)，以 \\(0/1\\) 结尾的广义全 \\(1\\) 串数量。这可以简单地转移。 可以发现不合法的串一定是由长度小于 \\(A\\) 的全 \\(0\\) 串和长度小于 \\(B\\) 且首尾都是 \\(1\\) 的广义全 \\(1\\) 串交替拼接而成。但是开头的如果是广义全 \\(1\\) 串，则开头可以是 \\(0\\)，结尾同理。 接下来我们考虑求出 \\(g_{i,0/1}\\) 表示长度为 \\(i\\)，以长度小于 \\(A\\) 的全 \\(0\\) 串结尾或是以长度小于 \\(B\\) 且首尾都是 \\(1\\) 的广义全 \\(1\\) 串结尾的不合法串数量。转移也较为简单，注意开头和结尾需要特殊处理。 时间复杂度 \\(O(NB)\\)。 D - Lamps and Buttons 题意 A 和 B 玩游戏。有 \\(N\\) 盏灯，其中 \\(1\\) 到 \\(A\\) 是亮的，其他是暗的。灯的状态在游戏过程中对两个人都是公开的。 A 会首先等概率选择一个排列 \\(p_1,p_2,\\ldots,p_N\\)，B 不知道这个排列。这个排列在游戏过程中不会改变。 然后 B 会执行若干次操作，每次操作 B 会选定一盏亮着的灯 \\(i\\)，如果没有则 A 获胜。接着 A 会把灯 \\(p_i\\) 的状态改变，注意灯 \\(i\\) 的状态不会改变。 如果某一时刻灯全部亮着，则 B 获胜。另外，如果过程中某一时刻灯的状态不可能通过有限次操作变成全部亮着，那么 A 获胜。 B 会有一个最优的策略使得自己胜率最大。求在最优策略下可以使 B 获胜的排列数量。 \\(N\\le 10^7,A\\le 5000\\) 题解 对于一个大小不小于 \\(2\\) 的置换环，如果 B 某次选到了该置换环上一个亮着的灯，那么 B 就可以将整个环都点亮。 对于一个大小为 \\(1\\) 的置换环，如果 B 某次选到了该置换环上的那个点，那么 B 就不可能再点亮该点，就会输掉游戏。 那么 B 的最优策略是每次随机选择一个点，然后将这个点所在的置换环点亮。 令 \\(t\\) 为满足 \\(1\\le t\\le A\\) 且 \\(p_t=t\\) 的最小值。若不存在则 \\(t=A+1\\)。我们可以根据上面的分析得到，排列 \\(p\\) 合法的充要条件为，对于所有 \\(A &lt; i\\le n\\)，\\(i\\) 所在的置换环存在一个小于 \\(t\\) 的元素。 考虑枚举 \\(t\\)，我们需要额外保证对于所有 \\(1\\le i &lt; t\\) 都有 \\(p_i\\ne i\\)，这个条件可以通过容斥解决，即枚举 \\(p_i=i\\) 位置数量 \\(j\\)，那么我们现在可以把所有 \\(n\\) 个点分成若干类点： 限制 \\(p_i=i\\) 的点。这类点可以直接忽略。下面的几类点都默认去掉这类点。 \\(1\\le i &lt; t\\) 的点。记为 A 类点，假设有 \\(a\\) 个。 \\(A &lt; i\\le n\\) 的点。记为 B 类点，假设有 \\(b\\) 个。这类点有一个额外的限制为，每个点所在的置换环中都要存在一个 \\(1\\le i &lt; t\\) 的点（即 A 类点）。 \\(t &lt; i\\le A\\) 的点。记为 C 类点，假设有 \\(c\\) 个。 考虑依次插入 A 类点、B 类点、C 类点。在插入时既可以在之前某个置换环上的两个相邻点之间插入，也可以单独成点（B 类点除外）。所以方案数为 \\[ \\begin{aligned} 1^{\\overline{a}}\\times a^{\\overline{b}}\\times (a+b+1)^{\\overline{c}}&amp;=a!\\times \\frac{(a+b-1)!}{(a-1)!}\\times \\frac{(a+b+c)!}{(a+b)!}\\\\ &amp;=\\frac{(a+b+c)!\\times a}{a+b} \\end{aligned} \\] 再乘上选出 \\(j\\) 个数的方案数 \\(\\begin{pmatrix}t-1\\\\j\\end{pmatrix}\\) 和容斥系数 \\((-1)^j\\) 加入答案即可。 时间复杂度 \\(O(A^2+N)\\)。 代码 E - Fragile Balls 题意 有 \\(N\\) 个盒子和 \\(M\\) 个球，一开始第 \\(i\\) 个球在第 \\(A_i\\) 个盒子。 每次操作可以选择一个至少有两个球的盒子，取出其中一个球放入另一个盒子。 第 \\(i\\) 个球最多只能被操作 \\(C_i\\) 次，目标是最终到第 \\(B_i\\) 个盒子。 求最少需要操作多少次，或输出无解。 \\(N,M\\le 10^5\\)，保证对于每个 \\(1\\le i\\le N\\)，都存在 \\(1\\le j\\le M\\) 满足 \\(B_j=i\\)。 题解 考虑建立一个 \\(N\\) 个点的有向图。对于第 \\(i\\) 个球，我们连一条 \\(A_i\\) 到 \\(B_i\\) 的权值为 \\(C_i\\) 的边。一次操作相当于改变一条边的起点并将这条边的权值减 \\(1\\)，需要保证操作前起点的出度大于 \\(1\\) 且边权大于 \\(0\\)。 首先我们不考虑边权，假设 \\(C_i=1\\)。对于图中的一个弱连通分量（即把边看成无向边后的一个连通块），如果是一个环，那么一定无解；否则因为每个点入度大于 \\(0\\)，那么一定存在一个点出度不小于 \\(2\\)，一定有解。 注意到我们可以操作一个不是环的弱连通分量中的一条权值不小于 \\(2\\) 的边（若起点出度不满足限制我们可以先操作若干次使得出度满足限制），将一个环与该弱连通分量合并成一个更大的弱连通分量。 这就意味着，我们只需要不断地选择不是环的弱连通分量中的权值不小于 \\(2\\) 的边减 \\(1\\)，就可以将环不断地合并进不是环的弱连通分量。 假若我们忽略 \\(A_i=B_i\\) 的情况，那么我们只需要把每个弱连通分量的 \\(C_i-1\\) 求和，将环按 \\(C_i-1\\) 的和从大到小排序后依次合并进不是环的弱连通分量。 如果存在 \\(A_i=B_i\\)，这样的边原来没有贡献，所以如果用来合并环则会导致贡献相比于其他边有额外的增加。额外的增加分两种情况： 这个自环在一个不是环的弱连通分量里。此时额外的贡献是 \\(1\\)。 这个自环单独成为一个弱连通分量。此时额外的贡献是 \\(2\\)。 这相当于一个背包，我们可以枚举额外贡献是 \\(1\\) 的自环数量，用双指针维护额外贡献是 \\(2\\) 的自环数量即可。 一种合并方案合法的条件是： 所有可以用来合并的边 \\(C_i-1\\) 之和不小于需要合并的环数。 初始时不是环的弱连通分量中可用来合并的边 \\(C_i-1\\) 之和大于 \\(0\\)。 注意细节较多。 时间复杂度瓶颈在于排序，使用桶排可以做到时间复杂度 \\(O(N+M)\\)。 代码 F - Division into Multiples 题意 你有 \\(X+Y\\) 个数字，其中 \\(X\\) 个数字是 \\(A\\)，\\(Y\\) 个数字是 \\(B\\)，\\(A\\ne B\\)。 你需要将这些数字分成若干组，如果一组中数字的和为 \\(C\\) 的倍数，则这一组是好的组。 求最多有多少好的组。 \\(T\\) 组数据，\\(T\\le 20000,A,B,X,Y,C\\le 10^9\\)。 题解 首先我们可以通过顺序执行以下几个操作使得 \\(A,B,C\\) 两两互质： 若 \\(\\gcd(A,B)&gt;1\\)，则可以将 \\(A,B\\) 同时除以 \\(\\gcd(A,B)\\)，并且将 \\(C\\) 除以 \\(\\gcd(A,B,C)\\)。 若 \\(\\gcd(A,C)&gt;1\\)，则可以将 \\(A,C\\) 同时除以 \\(\\gcd(A,C)\\)，并且将 \\(Y\\) 除以 \\(\\gcd(A,C)\\) 并下取整。 若 \\(\\gcd(B,C)&gt;1\\)，则可以将 \\(B,C\\) 同时除以 \\(\\gcd(B,C)\\)，并且将 \\(X\\) 除以 \\(\\gcd(B,C)\\) 并下取整。 考虑求出同余方程 \\(Ax+By\\equiv 0\\pmod{C}\\) 的所有最小解 \\((x_i,y_i)\\)，最小指的是不存在 \\(i\\ne j\\) 使得 \\(x_i\\le x_j,y_i\\le y_j\\)。注意不能包含 \\(x=y=0\\) 这组解。 由于 \\(\\gcd(B,C)=1\\)，我们可以令 \\(D=\\frac{A}{B}\\bmod C\\)，那么有 \\(y\\equiv -xD\\pmod{C}\\)。 于是我们可以从 \\(0\\) 到 \\(C\\) 枚举 \\(x\\)，若求出的 \\(y\\) 比之前的都要小，那么加入最小解。考虑如何加速。 考虑这么一个过程，假设有一个 \\((0,0)\\) 到 \\((C,D)\\) 的矩形，一个点 \\((p,q)\\) 从原点出发，沿向量 \\((1,1)\\) 方向前进，若 \\(q=D\\) 则将 \\(q\\) 置为 \\(0\\)，若 \\(p=C\\) 则将 \\(p\\) 置为 \\(0\\)。\\(q=0\\) 时，若当前的 \\(p\\) 比之前的都大，则将 \\(x\\equiv \\frac{p}{D},y\\equiv -p\\) 加入最小解。 于是我们可以递归，假设当前矩形的宽度为 \\(W\\)，长度为 \\(H\\)。当 \\(W\\ge H\\) 时，我们可以去掉 \\((0,0)\\) 到 \\((W,W)\\) 这个正方形，可以发现对之后的过程不会有太大影响。\\(W&lt;H\\) 的情况类似，也可以去掉一个正方形。 可以发现这是一个类似于辗转相减的过程，每次最多会加入一个最小解。辗转相减的复杂度会有问题，我们可以变成辗转相除，将一段等差数列（即 \\(x\\) 等差，\\(y\\) 等差）加入最小解。 注意到 \\(y\\) 之差会随着矩形减小不断减小，\\(x\\) 之差会随着删除的正方形的增多不断增大，所以我们有 \\(x_{i+1}-x_i\\ge x_i-x_{i-1},y_{i+1}-y_i\\ge y_i-y_{i-1}\\)。所以最优解的点组成了一个下凸壳。 接下来我们的问题是我们需要选择一个最大的可重集 \\(S\\) 使得 \\(\\sum\\limits_{i\\in S}x_i\\le X,\\sum\\limits_{i\\in S}y_i\\le Y\\)。 我们只要考虑 \\(\\max S-\\min S\\le 1\\) 的 \\(S\\) 即可。证明考虑假设存在 \\(i,j\\in S,j-i\\ge 2\\)，那么因为有 \\(x_{i+1}-x_i\\le x_j-x_{j-1}, y_{i+1}-y_i\\le y_j-y_{j-1}\\)，我们可以将 \\(i,j\\) 从 \\(S\\) 中删去，插入 \\(i+1,j-1\\)，一定仍然满足条件。 假设一个等差数列为 \\((x_l,y_l),(x_l+\\Delta x,y_l-\\Delta y),(x_l+2\\Delta x,y_l-2\\Delta y),\\ldots,(x_r=x_l+n\\Delta x,y_r=y_l-n\\Delta y)\\)。 考虑如何计算这个等差数列的答案。考虑二分答案 \\(m\\)，由于等差数列上的一个点可以表示成 \\((x_l+k\\Delta x,y_r+(n-k)\\Delta y)\\)，于是我们只需要满足 \\(\\lfloor\\frac{X-m\\cdot x_l}{\\Delta x}\\rfloor+\\lfloor\\frac{Y-m\\cdot y_l}{\\Delta y}\\rfloor\\ge m\\cdot n\\) 就一定可以构造出合法的可重集合 \\(S\\)。 时间复杂度 \\(O(T\\log^2 V)\\)，其中 \\(V\\) 是输入中数字的最大值。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"图论","slug":"图论","permalink":"https://autumnkite.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"博弈","slug":"博弈","permalink":"https://autumnkite.github.io/tags/%E5%8D%9A%E5%BC%88/"},{"name":"二分","slug":"二分","permalink":"https://autumnkite.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"凸包","slug":"凸包","permalink":"https://autumnkite.github.io/tags/%E5%87%B8%E5%8C%85/"},{"name":"线性基","slug":"线性基","permalink":"https://autumnkite.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"}]},{"title":"NOMURA Programming Competition 2020 题解","slug":"atcoder-nomura2020","date":"2020-09-04T10:52:55.000Z","updated":"2020-09-13T05:34:16.698Z","comments":true,"path":"atcoder-nomura2020/","link":"","permalink":"https://autumnkite.github.io/atcoder-nomura2020/","excerpt":"比赛地址","text":"比赛地址 ABC 之前做过，就不写了。 D - Urban Planning 题意 有一个 \\(n\\) 个点的无向图，初始没有边。 定义一个序列 \\(a_1,a_2,\\ldots,a_n\\ (1\\le a_i\\le n,a_i\\ne i)\\) 的权值为，要求对于每个 \\(1\\le i\\le n\\)，最终的无向图中 \\(i\\) 与 \\(a_i\\) 连通，最少需要加入的边数。 给定序列 \\(P_1,P_2,\\ldots,P_n\\)，有些 \\(P_i\\) 可能为 \\(-1\\)，你需要将所有 \\(P_i=-1\\) 的位置替换成一个不为 \\(i\\) 的 \\(1\\) 到 \\(n\\) 的整数，求所有这些序列的权值之和。对 \\(10^9+7\\) 取模。 \\(n\\le 5000\\) 题解 显然序列 \\(a_1,a_2,\\ldots,a_n\\) 的权值为 \\(i\\) 与 \\(a_i\\) 连边时的最小生成森林大小，即点数减环数。那么不妨计算环数之和。考虑计算每个环对答案的贡献。 对于所有 \\(P_i\\ne -1\\) 的位置，我们将 \\(i\\) 与 \\(P_i\\) 连边，这样每个连通块就是一个基环树或树。 设 \\(-1\\) 的数量为 \\(k\\)。 对于是基环树的连通块，每一种方案都会包含这个环，所以答案直接加上 \\((n-1)^k\\) 即可。 接下来我们考虑是树的连通块之间形成的环。假设这些连通块大小为 \\(a_1,a_2,\\ldots,a_m\\)。 若我们选出了 \\(x_1,x_2,\\ldots,x_l\\) 这些连通块连成一个基环树，那么方案数为 \\[(l-1)!\\prod_{i=1}^{l} a_{x_i}\\] 对答案的贡献只要再乘上 \\((n-1)^{m-l}\\) 即可。 简单的 DP 即可。时间复杂度 \\(O(n^2)\\)。 代码 E - Binary Programming 题意 有一个初始为空的字符串 \\(S\\) 和初始为 \\(0\\) 的整数变量 \\(x\\)。 给定 01 字符串 \\(T\\)，你可以执行以下操作 \\(|T|\\) 次： 在 \\(S\\) 的任意位置插入字符 \\(0\\) 或 \\(1\\)。 将 \\(x\\) 加上 \\(S\\) 中奇数位置的数字之和。\\(S\\) 从 \\(1\\) 开始标号。 你需要保证最后 \\(S=T\\)。 求最终 \\(x\\) 的最大值。 \\(|T|\\le 2\\times 10^5\\) 题解 首先我们可以将操作变成从 \\(T\\) 中不断删除字符。 那么一定是先删 \\(0\\) 再删 \\(1\\)。 证明可以考虑如果当前存在 \\(0\\) 但是删除了 \\(1\\)，假设这个字符串是 \\(S\\)，那么我们如果不删除这个 \\(1\\)，改而删除这个 \\(1\\) 左边或右边最近的一个 \\(0\\)，得到的字符串 \\(S&#39;\\) 相比于 \\(S\\) 一定是某个位置的 \\(0\\) 变成了 \\(1\\)，不会更劣。 而删除 \\(0\\) 时一定是不断删除第一个奇数位置的 \\(0\\)。若不存在奇数位置的 \\(0\\)，则从后往前依次删除 \\(0\\)。 证明可以考虑对于一段长度为偶数的连续的 \\(1\\)，在删除 \\(0\\) 的过程中贡献一定相同，可以不考虑，直接删去。 于是我们可以将原串处理成没有连续两个 \\(1\\) 相邻的形式。剩下对于所有 \\(1\\) 的位置 \\(i\\)，记 \\(pre_i\\) 为 \\(1\\) 到 \\(i\\) 中 \\(0\\) 的数量，\\(suf_i\\) 为 \\(i\\) 到 \\(|T|\\) 中 \\(0\\) 的数量，那么这个位置的 \\(1\\) 在删除 \\(0\\) 的过程中贡献最多为 \\(\\lfloor\\frac{pre_i+1+i\\bmod 2}{2}\\rfloor+suf_i\\)，而上述删除顺序恰好可以达到该上界。 删除 \\(1\\) 时的贡献可以简单的算出。 时间复杂度 \\(O(|T|)\\)。 代码 F - Sorting Game 题意 A 和 B 玩游戏，过程如下： 给出一个长度为 \\(M\\)，元素为 \\(0\\) 到 \\(2^N-1\\) 的整数的序列 \\(a_1,\\ldots,a_M\\)。 A 可以选择一些二进制位，将 \\(a\\) 中每个数的这些二进制位置为 \\(0\\)。 B 可以执行若干次交换 \\(a_i\\) 和 \\(a_{i+1}\\) 的操作，需要满足 \\(a_i\\) 和 \\(a_{i+1}\\) 二进制位恰好有一位不同。 你需要求有多少种不同的序列 \\(a\\)，使得 A 无论如何操作，B 都可以将 \\(a\\) 从小到大排序。对 \\(10^9+7\\) 取模。 \\(N,M\\le 5000\\) 题解 注意到合法的 \\(a\\) 需要满足对于所有 \\(1\\le i &lt; j\\le M\\)，\\(a_i\\) 与 \\(a_j\\) 从高到低第一次出现 \\(a_i\\) 的这一位为 \\(1\\)，\\(a_j\\) 的这一位为 \\(0\\) 的位置后，更低位都相同。 考虑 \\(a_1,a_2,\\ldots,a_M\\) 的最高位，有两种情况： 形如 \\(0\\ldots01\\ldots1\\)，这样我们就不需要考虑这一位，变成一个 \\(N-1\\) 位的子问题，最高位的填数方案数为 \\(M+1\\)。 形如 \\(0\\ldots0\\mathbf{1x\\ldots x0}1\\ldots 1\\)，此时中间加粗部分的更低位需要全部相同，所以假设加粗部分的长度为 \\(i\\)，那么变成了一个 \\(N-1\\) 位，序列长度为 \\(M-i+1\\) 的子问题，最高位的填数方案为 \\((M-i+1)2^{i-2}\\)。 可以证明除这两种情况以外的情况一定不合法。 所以我们就有了一个朴素的 \\(O(NM^2)\\) DP，用前缀和优化可以做到 \\(O(NM)\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"}]},{"title":"Tokio Marine & Nichido Fire Insurance Programming Contest 2020 题解","slug":"atcoder-tokiomarine2020","date":"2020-09-04T02:56:28.000Z","updated":"2020-09-13T05:32:05.595Z","comments":true,"path":"atcoder-tokiomarine2020/","link":"","permalink":"https://autumnkite.github.io/atcoder-tokiomarine2020/","excerpt":"比赛地址","text":"比赛地址 ABC 之前做过，就不写了。 D - Knapsack Queries on a tree 题意 给定一个 \\(N\\) 个点的完全二叉树，每个点上有一个重量为 \\(W_i\\)，价值为 \\(V_i\\) 的物品。 \\(Q\\) 次询问，每次询问给定 \\(v,L\\)，求在 \\(v\\) 到根路径上的物品中选出若干个（可以为 \\(0\\) 个）重量和不超过 \\(L\\) 的物品的最大价值和。 \\(N &lt; 2^{18}, Q\\le 10^5, L\\le 10^5\\) 题解 一个朴素 DP 是，用 \\(f[i][j]\\) 表示在 \\(i\\) 到根的路径上选出重量和不超过 \\(j\\) 的物品的最大价值和。 直接 DP 是 \\(O(NL)\\) 的，需要优化。 我们考虑只处理出前 \\(9\\) 层节点的 DP 数组。然后对于每个询问，暴力枚举最后不超过 \\(9\\) 个物品的选择状态即可。 时间复杂度 \\(O(Q\\sqrt{N})\\)。 代码 E - O(rand) 题意 有 \\(N\\) 个数 \\(A_1,A_2,\\ldots,A_N\\)，求在其中选出 \\(1\\) 到 \\(K\\) 个满足以下条件的数的方案数： 选择的数的 AND 和为 \\(S\\)； 选择的数的 OR 和为 \\(T\\)。 \\(N\\le 50,A_i &lt; 2^{18}\\) 题解 一个朴素的 \\(3^{18}\\) 的容斥是，对于所有 \\(S\\) 为 \\(0\\)，\\(T\\) 为 \\(1\\) 的位，枚举是强制选 \\(0\\)、强制选 \\(1\\) 还是没有限制。 考虑优化，发现容斥系数只与有限制的位置数量有关，于是我们考虑枚举有限制的位置。然后我们再枚举一个数 \\(A_i\\) 强制选择，这样我们就可以确定每一个有限制的位是填 \\(0\\) 还是填 \\(1\\)。 统计出合法的数字数量，用组合数计算即可。 时间复杂度 \\(O(2^{18}N)\\)。 代码 F - Triangles 题意 二维平面上有一个以 \\((0,0)\\) 为左下角，\\((W,H)\\) 为右上角的矩形。 你需要求满足以下条件的三角形数量： 顶点为格点； 三个顶点分别在矩形的三条不同的边上，且不能在矩形的顶点上； 三角形内部（不包括边和顶点）的格点数不超过 \\(K\\)。 \\(W,H,K\\le 10^5\\) 题解 下面我们考虑计算三个点分别为 \\((0,y),(x_1,0),(x_1+d,H)\\ (0 &lt; y &lt; H, 0 &lt; x_1 &lt; x_1+d &lt; W)\\) 的三角形数量，其他情况类似。 由皮克定理，设三角形面积为 \\(S\\)，内部格点数为 \\(i\\)，边和顶点上格点数为 \\(b\\)，则有 \\[2S=2i+b-2\\] 对于该三角形，有 \\(2S=x_1H+dy,b=\\gcd(d,H)+\\gcd(x_1+d,H-y)+\\gcd(x_1,y)\\)。 代入皮克定理的式子，得到 \\[x_1H+dy=2i+\\gcd(d,H)+\\gcd(x_1+d,H-y)+\\gcd(x_1,y)-2\\] 显然当 \\(x_1H+dy &gt;3H+2K\\) 时 \\(i\\le K\\) 不可能成立，所以有 \\(dy\\le 3H+2K\\)。于是我们可以考虑枚举 \\(dy\\)，这一部分时间复杂度为 \\(O((H+K)\\log (H+K))\\)。 根据 \\(i\\le K\\) 写出不等式并将只与 \\(d,y\\) 有关的项移到右边，得到 \\[x_1H-\\gcd(x_1+d,H-y)-\\gcd(x_1,y)\\le \\gcd(d,H)+2K-2-dy\\] 记右式的值为 \\(R\\)，若 \\(x_1\\le \\frac{R}{H}\\)，则一定成立；若 \\(x_1\\ge \\frac{R}{H}+2\\)，则一定不成立。所以我们只要判断满足 \\(\\frac{R}{H} &lt; x_1 &lt; \\frac{R}{H}+2\\) 的 \\(x_1\\) 是否成立即可。这样的 \\(x_1\\) 只有 \\(O(1)\\) 个，每次判断需要求 \\(\\gcd\\)，复杂度为 \\(O(\\log (W+H))\\)。 所以总复杂度为 \\(O((W+H+K)\\log (W+H+K)\\log (W+H))\\)。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"枚举","slug":"枚举","permalink":"https://autumnkite.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"AtCoder Grand Contest 046 题解","slug":"atcoder-agc046","date":"2020-09-03T06:57:08.000Z","updated":"2020-09-13T05:29:40.170Z","comments":true,"path":"atcoder-agc046/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc046/","excerpt":"比赛地址","text":"比赛地址 A - Takahashikun, The Strider 题意 有一个人，初始时在 \\((0,0)\\)，面向 \\(y\\) 轴正方向。每一步会向前走一个单位，然后逆时针旋转 \\(X^{\\circ}\\)。 求第一次回到 \\((0,0)\\) 时用的步数。 题解 可以证明答案为 \\(\\frac{360}{\\gcd(X,360)}\\)。 代码 B - Extension 题意 有一个 \\(A\\times B\\) 的全白网格。每次可以在上面加上一行，并且将这一行的恰好一个格子染成黑色；或者在右边加上一列，并且将这一列的恰好一个格子染成黑色。 求通过若干次操作后 \\(C\\times D\\) 的本质不同的网格数量。对 \\(998244353\\) 取模。 \\(C,D\\le 3000\\) 题解 直接 DP，记 \\(f_{i,j}\\) 为 \\(i\\times j\\) 的本质不同网格数量。转移考虑最后一次操作是扩充行还是扩充列，但是注意右上角为白色的方案会被算两次，要减去。转移方程为 \\[f_{i,j}=f_{i-1,j}\\times j+f_{i,j-1}\\times i-f_{i-1,j-1}\\times (i-1)\\times (j-1)\\] 时间复杂度 \\(O(CD)\\)。 代码 C - Shift 题意 给定 01 字符串 \\(S\\)，求有多少本质不同的字符串可以通过 \\(S\\) 执行 \\(0\\) 到 \\(K\\) 次以下操作得到： 选择 \\(i,j\\ (i&lt;j)\\) 满足 \\(S_i=0,S_j=1\\)，将 \\(S_j\\) 移动到 \\(S_i\\) 的左边。 \\(|S|\\le 300,K\\le 10^9\\) 题解 考虑将相邻的 \\(0\\) 之间（包括首尾）\\(1\\) 的数量依次记为 \\(a_1,a_2,\\ldots,a_m\\)。 则一次操作相当于 \\(a_i\\gets a_i+1,a_j\\gets a_j-1\\)，其中 \\(i&lt;j\\)。 考虑最终得到的序列 \\(b_1,b_2,\\ldots,b_m\\)，需要满足： 对于所有 \\(1\\le i\\le m\\)，满足 \\(\\sum\\limits_{j=1}^{i} b_j\\ge \\sum\\limits_{j=1}^{i} a_j\\)； \\(\\sum\\limits_{i=1}^{m}b_i=\\sum\\limits_{i=1}^{m}a_i\\)； \\(\\sum\\limits_{i=1}^{m}\\max(b_i-a_i,0)\\le k\\) 于是在 DP 状态中记录当前 \\(b_i\\) 之和以及 \\(\\max(b_i-a_i,0)\\) 之和，直接转移是 \\(O(|S|^4)\\) 的，可以用前缀和优化到 \\(O(|S|^3)\\)。 代码 D - Secret Passage 题意 给定 01 字符串 \\(S\\)，求有多少本质不同的字符串可以通过 \\(S\\) 执行若干次（包括 \\(0\\) 次）以下操作得到： 删除前两个字符中的一个，将另一个插入到字符串中的任意位置。 \\(|S|\\le 300\\) 题解 考虑将 \\(T\\) 表示成 \\(S\\) 的一个后缀中插入若干个 \\(0,1\\)。 为了判断 \\(T\\) 能否通过 \\(S\\) 得到，我们一定会使这个表示中 \\(0,1\\) 数量尽量，也就是 \\(S\\) 的后缀尽量长。 那么我们用 \\(f[i][j][k]\\) 表示后缀为 \\(S[i+1,n]\\)，需要插入 \\(j\\) 个 \\(0\\)、\\(k\\) 个 \\(1\\) 的字符串 \\(T\\) 的数量。因为我们保证后缀尽量长，所以不会算重。 接下来我们需要考虑的问题是通过删除前缀 \\(S[1..i]\\)，能否向后缀中插入 \\(j\\) 个 \\(0\\) 和 \\(k\\) 个 \\(1\\)。 令 \\(g[i][j][k]\\) 表示已经删除前缀 \\(S[1..i]\\)，向后缀中插入 \\(j\\) 个 \\(0\\) 和 \\(k\\) 个 \\(1\\) 时，最多有多少个字符可以被再次删除。 转移考虑直接删除 \\(i\\) 和 \\(i+1\\) 还是删除 \\(i\\) 和之前一个删除后插入到该位置的字符。 最后对于 \\(i,j,k\\)，若存在一个 \\(i&#39;\\le i,j&#39;\\ge j,k&#39;\\ge k\\) 满足 \\(g[i&#39;][j&#39;][k&#39;]\\ge 0\\)，则答案加上 \\(f[i][j][k]\\) 即可。 时间复杂度 \\(O(|S|^3)\\)。 代码 E - Permutation Cover 题意 你需要构造一个满足以下条件的序列 \\(P\\)，无解输出 \\(-1\\)： 序列中每个元素为 \\(1\\) 到 \\(K\\) 的整数，且整数 \\(i\\) 恰好出现 \\(a_i\\) 次。 对于序列中每个元素，都存在至少一个连续子序列包含该元素并且是一个 \\(1\\) 到 \\(K\\) 的排列。 在满足以上条件的前提下要求字典序最小。 \\(K\\le 100,\\sum a_i\\le 1000\\) 题解 令 \\(x=\\max a_i,y=\\min a_i\\)，则有解的充要条件为 \\(x\\le 2y\\)，证明如下： 必要性：假设不满足该条件。取满足 \\(a_i=x\\) 的任意一个 \\(i\\) 和满足 \\(a_i=y\\) 的任意一个 \\(j\\)，只考虑序列 \\(P\\) 中值为 \\(i\\) 或 \\(j\\) 的位置按相对顺序拿出来组成一个新的序列，则必定存在一个值为 \\(i\\) 的位置只与 \\(i\\) 相邻，那么就一定不存在一个排列覆盖到这个位置。假设不成立，必要性得证。 充分性：考虑从空序列开始依次加入若干个序列得到最终的序列。记 \\(B_i\\) 为当前元素 \\(i\\) 还需要放多少个。将所有满足 \\(B_i=y\\) 的元素 \\(i\\) 取出，按任意顺序排列得到序列 \\(S\\)，其他元素按任意顺序排列得到序列 \\(T\\)。我们在 \\(P\\) 中依次加入序列 \\(T,S,T\\) 即可。这样的构造可以始终满足 \\(x\\le 2y\\) 的条件，充分性得证。 接下来我们仍然考虑用依次加入若干序列的方式构造最终的序列。 假设当前序列为 \\(P\\)，最后 \\(k\\) 个元素按顺序组成的序列为 \\(Q\\)，第 \\(i\\) 个元素还需要 \\(B_i\\) 个。 显然 \\(Q\\) 一定是一个排列。 令 \\(x=\\max B_i,y=\\min B_i\\)，则有解的充要条件为： \\(x\\le 2y+1\\)； 若 \\(x=2y+1\\)，则还需要满足 \\(Q\\) 中所有 \\(B_i=x\\) 的元素 \\(i\\) 在所有 \\(B_j=x\\) 的元素 \\(j\\) 的前面。 第一个条件的必要性：类似于之前有解条件的必要性证明，需要注意第一个 \\(B_i=x\\) 的元素 \\(i\\) 可以和前面部分组成一个排列，所以需要删去。 第二个条件的必要性：可以假设存在一个 \\(B_j=y\\) 的元素 \\(j\\) 和 \\(B_i=x\\) 的元素 \\(i\\) 满足 \\(j\\) 的位置在 \\(i\\) 前面，观察 \\(x\\le 2y+1\\) 的必要性证明，可以发现此时第一个元素不能与前面组成排列，不能删去，那么此时必须满足 \\(x\\le 2y\\)，与 \\(x=2y+1\\) 矛盾，假设不成立，得证。 充分性：假设最后一个满足 \\(B_i=x\\) 的元素 \\(i\\) 为 \\(Q\\) 中第 \\(s\\) 个。考虑在 \\(P\\) 的末尾加入 \\(Q_1,Q_2,\\ldots,Q_s\\)，此时 \\(y\\) 不变，\\(x\\) 一定减 \\(1\\)，所以此时满足 \\(x=2y\\)，一定有解。充分性得证。 有了以上两个结论后，我们就可以构造字典最小的解了。 考虑每次枚举加入的元素个数 \\(s\\)，则此时加入的一定是 \\(Q_1,Q_2,\\ldots,Q_s\\) 的一个排列，那么我们就可以确定加入以后的 \\(B_i\\)，于是可以求出新的 \\(x\\) 和 \\(y\\)。分三种情况： 若 \\(x\\le 2y\\)，则直接从小到大排序后加入即可； 若 \\(x=2y+1\\)，我们将 \\(B_{Q_i}\\in \\{x,y\\}\\) 的元素 \\(Q_i\\) 放在序列 \\(f_1\\) 中，其余元素放在 \\(f_2\\) 中。\\(f_1\\) 优先按是否为 \\(y\\) 进行排序，都是 \\(y\\) 或都是 \\(x\\) 则按大小排序；\\(f_2\\) 直接按大小排序。然后将 \\(f_1\\) 和 \\(f_2\\) 归并即可。注意需要判断最终的序列是否合法。 若 \\(x&gt;2y+1\\)，则直接无解。 时间复杂度 \\(O(K^2\\sum a_i)\\)。 代码 F - Forbidden Tournament 题意 求满足以下条件的 \\(N\\) 个点有标号竞赛图数量： 每个节点入度不超过 \\(K\\)； 不存在四个互不相同的节点 \\(a,b,c,d\\) 满足，同时存在 \\(a\\to b,b\\to c,c\\to a,a\\to d,b\\to d,c\\to d\\) 这六条边。 \\(N\\le 200\\) 题解 令图 \\(H=(\\{a,b,c,d\\},\\{(a,b),(b,c),(c,a),(a,d),(b,d),(c,d)\\})\\)，即不能出现的子图。下文中，在不会引起歧义的前提下，会使用一个点集来表示一个诱导子图。 接下来我们考虑一个合法的竞赛图 \\(G\\) 的结构。 首先我们不断将入度为 \\(0\\) 的节点删去，假设删去了 \\(s\\) 个节点，则现在 \\(G\\) 变为了一个 \\(N-s\\) 个点，入度不超过 \\(K-s\\) 的强连通竞赛图。 接下来我们任选 \\(G\\) 中的一个节点 \\(v\\)，将所有存在边 \\(v\\to w\\) 的节点 \\(w\\) 组成的集合记为 \\(Y\\)，其余节点记为 \\(X\\)，注意 \\(v\\in X\\)。 竞赛图有性质：若一个竞赛图中存在环，则该图中一定存在三元环。 那么假设 \\(X\\) 中存在环，那么一定存在不包含 \\(v\\) 的三元环，那么这个三元环与 \\(v\\) 一起会组成 \\(H\\)，不合法，所以 \\(X\\) 一定是一个 DAG。我们将这些节点按拓扑序记为 \\(x_1,x_2,\\ldots,x_k\\)，那么有 \\(x_i\\to x_j\\) 当且仅当 \\(i &lt; j\\)。 因为不存在入度为 \\(0\\) 的点，那么一定存在 \\(w\\in Y,u\\in X\\) 满足存在边 \\(w\\to u\\)。假设存在一个点 \\(w&#39;\\in Y\\) 满足存在边 \\(w\\to w&#39;\\)，那么一定存在边 \\(w&#39;\\to u\\)。这是因为如果存在边 \\(u\\to w&#39;\\)，则 \\(u,v,w,w&#39;\\) 会构成 \\(H\\)，不合法。 然后我们可以推导出对于 \\(w\\) 能到的所有在 \\(Y\\) 中的点 \\(w&#39;&#39;\\)，都存在边 \\(w&#39;&#39;\\to u\\)。那么 \\(w\\) 能到的在 \\(Y\\) 中的点一定不会有环，因为如果有环，就会有三元环，就会与 \\(u\\) 组成 \\(H\\)，不合法。 对于 \\(w\\) 不能到的所有在 \\(Y\\) 中的点 \\(z\\)，一定存在边 \\(z\\to w\\)，那么如果这些点中存在环，又会与 \\(w\\) 组成 \\(H\\)，不合法。 综合以上两部分，我们证明了 \\(Y\\) 也是一个 DAG，我们可以将 \\(Y\\) 中的节点按拓扑序记为 \\(y_1,y_2,\\ldots,y_l\\)。 接下来我们只要考虑 \\(X,Y\\) 之间边的方向。 根据上面的讨论，我们得到了一个引理：如果存在边 \\(y_j\\to x_i\\)，那么对于所有 \\(j\\le j&#39;\\le l\\)，都存在边 \\(y_{j&#39;}\\to x_i\\)。 根据这个引理，假设存在边 \\(x_1\\to y_l\\)，那么对于所有 \\(1\\le j\\le l\\)，都存在边 \\(x_1\\to y_j\\)，这与 \\(x_1\\) 入度大于 \\(0\\) 矛盾，所以一定存在边 \\(y_l\\to x_1\\)。 接下来我们证明，对于所有 \\(2\\le i\\le k\\)，假设存在边 \\(x_i\\to y_l\\)，那么对于所有 \\(i &lt; i&#39; \\le k\\)，一定存在边 \\(x_{i&#39;}\\to y_l\\)。假设存在边 \\(y_l\\to x_{i&#39;}\\)，那么 \\(x_i,y_l,x_1,x_{i&#39;}\\) 构成了 \\(H\\)，不合法。也就是说，存在边 \\(y_l\\to x_i\\) 的 \\(i\\) 一定是一个前缀 \\(\\{1,\\ldots,t\\}\\)。 我们还可以证明，对于所有 \\(1\\le i\\le t,1\\le j\\le l-1\\)，若存在边 \\(x_i\\to y_j\\)，那么对于所有 \\(i &lt; i&#39; \\le k\\)，都存在边 \\(x_{i&#39;}\\to y_j\\)。假设存在边 \\(y_j\\to x_{i&#39;}\\)，根据引理一定存在 \\(y_l\\to x_{i&#39;}\\)，那么 \\(x_i,y_j,y_l,x_{i&#39;}\\) 构成了 \\(H\\)，不合法。 我们可以将上面的结论推广到 \\(1\\le i\\le k\\) 的情况，此时我们需要证明当所有 \\(1\\le i&#39;&#39;\\le t\\) 都存在边 \\(y_j\\to x_{i&#39;&#39;}\\) 时，对于 \\(t &lt; i &lt; i&#39; \\le k\\)，若存在边 \\(x_i\\to y_j\\)，则一定存在边 \\(x_{i&#39;}\\to y_j\\)。假设存在边 \\(y_j\\to x_{i&#39;}\\)，则 \\(x_{i&#39;&#39;},x_i,y_j,x_{i&#39;}\\) 会构成 \\(H\\)，不合法。 根据上面的结论，我们可以发现对于所有 \\(1\\le j\\le l\\)，都存在一个 \\(p_j\\) 满足，对于所有 \\(1\\le i\\le p_j\\)，存在边 \\(y_j\\to x_i\\)；对于所有 \\(p_j &lt; i\\le k\\)，存在边 \\(x_i\\to y_j\\)。 根据引理，我们可以得到 \\(p_j \\le p_{j+1}\\)。 另外我们还需要满足 \\(0\\le p_j &lt; k, p_l\\ge 1\\)。 可以发现只需要满足这三个条件就可以唯一构造出一个不存在 \\(H\\) 的强连通竞赛图 \\(G\\)。 那么我们只需要计算 \\(p\\) 的方案数，DP 即可，注意判断当前的状态是否满足度数限制。 一次 DP 复杂度 \\(O(kl)\\)，总复杂度 \\(O(N^4)\\)。 值得一提的是，序列 \\(p\\) 的方案数等价于不能经过两条直线的路径方案数，可以用容斥与组合数学优化到更低的复杂度。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"竞赛图","slug":"竞赛图","permalink":"https://autumnkite.github.io/tags/%E7%AB%9E%E8%B5%9B%E5%9B%BE/"}]},{"title":"AtCoder Grand Contest 047 题解","slug":"atcoder-agc047","date":"2020-09-02T13:16:43.000Z","updated":"2020-09-13T05:27:10.915Z","comments":true,"path":"atcoder-agc047/","link":"","permalink":"https://autumnkite.github.io/atcoder-agc047/","excerpt":"比赛地址","text":"比赛地址 A - Integer Product 题意 给定 \\(n\\) 个小数点后最多 \\(9\\) 位的实数 \\(A_1,A_2,A_3,\\ldots,A_n\\)，求有多少对 \\((i,j)\\ (1\\le i &lt; j\\le n)\\) 满足 \\(A_i\\cdot A_j\\) 为整数。 \\(n\\le 2\\times 10^5,0&lt;A_i&lt;10^4\\) 题解 令 \\(a_i=10^9A_i=2^{x_i}5^{y_i}r_i\\)，将小数转化为整数。 则合法的 \\((i,j)\\) 需要满足 \\(10^{18}|a_ia_j\\)，也就是满足 \\(x_i+x_j\\ge 18,y_i+y_j\\ge 18\\)。 直接枚举 \\(x_i,x_j,y_i,y_j\\) 即可。注意去掉 \\(i\\ge j\\) 的情况。 记 \\(m=\\max\\{a_i\\}\\)，时间复杂度 \\(O(n\\log m+\\log^4 m)\\)。 代码 B - First Second 题意 对于一个字符串，有一种操作是删除这个字符串的第一个字符或第二个字符。 有 \\(n\\) 个字符串 \\(S_1,S_2,S_3,\\ldots,S_n\\)，求有多少对 \\((i,j)\\ (1\\le i &lt; j\\le n)\\) 满足 \\(S_i\\) 和 \\(S_j\\) 中的其中一个字符串可以通过若干次上述操作得到另一个字符串。 \\(n\\le 2\\times 10^5,\\sum |S_i|\\le 10^6,|\\Sigma|\\le 26,S_i\\ne S_j\\)。 题解 考虑两个字符串 \\(A,B\\ (|A|\\le |B|)\\) 可以从 \\(B\\) 变成 \\(A\\) 当且仅当 \\(A[2..|A|]\\) 是 \\(B\\) 的一个后缀，且 \\(A[1]\\) 在 \\(B[1..|B|-|A|+1]\\) 中出现。 将字符串翻转后，条件变为 \\(A\\) 可以拆成 \\(B\\) 中一个前缀加一个字符的形式。 考虑将所有 \\(S_i\\) 翻转后建 Trie，枚举每个字符串以及另一个字符串在该字符串中对应的前缀和后面加的字符即可。 时间复杂度 \\(O(|\\Sigma|\\sum |S_i|)\\)。 代码 C - Product Modulo 题意 令质数 \\(P=200003\\)。给定 \\(n\\) 个整数 \\(A_1,A_2,A_3,\\ldots,A_n\\)，求 \\[\\sum_{i=1}^{n}\\sum_{j=i+1}^{n} (A_iA_j\\bmod P)\\] 的值。 \\(n\\le 2\\times 10^5\\) 题解 求出 \\(P\\) 的一个原根 \\(g=2\\)。 于是我们可以将 \\(A_i\\) 表示成 \\(g^{B_i}\\bmod P\\)。 于是 \\(A_iA_j\\bmod P=g^{B_i+B_j}\\bmod P\\)。 用 FFT 求出对于每个 \\(k\\) 求出 \\(B_i+B_j=k\\) 的 \\((i,j)\\) 数量即可。 时间复杂度 \\(O(P\\log P)\\)。 代码 D - Twin Binary Trees 题意 有两棵高度为 \\(H\\) 的满二叉树 \\(T_1,T_2\\)，节点编号为从根开始逐层标号 \\(1\\) 到 \\(2^H-1\\)。 有一个 \\(1\\) 到 \\(2^{H-1}\\) 的排列 \\(P\\)，表示 \\(T_1\\) 中编号为 \\(2^{H-1}+i-1\\) 的叶子与 \\(T_2\\) 中编号为 \\(2^{H-1}+P_i-1\\) 的叶子有一条特殊边。 定义一个环的权值为环上所有节点编号的乘积。 求所有恰好包含两条特殊边的简单环的权值之和。对 \\(10^9+7\\) 取模。 \\(H\\le 18\\) 题解 一个暴力的想法是枚举 \\(T_1\\) 中的两个叶子 \\(x,y\\)，然后能唯一确定一个简单环 \\(x\\to \\operatorname{LCA}(T_1,x,y)\\to y\\to P_y\\to \\operatorname{LCA}(T_2,P_x,P_y)\\to P_x\\to x\\)。 考虑枚举 \\(x,y\\) 在 \\(T_1\\) 上的 LCA \\(u\\)，然后枚举 \\(u\\) 左子树中每个叶子 \\(x\\)，在 \\(T_2\\) 中 \\(P_x\\) 到根路径上的每个点上加上对应的路径权值。 接下来枚举右子树中每个点 \\(y\\)，枚举 \\(T_2\\) 中 \\(P_y\\) 到根路径上的每个点作为 \\(P_x,P_y\\) 的 LCA 计算贡献。 时间复杂度 \\(O(2^H\\times H^2)\\)。 代码 E - Product Simulation 题意 本题没有输入。 你可以在长度为 \\(N=200000\\) 的数组 \\(a_0,a_1,a_2,\\ldots,a_{N-1}\\) 上执行以下两种操作： `+ i j k`，表示执行 \\(a_k\\gets a_i+a_j\\)。\\(i,j,k\\) 不需要互不相同。 &lt; i j k，表示执行 \\(a_k\\gets [a_i&lt;a_j]\\)。\\(i,j,k\\) 不需要互不相同。 初始时，\\(a_0=A,a_1=B,a_2=a_3=\\ldots=a_{N-1}=0\\)。 你可以执行最多 \\(Q=200000\\) 次操作来实现 \\(a_2\\gets a_0\\times a_1\\)。 \\(0\\le A,B\\le 10^9\\)。注意你不知道 \\(A,B\\) 具体的值。 题解 首先考虑一个最简单的问题，实现 \\(a_k\\gets a_i\\times a_j\\)，其中 \\(a_i,a_j\\in \\{0,1\\}\\)。 在这种情况下，有一个简单的式子 \\(a_i\\times a_j=[1&lt;a_i+a_j]\\)。 假设我们已经在第 \\(3\\) 个位置构造出了 \\(1\\)，则我们只要依次执行 + i j k 和 &lt; 3 k k 即可。 注意到 \\(A=B=0\\) 时无论如何执行操作数组中都不可能出现除 \\(0\\) 以外的数，所以我们可以忽略这种情况。 在其他情况下，\\(A&lt;2(A+B)\\) 恒成立，所以我们用该式子可以构造出 \\(1\\)。 构造出 \\(1\\) 以后，我们可以依次构造出 \\(2^1,2^2,\\ldots,2^{29}\\)。 类似地，我们可以实现 \\(a_x\\gets a_x\\times 2^k\\) 的操作，只要执行 \\(k\\) 次 + x x x 即可。 接下来我们可以实现对非负整数 \\(x\\) 二进制分解。从高到低依次枚举 \\(2^k\\)，用临时变量 \\(S\\) 存储已经确定的位，每次将 \\(S+2^k&lt;x+1\\) 的值存在临时变量 \\(t\\) 中，将 \\(t\\) 的值赋值到存储分解结果的位置，然后将 \\(t\\) 乘上 \\(2^k\\) 后加到 \\(S\\) 中。可以发现这些操作都可以用上面讨论过的操作实现。 我们用上述操作将 \\(A,B\\) 分解后，枚举每一对二进制位 \\((i,j)\\)，用之前提到过的 01 乘法和自乘 \\(2\\) 的幂次的操作即可实现乘法。 数组使用约 \\(100\\) 个，操作次数约为 \\(30000\\) 次。 代码 F - Rooks 题意 有一个无限大的棋盘上有 \\(n\\) 个互不攻击的车 \\((X_i,Y_i)\\)。车的攻击范围为所在的行和所在的列。 你可以用一个国王替换某一个车。国王的移动方式为每次向上下左右其中一个方向移动一格。特别地，在攻击车时，移动方式为每次向左上、左下、右上、右下四个方向其中一个方向移动一格。 国王不能进入存在的车的攻击范围内。 对于每个 \\(i\\)，求用国王替换第 \\(i\\) 个车时，在攻击最多的车的前提下，最少需要的移动步数。 \\(n\\le 2\\times 10^5\\) 题解 考虑一个简单的 DP。将车按 \\(x\\) 坐标排序，国王在攻击的过程中，被攻击的车一定是一个区间。用 \\(f[L][R][0/1]\\) 表示当前已经攻击掉 \\([L,R]\\) 这些车，国王在车 \\(L\\)/车 \\(R\\) 的位置时，攻击最多的车还需要的最少步数。 转移比较简单，不再展开。 注意到若要攻击的区间 \\([l,r]\\) 满足，横坐标相邻的车纵坐标也相邻，那么假设起点为 \\(s\\)，攻击的路线一定是 \\(s\\to l\\to r\\) 或 \\(s\\to r\\to l\\)。可以 \\(O(1)\\) 计算。 然后我们发现，如果我们将这样的极大区间看成一个整体，我们可以将这个区间继续往左右两边扩张，扩张后的区间仍然存在类似的性质。可以结合下图理解： 于是我们只要将每次扩张的区间作为 DP 的状态进行 DP 即可。 注意到最开始的区间中的每个点作为起点时，都可以快速计算，于是我们可以通过这样的一次扩张和 DP 将初始的区间中每个车作为起点的答案都计算出来。 结合上图可以发现，只有在扩张白色点时才会将白色、蓝色、绿色的点都访问一遍，而扩张蓝色点、绿色点时都只会扩张出本身的一个区间，所以每个点最多被访问 \\(2\\) 次。 还有一个小情况如下： 中间的相交部分最多只会被两个大矩形包含，所以最多被访问 \\(3\\) 次。 最终复杂度瓶颈在于排序和离散的复杂度，扩张和 DP 部分复杂度为线性。 图片来自于官方视频题解。 代码","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"枚举","slug":"枚举","permalink":"https://autumnkite.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"数论","slug":"数论","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"trie","slug":"trie","permalink":"https://autumnkite.github.io/tags/trie/"},{"name":"FFT","slug":"FFT","permalink":"https://autumnkite.github.io/tags/FFT/"}]},{"title":"Educational Codeforces Round 85 (Rated for Div. 2)","slug":"cf1334","date":"2020-04-13T13:23:00.000Z","updated":"2020-04-13T13:59:19.886Z","comments":true,"path":"cf1334/","link":"","permalink":"https://autumnkite.github.io/cf1334/","excerpt":"罚时被 E 搞没了。","text":"罚时被 E 搞没了。 A - Level Statistics 题目传送门 题解 初始状态为 \\(p_0=0,c_0=0\\)。 由于每进行一次游戏，\\(p\\) 一定会加 \\(1\\)，而 \\(c\\) 可能加 \\(1\\) 也有可能不变，所以 \\(p\\) 增加的值一定大于等于 \\(c\\) 增加的值，并且他们增加的值必须非负。 所以只要判断是否所有 \\(i\\) 都满足 \\(p_{i-1} \\le p_i,c_{i-1} \\le c_i,p_i-p_{i-1}\\ge c_{i}-c_{i-1}\\) 即可。 代码 1234567891011121314151617181920212223int n;void solve() &#123; read(n); int x = 0, y = 0; bool flag = true; for (int i = 1; i &lt;= n; ++i) &#123; int nx, ny; read(nx), read(ny); if (nx &lt; x || ny &lt; y) &#123; flag = false; &#125; if (nx - x &lt; ny - y) &#123; flag = false; &#125; x = nx, y = ny; &#125; if (flag) &#123; printStr(&quot;YES&quot;); &#125; else &#123; printStr(&quot;NO&quot;); &#125;&#125; B - Middle Class 题目传送门 题解 假设我们已经知道了答案 \\(s\\)，考虑如何判断是否合法。 我们需要让 \\(s\\) 个人的钱数 \\(\\ge x\\)，那么我们的最优策略一定是选择最大的 \\(s\\) 个人，然后对这 \\(s\\) 个人进行一次操作，如果得到的平均值 \\(\\ge x\\) 则符合条件，否则一定不可以。 那么我们只要将所有数从大到小排序以后，枚举答案 \\(s\\) 进行判断即可。 代码 123456789101112131415161718192021const int N = 100005;int n, x, a[N];void solve() &#123; read(n), read(x); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; std::sort(a + 1, a + 1 + n); std::reverse(a + 1, a + 1 + n); long long sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; sum += a[i]; if (sum &lt; 1ll * x * i) &#123; print(i - 1); return; &#125; &#125; print(n);&#125; C - Circle of Monsters 题目传送门 题解 为方便描述，下文中 \\(i+1\\) 表示环上 \\(i\\) 的下一个怪物，\\(i-1\\) 表示环上 \\(i\\) 的上一个怪物。 首先我们将 \\(b_i\\) 与 \\(a_{i+1}\\) 取 \\(\\min\\)，这显然不会影响答案。 对于一个怪物 \\(i\\)，打败他至少需要的操作次数为 \\(a_i-b_{i-1}\\)，即打 \\(a_i-b_{i-1}\\) 枪，剩下的血量用上一个怪物炸。 那么总的操作次数的下界即为 \\(\\sum\\limits_{i=1}^{n} a_i-b_{i-1}\\)。 但是这是一个环形，我们不可能做到每个怪物都被上一个怪物炸，必须有一个怪物是手动打死的。 而在之前的操作次数下界的基础上，手动打死怪物 \\(i\\) 需要花费额外的 \\(b_i\\) 次操作，所以我们只要选择 \\(b_i\\) 最小的那个怪物手动打死即可。 总花费即为 \\(\\min\\limits_{1\\le i\\le n} b_i+\\sum\\limits_{i=1}^{n} a_i-b_{i-1}\\)。 代码 1234567891011121314151617181920const int N = 300005;const long long INF = 0x3f3f3f3f3f3f3f3fll;int n;long long a[N], b[N];void solve() &#123; read(n); long long sum = 0, mn = INF; for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]), read(b[i]); sum += a[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; b[i] = std::min(b[i], a[i % n + 1]); mn = std::min(mn, b[i]); sum -= b[i]; &#125; print(sum + mn);&#125; D - Minimum Euler Cycle 题目传送门 题解 看到完全图，欧拉回路，以及字典序最小，一个很自然的想法是从 \\(1\\) 开始，每次走能走的最小的那个点。 模拟发现，这样走一定能恰好走出一条欧拉回路，顶点序列如下： \\[1,2,1,3,\\cdots,1,n,2,3,2,4,\\cdots,2,n,3,4,\\cdots,n,n-1,n,1\\] 我们可以将这个序列分成若干组，可以更直观的看出规律： \\[ \\begin{aligned} &amp; 1,2,1,3,\\cdots,1,n \\\\ &amp; 2,3,2,4,\\cdots,2,n \\\\ &amp; 3,4,3,5,\\cdots,3,n \\\\ &amp; \\vdots \\\\ &amp; n-2,n-1,n-2,n \\\\ &amp; n-1,n \\\\ &amp; 1 \\end{aligned} \\] 于是我们求出 \\(l,r\\) 在第几组中的第几个，直接模拟即可。 注意需要特判最后的 \\(1\\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142const int N = 100005;int n;long long l, r;std::pair&lt;int, int&gt; get(long long l) &#123; int p = 1; while (p &lt; n &amp;&amp; l &gt; 2 * (n - p)) &#123; l -= 2 * (n - p); ++p; &#125; return &#123;p, l&#125;;&#125;void solve() &#123; read(n), read(l), read(r); bool flag = 0; if (r == 1ll * n * (n - 1) + 1) &#123; if (l == r) &#123; print(1); return; &#125; flag = 1, --r; &#125; std::pair&lt;int, int&gt; L = get(l), R = get(r); for (int k = L.first; k &lt;= R.first; ++k) &#123; int lb = k == L.first ? L.second : 1; int rb = k == R.first ? R.second : 2 * (n - k); for (int i = lb; i &lt;= rb; ++i) &#123; if (i &amp; 1) &#123; print(k, &#x27; &#x27;); &#125; else &#123; print(k + i / 2, &#x27; &#x27;); &#125; &#125; &#125; if (flag) &#123; print(1); &#125; else &#123; putchar(&#x27;\\n&#x27;); &#125;&#125; E - Divisor Paths 题目传送门 题解 打 CF 只知道猜结论，一个 WA22 以为结论错了，没想到是没开 long long。当场去世。 好的我们开始猜结论。 首先，对于两个点 \\(x,y\\ (x \\ge y)\\)，若 \\(y|x\\)，那么 \\(x\\) 到 \\(y\\) 的最短路长度一定是 \\(d(x)-d(y)\\)（\\(d(x)\\) 表示 \\(x\\) 的因子数量）。所以，从 \\(x\\) 开始不断除掉某个质因子直到等于 \\(y\\) 的一条路径一定是一条最短路。 如果中途增大了会导致因子数量变多，所以反过来也是成立的。 上面的结论可以更加严谨的证明，这里不做详细证明。 那么最短路条数等于将 \\(\\frac{x}{y}\\) 分解质因数后的可重元素排列数量。可以直接预处理阶乘和阶乘逆元求出。 拓展到一般情况，\\(x\\) 到 \\(y\\) 的最短路一定经过点 \\(\\gcd(x,y)\\)。大概理解一下，一定不会经过比 \\(\\gcd(x,y)\\) 更小的公因子，这样显然不优；也一定不会往 \\(\\operatorname{lcm}(x,y)\\) 的方向走，由于 \\(\\frac{a}{b}=\\frac{b}{c}\\) 时，\\(d(a)-d(b) &gt; d(b)-d(c)\\)，所以往 \\(\\operatorname{lcm}(x,y)\\) 方向走也是不优的。 那么只要分别求出 \\(x\\to \\gcd(x,y)\\) 和 \\(y\\to \\gcd(x,y)\\) 的最短路数量，相乘即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const int P = 998244353;long long n;int q;int fac[105], inv[105];std::vector&lt;std::pair&lt;long long, int&gt;&gt; p;long long gcd(long long a, long long b) &#123; return b ? gcd(b, a % b) : a;&#125;int qpow(int a, int b) &#123; int s = 1; for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1) &#123; s = 1ll * s * a % P; &#125; a = 1ll * a * a % P; &#125; return s;&#125;void init(int n) &#123; fac[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; fac[i] = 1ll * fac[i - 1] * i % P; &#125; inv[n] = qpow(fac[n], P - 2); for (int i = n; i; --i) &#123; inv[i - 1] = 1ll * inv[i] * i % P; &#125;&#125;int get(long long x) &#123; int res = 1, sum = 0; for (auto v : p) &#123; int k = 0; while (x % v.first == 0) &#123; x /= v.first; ++k; &#125; res = 1ll * res * inv[k] % P; sum += k; &#125; return 1ll * res * fac[sum] % P;&#125;void solve() &#123; read(n); init(100); long long x = n; for (int i = 2; 1ll * i * i &lt;= x; ++i) &#123; if (x % i == 0) &#123; p.push_back(&#123;i, 0&#125;); while (x % i == 0) &#123; x /= i; ++p.back().second; &#125; &#125; &#125; if (x &gt; 1) &#123; p.push_back(&#123;x, 1&#125;); &#125; read(q); while (q--) &#123; long long x, y; read(x), read(y); long long g = gcd(x, y); print(1ll * get(x / g) * get(y / g) % P); &#125;&#125; F - Strange Function 题目传送门 题解 首先考虑将删去最小的转化成保留最大的。 这种选一个子序列满足什么条件的问题，我们首先考虑一个经典的 DP。 设 \\(f_{i,j}\\) 表示 \\(a\\) 的前 \\(i\\) 个数中选出一个子序列（强制 \\(i\\) 选），进行题目中的操作后得到的序列与 \\(b_{1\\ldots j}\\) 相等时的最大权值。 由于我们强制 \\(i\\) 选，所以合法的 \\(j\\) 是唯一的，我们大可不必记录 \\(j\\) 这一维状态。 考虑满足 \\(a_i=b_j\\) 的唯一的 \\(j\\)，令 \\(a_0=b_0=0\\)，那么有转移 \\[f_i=\\max_{0\\le k &lt; i,a_k=b_{j-1}}\\{f_k+\\sum_{t=k+1}^{i-1}[a_t\\le a_k][p_t &gt; 0]p_t\\}+p_i\\] 对于当前的 \\(i\\)，设 \\[g_k=f_k+\\sum_{t=k+1}^{i-1}[a_t\\le a_k][p_t &gt; 0]p_t\\] 考虑将 \\(i\\) 加 \\(1\\) 后 \\(g_k\\) 的变化。对于满足 \\(0\\le k &lt; i\\) 的所有 \\(k\\)，如果 \\(p_i\\le 0\\) 那么 \\(g_k\\) 显然不会改变，否则所有满足 \\(a_k\\ge a_i\\) 的 \\(g_k\\) 会加上 \\(p_i\\)；对于 \\(k=i\\) 的 \\(g_k\\)，有 \\(g_k=f_i\\)。 考虑一个以 \\(a_k\\) 为下标的数组，位置 \\(v\\) 的值即为 \\[\\max_{0\\le k &lt; i,a_k=v}\\{g_k\\}\\] 根据上述分析，我们需要在这个数组上支持后缀加、单点取 \\(\\max\\)、单点查询操作即可。单点取 \\(\\max\\) 操作可以拆分为一个单点查询和两个后缀加操作。 后缀加、单点查询可以用树状数组简单地维护。 时间复杂度 \\(O(n\\log n)\\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const int N = 500005;const long long INF = 0x3f3f3f3f3f3f3f3fll;int n, a[N], m, b[N];long long w[N], sum, f[N];struct BIT&#123; long long c[N]; void add(int x, long long v) &#123; // 后缀加 for (; x &lt;= n; x += x &amp; -x) &#123; c[x] += v; &#125; &#125; long long query(int x) &#123; // 单点查询 long long s = 0; for (; x; x ^= x &amp; -x) &#123; s += c[x]; &#125; return s; &#125;&#125; T;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; for (int i = 1; i &lt;= n; ++i) &#123; read(w[i]); sum += w[i]; &#125; read(m); for (int i = 1; i &lt;= m; ++i) &#123; read(b[i]); &#125; T.add(1, -INF); for (int i = 1; i &lt;= n; ++i) &#123; int j = std::lower_bound(b + 1, b + 1 + m, a[i]) - b; if (j &lt;= m &amp;&amp; a[i] == b[j]) &#123; if (j == 1) &#123; f[i] = w[i]; &#125; else &#123; f[i] = T.query(b[j - 1]) + w[i]; &#125; &#125; else &#123; f[i] = -INF; &#125; if (w[i] &gt; 0) &#123; T.add(a[i], w[i]); &#125; long long tmp = T.query(a[i]); if (f[i] &gt; tmp) &#123; T.add(a[i], f[i] - tmp); T.add(a[i] + 1, tmp - f[i]); &#125; &#125; long long ans = T.query(b[m]); if (ans &gt; -1e15) &#123; printStr(&quot;YES&quot;); print(sum - ans); // 用总和减去最大保留的权值 &#125; else &#123; printStr(&quot;NO&quot;); &#125;&#125; G - Substring Search 题目传送门 也许会补的吧...","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"数论","slug":"数论","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"树状数组","slug":"树状数组","permalink":"https://autumnkite.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}]},{"title":"Codeforces Round #632 (Div. 2) 裂开记","slug":"cf1333","date":"2020-04-10T06:23:00.000Z","updated":"2020-04-10T06:40:22.083Z","comments":true,"path":"cf1333/","link":"","permalink":"https://autumnkite.github.io/cf1333/","excerpt":"打得非常裂开，被 D 续了半年。","text":"打得非常裂开，被 D 续了半年。 A - Little Artem 题目传送门 题解 首先我们考虑将所有格子填上黑色，此时 \\(B=W=0\\)。 我们尝试将一个格子变成白色，可以发现将一个格子变成白色会使得 \\(W\\) 变成 \\(1\\)，\\(B\\) 变成这个格子上下左右的黑色格子数量。 我们的目标是使得 \\(B=2,W=1\\)，那么我们只要选择角落上的格子变成白色即可。 代码 12345678910111213void solve() &#123; read(n), read(m); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (i == n &amp;&amp; j == m) &#123; putchar(&#x27;W&#x27;); &#125; else &#123; putchar(&#x27;B&#x27;); &#125; &#125; putchar(&#x27;\\n&#x27;); &#125;&#125; B - Kind Anton 题目传送门 题解 考虑从后往前依次将 \\(a_i\\) 变成 \\(b_i\\)。 考虑对于当前位置 \\(i\\)，若 \\(b_i &lt; a_i\\)（即需要变小），那么显然只需要存在一个 \\(j\\) 满足 \\(j &lt; i\\) 且 \\(a_j=-1\\) 就可以不断将 \\(a_i\\) 减 \\(1\\) 直到等于 \\(b_i\\)；同理，若 \\(b_i &gt; a_i\\)（即需要变大），那么只需要存在一个 \\(j\\) 满足 \\(j &lt; i\\) 且 \\(a_j=1\\) 就可以不断将 \\(a_i\\) 加 \\(1\\) 直到等于 \\(b_i\\)。 那么我们只需要从左往右找到第一个 \\(1\\) 和 \\(-1\\) 然后进行判断即可。 代码 12345678910111213141516171819202122232425262728293031323334353637const int N = 200005;int n, a[N], b[N];void solve() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; for (int i = 1; i &lt;= n; ++i) &#123; read(b[i]); &#125; int p1 = 1, p2 = 1; while (p1 &lt;= n &amp;&amp; a[p1] &lt; 1) &#123; if (a[p1] &lt; b[p1]) &#123; printStr(&quot;NO&quot;); return; &#125; ++p1; &#125; if (p1 &lt;= n &amp;&amp; a[p1] &lt; b[p1]) &#123; printStr(&quot;NO&quot;); return; &#125; while (p2 &lt;= n &amp;&amp; a[p2] &gt; -1) &#123; if (a[p2] &gt; b[p2]) &#123; printStr(&quot;NO&quot;); return; &#125; ++p2; &#125; if (p2 &lt;= n &amp;&amp; a[p2] &gt; b[p2]) &#123; printStr(&quot;NO&quot;); return; &#125; printStr(&quot;YES&quot;);&#125; C - Eugene and an array 题目传送门 题解 不知道为什么 CF 的评论里有很多人说这题很难，感觉好像就是个套路题？ 首先考虑求出 \\(a_i\\) 的前缀和 \\(b_i=\\sum\\limits_{j=1}^{i} a_j\\)，那么一个区间 \\((l,r]\\) 合法当且仅当不存在 \\(l\\le j &lt; i\\le r\\) 使得 \\(b_i=b_j\\)。 考虑对于一个 \\(b_i\\)，求出上一个与 \\(b_i\\) 相同的位置 \\(lst_i\\)，即 \\[lst_i=\\max\\{j\\ |\\ j&lt;i,b_j=b_i\\}\\] 不存在则 \\(lst_i=-1\\)。 那么区间 \\((l,r]\\) 合法的条件变为对于所有 \\(0\\le i\\le n\\)，满足 \\(l &gt; lst_i\\) 或 \\(r &lt; i\\)。 那么我们只要从左往右枚举 \\(r\\)，那么 \\(l\\) 需要大于 \\(\\max\\{lst_j\\ |\\ j \\le r\\}\\)，直接在枚举的同时维护 \\(lst\\) 数组的前缀 \\(\\max\\) 即可。 代码 12345678910111213141516171819202122232425262728const int N = 200005;int n, lst[N];long long a[N];std::map&lt;long long, int&gt; M;void solve() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); a[i] += a[i - 1]; &#125; for (int i = 0; i &lt;= n; ++i) &#123; // 用 std::map 计算 lst 数组 if (!M.count(a[i])) &#123; lst[i] = -1; &#125; else &#123; lst[i] = M[a[i]]; &#125; M[a[i]] = i; &#125; int mx = -1; long long ans = 0; for (int i = 0; i &lt;= n; ++i) &#123; mx = std::max(mx, lst[i]); ans += i - mx - 1; &#125; print(ans);&#125; D - Challenges in school №41 题目传送门 题解 考场上的我不知道在干什么... 首先我们把 \\(\\mathtt{R}\\) 看成 \\(1\\)，\\(\\mathtt{L}\\) 看成 \\(0\\)，那么交换轮数的上界为逆序对数。如果 \\(k\\) 大于逆序对数，那一定无解。 然后我们考虑求出交换轮数的下界并求出一组解。 由于总交换次数固定，为逆序对数，那么我们只要每一轮贪心地将可以交换的相邻的数对交换即可。 考场上并没有过多的时间证明交换轮数下界的级别，所以代码中我直接使用了 \\(\\mathtt{set}\\) 来快速找到所有需要交换的数对。 在求出达到下界的这一组解后，若 \\(k\\) 大于这个下界，我们只需要将同一轮中的若干次交换拆成若干轮，直到轮数搞好为 \\(k\\) 即可。 由于我使用了 \\(\\mathtt{set}\\)，所以复杂度是 \\(O(n^2\\log n)\\) 的，可以通过此题。 另外，可以证明下界一定是 \\(O(n)\\) 级别的（根据官方题解的下界求法），所以直接每次暴力找可以交换的数对，时间复杂度 \\(O(n^2)\\)。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const int N = 3005;int n, k, a[N];char s[N];std::set&lt;int&gt; S;std::vector&lt;std::pair&lt;int, int&gt;&gt; move;void solve() &#123; read(n), read(k), readStr(s + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = (s[i] == &#x27;R&#x27;); if (i == 1 || a[i] != a[i - 1]) S.insert(i); &#125; S.insert(n + 1); int cnt = 0; while (1) &#123; std::vector&lt;int&gt; p; int x = 1; while (x &lt;= n) &#123; if (a[x] || x == 1) &#123; x = *S.upper_bound(x); continue; &#125; p.push_back(x - 1); std::swap(a[x], a[x - 1]); int tmp = *S.upper_bound(x); if (x &gt; 2 &amp;&amp; !a[x - 2]) &#123; S.erase(x - 1); &#125; else &#123; S.insert(x - 1); &#125; if (!a[x + 1]) &#123; S.insert(x + 1); &#125; x = tmp; &#125; if (p.empty()) &#123; break; &#125; ++cnt; for (int v : p) &#123; move.push_back(&#123;v, cnt&#125;); &#125; &#125; if (k &lt; cnt || k &gt; (int)move.size()) &#123; print(-1); return; &#125; for (int i = (int)move.size() - 1; i &gt;= 1; --i) &#123; move[i].second -= move[i - 1].second; &#125; for (int i = 0; i &lt; (int)move.size(); ++i) &#123; if (move[i].second) &#123; continue; &#125; if (cnt == k) &#123; break; &#125; move[i].second = 1; ++cnt; &#125; std::vector&lt;std::vector&lt;int&gt;&gt; ans(k); int now = 0; for (auto p : move) &#123; now += p.second; // debug(&quot;%d %d\\n&quot;, p.first, p.second); ans[now - 1].push_back(p.first); &#125; for (auto p : ans) &#123; print((int)p.size(), &#x27; &#x27;); for (int v : p) &#123; print(v, &#x27; &#x27;); &#125; putchar(&#x27;\\n&#x27;); &#125;&#125; E - Road to 1600 题目传送门 题解 直接考虑一个很大的棋盘看上去非常难做。我们考虑首先将车和后延一条固定的、相同的路径引导至一个较小的棋盘内。 考虑到 \\(n\\le 2\\) 时一定无解，我们只要将最后的棋盘控制在 \\(3\\times 3\\) 的规模即可。 如何构造一个满足题目条件的 \\(3\\times 3\\) 的棋盘？ 一共只有 \\(3\\times 3=9\\) 个数，我们可以直接暴力枚举所有棋盘！ 注意这个棋盘的最小值所在的格子必须与路径的终点在同一行或同一列，这样才可以保证车和后在这个棋盘中的起点相同。 暴力代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int a[5][5], p[15], vis[5][5];bool rook(int x1, int y1, int x2, int y2) &#123; return x1 == x2 || y1 == y2;&#125;bool queen(int x1, int y1, int x2, int y2) &#123; return x1 == x2 || y1 == y2 || x1 + y1 == x2 + y2 || x1 - y1 == x2 - y2;&#125;template&lt;typename T&gt;int work(T check) &#123; // check 是一个判断两点是否可以互相到达的函数（上方 rook 和 queen 中的一种） int x = 0, y = 0; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; if (a[i][j] == 1) &#123; x = i, y = j; &#125; vis[i][j] = 0; &#125; &#125; vis[x][y] = 1; int res = 0; while (1) &#123; int nx = 0, ny = 0, mn = 10, type = 2; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; if (!vis[i][j]) &#123; int tp = !check(x, y, i, j); if (tp &lt; type || (tp == type &amp;&amp; a[i][j] &lt; mn)) &#123; nx = i, ny = j, mn = a[i][j], type = tp; &#125; &#125; &#125; &#125; if (type == 2) &#123; break; &#125; res += type, x = nx, y = ny, vis[x][y] = 1; &#125; return res;&#125;int main() &#123; for (int i = 1; i &lt;= 9; ++i) &#123; p[i] = i; &#125; while (1) &#123; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; a[i][j] = p[(i - 1) * 3 + j]; &#125; &#125; if (work(rook) &lt; work(queen)) &#123; for (int i = 1; i &lt;= 9; ++i) &#123; print(p[i], &#x27; &#x27;); if (i % 3 == 0) &#123; putchar(&#x27;\\n&#x27;); &#125; &#125; return 0; &#125; if (!std::next_permutation(p + 1, p + 1 + 9)) &#123; break; &#125; &#125;&#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839const int N = 505;int n, a[N][N];void solve() &#123; read(n); if (n &lt;= 2) &#123; print(-1); return; &#125; int B = n * n - 9; a[1][1] = B + 1, a[1][2] = B + 2, a[1][3] = B + 4; a[2][1] = B + 5, a[2][2] = B + 3, a[2][3] = B + 8; a[3][1] = B + 9, a[3][2] = B + 6, a[3][3] = B + 7; int now = 0; for (int i = 4; i &lt;= n; ++i) &#123; if (i &amp; 1) &#123; for (int j = 1; j &lt;= i; ++j) &#123; a[i][j] = ++now; &#125; for (int j = i - 1; j; --j) &#123; a[j][i] = ++now; &#125; &#125; else &#123; for (int j = 1; j &lt;= i; ++j) &#123; a[j][i] = ++now; &#125; for (int j = i - 1; j; --j) &#123; a[i][j] = ++now; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; print(a[i][j], &#x27; &#x27;); &#125; putchar(&#x27;\\n&#x27;); &#125;&#125; F - Kate and imperfection 题目传送门 题解 考虑依次求出 \\(I_2,I_3,\\cdots,I_n\\)。 开始时集合大小为 \\(1\\)，我们强制集合中只包含 \\(1\\)。我们贪心地往集合内加入元素。 由于我们需要使集合中两两 \\(\\gcd\\) 的最大值最小，一开始我们一定是考虑依次加入所有质数。 加入完所有质数后，我们不可能再保证答案为 \\(1\\)，我们考虑放宽限制，使得两两 \\(\\gcd\\) 的最大值为 \\(2\\)。 显然，我们可以加入 \\(4=2\\times 2\\)，但不可以加入 \\(6=2\\times 3,8=2\\times 4,\\cdots\\)。 然后我们考虑使得最大值为 \\(3\\)，那么我们可以加入 \\(6=2\\times 3,9=3\\times 3\\)，但不能加入 \\(12=4\\times 3,\\cdots\\)。 接下来考虑使得最大值为 \\(4\\)，我们可以加入 \\(8=2\\times 4\\)，可是我们不能加入 \\(12=3\\times 4\\)，因为之前已经加入了 \\(6\\)。 那么什么时候可以加入 \\(12\\)？在我们枚举最大值为 \\(6\\) 时才可以加入 \\(12\\)。 再往后模拟若干次，大胆猜想，一个数 \\(x\\) 会在枚举最大值为 \\(x\\) 的最大真因子（即不等于本身的因子）时被加入集合。 直接使用欧拉筛求出 \\(2\\) 到 \\(n\\) 每个数的最大真因子即可。 时间复杂度 \\(O(n)\\)。 （做题全靠猜结论.jpg） 上述做法的正确性可以参考官方题解。 代码 123456789101112131415161718192021222324252627282930const int N = 500005;int n, c[N];int cnt, p[N], vis[N], minp[N];void solve() &#123; read(n); for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) &#123; p[++cnt] = i; minp[i] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; 1ll * p[j] * i &lt;= n; ++j) &#123; vis[i * p[j]] = 1; minp[i * p[j]] = p[j]; if (i % p[j] == 0) &#123; break; &#125; &#125; &#125; for (int i = 2; i &lt;= n; ++i) &#123; ++c[i / minp[i]]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= c[i]; ++j) &#123; print(i, &#x27; &#x27;); &#125; &#125; putchar(&#x27;\\n&#x27;);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"数论","slug":"数论","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"Codeforces Round #630 (Div. 2) 被爆踩记","slug":"cf1332","date":"2020-04-01T13:31:00.000Z","updated":"2021-05-29T10:26:33.983Z","comments":true,"path":"cf1332/","link":"","permalink":"https://autumnkite.github.io/cf1332/","excerpt":"被神仙 Froggy 爆踩了。","text":"被神仙 Froggy 爆踩了。 A - Exercising Walk 题目传送门 题意 在二维平面上有一个矩形 \\((x_1,y_1),(x_2,y_2)\\)，你初始在 \\((x,y)\\)。你被强制规定往左、右、上、下四个方向分别走恰好 \\(a,b,c,d\\) 步。 你可以任意调整走的顺序。判断是否可以不走出这个矩形。 \\(0\\le a,b,c,d\\le 10^8,-10^8\\le x_1\\le x\\le x_2\\le 10^8,-10^8\\le y_1\\le y\\le y_2\\le 10^8\\)。 题解 如果 \\(a+b \\ge 1\\) 且 \\(x_1=x=x_2\\)，那么一定不合法。纵坐标同理。 首先因为走的步数是强制规定的，所以我们可以得到终点 \\((x_t,y_t)\\)。 我们考虑先在原地不断左右来回走，把 \\(a,b\\) 抵消成只剩一个。然后直接沿着剩下那个的方向走完即可。纵坐标同理。 可以发现，这样走一定能始终保持在 \\((x,y)\\) 和 \\((x_t,y_t)\\) 形成的矩形内。 那么我们只要判断 \\((x_t,y_t)\\) 是否在 \\((x_1,y_1),(x_2,y_2)\\) 这个矩形内即可。 代码 12345678910int a, b, c, d, x, y, x1, y1, x2, y2;void solve()&#123; read(a), read(b), read(c), read(d); read(x), read(y), read(x1), read(y1), read(x2), read(y2); if ((a || b) &amp;&amp; x1 == x2) return prints(&quot;No&quot;), void(0); if ((c || d) &amp;&amp; y1 == y2) return prints(&quot;No&quot;), void(0); x = x + b - a, y = y + d - c; if (x1 &lt;= x &amp;&amp; x &lt;= x2 &amp;&amp; y1 &lt;= y &amp;&amp; y &lt;= y2) return prints(&quot;Yes&quot;), void(0); prints(&quot;No&quot;);&#125; B - Composite Coloring 题目传送门 题意 有 \\(n\\) 个大于 \\(1\\) 的合数 \\(a_i\\)，你需要给每个数一个颜色 \\(c_i\\)，使得对于任意颜色相同的点对 \\(i,j\\ (i\\ne j)\\)，满足 \\(\\gcd(a_i,a_j) &gt; 1\\)。 你不需要最小化颜色数，但是你需要保证颜色数不超过 \\(11\\)，并且每种颜色都出现。 \\(1\\le n\\le 1000,4\\le a_i\\le 1000\\)。 题解 我这个憨批一直把 \\(\\sqrt{1000}\\) 当作 \\(300\\) 左右在算...我也不知道我在想什么... 事实上，\\(\\lfloor\\sqrt{1000}\\rfloor=31\\)，这意味着任意 \\(a_i\\) 都含有一个不超过 \\(31\\) 的质因子。 而 \\(31\\) 以内的质数只有 \\(11\\) 个，分别是 \\(2,3,5,7,11,13,17,19,23,29,31\\)。 直接求出每个数的最小质因子 \\(p_i\\) 后，把 \\(p_i\\) 相同的数颜色染成相同即可。 代码 1234567891011121314151617181920212223const int N = 1005;const int p[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31&#125;;int n, c[N];std::vector&lt;int&gt; b[11];void solve()&#123; read(n); for (register int i = 0; i &lt; 11; ++i) b[i].clear(); for (register int i = 1; i &lt;= n; ++i)&#123; int x; read(x); for (register int j = 0; j &lt; 11; ++j) if (x % p[j] == 0)&#123; b[j].push_back(i); break; &#125; &#125; int cnt = 0; for (register int i = 0; i &lt; 11; ++i) if (b[i].size())&#123; ++cnt; for (int v : b[i]) c[v] = cnt; &#125; print(cnt); for (register int i = 1; i &lt;= n; ++i) print(c[i], &#x27; &#x27;); putchar(&#x27;\\n&#x27;);&#125; C - K-Complete Word 题目传送门 题意 一个长度为 \\(n\\) 的字符串 \\(s\\) 被称作 \\(k\\)-complete 的当且仅当满足以下条件： \\(s\\) 是回文串，即对于所有 \\(1\\le i\\le n\\) 满足 \\(s_i=s_{n-i+1}\\)； \\(s\\) 存在一个长度为 \\(k\\) 的周期，即对于所有 \\(1\\le i\\le n-k\\)，满足 \\(s_i=s_{i+k}\\)。 给定一个长度为 \\(n\\) 的小写字母串 \\(s\\) 和正整数 \\(k\\)，每次可以修改 \\(s\\) 某个位置的字符，求最少修改次数使得 \\(s\\) 是 \\(k\\)-complete 的。 \\(1\\le k &lt; n\\le 2\\times 10^5\\)，\\(n\\) 能被 \\(k\\) 整除。 题解 显然满足条件的 \\(s\\) 一定是一个长度为 \\(k\\) 的回文串重复 \\(\\frac{n}{k}\\) 次拼接而成的。 这就意味着，我们可以把 \\(s\\) 中的所有字符分成若干组，每一组中的字符都要相等。 那么我们只要将每一组的字符都修改成这一组中出现次数最多的那个字符即可。 代码 12345678910111213141516171819const int N = 200005;int n, k;int c[26];char s[N], a[N];void solve()&#123; read(n), read(k), reads(s); for (register int i = 0; i &lt; (k + 1) / 2; ++i)&#123; for (register int j = 0; j &lt; 26; ++j) c[j] = 0; for (register int j = i; j &lt; n; j += k) ++c[s[j] - &#x27;a&#x27;]; for (register int j = k - i - 1; j &lt; n; j += k) ++c[s[j] - &#x27;a&#x27;]; char mx = std::max_element(c, c + 26) - c; for (register int j = i; j &lt; n; j += k) a[j] = mx + &#x27;a&#x27;; for (register int j = k - i - 1; j &lt; n; j += k) a[j] = mx + &#x27;a&#x27;; &#125; int ans = 0; for (register int i = 0; i &lt; n; ++i) ans += a[i] != s[i]; // debug(&quot;%s\\n&quot;, a); print(ans);&#125; D - Walk on Matrix 题目传送门 题意 有一个问题： 给定一个 \\(n\\times m\\) 的矩阵 \\(\\{a_{i,j}\\}\\)，求一条从 \\((1,1)\\) 到 \\((n,m)\\) 的路径，使得路径上所有数按位与（\\(\\operatorname{and}\\)）的结果最大。 有一个错误的 DP 做法： 请你构造一个满足 \\(1\\le n,m\\le 500,0\\le a_{i,j}\\le 3\\times 10^5\\) 的矩阵，使得最优答案与这个错误 DP 得到的答案恰好差 \\(k\\)。 \\(0\\le k\\le 10^5\\)。 题解 我们可以把 \\(a_{i,j}=0\\) 的位置视为不能经过的点，那么我们只需要构造一个点 \\((x,y)\\) 使得： 所有 \\((1,1)\\) 到 \\((n,m)\\) 的路径必须经过 \\((x,y)\\)。 \\((x,y)\\) 到 \\((n,m)\\) 的路径唯一（为了方便构造）。 记 \\(P_1\\) 为从 \\((1,1)\\) 到 \\((n,m)\\) 的最优路径，\\(P_2\\) 为从 \\((1,1)\\) 到 \\((x,y)\\) 的最优路径加上 \\((x,y)\\) 到 \\((n,m)\\) 的唯一路径，需要满足 \\(w(P_1)-w(P_2)=k\\)。 记 \\(P_1\\) 为从 \\((1,1)\\) 到 \\((n,m)\\) 的最优路径上 \\((1,1)\\) 到 \\((x,y)\\) 的路径，\\(P_2\\) 为从 \\((1,1)\\) 到 \\((x,y)\\) 的最优路径，需要满足 \\(w(P_1) &lt; w(P_2)\\)。 其中 \\(w(P)\\) 表示路径 \\(P\\) 上所有数的 \\(\\operatorname{and}\\) 和。 那么构造就非常简单了，我们只要构造矩阵 \\[\\begin{bmatrix} 2^{18}-1 &amp; 2^{17} \\\\ k &amp; 2^{18}-1 \\\\ 0 &amp; k\\end{bmatrix}\\] 即可满足条件。 代码 12345678int k;void solve()&#123; read(k); print(3, &#x27; &#x27;), print(2); print((1 &lt;&lt; 18) - 1, &#x27; &#x27;), print(1 &lt;&lt; 17); print(k, &#x27; &#x27;), print((1 &lt;&lt; 18) - 1); print(0, &#x27; &#x27;), print(k);&#125; E - Height All the Same 题目传送门 题意 考虑一个 \\(n\\times m\\) 的矩阵 \\(\\{a_{i,j}\\}\\)，每次可以执行两种操作中的一种： 把相邻两个元素分别加 \\(1\\)。 将某个元素加 \\(2\\); 我们称这个矩阵是好的当且仅当你可以通过若干次操作使得所有元素相等。 给定 \\(n,m,l,r\\)，求满足 \\(l\\le a_{i,j}\\le r\\) 的好的矩阵数量。 \\(1\\le n,m\\le 10^9,1\\le l\\le r\\le 10^9\\)。 题解 当整个矩阵的奇偶性相同时，我们只要用若干次 \\(2\\) 操作调整即可。 \\(1\\) 操作相当于改变了相邻两个元素的奇偶性。对于任意两个元素，我们可以将这两个元素路径上相邻两个元素执行 \\(1\\) 操作，就可以改变这两个元素的奇偶性而不改变其他元素的奇偶性。 那么我们只需要使得初始矩阵奇数数量或偶数数量为偶数即可。问题得到了转化。 现在需要解决的问题是： 有 \\(n\\) 个数，每个数有 \\(p\\) 的概率是奇数，\\(1-p\\) 的概率是偶数。记 \\(n_0\\) 为这 \\(n\\) 个数中偶数的数量，\\(n_1\\) 为奇数的数量，求满足 \\(n_0\\) 或 \\(n_1\\) 至少有一个是偶数的概率。 因为有 \\(n_0+n_1=n\\)，所以当 \\(n\\) 是奇数时，\\(n_0,n_1\\) 的奇偶性不相同，一定有一个偶数，所以概率为 \\(1\\)。 否则，\\(n_0,n_1\\) 奇偶性相同，我们只需要计算 \\(n_1\\) 为偶数时的概率。 答案式子为 \\[ \\begin{aligned} f_n &amp;=\\sum_{i=0}^{\\lfloor\\frac{n}{2}\\rfloor} \\begin{pmatrix} n \\\\ 2i \\end{pmatrix} p^{2i} (1-p)^{n-2i} \\\\ &amp;=(1-p)\\sum_{i=0}^{\\lfloor\\frac{n}{2}\\rfloor} \\left(\\begin{pmatrix} n-1 \\\\ 2i \\end{pmatrix}+\\begin{pmatrix} n-1 \\\\ 2i-1 \\end{pmatrix}\\right) p^{2i} (1-p)^{(n-1)-2i} \\\\ &amp;=(1-p)\\left(\\sum_{i=0}^{\\lfloor\\frac{n-1}{2}\\rfloor} \\begin{pmatrix} n-1 \\\\ 2i \\end{pmatrix}p^{2i}(1-p)^{(n-1)-2i} + \\frac{p}{1-p} \\sum_{i=1}^{\\lfloor\\frac{n}{2}\\rfloor} \\begin{pmatrix} n-1 \\\\ 2i-1 \\end{pmatrix}p^{2i-1}(1-p)^{(n-1)-(2i-1)}\\right) \\\\ &amp;=(1-p)\\left(f_{n-1}+\\frac{p}{1-p}\\left(-f_{n-1}+\\sum_{i=0}^{n-1} \\begin{pmatrix} n-1 \\\\ i \\end{pmatrix} p^i (1-p)^{(n-1)-i}\\right) \\right) \\\\ &amp;=(1-p)(f_{n-1}+\\frac{p}{1-p}(-f_{n-1}+(p+(1-p))^{n-1})) \\\\ &amp;=(1-2p)f_{n-1}+p \\end{aligned} \\] 用特征方程或者错位相减等方法，化简后可以得到 \\(f_n\\) 的通项公式 \\[f_n=\\frac{1+(1-2p)^n}{2}\\] 注意到模数为 \\(998\\,244\\,353\\)，而 \\(l,r\\) 的范围是 \\(10^9\\)，在算 \\(p\\) 时可能会出现 \\(r-l+1\\) 没有逆元的情况。一种解决方案是将 \\(p\\) 写成 \\(\\frac{c}{r-l+1}\\) 的形式，将最后的 \\((r-l+1)^n\\) 乘进去后化简，可以去掉分母中的 \\(r-l+1\\)。 代码 12345678910111213const int P = 998244353, Inv2 = (P + 1) &gt;&gt; 1;int n, m, l, r;int qpow(int a, long long b)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if (b &amp; 1) s = 1ll * s * a % P; return s;&#125;void solve()&#123; read(n), read(m), read(l), read(r); if (1ll * n * m % 2 == 1) return print(qpow(r - l + 1, 1ll * n * m)), void(0); if ((r - l + 1) &amp; 1) return print(1ll * (qpow(r - l + 1, 1ll * n * m) + 1) * Inv2 % P), void(0); else return print(1ll * qpow(r - l + 1, 1ll * n * m) * Inv2 % P), void(0);&#125; F - Independent Set 题目传送门 题意 对于一个无向图 \\(G=(V,E)\\)，一个独立集是一个 \\(V\\) 的子集 \\(V&#39;\\)，满足对于所有 \\(u,v\\in V&#39;\\)，有 \\((u,v)\\not\\in E\\)。 一个边导出子图是由边集 \\(E\\) 的一个子集 \\(E&#39;\\) 以及所有在 \\(E&#39;\\) 的边中出现至少一次的点组成的。 给定一棵树 \\(G=(V,E)\\)，我们定义 \\(G[E&#39;]\\) 表示边集为 \\(E&#39;\\) 时 \\(G\\) 的边导出子图，\\(w(G)\\) 表示图 \\(G\\) 的独立集数量。求 \\[\\sum_{E&#39;\\subset E, E&#39;\\ne \\varnothing} w(G[E&#39;])\\] \\(n\\le 3\\times 10^5\\)，答案对 \\(998\\,244\\,353\\) 取模。 题解 对于一棵树求独立集数量，这个问题可以用简单的 DP 解决。 在这个问题中，无非就是多了另外一个决策——断边。我们仍然考虑使用 DP 去解决这个问题。首先我们强制以 \\(1\\) 为根。 设 \\(f_{u,0/1,0/1}\\) 表示以 \\(u\\) 为根的子树，\\(u\\) 与父亲的边在/不在边导出子图内，\\(u\\) 在/不在独立集内时的方案数。转移如下： \\[ \\begin{aligned} f_{u,1,1} &amp;= \\prod_{v\\in \\operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1}+f_{v,1,0}) \\\\ f_{u,1,0} &amp;= \\prod_{v\\in \\operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1}+f_{v,1,0}+f_{v,1,1}) \\\\ f_{u,0,1} &amp;= \\prod_{v\\in \\operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1}+f_{v,1,0}) - \\prod_{v\\in \\operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1})\\\\ f_{u,0,0} &amp;= \\prod_{v\\in \\operatorname{son}(u)} (f_{v,0,0}+f_{v,0,1}+f_{v,1,0}+f_{v,1,1}) \\end{aligned} \\] 当 \\(u\\) 的连边都不在边导出子图内时也是合法的，但是此时 \\(u\\) 不能选在独立集内，所以 \\(f_{u,0,1}\\) 的转移需要减去所有与儿子的边都不在子图内的情况，而 \\(f_{u,0,0}\\) 不需要减。 最后答案即为 \\(f_{1,0,0}+f_{1,0,1}-1\\)（减 \\(1\\) 是减去边集为空的情况）。 时间复杂度 \\(O(n)\\)。 代码 12345678910111213141516171819202122232425const int N = 300005, P = 998244353;int n;std::vector&lt;int&gt; E[N];int f[N][2][2];void dfs(int u, int fa = 0)&#123; int mul = 1; f[u][1][0] = f[u][1][1] = 1; for (int v : E[u]) if (v != fa)&#123; dfs(v, u); f[u][1][0] = 1ll * f[u][1][0] * (0ll + f[v][0][0] + f[v][0][1] + f[v][1][0] + f[v][1][1]) % P; f[u][1][1] = 1ll * f[u][1][1] * (0ll + f[v][0][0] + f[v][0][1] + f[v][1][0]) % P; mul = 1ll * mul * (0ll + f[v][0][0] + f[v][0][1]) % P; &#125; f[u][0][1] = (f[u][1][1] - mul + P) % P; f[u][0][0] = f[u][1][0];&#125;void solve()&#123; read(n); for (register int i = 1; i &lt;= n; ++i) E[i].clear(); for (register int i = 1, u, v; i &lt; n; ++i) read(u), read(v), E[u].push_back(v), E[v].push_back(u); dfs(1); print((0ll + f[1][0][0] + f[1][0][1] + P - 1) % P);&#125; G - No Monotone Triples 题目传送门 咕咕咕...","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"模拟","slug":"模拟","permalink":"https://autumnkite.github.io/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"状压DP","slug":"状压DP","permalink":"https://autumnkite.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"AC自动机","slug":"AC自动机","permalink":"https://autumnkite.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"一个镜像","slug":"mirror","date":"2020-03-27T09:26:00.000Z","updated":"2020-03-27T09:32:14.863Z","comments":true,"path":"mirror/","link":"","permalink":"https://autumnkite.github.io/mirror/","excerpt":"","text":"由于最近 GitHub 遭到多次攻击，国内经常上不去 GitHub Pages，且 GitHub 加载较慢，所以在 Gitee 上搭了一个镜像站，尽量做到实时同步（因为 Gitee Pages 需要手动部署）。 GitHub Pages 链接 Gitee Pages 链接","categories":[{"name":"公告","slug":"公告","permalink":"https://autumnkite.github.io/categories/%E5%85%AC%E5%91%8A/"}],"tags":[]},{"title":"Educational Codeforces Round 84 (Rated for Div. 2) 自闭记","slug":"cf1327","date":"2020-03-25T12:46:00.000Z","updated":"2021-05-29T10:26:33.982Z","comments":true,"path":"cf1327/","link":"","permalink":"https://autumnkite.github.io/cf1327/","excerpt":"自闭了。","text":"自闭了。 A - Sum of Odd Integers 题目传送门 题解 首先，我们尝试取出最小的 \\(k\\) 个正奇数：\\(1,3,5,7,\\cdots,2k-1\\)。 这些奇数的和为 \\(\\frac{(1+2k-1)k}{2}=k^2\\)。 那么我们如何构造才能使得 \\(k\\) 个奇数互不相同且和为 \\(n\\) 呢？ 只要不断将最大的奇数加 \\(2\\) 即可。 所以当 \\(n-k^2\\) 是大于等于 \\(0\\) 的偶数时，一定能够构造出解。 而当 \\(n &lt; k^2\\) 时，最小的 \\(k\\) 个正奇数的和已经有 \\(k^2\\)，那么一定不能构造出解。 当 \\(n-k^2\\) 不为偶数时，由于任意 \\(k\\) 个奇数一定可以通过最小的 \\(k\\) 个正奇数中的数 \\(+2,-2\\) 得到，所以任意 \\(k\\) 个奇数的和一定与 \\(k^2\\) 的奇偶性相同，而 \\(n\\) 的奇偶性与 \\(k^2\\) 不同，所以一定不能构造出解。 所以「\\(n-k^2\\) 是大于等于 \\(0\\) 的偶数」是能构造出解的充要条件。 注意计算 \\(k^2\\) 时要开 long long。另外，\\(k\\) 与 \\(k^2\\) 的奇偶性一定是相同的，所以我们判断 \\(n\\) 与 \\(k^2\\) 的奇偶性是否相同只需要判断 \\(n\\) 与 \\(k\\) 的奇偶性是否相同。 代码 123456int n, k;void solve()&#123; read(n), read(k); if ((n &amp; 1) == (k &amp; 1) &amp;&amp; 1ll * k * k &lt;= n) prints(&quot;YES&quot;); else prints(&quot;NO&quot;);&#125; B - Princesses and Princes 题目传送门 题解 我这个彩笔又看错题了... 题目里说只要能够增加就行...而我以为要取增加最多的方案... 那么只要模拟一遍以后，如果存在一个没有匹配的公主，任选一个王子与她匹配即可。 如果需要「增加最多」，这样构造是否正确呢 QAQ 有没有神仙来证明一下或者给出一个反例啊 QAQ 代码 123456789101112131415161718192021222324252627const int N = 100005;int n, vis[N];std::vector&lt;int&gt; E[N];void solve()&#123; read(n); for (register int i = 1; i &lt;= n; ++i) vis[i] = 0, E[i].clear(); for (register int i = 1, k; i &lt;= n; ++i)&#123; read(k); for (register int j = 0, x; j &lt; k; ++j) read(x), E[i].push_back(x); &#125; int add_x = 0, add_y = 0; for (register int i = 1; i &lt;= n; ++i)&#123; bool flag = 0; for (register int j = 0; j &lt; (int)E[i].size(); ++j) if (!vis[E[i][j]])&#123; vis[E[i][j]] = 1, flag = 1; break; &#125; if (flag || add_x) continue; add_x = i; &#125; if (!add_x) prints(&quot;OPTIMAL&quot;); else&#123; add_y = n; while (vis[add_y]) --add_y; prints(&quot;IMPROVE&quot;), print(add_x, &#x27; &#x27;), print(add_y); &#125;&#125; C - Game with Chips 题目传送门 题解 考场上的我甚至想过把坐标旋转 \\(x,y\\) 独立等等奇怪的玩意。 在想这东西的时候，发现这东西是有边界的，而且到边界他就不会继续走了。 于是我不会了。 转念一想，既然可以走 \\(2nm\\) 步，好像直接把所有点移到 \\((1,1)\\)，然后把所有点走一遍就好了！ 移到 \\((1,1)\\) 需要 \\(n+m-2\\) 步，遍历所有点需要 \\(nm-1\\) 步，步数显然是不超过 \\(2nm\\) 的。 代码里移动到 \\((1,1)\\) 用了 \\(n+m\\) 步。 代码 1234567891011121314int n, m, k;void solve()&#123; read(n), read(m), read(k); for (register int i = 1, x, y; i &lt;= k; ++i) read(x), read(y); for (register int i = 1, x, y; i &lt;= k; ++i) read(x), read(y); print(n + m + n * m - 1); for (register int i = 1; i &lt;= n; ++i) putchar(&#x27;U&#x27;); for (register int i = 1; i &lt;= m; ++i) putchar(&#x27;L&#x27;); for (register int i = 1; i &lt;= n; ++i)&#123; for (register int j = 1; j &lt; m; ++j) putchar(i &amp; 1 ? &#x27;R&#x27; : &#x27;L&#x27;); if (i &lt; n) putchar(&#x27;D&#x27;); &#125; putchar(&#x27;\\n&#x27;);&#125; D - Infinite Path 题目传送门 题解 首先看到一个排列求 \\(k\\) 次幂，容易想到将排列看成若干置换环的形式。 如排列 \\(p=\\{2,4,1,3,6,5\\}\\) 可以看成： 12341 --&gt; 2^ || v3 &lt;-- 4 以及 15 &lt;==&gt; 6 两个置换环。 将一个排列求 \\(k\\) 次幂以后，某个点 \\(i\\) 会重新指向原来环上从 \\(i\\) 开始第 \\(k\\) 个点。 那么由于我们只需要一个环满足颜色相等，容易想到将每个环单独处理以后取 \\(\\min\\) 即可。 对于一个环长为 \\(l\\) 的环，我们将环上的点从某个点开始重新标号。我们判断一个 \\(k\\) 是否可行，只需要记 \\(p=\\gcd(k,l)\\)，我们判断是否存在一个 \\(0\\le t &lt; p\\) 使得环上所有模 \\(p\\) 等于 \\(t\\) 的点颜色是否相同即可。 那么显然只要枚举所有 \\(l\\) 的因数 \\(k\\) 即可。 时间复杂度 \\(O(n\\sqrt{n})\\)。 代码 123456789101112131415161718192021222324252627282930313233343536const int N = 200005;int n, p[N], c[N], vis[N];int solve(std::vector&lt;int&gt; &amp;a)&#123; std::vector&lt;int&gt; d; int l = a.size(); for (register int i = 1; 1ll * i * i &lt;= l; ++i) // 求因数 if (l % i == 0)&#123; d.push_back(i); if (i * i &lt; l) d.push_back(l / i); &#125; std::sort(d.begin(), d.end()); for (int k : d)&#123; // 枚举 k for (register int i = 0; i &lt; k; ++i)&#123; bool flag = 1; for (register int j = i; j &lt; l; j += k) flag &amp;= a[j] == a[i]; // 判断颜色是否相同 if (flag) return k; &#125; &#125; return l;&#125;void solve()&#123; read(n); for (register int i = 1; i &lt;= n; ++i) read(p[i]), vis[i] = 0; for (register int i = 1; i &lt;= n; ++i) read(c[i]); int ans = n; for (register int i = 1; i &lt;= n; ++i) if (!vis[i])&#123; std::vector&lt;int&gt; tmp; tmp.push_back(c[i]), vis[i] = 1; for (register int j = p[i]; j != i; j = p[j]) tmp.push_back(c[j]), vis[j] = 1; ans = std::min(ans, solve(tmp)); &#125; print(ans);&#125; E - Count The Blocks 题目传送门 题解 设答案为 \\(g_i\\)，考虑计算出 \\(f_i=\\sum\\limits_{j=i}^{n} (j-i+1)g_j\\)，根据 \\(f_i\\) 的实际意义，显然有 \\(f_i=(n-i+1)\\times 10^{n-i+1}\\)。 根据容斥，可以得到 \\(g_i=f_i-2f_{i-1}+f_{i-2}\\)。这个式子的正确性也可以将 \\(f_i\\) 的定义式子代入证明。 代码 1234567891011121314151617const int N = 200005, P = 998244353;int n, f[N];void inc(int &amp;a, int b)&#123; (a += b) &gt;= P ? a -= P : 0; &#125;void dec(int &amp;a, int b)&#123; a &lt; b ? a += P - b : a -= b; &#125;void solve()&#123; read(n); int pw = 10; for (register int i = n; i; --i)&#123; f[i] = 1ll * pw * (n - i + 1) % P; pw = 10ll * pw % P; &#125; for (register int i = 1; i &lt;= n; ++i)&#123; dec(f[i], f[i + 1]), dec(f[i], f[i + 1]), inc(f[i], f[i + 2]); print(f[i], &#x27; &#x27;); &#125; putchar(&#x27;\\n&#x27;);&#125; F - AND Segments 题目传送门 题解 不错，最后 5min 开始写代码，没调出来，直接死在这题上了。 上面是一个菜鸡 xjb BB，不要管他。 首先看到这题，一看是位运算，先考虑每位是否独立。 因为只有 and 运算的限制，所以很显然每一位是独立的。那么我们只需要求出每一位满足限制的方案数，然后乘起来即可。 对于当前位，有若干个限制，每个限制规定了一个区间的 and 和是 \\(0\\) 还是 \\(1\\)。 对于限制为 \\(1\\) 的区间，直接强制每一位必须填 \\(1\\)。而对于限制为 \\(0\\) 的区间，看上去非常难搞。 一开始我以为可以容斥，但是若干区间取并这玩意非常难处理。 突然想到了联赛前的一道作业题：P4229 某位歌姬的故事。 那题由于需要离散，并且限制比较宽，所以 DP 是 \\(O(nq)\\) 的。 然而这题不需要离散，并且只有 \\(0\\) 和 \\(1\\)，所以我们尝试去优化这个 DP。 预处理 \\(\\operatorname{pos}[i]\\) 表示 \\(i\\) 之前（不包括 \\(i\\)）第一个 \\(0\\) 至少填在 \\(\\operatorname{pos}[i]\\) 位置。这个预处理可以参考 P4229 中的预处理。 考虑 DP，\\(f[i][j]\\) 表示前 \\(i\\) 位，最后一个 \\(0\\) 的位置为 \\(j\\) 时满足限制的方案数。分三种情况进行转移： \\(j&lt;\\operatorname{pos}[i]\\) 时，有 \\(f[i][j]=0\\)； \\(\\operatorname{pos}[i]\\le j &lt; i\\) 时，有 \\(f[i][j]=f[i-1][j]\\)； \\(j=i\\) 时，若根据 \\(1\\) 的限制，第 \\(i\\) 位强制选 \\(1\\)，那么 \\(f[i][j]=0\\)；否则 \\(f[i][j]=\\sum\\limits_{k=\\operatorname{pos}[i]}^{i-1} f[i-1][k]\\)。 对于第一种情况，我们只需要维护一个最左边不为 \\(0\\) 的指针，每次把 \\(&lt; \\operatorname{pos}[i]\\) 的位置刷成 \\(0\\) 即可。 对于第二种情况，由于没有任何改变，所以我们不需要进行任何处理。 对于第三种情况，我们只要单点修改第 \\(i\\) 个位置的值即可。注意需要实时维护当前行的和。 于是这个 DP 的复杂度变成了 \\(O(n)\\)。 每一位预处理复杂度为 \\(O(m)\\)，所以总时间复杂度 \\(O(k(n+m))\\)。 我的做法好像比官方题解的做法复杂一万倍。 另：这题跟绍一新生考试的 F 好像差不多... 代码 12345678910111213141516171819202122232425262728const int N = 500005, P = 998244353;int n, k, m, a[N], l[N], r[N], x[N], f[N], pos[N];void inc(int &amp;a, int b)&#123; (a += b) &gt;= P ? a -= P : 0; &#125;void dec(int &amp;a, int b)&#123; a &lt; b ? a += P - b : a -= b; &#125;void solve()&#123; read(n), read(k), read(m); for (register int i = 1; i &lt;= m; ++i) read(l[i]), read(r[i]), ++r[i], read(x[i]); int ans = 1; for (register int p = 0; p &lt; k; ++p)&#123; for (register int i = 1; i &lt;= n + 1; ++i) pos[i] = 0, a[i] = 0; for (register int i = 1; i &lt;= m; ++i) if (x[i] &gt;&gt; p &amp; 1) ++a[l[i]], --a[r[i]]; // 差分实现区间加 else pos[r[i]] = std::max(pos[r[i]], l[i]); for (register int i = 2; i &lt;= n + 1; ++i) a[i] += a[i - 1], pos[i] = std::max(pos[i], pos[i - 1]); // a 预处理第 i 位是否强制选 1 // pos 预处理 i 之前第一个 0 至少选在哪里 for (register int i = 0; i &lt;= n + 1; ++i) f[0] = 0; f[0] = 1; int sum = 1, l = 0; for (register int i = 1; i &lt;= n + 1; ++i)&#123; while (l &lt; pos[i]) dec(sum, f[l]), f[l] = 0, ++l; // 把 &lt; pos[i] 的位置刷成 0 f[i] = a[i] ? 0 : sum, inc(sum, f[i]); // 修改第 i 个位置的 dp 值 &#125; ans = 1ll * ans * f[n + 1] % P; &#125; print(ans);&#125; G - Letters and Question Marks 题目传送门 题解 事实上这个题还是非常简单的。（别问我为什么现场没过 首先可以对所有模式串建个 AC 自动机，每个点的权值就是这个点在 \\(fail\\) 树上到根路径上所有点对应的字符串的权值和。 如果字符串 \\(s\\) 已经全部确定，那么我们只要把 \\(s\\) 在这个自动机上跑一遍，把经过节点的点权累加即可。 但是现在 \\(s\\) 有若干个字符不确定。我们考虑对于 \\(s\\) 的每段确定的极大子串，以及 AC 自动机上的点 \\(u\\)，预处理从 \\(u\\) 开始，按照这段子串跑，最终跑到的点以及沿路经过的点权和。 然后我们就可以 DP 了。记 \\(f_{S,u}\\) 表示当前问号的位置用了 \\(S\\) 这些字符，跑到自动机上的节点 \\(u\\) 时，最大的权值和。 转移只需要枚举下一个问号填的字符即可。 记 \\(n\\) 为字符串 \\(s\\) 的长度，\\(m\\) 为模式串的长度之和，\\(c\\) 为字符集大小，则复杂度为 \\(O(nm+2^cmc)\\)，可以通过本题。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100const long long INF = 0x3f3f3f3f3f3f3f3fll;const int N = 1005, C = 14;int n;char t[N], s[400005];std::pair&lt;int, long long&gt; go[N][C + 1];int bitcnt[1 &lt;&lt; C];long long f[1 &lt;&lt; C][N];struct AC_Automaton&#123; int rt, cnt, trans[N][C], fail[N]; long long w[N]; int new_node()&#123; int u = cnt++; w[u] = 0, fail[u] = -1; for (register int i = 0; i &lt; C; ++i) trans[u][i] = -1; return u; &#125; void init()&#123; cnt = 0, rt = new_node(); &#125; void insert(const std::vector&lt;int&gt; &amp;s, long long _w)&#123; int u = rt; for (register int i = 0; i &lt; (int)s.size(); ++i)&#123; if (trans[u][s[i]] == -1) trans[u][s[i]] = new_node(); u = trans[u][s[i]]; &#125; w[u] += _w; &#125; void build()&#123; std::vector&lt;int&gt; Q; fail[rt] = -1; for (register int i = 0; i &lt; C; ++i) if (~trans[rt][i]) Q.push_back(trans[rt][i]), fail[trans[rt][i]] = rt; else trans[rt][i] = rt; for (register int i = 0; i &lt; (int)Q.size(); ++i)&#123; int u = Q[i]; w[u] += w[fail[u]]; for (register int j = 0; j &lt; C; ++j) if (~trans[u][j]) Q.push_back(trans[u][j]), fail[trans[u][j]] = trans[fail[u]][j]; else trans[u][j] = trans[fail[u]][j]; &#125; &#125; std::pair&lt;int, long long&gt; run(int u, const std::vector&lt;int&gt; &amp;s)&#123; long long sum = 0; for (register int i = 0; i &lt; (int)s.size(); ++i) u = trans[u][s[i]], sum += w[u]; return &#123;u, sum&#125;; &#125;&#125;A;int main()&#123;#ifdef AT_HOME freopen(&quot;test.in&quot;, &quot;r&quot;, stdin); freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);#endif read(n); A.init(); for (register int i = 0; i &lt; n; ++i)&#123; int m = reads(t), w; std::vector&lt;int&gt; tmp; read(w); for (register int j = 0; j &lt; m; ++j) tmp.push_back(t[j] - &#x27;a&#x27;); A.insert(tmp, w); &#125; A.build(); int len = reads(s); std::vector&lt;int&gt; tmp; int cnt = 0; for (register int i = 0; i &lt;= len; ++i) if (i == len || s[i] == &#x27;?&#x27;)&#123; for (register int j = 0; j &lt; A.cnt; ++j) go[j][cnt] = A.run(j, tmp); tmp.clear(), ++cnt; &#125; else tmp.push_back(s[i] - &#x27;a&#x27;); bitcnt[0] = 0; for (register int i = 1; i &lt; (1 &lt;&lt; C); ++i) bitcnt[i] = bitcnt[i &gt;&gt; 1] + (i &amp; 1); for (register int i = 0; i &lt; (1 &lt;&lt; C); ++i) for (register int j = 0; j &lt; A.cnt; ++j) f[i][j] = -INF; f[0][go[A.rt][0].first] = go[A.rt][0].second; long long ans = -INF; for (register int S = 0; S &lt; (1 &lt;&lt; C); ++S)&#123; int k = bitcnt[S] + 1; if (k == cnt)&#123; for (register int u = 0; u &lt; A.cnt; ++u) ans = std::max(ans, f[S][u]); &#125; if (k &gt;= cnt) continue; for (register int u = 0; u &lt; A.cnt; ++u) if (f[S][u] != -INF)&#123; for (register int i = 0; i &lt; C; ++i) if (!(S &gt;&gt; i &amp; 1))&#123; int v = A.trans[u][i]; int S_ = S | (1 &lt;&lt; i), u_ = go[v][k].first; f[S_][u_] = std::max(f[S_][u_], f[S][u] + A.w[v] + go[v][k].second); &#125; &#125; &#125; print(ans);&#125; 我还是太菜了 /kk","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"模拟","slug":"模拟","permalink":"https://autumnkite.github.io/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"状压DP","slug":"状压DP","permalink":"https://autumnkite.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"AC自动机","slug":"AC自动机","permalink":"https://autumnkite.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"Codeforces Global Round 7 上 IM 记","slug":"cf1326","date":"2020-03-25T10:05:00.000Z","updated":"2020-04-01T09:11:16.453Z","comments":true,"path":"cf1326/","link":"","permalink":"https://autumnkite.github.io/cf1326/","excerpt":"终于上 IM 了（","text":"终于上 IM 了（ A - Bad Ugly Numbers 题目传送门 题解 为什么您们都能想到构造 \\(2333\\cdots 333\\) 啊 QAQ 显然一个能被 \\(p\\) 整除的数，加或减一个不能被 \\(p\\) 整除的数后，不能被 \\(p\\) 整除。 我们考虑 \\(777\\cdots 777\\) 能被 \\(7\\) 整除，而 \\(777\\cdots 77x\\)（\\(x &gt; 0\\)）不能被 \\(7\\) 整除。 又根据小学数学知识，能被 \\(4\\) 整除的数的特征是最后两位能被 \\(4\\) 整除，由于 \\(74\\bmod 4\\ne 0\\)，所以我们构造 \\(777\\cdots 774\\) 即可。 注意需要特判 \\(n=1\\)。 代码 1234567int n;void solve()&#123; read(n); if (n == 1) return print(-1), void(0); for (register int i = 1; i &lt; n; ++i) putchar(&#x27;7&#x27;); putchar(&#x27;4&#x27;), putchar(&#x27;\\n&#x27;);&#125; B - Maximums 题目传送门 题解 由 \\(c_i\\) 的定义可得 \\[\\begin{aligned} b_i&amp;=a_i-c_i \\\\&amp;=a_i-\\max\\{0,\\max\\limits_{j=1}^{i-1} a_j\\} \\end{aligned}\\] 移项后可得 \\[a_i=b_i+\\max\\{0,\\max\\limits_{j=1}^{i-1}a_j\\}\\] 我们只要在递推的同时维护 \\(a_1,a_2,\\cdots,a_{i-1}\\) 的最大值即可。 时间复杂度 \\(O(n)\\)。 代码 1234567891011const int N = 200005;int n, a[N];void solve()&#123; read(n); for (register int i = 1; i &lt;= n; ++i) read(a[i]); long long now = 0; for (register int i = 1; i &lt;= n; ++i) if (a[i] &gt; 0) now += a[i], print(now, &#x27; &#x27;); else print(now + a[i], &#x27; &#x27;); putchar(&#x27;\\n&#x27;);&#125; C - Permutation Partitions 题目传送门 题解 考场上我看到本题一脸懵逼，我发现我好像不会第一问... 冷静一下，发现显然答案的上界是取最大的 \\(k\\) 个数，即 \\((n-k+1)+(n-k+2)+\\cdots+n=\\frac{(2n-k+1)k}{2}\\)。 我们可以在原排列中标记出这最大的 \\(k\\) 个数，记从左往右第 \\(i\\) 个被标记的位置为 \\(x_i\\)。 我们要把原排列划分成 \\(k\\) 段意味着我们要找到 \\(k-1\\) 个分界点，并且我们现在要求两个分界点之间恰好包含一个被标记的数。 那么显然第 \\(i\\) 个分界点应该选在 \\(x_i\\) 到 \\(x_{i+1}\\) 之间。 每个分界点的选择是独立的（即不会影响其他分界点的选择），所以根据乘法原理，把每个分界点的方案数相乘即可。 时间复杂度 \\(O(n)\\)。 代码 12345678910111213141516const int N = 200005, P = 998244353;int n, k, a[N];void solve()&#123; read(n), read(k); long long sum = 0; int lst = 0, ans = 1; for (register int i = 1; i &lt;= n; ++i)&#123; read(a[i]); if (a[i] &gt; n - k)&#123; sum += a[i]; if (lst) ans = 1ll * ans * (i - lst) % P; lst = i; &#125; &#125; print(sum, &#x27; &#x27;), print(ans);&#125; D2 - Prefix-Suffix Palindrome (Hard version) 题目传送门 题解 考场上看到本题的第一想法是枚举前后缀匹配的长度 \\(l\\)，然后要求从 \\(l+1\\) 开始的最长回文串或者以 \\(n-l\\) 结尾的最长回文串。 刚打算去隔壁 最长双回文串 复制一个代码，意识到了不对... 如果求出来的回文串与前后缀有重叠怎么办？ 考虑上面这个想法用暴力怎么实现。在我们将原串中间插入 # 后，用 manacher 算法以 \\(i\\) 为回文中心的回文半径 \\(d_i\\)。 然后我们枚举前后缀匹配长度 \\(l\\)，分两种情况： 对于所有 \\(l+1\\le i\\le \\frac{|s|+1}{2}\\) 且 \\(i-d_i+1\\le l+1\\)，求出 \\(i\\) 的最大值； 对于所有 \\(\\frac{|s|+1}{2}\\le i\\le n-l\\) 且 \\(i+d_i-1\\ge n-l\\)，求出 \\(i\\) 的最小值。 可以发现，\\(l\\) 越大，越容易满足限制，越容易使得 \\(i\\) 取到极值。 所以我们求出最大的 \\(l\\) 以后用上面的暴力实现即可。 如果你不怕被 hack 的话 manacher 也可以用哈希实现。 时间复杂度 \\(O(n)\\)。 代码 12345678910111213141516171819202122232425262728293031323334353637383940const int N = 2000005; // 注意数组开大一倍int n, d[N];char s[N];void manacher(int *d, char *s, int n)&#123; for (register int i = 1, m = 0, r = 0; i &lt;= n; ++i)&#123; d[i] = i &gt; r ? 0 : std::min(r - i + 1, d[m - (i - m)]); while (i - d[i] &gt; 0 &amp;&amp; i + d[i] &lt;= n &amp;&amp; s[i - d[i]] == s[i + d[i]]) ++d[i]; if (i + d[i] - 1 &gt; r) m = i, r = i + d[i] - 1; &#125;&#125;void solve()&#123; n = reads(s + 1); for (register int i = n; i; --i) s[i &lt;&lt; 1] = s[i], s[i &lt;&lt; 1 | 1] = &#x27;#&#x27;; s[1] = &#x27;#&#x27;, n = n * 2 + 1; manacher(d, s, n); // for (register int i = 1; i &lt;= n; ++i) debug(&quot;%d &quot;, d[i]); debug(&quot;\\n&quot;); int len = 0; for (register int i = 1; i &lt;= n / 2; ++i) if (s[i] != s[n - i + 1]) break; else ++len; // debug(&quot;%d\\n&quot;, len); int d1 = 0, d2 = 0; for (register int i = len + 1; i &lt;= (n + 1) / 2; ++i) if (i - d[i] + 1 &lt;= len + 1) d1 = std::max(d1, (i - len) * 2 - 1); for (register int i = (n + 1) / 2; i &lt;= n - len; ++i) if (i + d[i] - 1 &gt;= n - len) d2 = std::max(d2, (n - len - i + 1) * 2 - 1); if (d1 &gt; d2)&#123; for (register int i = 1; i &lt;= len + d1; ++i) if (s[i] != &#x27;#&#x27;) putchar(s[i]); for (register int i = n - len + 1; i &lt;= n; ++i) if (s[i] != &#x27;#&#x27;) putchar(s[i]); &#125; else&#123; for (register int i = 1; i &lt;= len; ++i) if (s[i] != &#x27;#&#x27;) putchar(s[i]); for (register int i = n - len - d2 + 1; i &lt;= n; ++i) if (s[i] != &#x27;#&#x27;) putchar(s[i]); &#125; putchar(&#x27;\\n&#x27;);&#125; E - Bombs 题目传送门 题解 发现答案单调递减，可以考虑枚举答案 \\(x\\)。 将 \\(&gt; x\\)（即必须炸掉的数）的位置置为 \\(1\\)，炸弹置为 \\(-1\\)，其他位置置为 \\(0\\)。 则合法的条件是所有后缀和 \\(\\le 0\\)。 用线段树维护即可。 时间复杂度 \\(O(n\\log n)\\)。 别问我为什么对，感觉挺对的就行了（雾 代码 123456789101112131415161718192021222324252627282930const int N = 300005;int n, p[N], q[N], pos[N];struct Segment_Tree&#123; int mx[N &lt;&lt; 2], lz[N &lt;&lt; 2]; void add(int u, int v)&#123; mx[u] += v, lz[u] += v; &#125; void down(int u)&#123; add(u &lt;&lt; 1, lz[u]), add(u &lt;&lt; 1 | 1, lz[u]), lz[u] = 0; &#125; void modify(int u, int l, int r, int L, int R, int v)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return add(u, v), void(0); int md = (l + r) &gt;&gt; 1; down(u); if (L &lt;= md) modify(u &lt;&lt; 1, l, md, L, R, v); if (R &gt; md) modify(u &lt;&lt; 1 | 1, md + 1, r, L, R, v); mx[u] = std::max(mx[u &lt;&lt; 1], mx[u &lt;&lt; 1 | 1]); &#125;&#125;T;void solve()&#123; read(n); for (register int i = 1; i &lt;= n; ++i) read(p[i]), pos[p[i]] = i; for (register int i = 1; i &lt;= n; ++i) read(q[i]); print(n, &#x27; &#x27;); int now = n; T.modify(1, 1, n, 1, pos[n], 1); for (register int i = 1; i &lt; n; ++i)&#123; T.modify(1, 1, n, 1, q[i], -1); while (T.mx[1] &lt;= 0) --now, T.modify(1, 1, n, 1, pos[now], 1); print(now, &#x27; &#x27;); &#125;&#125; F1 - Wise Men (Easy Version) 题目传送门 题解 考场上看到 Easy Version \\(n\\le 14\\)，Hard Version \\(n\\le 18\\)，莫名就想到了 meet in middle... 可以预处理出 \\(f_{S,T,i}\\) 表示当前排列中数的集合为 \\(S\\)，导出的 01 字符串为 \\(T\\)，且排列中最后一个数为 \\(i\\) 的方案数。 然后考虑 meet in middle，合并两边的方案。 问题来了，我好像不会快速合并两边的方案 QAQ 但是问题不大，我们可以 暴力合并！ 直接枚举左边的数集 \\(S\\)，最后的 01 串 \\(T\\)，以及中间相邻的两个数，显然方案数可以利用 \\(f\\) 进行计算。 但是，你可能需要一些卡常技巧（设两边的大小分别为 \\(B_1,B_2\\)）： \\(f\\) 数组只需要预处理所有 \\(|S|=B_1\\) 或 \\(|S|=B_2\\) 的位置，可以直接枚举所有排列进行统计，不需要进行 DP。 显然 01 串反转以后答案是不变的，所以我们只计算 \\(T\\le \\operatorname{rev}(T)\\) 的位置即可。 可以预处理 \\(2^n-1,2^{B_1-1}-1,2^{B_2-1}-1\\) 的值来减少运算次数。 由于枚举 \\(T\\) 以后我们可以知道中间相邻两个数是否有边，我们可以预处理出与一个点有边/无边的点来快速枚举。 根据代码常数调整 \\(B_1,B_2\\) 的大小。 为了保险，你可以再加上 Ofast 和 O3 优化。 理论时间复杂度 \\(O(C_{n}^{B_1}(B_1!+B_2!+2^n n^2))\\)，事实上有好几个 \\(\\frac{1}{2}\\) 的常数。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445int n, E[14][14], bitcnt[1 &lt;&lt; 14], rev[1 &lt;&lt; 14], p[14], f[1 &lt;&lt; 14][1 &lt;&lt; 6][14];long long ans[1 &lt;&lt; 14];std::vector&lt;int&gt; G[14][2];void solve()&#123; read(n); for (register int i = 0; i &lt; n; ++i) for (register int j = 0; j &lt; n; ++j)&#123; while (!isdigit(E[i][j] = getchar())) ; E[i][j] ^= &#x27;0&#x27;; G[i][E[i][j]].push_back(j); &#125; bitcnt[0] = 0; for (register int i = 1; i &lt; (1 &lt;&lt; n); ++i) bitcnt[i] = bitcnt[i &gt;&gt; 1] + (i &amp; 1); rev[0] = 0; for (register int i = 1; i &lt; (1 &lt;&lt; (n - 1)); ++i) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; (n - 2); int B1 = n &gt;&gt; 1, B2 = n - B1; for (register int S = 0; S &lt; (1 &lt;&lt; n); ++S) if (bitcnt[S] == B1 || bitcnt[S] == B2)&#123; int cnt = 0; for (register int i = 0; i &lt; n; ++i) if (S &gt;&gt; i &amp; 1) p[cnt++] = i; while (1)&#123; int T = 0; for (register int i = 0; i &lt; cnt - 1; ++i) if (E[p[i]][p[i + 1]]) T |= 1 &lt;&lt; i; ++f[S][T][p[cnt - 1]]; if (!std::next_permutation(p, p + cnt)) break; &#125; &#125; int U = (1 &lt;&lt; n) - 1, U1 = (1 &lt;&lt; (B1 - 1)) - 1, U2 = (1 &lt;&lt; (B2 - 1)) - 1; for (register int S = 0; S &lt; (1 &lt;&lt; n); ++S) if (bitcnt[S] == B1)&#123; for (register int T = 0; T &lt; (1 &lt;&lt; (n - 1)); ++T) if (T &lt;= rev[T])&#123; int T1 = T &amp; U1, T2 = rev[T] &amp; U2, t = (T &gt;&gt; (B1 - 1)) &amp; 1, _S = U ^ S; for (register int i = 0; i &lt; n; ++i) if (f[S][T1][i]) for (int j : G[i][t]) ans[T] += f[S][T1][i] * f[_S][T2][j]; &#125; &#125; for (register int T = 0; T &lt; (1 &lt;&lt; (n - 1)); ++T) if (T &lt;= rev[T]) print(ans[T], &#x27; &#x27;); else print(ans[rev[T]], &#x27; &#x27;); putchar(&#x27;\\n&#x27;);&#125; 最后一分钟绝杀的感觉真的非常舒适（ F2 - Wise Men (Hard Version) 题目传送门 来了来了，来填坑了。 题解 发现既有有边又有没边的限制非常难搞，于是我们考虑容斥，即计算 \\(ans_A\\) 为对于所有 \\(A\\) 中为 \\(1\\) 的位置 \\(i\\)，满足 \\(p_i\\) 与 \\(p_{i+1}\\) 有边的排列 \\(p\\) 的数量（对于 \\(0\\) 的位置没有限制）。 计算出 \\(ans_A\\) 后，只要用类似于「逆高维前缀和」的方法，就可以在 \\(O(2^nn)\\) 求出真正的答案。 考虑如何计算 \\(ans_A\\)。发现 \\(ans_A\\) 的值只与 \\(A\\) 中 \\(1\\) 连续段的长度形成的可重集合有关。如 \\(A=\\{0,1,1,1,0,0,1\\}\\) 时，所有 \\(1\\) 连续段长度形成的集合就是 \\(\\{1,1,2,4\\}\\)（原长加 \\(1\\)）。 可以发现，对于任意 \\(A\\)，对应的 \\(1\\) 连续段长度形成的可重集合中所有元素的和一定恰好为 \\(n\\)。这意味着不同的集合数量等于 \\(n\\) 的划分数。 对于一个划分 \\(P=\\{a_1,a_2,\\cdots,a_k\\}\\)，可以发现对应的方案数实质上是在原图中选出 \\(k\\) 条不相交的简单路径，满足第 \\(i\\) 条路径的点数为 \\(a_i\\) 的方案数。 那么我们先考虑选 \\(1\\) 条路径。可以用 DP 求出 \\(f_{u,S}\\) 表示当前在节点 \\(u\\)，经过的点集为 \\(S\\) 时的路径条数，进而求出 \\(g_S\\) 表示经过的点集为 \\(S\\) 的路径条数。 那么对于一个划分 \\(P=\\{a_1,a_2,\\cdots,a_k\\}\\)，答案即为 \\[\\sum_{S_1,S_2,\\cdots,S_k} \\left[|S_i|=a_i\\right]\\left[\\forall i\\ne j:S_i\\cap S_j=\\varnothing\\right]\\left[\\bigcup\\limits_{i=1}^{k}S_i=U\\right]\\prod\\limits_{i=1}^{k} g_{S_i}\\] 其中 \\(U\\) 表示全集。 注意到由于 \\(\\sum\\limits_{i=1}^{k} a_i=n\\)，后面两个条件只需要保留一个即可。第二个条件很难处理，我们考虑保留第三个。若不考虑前两个条件，只考虑第三个条件，只需要用 FWT 即可方便地求出答案。 存在第一个条件时，我们只要将 \\(g\\) 加上一维，\\(g_{l,S}\\) 表示长度为 \\(l\\)，经过点集为 \\(S\\) 的简单路径数量。对于 \\(|S|\\ne l\\) 的位置就置为 \\(0\\)。那么答案式子变成了 \\[\\sum_{S_1,S_2,\\cdots,S_k} \\left[\\bigcup\\limits_{i=1}^{k}S_i=U\\right]\\prod\\limits_{i=1}^{k} g_{a_i,S_i}\\] 直接将所有 \\(g_i\\) 进行一次 FWT 后，枚举划分时直接点乘。由于我们实际只需要卷积结果中 \\(2^n-1\\) 位置的值，所以我们不需要每次 IFWT，直接根据实际意义用容斥就可以 \\(O(2^n)\\) 求出这个值。 总时间复杂度 \\(O(2^n(P(n)+n^2))\\)，其中 \\(P(n)\\) 表示 \\(n\\) 的划分数。 实现得不好可能会变成 \\(O(2^n(S(n)+n^2))\\) 或 \\(O(2^nn(P(n)+n))\\)，其中 \\(S(n)\\) 表示 \\(n\\) 的所有划分的大小之和。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int n;std::vector&lt;int&gt; bitcnt;std::vector&lt;std::vector&lt;long long&gt;&gt; f;std::vector&lt;std::vector&lt;long long&gt;&gt; g;std::map&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt;&gt; part;std::vector&lt;long long&gt; ans;void dfs(int r, const std::vector&lt;int&gt; &amp;l, const std::vector&lt;long long&gt; &amp;s)&#123; if (!r)&#123; long long res = 0; int mask = (1 &lt;&lt; n) - 1; for (register int i = 0; i &lt; (1 &lt;&lt; n); ++i) if (bitcnt[mask ^ i] &amp; 1) res -= s[i]; else res += s[i]; const std::vector&lt;int&gt; &amp;p = part[l]; for (int v : p) ans[v] += res; return; &#125; int lst = l.empty() ? 1 : l.back(); for (register int k = lst; k &lt;= r; ++k)&#123; if (k &lt; r &amp;&amp; r - k &lt; k) continue; std::vector&lt;int&gt; nl(l); std::vector&lt;long long&gt; ns(s); nl.push_back(k); for (register int i = 0; i &lt; (1 &lt;&lt; n); ++i) ns[i] *= g[k - 1][i]; dfs(r - k, nl, ns); &#125;&#125;void solve()&#123; read(n); std::vector&lt;std::vector&lt;int&gt;&gt; E(n); for (register int i = 0; i &lt; n; ++i) for (register int j = 0; j &lt; n; ++j)&#123; char ch; while (!isdigit(ch = getchar())) ; if (ch == &#x27;1&#x27;) E[i].push_back(j); &#125; bitcnt.resize(1 &lt;&lt; n); bitcnt[0] = 0; for (register int i = 1; i &lt; (1 &lt;&lt; n); ++i) bitcnt[i] = bitcnt[i &gt;&gt; 1] + (i &amp; 1); f.resize(n, std::vector&lt;long long&gt;(1 &lt;&lt; n, 0)); g.resize(n, std::vector&lt;long long&gt;(1 &lt;&lt; n, 0)); for (register int i = 0; i &lt; n; ++i) f[i][1 &lt;&lt; i] = 1; for (register int S = 1; S &lt; (1 &lt;&lt; n); ++S) for (register int i = 0; i &lt; n; ++i) if (f[i][S])&#123; g[bitcnt[S] - 1][S] += f[i][S]; for (int v : E[i]) if (!(S &gt;&gt; v &amp; 1)) f[v][S | (1 &lt;&lt; v)] += f[i][S]; &#125; for (register int k = 0; k &lt; n; ++k) for (register int i = 0; i &lt; n; ++i) for (register int S = 0; S &lt; (1 &lt;&lt; n); ++S) if (S &gt;&gt; i &amp; 1) g[k][S] += g[k][S ^ (1 &lt;&lt; i)]; for (register int S = 0; S &lt; (1 &lt;&lt; (n - 1)); ++S)&#123; std::vector&lt;int&gt; p; int x = 1; for (register int i = 0; i &lt; n - 1; ++i) if (S &gt;&gt; i &amp; 1) ++x; else p.push_back(x), x = 1; p.push_back(x); std::sort(p.begin(), p.end()); part[p].push_back(S); &#125; ans.resize(1 &lt;&lt; (n - 1), 0); dfs(n, std::vector&lt;int&gt;(), std::vector&lt;long long&gt;(1 &lt;&lt; n, 1)); for (register int i = 0; i &lt; n - 1; ++i) for (register int S = 0; S &lt; (1 &lt;&lt; (n - 1)); ++S) if (S &gt;&gt; i &amp; 1) ans[S ^ (1 &lt;&lt; i)] -= ans[S]; for (long long v : ans) print(v, &#x27; &#x27;); putchar(&#x27;\\n&#x27;);&#125; G - Spiderweb Trees 题目传送门 tourist 都没过的题，鸽了鸽了。","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"manacher","slug":"manacher","permalink":"https://autumnkite.github.io/tags/manacher/"},{"name":"线段树","slug":"线段树","permalink":"https://autumnkite.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"递推","slug":"递推","permalink":"https://autumnkite.github.io/tags/%E9%80%92%E6%8E%A8/"},{"name":"meet in middle","slug":"meet-in-middle","permalink":"https://autumnkite.github.io/tags/meet-in-middle/"}]},{"title":"Codeforces Round #628 (Div. 2) 爆蛋记","slug":"cf1325","date":"2020-03-20T06:04:00.000Z","updated":"2020-03-27T02:33:26.019Z","comments":true,"path":"cf1325/","link":"","permalink":"https://autumnkite.github.io/cf1325/","excerpt":"完全爆蛋，小号三场上橙无望 /kk 爆蛋链接","text":"完全爆蛋，小号三场上橙无望 /kk 爆蛋链接 A - EhAb AnD gCd 题目传送门 题意 构造正整数 \\(a,b\\) 满足 \\(\\gcd(a,b)+\\operatorname{lcm}(a,b)=x\\)。 \\(x\\le 10^9\\) 题解 构造 \\(a=1,b=x-1\\) 即可。 代码 12345int x;void solve()&#123; read(x); print(1, &#x27; &#x27;), print(x - 1);&#125; B - CopyCopyCopyCopyCopy 题目传送门 题意 求将一个长度为 \\(n\\) 的序列 \\(a\\) 复制 \\(n\\) 次后的 LIS 长度。 \\(n\\le 10^5\\) 题解 显然最优方案是在复制的第一份中选最小值，第二份中选次小值…… 所以 LIS 长度就是所有数去重后的数量。 代码 1234567int n, a[100005];void solve()&#123; read(n); for (register int i = 1; i &lt;= n; ++i) read(a[i]); std::sort(a + 1, a + 1 + n); print(std::unique(a + 1, a + 1 + n) - a - 1);&#125; C - Ehab and Path-etic MEXs 题目传送门 题意 给定一棵 \\(n\\) 个点的树，你需要给每条边定上互不相同的 \\(0\\sim n-2\\) 的整数权值，使得 \\(\\max\\limits_{u,v} \\operatorname{mex}(\\operatorname{path}(u,v))\\) 最小。\\(\\operatorname{path}(u,v)\\) 表示 \\(u\\) 到 \\(v\\) 路径上所有边边权组成的集合。 \\(n\\le 10^5\\) 题解 对于 \\(n&gt;2\\) 时，我们始终可以找到一条包含 \\(0,1\\) 的路径，所以有答案 \\(\\ge 2\\)。 我们只要找到一个度数 \\(\\ge 3\\) 的点，把 \\(0,1,2\\) 放在这个点连出去的边中，就可以保证不存在某条路径同时包含 \\(0,1,2\\)，即达到了答案的下界。 若没有度数 \\(\\ge 3\\) 的点，此时树的形态是一条链，答案显然为 \\(n-1\\)，任意构造即可。 代码 考场上想复杂了，尝试以某个叶子节点为根以后去考虑 \\(0,1,2\\) 的放置，于是罚时罚没了（成功搞炸心态）。 12345678910111213141516171819202122232425const int N = 100005;int n, ans[N];std::vector&lt;std::pair&lt;int, int&gt;&gt; E[N];void solve()&#123; read(n); for (register int i = 0, u, v; i &lt; n - 1; ++i) read(u), read(v), E[u].push_back(&#123;v, i&#125;), E[v].push_back(&#123;u, i&#125;), ans[i] = -1; int id = 0, cnt = 0; for (register int i = 1; i &lt;= n; ++i) if (E[i].size() == 1) ++cnt, id = i; if (cnt == 2)&#123; for (register int i = 0; i &lt; n - 1; ++i) print(i); return; &#125; ans[E[id][0].second] = 0; int u = E[id][0].first, lst = id, now = 0; while (E[u].size() == 2)&#123; int v = E[u][0].first ^ E[u][1].first ^ lst; lst = u, u = v; &#125; for (auto p : E[u]) if (p.first != lst) ans[p.second] = ++now; for (register int i = 0; i &lt; n - 1; ++i) if (ans[i] == -1) ans[i] = ++now; for (register int i = 0; i &lt; n - 1; ++i) print(ans[i]);&#125; D - Ehab the Xorcist 题目传送门 题意 构造一个最短的序列使得异或和为 \\(u\\)，和为 \\(v\\)。 \\(u,v\\le 10^{18}\\) 题解 考场上尝试从高位到低位逐位构造，但是他先 WA9 然后 WA18 了。 神仙 Froggy 告诉我本题考查了 if 语句。 我离当场去世真的只差一点.jpg 代码 123456789101112long long u, v;void solve()&#123; read(u), read(v); if (v &lt; u || (v - u) &amp; 1) return print(-1), void(0); if (u == 0)&#123; if (v == 0) return print(0), void(0); else return print(2), print(v &gt;&gt; 1, &#x27; &#x27;), print(v &gt;&gt; 1), void(0); &#125; if (u == v) return print(1), print(u), void(0); if (u &amp; ((v - u) &gt;&gt; 1)) return print(3), print(u, &#x27; &#x27;), print((v - u) &gt;&gt; 1), print((v - u) &gt;&gt; 1), void(0); else return print(2), print(u + ((v - u) &gt;&gt; 1), &#x27; &#x27;), print((v - u) &gt;&gt; 1), void(0);&#125; E - Ehab's REAL Number Theory Problem 题目传送门 题意 给定一个长度为 \\(n\\) 的序列 \\(a\\)，求出所有乘积为完全平方数的子序列（可以不连续）的最短长度。 保证 \\(a_i\\) 的因数个数不超过 \\(7\\)。 \\(n\\le 10^5,a_i\\le 10^6\\) 题解 由于包含三个不同质因子的数至少有 \\((1+1)^3=8\\) 个因数，所以因数个数不超过 \\(7\\) 说明不同质因子数量不超过 \\(2\\)。 并且，我们可以去掉 \\(a_i\\) 中包含的完全平方因子，这样处理后 \\(a_i\\) 只会包含至多两个次数为 \\(1\\) 的质因子。 于是我们可以把 \\(a_i\\) 表示成 \\(p\\times q\\) 的形式，其中 \\(p,q\\) 为质数或 \\(1\\)。我们把这样的 \\(a_i\\) 看成一条连接 \\(p,q\\) 的无向边。 现在问题是在这样得到的图中选择最少数量的边（至少一条），使得只保留这些边后图中每个点的度数为偶数。 显然存在度数 \\(&gt;2\\) 的点是不优的，所以我们可以强制最后每个点的度数为 \\(2\\)（不考虑度数为 \\(0\\) 的点）。 这意味着我们要求新图的最小环。 考场上被人误导想了一个假算法，就是把 \\(&gt;1000\\) 的点扔掉，直接在他连的点之间互相连边以后跑 Floyd。 但是显然这样做是错的，会导致一个数被选多次。 考场上只想到了上面部分，于是当场去世了。 我们需要求出一个无向图的最小环。那么我们考虑枚举一个点 \\(s\\) 以及一条边 \\((u,v)\\)，得到以 \\(s\\) 为起点的最短路树，求出包含点 \\(s\\) 和非树边 \\((u,v)\\) 的最小环。 考虑最短路树上加入 \\((u,v)\\)，我们得到了一个包含 \\((u,v)\\) 但有可能不包含 \\(s\\) 的环。 可以发现，我们直接用 \\(\\operatorname{dist}(s,u)+\\operatorname{dist}(s,v)\\) 更新答案一定是对的，因为如果上面得到的环不包含 \\(s\\)，一定会在枚举其他起点时被计算入答案，并且一定优于 \\(\\operatorname{dist}(s,u)+\\operatorname{dist}(s,v)\\)，所以我们并不需要判断这个环是否包含 \\(s\\)。 我们仍然需要考虑的是上述算法是否能覆盖到最优解。考虑最优解环上任意一个点 \\(s\\)，环上一定存在一条边 \\((u,v)\\) 不在以 \\(s\\) 为起点形成的最短路树上。如果 \\(u,v\\) 在这棵树上的 LCA 不是 \\(s\\)，说明存在一个更小的环，与假设矛盾；否则此时 \\(\\operatorname{dist}(s,u)+\\operatorname{dist}(s,v)\\) 一定就是最优解的环长。由于我们枚举了所有 \\(s,u,v\\)，所以一定能覆盖到最优解。 然而上面的算法是 \\(O(nm)\\) 的。 设 \\(m=\\max \\{a_i\\}\\)，可以发现我们需要求最小环的图与一般的图有一个很大的区别是，两个点 \\(u,v\\) 若 \\(uv&gt;m\\) 是不可能有边的，所以一定不会存在 \\(u,v&gt;\\sqrt{m}\\) 的连边。 那么显然一个环内至少存在一个点的编号是 \\(\\le \\sqrt{m}\\) 的。根据上面算法能覆盖到最优解的证明过程，我们只要能够枚举到环上任意一个点作为 \\(s\\) 就可以覆盖到这个环。所以，我们只要将上面求最小环的算法中 \\(s\\) 的枚举范围缩小到 \\(\\sqrt{m}\\) 即可。 时间复杂度根据实现为 \\(O(n\\frac{\\sqrt{m}}{\\log m})\\) 或 \\(O((n+\\frac{m}{\\log m})\\frac{\\sqrt{m}}{\\log m})\\)。 除以 \\(\\log m\\) 是因为只需要考虑质数。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const int N = 1000005, M = 100005, INF = 0x3f3f3f3f;int n;int cnt, p[N], vis[N];void init(int n)&#123; // 欧拉筛预处理所有质数 for (register int i = 2; i &lt;= n; ++i)&#123; if (!vis[i]) p[++cnt] = i, vis[i] = cnt; for (register int j = 1; j &lt;= cnt &amp;&amp; p[j] * i &lt;= n; ++j)&#123; vis[p[j] * i] = 1; if (i % p[j] == 0) break; &#125; &#125;&#125;std::vector&lt;int&gt; v[M];std::vector&lt;std::pair&lt;int, int&gt;&gt; E[N];int ans, ont[M], tim[N], dis[N];void bfs(int S)&#123; // bfs 求出最短路树 for (register int i = 1; i &lt;= n; ++i) ont[i] = 0; std::vector&lt;int&gt; Q; Q.push_back(S), tim[S] = S, dis[S] = 0; // 将 tim 置为每次 bfs 的起点，可以避免每次需要重置 dis 数组导致复杂度变劣 for (register int i = 0; i &lt; (int)Q.size(); ++i)&#123; int u = Q[i]; for (auto p : E[u])&#123; int v = p.first, eid = p.second; if (tim[v] != S) Q.push_back(v), tim[v] = S, dis[v] = dis[u] + 1, ont[eid] = 1; &#125; &#125; for (register int i = 1; i &lt;= n; ++i) // 枚举每条非树边，更新答案 if (!ont[i] &amp;&amp; tim[v[i][0]] == S &amp;&amp; tim[v[i][1]] == S) ans = std::min(ans, dis[v[i][0]] + dis[v[i][1]] + 1);&#125;void solve()&#123; read(n); init(1000000), p[0] = 1, vis[1] = 0; for (register int i = 1, x; i &lt;= n; ++i)&#123; read(x); for (register int j = 1; j &lt;= cnt &amp;&amp; 1ll * p[j] * p[j] &lt;= x; ++j) if (x % p[j] == 0)&#123; int k = 0; while (x % p[j] == 0) x /= p[j], k ^= 1; if (k) v[i].push_back(j); &#125; if (x &gt; 1) v[i].push_back(vis[x]); while (v[i].size() &lt; 2) v[i].push_back(0); E[v[i][1]].push_back(&#123;v[i][0], i&#125;), E[v[i][0]].push_back(&#123;v[i][1], i&#125;); // 连边 &#125; for (register int i = 0; i &lt;= cnt; ++i) tim[i] = -1; ans = INF; for (register int i = 0; i &lt;= cnt; ++i) if (p[i] &lt;= 1000) bfs(i); else break; // 只需要考虑编号 &lt;=1000 且为质数的点 if (ans == INF) print(-1); else print(ans);&#125; F - Ehab's Last Theorem 题目传送门 咕咕咕...","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"BFS","slug":"BFS","permalink":"https://autumnkite.github.io/tags/BFS/"},{"name":"最短路","slug":"最短路","permalink":"https://autumnkite.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"多项式相关","slug":"polynomial-notes","date":"2019-12-07T13:06:00.000Z","updated":"2020-06-14T05:06:03.450Z","comments":true,"path":"polynomial-notes/","link":"","permalink":"https://autumnkite.github.io/polynomial-notes/","excerpt":"太久没更新博客，开一篇多项式相关的博客记一下多项式的一些基础操作吧。","text":"太久没更新博客，开一篇多项式相关的博客记一下多项式的一些基础操作吧。 模域下的运算 1234567891011121314151617181920212223242526272829303132const int P = 998244353, G = 3;void inc(int &amp;a, int b) &#123; (a += b) &gt;= P ? a -= P : 0;&#125;void dec(int &amp;a, int b) &#123; a &lt; b ? a += P - b : a -= b;&#125;int plus(int a, int b) &#123; return a + b &gt;= P ? a + b - P : a + b;&#125;int minus(int a, int b) &#123; return a &lt; b ? a + P - b : a - b;&#125;int mul(int a, int b) &#123; return 1ll * a * b % P;&#125;int qpow(int a, int b) &#123; int s = 1; for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1) &#123; s = mul(s, a); &#125; a = mul(a, a); &#125; return s;&#125; 快速傅里叶变换与快速傅里叶逆变换 快速傅里叶变换 在这一节中，除特殊说明外，\\(n\\) 是 \\(2\\) 的幂次。 利用 FFT，我们可以在 \\(O(n\\log n)\\) 的时间内求出 \\(F(\\omega_n^0),F(\\omega_n^1),\\cdots,F(\\omega_n^{n-1})\\) 的值，以及由这些值得到 \\(F(x)\\) 的系数，其中 \\(\\omega_n^{i}\\) 表示单位根，这里不具体展开。 单位根具有一些优美的性质，如 \\(\\omega_{dn}^{dk}=\\omega_n^k\\) \\(\\omega_{n}^{\\frac{n}{2}}=\\omega_2^1=-1\\) \\(\\omega_{n}^{k+\\frac{n}{2}}=-\\omega_{n}^{k}\\) \\(\\omega_n^a=\\omega_n^{a \\bmod n}\\) FFT 正是利用了这些性质加快速度。 假设原多项式为 \\(F(x)=\\sum\\limits_{i=0}^{n-1} f_ix^i\\)，我们把 \\(F(x)\\) 按指数奇偶性拆成两部分，即 \\[F_0(x)=\\sum\\limits_{i=0}^{\\frac{n}{2}-1} f_{2i}x^i,F_1(x)=\\sum\\limits_{i=0}^{\\frac{n}{2}-1} f_{2i+1}x^i\\] 那么有 \\[F(x)=F_0(x^2)+xF_1(x^2)\\] 我们把 \\(x=\\omega_n^k\\ (0\\le k &lt; \\frac{n}{2})\\) 代入 \\(F(x)\\)，得到 \\[F(\\omega_n^k)=F_0(\\omega_{\\frac{n}{2}}^k)+\\omega_n^kF_1(\\omega_{\\frac{n}{2}}^k)\\] 同理，把 \\(x=\\omega_n^{k+\\frac{n}{2}}\\ (0\\le k &lt; \\frac{n}{2})\\) 代入 \\(F(x)\\)，得到 \\[F(\\omega_n^k)=F_0(\\omega_{\\frac{n}{2}}^k)-\\omega_n^kF_1(\\omega_{\\frac{n}{2}}^k)\\] 发现问题转化成了两个子问题，直接分治求解即可。时间复杂度 \\(O(n\\log n)\\)。 直接做常数太大，我们发现分治到底层时下标是原下标的二进制翻转，于是直接翻转完后从下往上合并即可。 可以用 unsigned long long 减少取模次数优化常数。 快速傅里叶逆变换 记多项式 \\(G(x)=\\sum\\limits_{i=0}^{n-1}F(\\omega_n^i)x^i\\)，考虑对 \\(G(x)\\) 做 FFT，得到 \\[\\begin{aligned}G(\\omega_n^k)&amp;=\\sum\\limits_{i=0}^{n-1}F(\\omega_n^i)(\\omega_n^k)^i\\\\&amp;=\\sum\\limits_{i=0}^{n-1}\\left(\\sum\\limits_{j=0}^{n-1} f_j(\\omega_n^i)^j\\right)(\\omega_n^k)^i\\\\&amp;=\\sum\\limits_{j=0}^{n-1}f_j\\sum\\limits_{i=0}^{n-1}(\\omega_n^{j+k})^i\\end{aligned}\\] 发现只有当 \\(j+k\\equiv 0\\pmod n\\) 时 \\(\\sum\\limits_{i=0}^{n-1}(\\omega_n^{j+k})^i=n\\)，其他情况都为 \\(0\\)。于是 \\[\\begin{aligned}G(\\omega_n^k)&amp;=\\sum\\limits_{j=0}^{n-1}f_j\\sum\\limits_{i=0}^{n-1}(\\omega_n^{j+k})^i\\\\&amp;=f_{(n-k)\\bmod n}\\cdot n\\end{aligned}\\] 直接翻转后乘上 \\(n\\) 的逆元即可，时间复杂度同样为 \\(O(n\\log n)\\)。 实现 \\(\\omega_{2^k}^{i}\\) 只有 \\(O(n)\\) 个，可以在程序的一开始预处理（同时还预处理了逆元）。 12345678910111213141516171819const int MAX_LEN = 1 &lt;&lt; 18;typedef std::vector&lt;int&gt; poly;int omega[MAX_LEN], inv[MAX_LEN];void Init() &#123; // 在程序开始调用 for (int m = 1; m &lt; MAX_LEN; m &lt;&lt;= 1) &#123; int w = qpow(G, (P - 1) / (m &lt;&lt; 1)); omega[m] = 1; for (int i = 1; i &lt; m; ++i) &#123; omega[m + i] = mul(omega[m + i - 1], w); &#125; &#125; inv[1] = 1; for (int i = 2; i &lt; MAX_LEN; ++i) &#123; inv[i] = mul(P - P / i, inv[P % i]); &#125;&#125; 每次需要预处理 \\(rev[i]\\)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950poly rev;int get(int _n) &#123; int n = 1; while (n &lt; _n) &#123; n &lt;&lt;= 1; &#125; return n;&#125;void init(int n) &#123; int k = 0; while ((1 &lt;&lt; k) &lt; n) &#123; ++k; &#125; rev.resize(n), rev[0] = 0, --k; for (int i = 1; i &lt; n; ++i) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; k); &#125;&#125;void DFT(poly &amp;f, int n) &#123; f.resize(n); static unsigned long long F[MAX_LEN]; for (int i = 0; i &lt; n; ++i) &#123; F[rev[i]] = f[i]; &#125; for (int m = 1; m &lt; n; m &lt;&lt;= 1) &#123; // 注意当 MAX_LEN &gt; 2^18 时这里需要把 F[i] 全部模 P for (int p = 0, l = m &lt;&lt; 1; p &lt; n; p += l) &#123; int *W = omega + m; unsigned long long *F0 = F + p, *F1 = F0 + m; for (int i = 0; i &lt; m; ++i, ++F0, ++F1, ++W) &#123; int t = (*F1) * (*W) % P; *F1 = *F0 + P - t, *F0 += t; &#125; &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; f[i] = (F[i] % P + P) % P; &#125;&#125;void IDFT(poly &amp;f, int n) &#123; DFT(f, n), std::reverse(f.begin() + 1, f.end()); int t = qpow(n, P - 2); for (int i = 0; i &lt; n; ++i) &#123; f[i] = mul(f[i], t); &#125;&#125; 多项式加法与减法 对于每个 \\(x_i\\) 的系数直接相加/相减即可。 时间复杂度 \\(O(n)\\)。 1234567891011121314151617poly Plus(poly a, poly b) &#123; int n = std::max(a.size(), b.size()); a.resize(n), b.resize(n); for (int i = 0; i &lt; n; ++i) &#123; inc(a[i], b[i]); &#125; return a;&#125;poly Minus(poly a, poly b) &#123; int n = std::max(a.size(), b.size()); a.resize(n), b.resize(n); for (int i = 0; i &lt; n; ++i) &#123; dec(a[i], b[i]); &#125; return a;&#125; 多项式乘法 DFT 后把点值乘起来，在 IDFT 回去即可。 代码中的参数 _n 的作用在下面会提到。 1234567891011121314151617poly Mul(poly a, poly b, int _n = -1) &#123; int na = (int)a.size(), nb = (int)b.size(), n = _n; if (!na || !nb || !n) &#123; return &#123;&#125;; &#125; if (n == -1) &#123; n = na + nb - 1; &#125; _n = n, n = get(n); init(n), DFT(a, n), DFT(b, n); for (int i = 0; i &lt; n; ++i) &#123; a[i] = mul(a[i], b[i]); &#125; IDFT(a, n); a.resize(_n); return a;&#125; 可以把计算 \\(F^2(x)\\) 单独写一个函数，常数可以更小。 1234567891011poly Pow2(poly a) &#123; int _n = 2 * (int)a.size() - 1; int n = get(_n); init(n), DFT(a, n); for (int i = 0; i &lt; n; ++i) &#123; a[i] = mul(a[i], a[i]); &#125; IDFT(a, n); a.resize(_n); return a;&#125; 多项式求逆 已知多项式 \\(F(x)\\)，求一个多项式 \\(G(x)\\) 满足 \\(F(x)G(x)\\equiv 1\\pmod{x^n}\\)。 假设我们已经求出 \\(G_0(x)\\) 满足 \\[F(x)G_0(x)\\equiv 1\\pmod {x^{\\lceil\\frac{n}{2}\\rceil}}\\] 那么有 \\[F(x)(G(x)-G_0(x))\\equiv 0\\pmod{x^{\\lceil\\frac{n}{2}\\rceil}}\\] 由于 \\(G(x)-G_0(x)\\) 是 \\(n-1\\) 次多项式，两边同时乘 \\(G(x)-G_0(x)\\) 得到 \\[F(x)(G(x)-G_0(x))^2\\equiv 0\\pmod{x^n}\\] 展开后整理得到 \\[G(x)\\equiv 2G_0(x)-F(x)G_0^2(x)\\pmod {x^n}\\] 迭代求出即可。 边界情况，即 \\(n=1\\) 时，求 \\(f_0\\) 的逆元即可。 时间复杂度 \\(O(n\\log n)\\)。 1234567891011121314151617poly Inv(poly f, int _n) &#123; int n = get(_n); f.resize(n); poly g(1); g[0] = qpow(f[0], P - 2); for (int m = 2; m &lt;= n; m &lt;&lt;= 1) &#123; int l = m &lt;&lt; 1; poly tmp(f.begin(), f.begin() + m); init(l), DFT(tmp, l), DFT(g, l); for (int i = 0; i &lt; l; ++i) &#123; g[i] = (2 + 1ll * (P - tmp[i]) * g[i]) % P * g[i] % P; &#125; IDFT(g, l), g.resize(m); &#125; g.resize(_n); return g;&#125; 多项式除法 已知 \\(n-1\\) 次多项式 \\(A(x)\\) 和 \\(m-1\\) 次多项式 \\(B(x)\\)，求 \\(n-m\\) 次多项式 \\(Q(x)\\) 和小于 \\(m-1\\) 次的多项式 \\(R(x)\\) 满足 \\(A(x)=B(x)Q(x)+R(x)\\)。 下面我们强制 \\(R(x)\\) 为 \\(m-2\\) 次，不足则高位补 \\(0\\)。 用记号 \\(F_r(x)\\) 表示 \\(F(x)\\) 的系数翻转后的结果。有 \\[F_r(x)=x^{\\operatorname{deg}F(x)}F(\\frac{1}{x})\\] 其中 \\(\\operatorname{deg}F(x)\\) 表示 \\(F(x)\\) 的次数。 把原式中的 \\(x\\) 用 \\(\\frac{1}{x}\\) 代替，得到 \\[A(\\frac{1}{x})=B(\\frac{1}{x})Q(\\frac{1}{x})+R(\\frac{1}{x})\\] 两边同乘 \\(x^{n-1}\\) 得到 \\[x^{n-1}A(\\frac{1}{x})=x^{m-1}B(\\frac{1}{x})x^{n-m}Q(\\frac{1}{x})+x^{n-m+1}\\cdot x^{m-2}R(x)\\] 即 \\[A_r(x)=B_r(x)Q_r(x)+x^{n-m+1}R(x)\\] 那么有 \\[A_r(x)\\equiv B_r(x)Q_r(x)\\pmod{x^{n-m+1}}\\] 由于 \\(Q(x)\\) 是一个 \\(n-m\\) 次多项式，所以 \\(\\bmod x^{n-m+1}\\) 不会对 \\(Q(x)\\) 产生影响。 此时由于去掉了 \\(R(x)\\)，直接做多项式求逆即可求出 \\(Q(x)\\)。然后根据 \\(R(x)=A(x)-B(x)Q(x)\\) 求出 \\(R(x)\\)。 时间复杂度 \\(O(n\\log n)\\)。 123456789101112131415std::pair&lt;poly, poly&gt; Div(const poly &amp;a, const poly &amp;b) &#123; int n = a.size(), m = b.size(); poly Q, R; if (n &lt; m) &#123; R = a, R.resize(m - 1); return &#123;Q, R&#125;; &#125; poly A(a), B(b); std::reverse(A.begin(), A.end()), A.resize(n - m + 1); std::reverse(B.begin(), B.end()), B.resize(n - m + 1); Q = Mul(A, Inv(B, n - m + 1)); Q.resize(n - m + 1), std::reverse(Q.begin(), Q.end()); R = Minus(a, Mul(b, Q)), R.resize(m - 1); return &#123;Q, R&#125;;&#125; 多项式求导与积分 求导有运算法则： - \\((u(x)+v(x))&#39;=u&#39;(x)+v&#39;(x)\\) - \\((u(x)\\cdot v(x))&#39;=u&#39;(x)\\cdot v(x)+u(x)\\cdot v&#39;(x)\\) 并且可以扩展到 \\(n\\) 个函数。同时有 \\(C&#39;=0,(x^n)&#39;=nx^{n-1}\\)。 于是 \\[F&#39;(x)=\\left(\\sum\\limits_{i=0}^{n-1} f_ix^i\\right)&#39;=\\sum\\limits_{i=0}^{n-1}(f_ix^i)&#39;=\\sum\\limits_{i=1}^{n-1} f_i\\cdot ix^{i-1}\\] 积分只要反着做一遍就好了。 时间复杂度 \\(O(n)\\)。 123456789101112131415161718poly Der(poly f) &#123; int n = (int)f.size(); for (int i = 1; i &lt; n; ++i) &#123; f[i - 1] = mul(f[i], i); &#125; f.pop_back(); return f;&#125;poly Int(poly f) &#123; f.push_back(0); int n = f.size(); for (int i = n - 1; i; --i) &#123; f[i] = mul(f[i - 1], inv[i]); &#125; f[0] = 0; return f;&#125; 泰勒展开 泰勒展开是将一个在 \\(x=x_0\\) 处具有 \\(n\\) 阶导数的函数 \\(f(x)\\) 利用关于 \\(x-x_0\\) 的 \\(n\\) 次多项式来逼近函数的方法。 当 \\(n\\) 趋向于无穷时，我们可以直接用下面这个式子表示泰勒公式： \\[f(x)=\\sum\\limits_{i=0}^{\\infty} \\frac{f^{(i)}(x_0)}{i!}(x-x_0)^i\\] 而麦克劳林级数就是上式 \\(x_0=0\\) 的特殊形式。 要对泰勒展开有更好地理解可以看怎样更好地理解并记忆泰勒展开式？- 知乎。 牛顿迭代 牛顿迭代法是一种用于解非线性方程 \\(G(x)=0\\) 的近似方法。 而在我们研究多项式相关时，我们一般用牛顿迭代法解关于无穷幂级数 \\(F(x)\\) 的非线性方程 \\(G(F(x))=0\\)，求 \\(F(x)\\) 在模 \\(x^n\\) 意义下得到的多项式，其中 \\(G(F(x))\\) 是一个自变量为多项式，应变量也为多项式的函数。 我们假设已经求出答案模 \\(x^{\\lceil\\frac{n}{2}\\rceil}\\) 意义下的多项式 \\(F_0(x)\\)，我们要求出答案模 \\(x^n\\) 意义下的多项式 \\(F_1(x)\\)。即我们已经有 \\[G(F_0(x))\\equiv 0\\pmod{x^{\\lceil\\frac{n}{2}\\rceil}}\\] 我们把 \\(G(F(x))\\) 在 \\(F(x)=F_0(x)\\) 处泰勒展开，得到 \\[\\begin{aligned}G(F(x))&amp;=G(F_0(x))\\\\ &amp;+G&#39;(F_0(x))(F(x)-F_0(x))\\\\ &amp;+\\frac{G&#39;&#39;(F_0(x))}{2}(F(x)-F_0(x))^2\\\\&amp;+\\cdots\\end{aligned}\\] 因为有 \\(F_1(x)-F_0(x)\\equiv 0\\pmod{x^{\\lceil\\frac{n}{2}\\rceil}}\\)，所以有 \\((F_1(x)-F_0(x))^2\\equiv 0\\pmod{x^n}\\)。 由于 \\(F_1(x)\\) 是答案在模 \\(x^n\\) 意义下的多项式，所以上述泰勒展开式中除前两项外的部分代入 \\(F_1(x)\\) 后模 \\(x^n\\) 为 \\(0\\)。所以我们只需要考虑前两项。即 \\(F_1(x)\\) 只需要满足 \\[G(F_0(x))+G&#39;(F_0(x))(F_1(x)-F_0(x))\\equiv 0\\pmod{x^n}\\] 整理，得 \\[F_1(x)\\equiv F_0(x)-\\frac{G(F_0(x))}{G&#39;(F_0(x))}\\pmod{x^n}\\] 于是我们可以在 \\(O(n\\log n)\\) 的时间求出答案在模 \\(x^n\\) 意义下的多项式。 多项式对数函数 已知多项式 \\(F(x)\\)（常数项为 \\(1\\)），求多项式 \\(G(x)\\) 满足 \\(G(x)\\equiv \\ln F(x)\\pmod{x^n}\\)。 注意多项式的对数函数可以认为是多项式和麦克劳林级数的复合。这意味着多项式对数函数是一个无穷级数。我们只能求他在模 \\(x^n\\) 意义下得到的多项式。 类似地，多项式求逆、多项式指数函数、多项式开根等我们都只能求出在模意义下的多项式。 注意 \\(F(x)\\) 常数项不为 \\(1\\) 时 \\(\\ln F(x)\\) 无意义。 两边同时求导，得到 \\[G&#39;(x)\\equiv (\\ln F(x))&#39;\\pmod {x^{n-1}}\\] 由复合函数求导公式，得到 \\[G&#39;(x)\\equiv \\frac{F&#39;(x)}{F(x)}\\pmod {x^{n-1}}\\] 然后两边同时求积分，得到 \\[\\ln F(x)\\equiv \\int \\frac{F&#39;(x)}{F(x)}\\pmod {x^n}\\] 时间复杂度 \\(O(n\\log n)\\)，瓶颈在于多项式乘法和多项式求逆。 1234poly Ln(const poly &amp;a, int n) &#123; poly res = Int(Mul(Der(a), Inv(a, n))); return res.resize(n), res;&#125; 多项式指数函数 已知多项式 \\(F(x)\\)（常数项为 \\(0\\)），求多项式 \\(G(x)\\) 满足 \\(G(x)\\equiv \\exp {F(x)}\\pmod{x^n}\\)。 多项式 \\(\\exp\\) 有两种做法，分别是 \\(O(n\\log n)\\) 的牛顿迭代法与 \\(O(n\\log^2 n)\\) 的分治法，并且分治法可以进一步优化成 \\(O(\\frac{n\\log^2 n}{\\log\\log n})\\)。从实际运行效率上看，\\(n\\le 10^5\\) 时普通分治与牛顿迭代的运行速度不相上下，且分治法的实现更简单。 牛顿迭代法 注意 \\(F(x)\\) 常数项不为 \\(0\\) 时 \\(\\exp F(x)\\) 无意义。 两边同时求 \\(\\ln\\)，得到 \\[\\ln G(x)\\equiv F(x)\\pmod{x^n}\\] 即 \\[(\\ln G(x))-F(x)\\equiv 0\\pmod{x^n}\\] 定义函数 \\[H(G(x))=(\\ln G(x))-F(x)\\] 那么我们要求 \\(G(x)\\) 满足 \\(H(G(x))\\equiv 0\\pmod{x^n}\\)。 套用牛顿迭代的式子，即假设我们求出了在模 \\(x^{\\lceil\\frac{n}{2}\\rceil}\\) 意义下的答案 \\(G_0(x)\\)，那么有 \\[G(x)\\equiv G_0(x)-\\frac{H(G_0(x))}{H&#39;(G_0(x))}\\pmod{x^n}\\] 又因为有（要注意函数 \\(H(G(x))\\) 的自变量是 \\(G(x)\\) 而非 \\(x\\)） \\[\\begin{aligned}H&#39;(G(x))&amp;=\\ln&#39; G(x)\\\\ &amp;=\\frac{1}{G(x)}\\end{aligned}\\] 所以，经整理得 \\[G(x)\\equiv G_0(x)(1-(\\ln G_0(x))+F(x))\\pmod{x^n}\\] 时间复杂度 \\(O(n\\log n)\\)。常数较大。 1234567891011121314151617181920poly ExpNewton(poly f, int _n) &#123; int n = get(_n); f.resize(n); poly g(1); g[0] = 1; for (int m = 2; m &lt;= n; m &lt;&lt;= 1) &#123; int l = m &lt;&lt; 1; poly tmp = Ln(g, m); for (int i = 0; i &lt; m; ++i) &#123; tmp[i] = minus(f[i], tmp[i]); &#125; inc(tmp[0], 1); init(l), DFT(tmp, l), DFT(g, l); for (int i = 0; i &lt; l; ++i) &#123; g[i] = mul(g[i], tmp[i]); &#125; IDFT(g, l), g.resize(m); &#125; return g.resize(_n), g;&#125; 分治法 我们在 \\(G(x)\\equiv \\exp F(x)\\pmod{x^n}\\) 两边同时求导，得到 \\[G&#39;(x)\\equiv (\\exp F(x))F&#39;(x)\\pmod{x^n}\\] 即 \\[G&#39;(x)\\equiv G(x)F&#39;(x)\\pmod{x^n}\\] 两边同时求积分，得 \\[G(x)\\equiv \\int G(x)F&#39;(x)\\] 直接分治 NTT 求解即可。时间复杂度 \\(O(n\\log^2 n)\\)。 关于卡常 在处理区间 \\([l,r)\\) 时我们需要将 \\(f[0,r-l)\\) 与 \\(g[l,\\lfloor\\frac{l+r+1}{2}\\rfloor)\\) 作卷积，求积分以后再加到 \\(g[\\lfloor\\frac{l+r+1}{2}\\rfloor,r)\\) 上（其中 \\(f,g\\) 分别是 \\(F&#39;(x),G(x)\\) 的系数数组）。 发现我们真正需要的部分是卷积后中间一部分，前后两部分是没有用的。而通过计算发现后面部分的长度一定不超过前面部分的长度，FFT 是循环卷积，我们只要把长度限定到 \\(r-l-1\\) 就可以把后面部分加到前面而不影响中间需要的部分。这样做对优化常数很有帮助。 12345678910111213141516171819202122232425void ExpSolve(const poly &amp;f, poly &amp;g, int l, int r) &#123; if (l + 1 == r) &#123; if (l) &#123; g[l] = mul(g[l], inv[l]); &#125; else &#123; g[l] = 1; &#125; return; &#125; int md = (l + r + 1) &gt;&gt; 1; ExpSolve(f, g, l, md); poly tmp(Mul(poly(g.begin() + l, g.begin() + md), poly(f.begin(), f.begin() + r - l - 1), r - l - 1)); for (int i = md; i &lt; r; ++i) &#123; inc(g[i], tmp[i - l - 1]); &#125; ExpSolve(f, g, md, r);&#125;poly Exp(poly f, int _n) &#123; f.resize(_n), f = Der(f); poly g(_n); ExpSolve(f, g, 0, _n); return g;&#125; 更为优秀的分治做法 咕咕咕 多项式求任意次幂 给定多项式 \\(F(x)\\) 和正整数 \\(k\\)，求 \\(G(x)\\equiv F^k(x)\\pmod{x^n}\\)。 如果 \\(F(x)\\) 常数项为 \\(1\\)，那么有 \\(G(x)=e^{k\\ln F(x)}\\)。 而 \\(F(x)\\) 常数项不为 \\(1\\) 时，我们可以把 \\(F(x)\\) 除以 \\(ax^p\\) 使得常数项为 \\(1\\)，最后再乘上 \\(a^kx^{kp}\\)。 理论上来说这个方法可以求任意实数幂次，但是系数在模意义下运算，\\(k\\) 为分数、无理数时很难求或者在模域下不存在答案。 时间复杂度 \\(O(n\\log n)\\)。 1234567891011121314151617181920212223242526272829303132333435363738394041poly Pow(poly a, int k, int n) &#123; a.resize(n); int t = n; for (int i = 0; i &lt; n; ++i) &#123; if (a[i]) &#123; t = i; break; &#125; &#125; if (t == n) &#123; if (!k) &#123; a[0] = 1; &#125; return a; &#125; int vi = qpow(a[t], P - 2), vk = qpow(a[t], k); for (int i = 0; i &lt; n - t; ++i) &#123; a[i] = mul(a[i + t], vi); &#125; a.resize(n - t); t = std::min(1ll * t * k, 1ll * n); if (t == n) &#123; a.resize(n); for (int i = 0; i &lt; n; ++i) &#123; a[i] = 0; &#125; return a; &#125; a = Ln(a, n - t); for (int i = 0; i &lt; n - t; ++i) &#123; a[i] = mul(a[i], k); &#125; a = Exp(a, n - t), a.resize(n); for (int i = n - t - 1; ~i; --i) &#123; a[i + t] = mul(a[i], vk); &#125; for (int i = 0; i &lt; t; ++i) &#123; a[i] = 0; &#125; return a;&#125; 注意下面部分的代码还未更新。 多项式开根 已知多项式 \\(F(x)\\)，求多项式 \\(G(x)\\) 满足 \\(G^2(x)\\equiv F(x)\\pmod{x^n}\\)。 定义函数 \\(H(G(x))=G^2(x)-F(x)\\)，那么我们要求 \\(G(x)\\) 使得 \\(H(G(x))\\equiv 0\\pmod{x^n}\\)。 仍然假设我们已经求出了 \\(G_0(x)\\) 满足 \\(H(G_0(x))\\equiv 0\\pmod{x^{\\lceil\\frac{n}{2}\\rceil}}\\)。根据牛顿迭代的式子，得到 \\[\\begin{aligned}G(x)&amp;\\equiv G_0(x)-\\frac{H(G_0(x))}{H&#39;(G_0(x))}\\\\&amp;=G_0(x)-\\frac{G_0^2(x)-F(x)}{2G_0(x)}\\\\&amp;=\\frac{G_0^2(x)+F(x)}{2G_0(x)}\\pmod{x^n}\\end{aligned}\\] 在模意义下运算时，边界我们只要用 Cipolla 算法求二次剩余即可。 时间复杂度 \\(O(n\\log n)\\)。 1234567891011121314poly Sqrt(poly f, int _n)&#123; int n = get(_n); f.resize(n); poly g(1); g[0] = Sqrt(f[0]); // 求二次剩余 for (register int m = 2; m &lt;= n; m &lt;&lt;= 1)&#123; poly tmp = Pow2(g); tmp.resize(m); for (register int i = 0; i &lt; m; ++i) inc(tmp[i], f[i]); g = Multiply(tmp, Inverse(g, m)), g.resize(m); for (register int i = 0; i &lt; m; ++i) g[i] = mul(g[i], inv[2]); &#125; return g.resize(_n), g;&#125; 多项式多点求值 给定多项式 \\(F(x)\\) 和 \\(n\\) 个点 \\(a_i\\)，对于每个 \\(a_i\\)，求 \\(F(a_i)\\) 的值。 记 \\(k=\\lfloor\\frac{n}{2}\\rfloor\\)，构造多项式 \\(G_0(x)=\\prod\\limits_{i=1}^{k}(x-a_i)\\)，然后用多项式除法求出 \\(D_0(x),R_0(x)\\) 满足 \\(F(x)=D_0(x)G_0(x)+R_0(x)\\)。 发现对于 \\(i\\le k\\) 的 \\(a_i\\)，代入后 \\(D_0(x)G_0(x)=0\\)，也就是说 \\(F(a_i)=R_0(a_i)\\)。 对于 \\(i &gt; k\\) 的部分也可以同理构造多项式 \\(G_1(x)\\) 求出 \\(R_1(x)\\) 使得 \\(F(a_i)=R_1(a_i)\\)。 于是我们把用 \\(O(n\\log n)\\) 的复杂度把原问题分成了两个规模减半的子问题。 每次的 \\(G_0(x),G_1(x)\\) 可以一开始都预处理出来。 预处理部分复杂度 \\(O(n\\log^2n)\\)，总复杂度 \\(O(n\\log^2 n)\\)。 注意到暴力展开计算常数非常小，在问题规模减到一定数值时可以暴力计算。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct tree_node&#123; int ls, rs; poly g;&#125;;int _T_cnt;std::vector&lt;tree_node&gt; _T;int eval_inter_init(const poly &amp;x, int l, int r)&#123; int u = _T_cnt++; _T[u].ls = _T[u].rs = -1, _T[u].g.resize(r - l + 1); if (l + 1 == r)&#123; _T[u].g[0] = minus(0, x[l]), _T[u].g[1] = 1; return u; &#125; int md = (l + r + 1) &gt;&gt; 1; _T[u].ls = eval_inter_init(x, l, md); _T[u].rs = eval_inter_init(x, md, r); _T[u].g = Multiply(_T[_T[u].ls].g, _T[_T[u].rs].g); return u;&#125;void Evaluate_solve(const poly &amp;f, const poly &amp;x, poly &amp;y, int u, int l, int r)&#123; if (r - l &lt;= 256)&#123; register int n = f.size(); for (register int k = l; k &lt; r; ++k)&#123; register unsigned now = 0; register unsigned long long b[17], c1, c2, c3, c4; b[0] = 1; for (register int i = 1; i &lt;= 16; ++i) b[i] = b[i - 1] * x[k] % P; for (register int i = n - 1; i - 15 &gt;= 0; i -= 16)&#123; c1 = now * b[16] + f[i] * b[15] + f[i - 1] * b[14] + f[i - 2] * b[13]; c2 = f[i - 3] * b[12] + f[i - 4] * b[11] + f[i - 5] * b[10] + f[i - 6] * b[9]; c3 = f[i - 7] * b[8] + f[i - 8] * b[7] + f[i - 9] * b[6] + f[i - 10] * b[5]; c4 = f[i - 11] * b[4] + f[i - 12] * b[3] + f[i - 13] * b[2] + f[i - 14] * b[1]; now = (c1 + c2 + c3 + c4 + f[i - 15]) % P; &#125; for (register int i = n % 16 - 1; ~i; --i) now = (1ull * now * x[k] + f[i]) % P; y[k] = now; &#125; return; &#125; int md = (l + r + 1) &gt;&gt; 1; poly R; R = Divide(f, _T[_T[u].ls].g).second; Evaluate_solve(R, x, y, _T[u].ls, l, md); R = Divide(f, _T[_T[u].rs].g).second; Evaluate_solve(R, x, y, _T[u].rs, md, r);&#125;poly Evaluate(const poly &amp;f, const poly &amp;x)&#123; int m = x.size(), rt = -1; _T_cnt = 0, _T.resize(2 * m - 1), rt = eval_inter_init(x, 0, m); poly res(m); Evaluate_solve(f, x, res, rt, 0, m); return res;&#125; 多项式快速插值 有一个 \\(n-1\\) 次多项式 \\(F(x)\\)，给定 \\(n\\) 个点及对应的点值 \\((x_i,y_i)\\)，求 \\(F(x)\\)。 根据拉格朗日插值公式，有 \\[\\begin{aligned}F(x)&amp;=\\sum_{i=1}^{n} y_i\\prod_{i\\ne j}\\frac{x-x_j}{x_i-x_j}\\\\&amp;=\\sum_{i=1}^{n}\\frac{y_i}{\\prod_{i\\ne j}(x_i-x_j)}\\prod_{i\\ne j}(x-x_j)\\end{aligned}\\] 令 \\(G(x)=\\prod_{i=1}^{n}(x-x_i),H_i(x)=\\frac{G(x)}{x-x_i}\\)，那么 \\(\\prod_{i\\ne j}(x_i-x_j)=H_i(x_i)\\)。根据洛必达法则，有 \\(H_i(x_i)=G&#39;(x_i)\\)。 于是我们用多项式多点求值求出所有 \\(G&#39;(x_i)\\) 即可。 记 \\(a_i=\\frac{y_i}{G&#39;(x_i)}\\)，那么有 \\[F(x)=\\sum_{i=1}^{n}a_i\\prod_{i\\ne j}(x-x_j)\\] 然后我们分治求解。设当前区间为 \\([l,r)\\)，中点 \\(m=\\lfloor\\frac{l+r+1}{2}\\rfloor\\)，我们要求 \\[\\begin{aligned}F_{l,r}(x)&amp;=\\sum_{i=l}^{r-1}a_i\\prod_{l\\le j &lt; r,j\\ne i}(x-x_j) \\\\ &amp;=\\left(\\prod_{i=m}^{r-1}(x-x_i)\\right)\\sum_{i=l}^{m-1}a_i\\prod_{l\\le j &lt; m,i\\ne j}(x-x_j)+\\left(\\prod_{i=l}^{m-1}(x-x_i)\\right)\\sum_{i=m}^{r-1}a_i\\prod_{m\\le j &lt; r,i\\ne j}(x-x_j) \\\\ &amp;=\\left(\\prod_{i=m}^{r-1}(x-x_i)\\right)F_{l,m}(x)+\\left(\\prod_{i=l}^{m-1}(x-x_i)\\right)F_{m,r}(x)\\end{aligned}\\] 时间复杂度 \\(O(n\\log^2 n)\\)。 123456789101112131415161718192021222324252627282930313233343536poly Divide_2(poly a, int t)&#123; int n = a.size(); poly b(n - 1); for (register int i = n - 1; i; --i)&#123; b[i - 1] = a[i]; dec(a[i - 1], mul(a[i], t)); &#125; return b;&#125;poly Inter_solve(const poly &amp;x, const poly &amp;y, int u, int l, int r)&#123; if (r - l &lt;= 64)&#123; poly f(r - l), g = _T[u].g; for (register int i = l; i &lt; r; ++i)&#123; poly tmp = Divide_2(g, minus(0, x[i])); for (register int j = 0; j &lt; r - l; ++j) f[j] = (f[j] + 1ull * tmp[j] * y[i]) % P; &#125; return f; &#125; int md = (l + r + 1) &gt;&gt; 1; poly A = _T[_T[u].rs].g, B = Inter_solve(x, y, _T[u].ls, l, md); poly C = _T[_T[u].ls].g, D = Inter_solve(x, y, _T[u].rs, md, r); register int m = get(r - l); init(m), DFT(A, m), DFT(B, m), DFT(C, m), DFT(D, m); for (register int i = 0; i &lt; m; ++i) A[i] = (1ull * A[i] * B[i] + 1ull * C[i] * D[i]) % P; IDFT(A, m), A.resize(r - l); return A;&#125;poly Interpolation(poly x, poly y)&#123; int n = x.size(), rt = -1; _T_cnt = 0, _T.resize((n &lt;&lt; 1) - 1), rt = eval_inter_init(x, 0, n); poly g = Derivative(_T[rt].g); poly res(n); Evaluate_solve(g, x, res, rt, 0, n); for (register int i = 0; i &lt; n; ++i) y[i] = mul(y[i], qpow(res[i], P - 2)); return Inter_solve(x, y, rt, 0, n);&#125; 多项式三角函数 不会 多项式反三角函数 不会 MTT 直接 FFT 的关键问题是精度不够。考虑将系数拆成 \\(a\\times 2^{15}+b\\) 的形式，则两个系数相乘会得到 \\[ \\begin{aligned} &amp; (a_1\\times 2^{15}+b_1)(a_2\\times 2^{15}+b_2) \\\\ =&amp; a_1a_2\\times 2^{30}+(a_1b_2+a_2b_1)\\times 2^{15}+b_1b_2 \\end{aligned} \\] 做 \\(4\\) 次 DFT 以及 \\(3\\) 次 IDFT 即可。 这是 \\(7\\) 次 DFT 的做法，\\(4\\) 次甚至 \\(3.5\\) 次 DFT 的做法暂时还不会。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111struct Complex &#123; double x, y; Complex operator + (const Complex &amp;rhs) const &#123; return &#123;x + rhs.x, y + rhs.y&#125;; &#125; Complex operator - (const Complex &amp;rhs) const &#123; return &#123;x - rhs.x, y - rhs.y&#125;; &#125; Complex operator * (const Complex &amp; rhs) const &#123; return &#123;x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x&#125;; &#125;&#125;;namespace MTTPoly &#123; const int MAX_LEN = 1 &lt;&lt; 18; const double pi = acos(-1); typedef std::vector&lt;int&gt; poly; Complex omega[MAX_LEN]; void Init() &#123; for (int m = 1; m &lt; MAX_LEN; m &lt;&lt;= 1) &#123; for (int i = 0; i &lt; m; ++i) &#123; omega[m + i] = &#123;cos(pi / m * i), sin(pi / m * i)&#125;; &#125; &#125; &#125; int get(int _n) &#123; int n = 1; while (n &lt; _n) &#123; n &lt;&lt;= 1; &#125; return n; &#125; std::vector&lt;int&gt; rev; void init(int n) &#123; int k = 0; while ((1 &lt;&lt; k) &lt; n) &#123; ++k; &#125; rev.resize(n), rev[0] = 0, --k; for (int i = 1; i &lt; n; ++i) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; k); &#125; &#125; void DFT(std::vector&lt;Complex&gt; &amp;f, int n) &#123; f.resize(n); static Complex F[MAX_LEN]; for (int i = 0; i &lt; n; ++i) &#123; F[rev[i]] = f[i]; &#125; for (int m = 1; m &lt; n; m &lt;&lt;= 1) &#123; for (int p = 0; p &lt; n; p += m &lt;&lt; 1) &#123; Complex *W = omega + m; Complex *F0 = F + p, *F1 = F0 + m; for (int i = 0; i &lt; m; ++i, ++W, ++F0, ++F1) &#123; Complex t = (*F1) * (*W); *F1 = *F0 - t, *F0 = *F0 + t; &#125; &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; f[i] = F[i]; &#125; &#125; void IDFT(std::vector&lt;Complex&gt; &amp;f, int n) &#123; DFT(f, n), std::reverse(f.begin() + 1, f.end()); for (int i = 0; i &lt; n; ++i) &#123; f[i] = f[i] * (Complex)&#123;1.0 / n, 0&#125;; &#125; &#125; poly Mul(const poly &amp;f, const poly &amp;g, int P) &#123; int fn = f.size(), gn = g.size(), _n = fn + gn - 1; std::vector&lt;Complex&gt; fa(fn), fb(fn), ga(gn), gb(gn); for (int i = 0; i &lt; fn; ++i) &#123; fa[i].x = f[i] &gt;&gt; 15, fa[i].y = 0; fb[i].x = f[i] &amp; 32767, fb[i].y = 0; &#125; for (int i = 0; i &lt; gn; ++i) &#123; ga[i].x = g[i] &gt;&gt; 15, ga[i].y = 0; gb[i].x = g[i] &amp; 32767, gb[i].y = 0; &#125; int n = get(_n); init(n), DFT(fa, n), DFT(fb, n), DFT(ga, n), DFT(gb, n); std::vector&lt;Complex&gt; a(n), b(n), c(n); for (int i = 0; i &lt; n; ++i) &#123; a[i] = fa[i] * ga[i]; b[i] = fa[i] * gb[i] + fb[i] * ga[i]; c[i] = fb[i] * gb[i]; &#125; IDFT(a, n), IDFT(b, n), IDFT(c, n); poly ans(_n); for (int i = 0; i &lt; _n; ++i) &#123; long long A = a[i].x + 0.5, B = b[i].x + 0.5, C = c[i].x + 0.5; A %= P, B %= P, C %= P; ans[i] = ((1 &lt;&lt; 30) * A + (1 &lt;&lt; 15) * B + C) % P; ans[i] = (P + ans[i]) % P; &#125; return ans; &#125;&#125; 完整代码 完整代码可以见 Codes/Polynomial.cpp at master · AutumnKite/Codes。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://autumnkite.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"FFT","slug":"FFT","permalink":"https://autumnkite.github.io/tags/FFT/"},{"name":"多项式","slug":"多项式","permalink":"https://autumnkite.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"}]},{"title":"「Codeforces 1244E」Minimizing Difference","slug":"cf1244e-sol","date":"2019-10-14T23:53:00.000Z","updated":"2020-03-26T07:22:57.197Z","comments":true,"path":"cf1244e-sol/","link":"","permalink":"https://autumnkite.github.io/cf1244e-sol/","excerpt":"题目传送门 题意 给定一个长度为 \\(n\\) 的序列 \\(a\\)，一次操作可以将序列中的某个数 \\(+1\\) 或 \\(-1\\)。 定义一个序列的差值为序列的最大值减去最小值得到的数。 求进行至多 \\(k\\) 次操作后序列差值的最小值。 \\(n\\le 10^5,a_i\\le 10^9,k\\le 10^{14}\\)","text":"题目传送门 题意 给定一个长度为 \\(n\\) 的序列 \\(a\\)，一次操作可以将序列中的某个数 \\(+1\\) 或 \\(-1\\)。 定义一个序列的差值为序列的最大值减去最小值得到的数。 求进行至多 \\(k\\) 次操作后序列差值的最小值。 \\(n\\le 10^5,a_i\\le 10^9,k\\le 10^{14}\\) 题解 显然可以二分答案 \\(x\\)，然后就是求使得差值 \\(\\le x\\) 需要进行至少多少次操作。 将 \\(a_i\\) 排序，假设最后的序列中的数在 \\([p,p+x]\\) 中，记序列中最后一个 \\(&lt; p\\) 的数为 \\(a_l\\)，第一个 \\(&gt;p+x\\) 的数为 \\(a_r\\)，那么需要进行的操作数量是 \\(p\\times l-\\sum_{i=1}^{l}a_i+\\sum_{i=r}^{n}a_i-(p+x)\\times (n-r+1)\\)。根据这个式子我们可以发现 \\(p\\) 和 \\(p+x\\) 这两个数中一定有一个数是存在于原序列中的，否则可以进行调整使得操作次数更少。于是我们枚举所有情况进行判断即可。 时间复杂度 \\(O(n\\log \\max a_i)\\)。 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;long long read()&#123; register long long x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 100005int n;long long k, a[N], sum[N];bool check(int x)&#123; for (register int i = 1, j = 1; i &lt;= n; ++i)&#123; while (j &lt;= n &amp;&amp; a[j] - a[i] &lt;= x) ++j; if (a[i] * (i - 1) - sum[i - 1] + sum[n] - sum[j - 1] - (a[i] + x) * (n - j + 1) &lt;= k) return 1; &#125; for (register int i = 1, j = 1; i &lt;= n; ++i)&#123; while (a[i] - a[j] &gt; x) ++j; if ((a[i] - x) * (j - 1) - sum[j - 1] + sum[n] - sum[i] - a[i] * (n - i) &lt;= k) return 1; &#125; return 0;&#125;int main()&#123; n = read(), k = read(); for (register int i = 1; i &lt;= n; ++i) a[i] = read(); std :: sort(a + 1, a + 1 + n); for (register int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + a[i]; int l = 0, r = a[n] - a[1], md, ans = 0; while (l &lt;= r) if (check(md = (l + r) &gt;&gt; 1)) r = md - 1, ans = md; else l = md + 1; printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分","slug":"二分","permalink":"https://autumnkite.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"「Codeforces 1244F」Chips","slug":"cf1244f-sol","date":"2019-10-14T23:33:00.000Z","updated":"2020-03-26T07:22:57.198Z","comments":true,"path":"cf1244f-sol/","link":"","permalink":"https://autumnkite.github.io/cf1244f-sol/","excerpt":"题目传送门 题意 有一个大小为 \\(n\\) 的环，环上每个点有一个颜色（黑/白）。定义一次操作是，对于每个点 \\(i\\)，若他和他相邻的两个点中，白点多于黑点，则在新的环中， \\(i\\) 变成白色，否则变为黑色。 求进行 \\(k\\) 次操作后每个点的颜色。 \\(n\\le 2\\times 10^5,k\\le 10^9\\)","text":"题目传送门 题意 有一个大小为 \\(n\\) 的环，环上每个点有一个颜色（黑/白）。定义一次操作是，对于每个点 \\(i\\)，若他和他相邻的两个点中，白点多于黑点，则在新的环中， \\(i\\) 变成白色，否则变为黑色。 求进行 \\(k\\) 次操作后每个点的颜色。 \\(n\\le 2\\times 10^5,k\\le 10^9\\) 题解 变色的条件相当于 \\(i\\) 相邻两个点的颜色都与 \\(i\\) 的颜色不同。对于一段长度 \\(\\ge 2\\) 的颜色相同的段，显然颜色是永远不会变的。只有这样的段之间的这些颜色交替改变的点的颜色会发生变化。例如 WWWBWBWBWBBB -&gt; WWWWBWBWBBBB -&gt; WWWWWBWBBBBB -&gt; WWWWWWBBBBBB。 考虑中间的颜色交替改变的一段（如上例中 BWBWBW），发现每进行一次操作，两边的点会向两边的颜色相同的连续段合并，中间的点会改变颜色。记这样的段中某个点 \\(i\\) 到两边颜色相同连续段的距离是 \\(a_i,b_i\\)，那么他会在第 \\(\\min(a_i,b_i)\\) 次操作被合并，颜色要看两边段的颜色和具体往哪边合并，被合并之后颜色就不会再变化，而在被合并之前颜色则是交替变化。所以只要根据 \\(k\\) 和 \\(\\min(a_i,b_i)\\) 的大小进行讨论即可。 要注意的是，可能题目给定字符串的最前面一段和最后面一段是可以拼起来的，所以要对顺序进行一定的调整。 代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define N 400005int n, k, d, dis1[N], dis2[N];char a[N], b[N];bool check()&#123; if (n &amp; 1) return 0; for (register int i = 2; i &lt;= n; ++i) if (a[i] == a[i - 1]) return 0; return 1;&#125;int main()&#123; scanf(&quot;%d%d%s&quot;, &amp;n, &amp;k, a + 1); if (check())&#123; if (k &amp; 1) std :: reverse(a + 1, a + 1 + n); return printf(&quot;%s&quot;, a + 1), 0; &#125; for (register int i = 1; i &lt;= n; ++i) a[n + i] = a[i]; for (register int i = n + 2; i &lt; (n &lt;&lt; 1); ++i) if (a[i - 1] != a[i] &amp;&amp; a[i] != a[i + 1]) continue; else&#123; d = i - 1; break; &#125; if (!d) d = (n &lt;&lt; 1) - 1; for (register int i = d - n + 1; i &lt;= d; ++i) if (a[i - 1] != a[i] &amp;&amp; a[i] != a[i + 1]) dis1[i] = dis1[i - 1] + 1; else dis1[i] = 0; for (register int i = d; i &gt; d - n; --i) if (a[i - 1] != a[i] &amp;&amp; a[i] != a[i + 1]) dis2[i] = dis2[i + 1] + 1; else dis2[i] = 0; for (register int i = d - n + 1; i &lt;= d; ++i) if (a[i - 1] != a[i] &amp;&amp; a[i] != a[i + 1]) if (k &gt;= std :: min(dis1[i], dis2[i])) if (dis1[i] &lt; dis2[i]) b[i] = a[i - dis1[i]]; else b[i] = a[i + dis2[i]]; else b[i] = a[i] == &#x27;B&#x27; &amp;&amp; (k &amp; 1) || (a[i] == &#x27;W&#x27; &amp;&amp; (k &amp; 1 ^ 1)) ? &#x27;W&#x27; : &#x27;B&#x27;; else b[i] = a[i]; for (register int i = 1; i &lt;= d - n; ++i) putchar(b[i + n]); for (register int i = d - n + 1; i &lt;= n; ++i) putchar(b[i]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://autumnkite.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"「Codeforces 1214H」Tiles Placement","slug":"cf1214h-sol","date":"2019-09-16T12:29:00.000Z","updated":"2020-03-26T07:22:57.195Z","comments":true,"path":"cf1214h-sol/","link":"","permalink":"https://autumnkite.github.io/cf1214h-sol/","excerpt":"题目传送门 题意 给定一棵 \\(n\\) 个点的树，你需要给每个点染一个 \\(1\\sim k\\) 的颜色，使得树上所有长度为 \\(k\\) 的路径都恰好包含 \\(k\\) 种颜色。 \\(n\\le 2\\times 10^5\\)","text":"题目传送门 题意 给定一棵 \\(n\\) 个点的树，你需要给每个点染一个 \\(1\\sim k\\) 的颜色，使得树上所有长度为 \\(k\\) 的路径都恰好包含 \\(k\\) 种颜色。 \\(n\\le 2\\times 10^5\\) 题解 根本不会构造.jpg 我来翻译官方题解了 显然如果一个点出去有三条路径（长度记为 \\(a,b,c\\)）满足 \\(a+b\\ge k-1,a+c\\ge k-1,b+c\\ge k-1\\)，则一定不满足条件。否则，存在以下一个构造方案。 拉出一条直径，从左到右染 \\(1,2,3,\\cdots,k,1,2,3,\\cdots\\) 。然后考虑直径外的部分，把直径分成两半，对于左边部分的某个染成 \\(i\\) 的点，我们把这个点多出去的部分按深度从小到大染成 \\(i,i-1,i-2,\\cdots,1,k,k-1,k-2\\cdots\\)；对于右边部分的某个染成 \\(i\\) 的点，我们把这个点多出去的部分按深度从小到大染成 \\(i,i+1,i+2,\\cdots,k,1,2,3\\cdots\\)。正确性可以参考官方题解。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;int read()&#123; register int x = 0; register char ch = getchar(), f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 200005int k, n;int mx[N], cmx[N];int rt, ed, dep[N], fa[N], cnt, p[N], on[N], col[N];int edge, to[N &lt;&lt; 1], pr[N &lt;&lt; 1], hd[N];void addedge(int u, int v)&#123; to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;&#125;std :: pair&lt;int, int&gt; dfs1(int u, int fa = 0)&#123; std :: pair&lt;int, int&gt; res(0, u), tmp; for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa) tmp = dfs1(v, u), ++tmp.first, res = std :: max(res, tmp); return res;&#125;void dfs2(int u)&#123; dep[u] = dep[fa[u]] + 1, mx[u] = cmx[u] = 0; for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa[u])&#123; fa[v] = u, dfs2(v); if (mx[v] + 1 &gt; mx[u]) cmx[u] = mx[u], mx[u] = mx[v] + 1; else if (mx[v] + 1 &gt; cmx[u]) cmx[u] = mx[v] + 1; &#125;&#125;void dfs3(int u, int c, int d)&#123; c = (c + d + k - 1) % k + 1, col[u] = c; for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa[u] &amp;&amp; !on[v]) dfs3(v, c, d);&#125;int main()&#123; n = read(), k = read(); for (register int i = 1, u, v; i &lt; n; ++i) u = read(), v = read(), addedge(u, v), addedge(v, u); dfs2(rt = dfs1(1).second); for (register int i = 1; i &lt;= n; ++i) if (cmx[i]) if (mx[i] + 1 &gt; dep[i]) if (dep[i] + cmx[i] &gt;= k &amp;&amp; k &gt; 2) return printf(&quot;No\\n&quot;), 0; else continue; else if (mx[i] + cmx[i] + 1 &gt;= k &amp;&amp; k &gt; 2) return printf(&quot;No\\n&quot;), 0; else continue; for (register int i = 1; i &lt;= n; ++i) if (!ed || dep[i] &gt; dep[ed]) ed = i; cnt = dep[ed]; for (register int i = ed; i; i = fa[i]) p[dep[i]] = i, on[i] = 1, col[i] = (dep[i] - 1) % k + 1; for (register int i = 1; i &lt;= cnt; ++i) for (register int j = hd[p[i]]; j; j = pr[j]) if (!on[to[j]]) dfs3(to[j], col[p[i]], i &lt;= cnt / 2 ? -1 : 1); printf(&quot;Yes\\n&quot;); for (register int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, col[i]); putchar(&#x27;\\n&#x27;);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"树的直径","slug":"树的直径","permalink":"https://autumnkite.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"}]},{"title":"「Codeforces 1214G」Feeling Good","slug":"cf1214g-sol","date":"2019-09-16T12:04:00.000Z","updated":"2020-03-26T07:22:57.193Z","comments":true,"path":"cf1214g-sol/","link":"","permalink":"https://autumnkite.github.io/cf1214g-sol/","excerpt":"题目传送门 题意 有一个 \\(n\\times m\\) 的黑白矩阵，初始时是全白的。有 \\(q\\) 次操作，每次操作形如 \\(a_i,l_i,r_i\\)，表示把 \\(a_i\\) 行的 \\(l_i\\) 列到 \\(r_i\\) 列的格子反转颜色。 每次操作后，你要找出 \\(x_1,y_1,x_2,y_2\\)，满足 \\(x_1 &lt; x_2,y_1 &lt; y_2, col(x_1,y_1)=col(x_2,y_2),col(x_1,y_2)=col(x_2,y_1),col(x_1,y_1)\\ne col(x_1,y_2)\\)。若不存在则输出 \\(-1\\)。 \\(n,m\\le 2000,q\\le 5\\times 10^5\\)","text":"题目传送门 题意 有一个 \\(n\\times m\\) 的黑白矩阵，初始时是全白的。有 \\(q\\) 次操作，每次操作形如 \\(a_i,l_i,r_i\\)，表示把 \\(a_i\\) 行的 \\(l_i\\) 列到 \\(r_i\\) 列的格子反转颜色。 每次操作后，你要找出 \\(x_1,y_1,x_2,y_2\\)，满足 \\(x_1 &lt; x_2,y_1 &lt; y_2, col(x_1,y_1)=col(x_2,y_2),col(x_1,y_2)=col(x_2,y_1),col(x_1,y_1)\\ne col(x_1,y_2)\\)。若不存在则输出 \\(-1\\)。 \\(n,m\\le 2000,q\\le 5\\times 10^5\\) 题解 考虑如何判断是否有解。 记 \\(S_i=\\{j\\mid col(i,j)=\\text{black}\\}\\)。对于固定的两行 \\(x_1,x_2\\)，有解的条件是 \\(S_{x_1}\\) 不是 \\(S_{x_2}\\) 的子集且 \\(S_{x_2}\\) 不是 \\(S_{x_1}\\) 的子集。 我们把这些集合按大小从小到大排序，若 \\(S_1\\subseteq S_2\\subseteq S_3\\subseteq\\cdots\\subseteq S_n\\)，则一定无解，否则一定存在一个 \\(i\\) 使得 \\(S_{i}\\) 不是 \\(S_{i+1}\\) 的子集，又因为是按集合大小从小到大排序的，\\(S_{i+1}\\) 也一定不是 \\(S_i\\) 的子集，那么这两行就是满足条件的。 然后考虑求出一组解，我们只要把所有满足条件的 \\(i\\) 都记下来。对于两个集合 \\(S_{i},S_{i+1}\\)，其中一个 \\(y\\) 一定是在 \\(S_{i}\\) 中是黑色的但在 \\(S_{i+1}\\) 中是白色的，另一个 \\(y\\) 反之。 用 bitset 维护这些集合，然后用位运算和 _Find_First 函数即可求出 \\(y_1,y_2\\)。 时间复杂度 \\(O(q(\\frac{m}{w}+\\log n))\\)。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;#include &lt;set&gt;int read()&#123; register int x = 0; register char ch = getchar(), f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 2005int n, m, q, x1, _y1, x2, _y2;std :: bitset&lt;N&gt; a[N], nw[N], tmp;std :: set&lt; std :: pair&lt;int, int&gt; &gt; S, ans;bool check(int i, int j)&#123; return (a[i] &amp; a[j]) != a[i];&#125;void add(std :: pair&lt;int, int&gt; p)&#123; if (check(p.first, p.second)) ans.insert(p);&#125;void del(std :: pair&lt;int, int&gt; p)&#123; if (check(p.first, p.second)) ans.erase(p);&#125;void Erase(std :: pair&lt;int, int&gt; x)&#123; int nx, i, pr; auto it = S.lower_bound(x), tmp = it; i = x.second, nx = (++tmp) -&gt; second, pr = (--it) -&gt; second; del(std :: make_pair(pr, i)), del(std :: make_pair(i, nx)), add(std :: make_pair(pr, nx)); S.erase(x);&#125;void Insert(std :: pair&lt;int, int&gt; x)&#123; int nx, i, pr; auto it = S.lower_bound(x); i= x.second, nx = it -&gt; second, pr = (--it) -&gt; second; add(std :: make_pair(pr, i)), add(std :: make_pair(i, nx)), del(std :: make_pair(pr, nx)); S.insert(x);&#125;int main()&#123; n = read(), m = read(), q = read(); nw[1] = 1; for (register int i = 2; i &lt;= m; ++i) nw[i] = nw[i - 1] &lt;&lt; 1 | nw[1]; a[n + 1] = nw[m], S.insert(std :: make_pair(0, 0)); for (register int i = 1; i &lt;= n; ++i) S.insert(std :: make_pair(0, i)); S.insert(std :: make_pair(m, n + 1)); for (register int i = 1; i &lt;= q; ++i)&#123; int k = read(), l = read(), r = read(); Erase(std :: make_pair(a[k].count(), k)); a[k] ^= nw[r - l + 1] &lt;&lt; (l - 1); Insert(std :: make_pair(a[k].count(), k)); if (ans.empty()) printf(&quot;-1\\n&quot;); else&#123; x1 = ans.begin() -&gt; first, x2 = ans.begin() -&gt; second; _y1 = ((a[x1] ^ a[x2]) &amp; a[x1])._Find_first(), _y2 = ((a[x1] ^ a[x2]) &amp; a[x2])._Find_first(); if (x1 &gt; x2) std :: swap(x1, x2); if (_y1 &gt; _y2) std :: swap(_y1, _y2); printf(&quot;%d %d %d %d\\n&quot;, x1, _y1 + 1, x2, _y2 + 1); &#125; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"bitset","slug":"bitset","permalink":"https://autumnkite.github.io/tags/bitset/"}]},{"title":"「Codeforces 1214F」Employment","slug":"cf1214f-sol","date":"2019-09-16T11:32:00.000Z","updated":"2020-03-26T07:22:57.190Z","comments":true,"path":"cf1214f-sol/","link":"","permalink":"https://autumnkite.github.io/cf1214f-sol/","excerpt":"题目传送门 题意 有一个大小为 \\(m\\) 的环，还上有 \\(n\\) 个点有工作单位，并且有 \\(n\\) 个点上住着一个人。你需要为每个人分配一个工作单位，使得所有人到工作单位的距离之和最短。输出一个方案。 \\(m\\le 10^9,n\\le 2\\times 10^5\\)","text":"题目传送门 题意 有一个大小为 \\(m\\) 的环，还上有 \\(n\\) 个点有工作单位，并且有 \\(n\\) 个点上住着一个人。你需要为每个人分配一个工作单位，使得所有人到工作单位的距离之和最短。输出一个方案。 \\(m\\le 10^9,n\\le 2\\times 10^5\\) 题解 下面的数组都从 \\(0\\) 开始标号。先将 \\(a,b\\) 数组分别从小到大排序，然后把 \\(b\\) 数组变成 \\(b_0,b_1,b_2,\\cdots,b_{n-1},b_0+m,b_1+m,\\cdots,b_{n-1}+m,b_0+2m,b_1+2m,\\cdots,b_{n-1}+2m\\)，把 \\(a\\) 数组变成 \\(a_0+m,a_1+m,a_2+m,\\cdots,a_{n-1}+m\\)。 考虑贪心，显然两个人的路径不能“交叉”，所以一定是小的和小的匹配，大的和大的匹配。问题变成了求 \\(\\min\\limits_{0\\le x\\le 2n} \\sum\\limits_{i=0}^{n-1} |a_i-b_{i+x}|\\) 的值。 记 \\(ans_x=\\sum\\limits_{i=0}^{n-1} |a_i-b_{i+x}|\\)，把绝对值拆开，则变成了 \\[\\begin{aligned}ans_x&amp;=\\sum\\limits_{i=0}^{n-1} |a_i-b_{i+x}| \\\\ &amp;=\\sum\\limits_{i=0}^{n-1} ([a_i &gt; b_{i+x}]a_i-[a_i &lt; b_{i+x}]a_i-[a_i &gt; b_{i+x}]b_{i+x}+[a_i &lt; b_{i+x}]b_{i+x})\\end{aligned}\\] 记 \\(sa_{x}=\\sum\\limits_{i=0}^{n-1} ([a_i &gt; b_{i+x}]a_i-[a_i &lt; b_{i+x}]a_i),sb_{x}=\\sum\\limits_{i=0}^{n-1} ([a_i &lt; b_{i+x}]b_{i+x}-[a_i &gt; b_{i+x}]b_{i+x})\\)。考虑单独计算。 我们将 \\(sa\\) 差分，发现 \\(sa_x-sa_{x-1}=\\sum\\limits_{i=0}^{n-1} ([a_i &gt; b_{i+x}]a_i-[a_i &lt; b_{i+x}]a_i-[a_i &gt; b_{i+x-1}]a_i+[a_i &lt; b_{i+x-1}]a_i)\\)，发现若 \\(a_i \\le b_{i+x-1} \\le b_{i+x}\\) 或 \\(b_{i+x-1} \\le b_{i+x} \\le a_i\\) 时，这个式子恰好为 \\(0\\)，只有当 \\(b_{i+x-1} &lt; a_i &lt; b_{i+x}\\) 时，这个式子的值为 \\(-2a_i\\)，而这个 \\(x\\) 又是唯一的。于是对于每个 \\(a_i\\) 求出这个唯一的 \\(x\\)，在差分数组上直接修改即可。 我们依次考虑每个 \\(b_i\\)，发现当 \\(x\\) 小于某个值时，\\(b_i\\) 对 \\(sb_x\\) 的贡献是负的，否则是正的。于是我们求出这个值，然后区间加贡献即可。这个也可以用差分简单的实现。 发现求 \\(sa_x,sb_x\\) 在实现的过程中都需要差分，不需要分开计算。 时间复杂度 \\(O(n\\log n)\\)。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;int read()&#123; register int x = 0; register char ch = getchar(), f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 200005int n, ansi, ansid[N];long long m, ans[N &lt;&lt; 1], Ans;struct node&#123; long long v; int id; bool operator &lt; (const node &amp;rhs) const &#123; return v &lt; rhs.v; &#125;&#125;a[N], b[N * 3];long long abs(long long a)&#123; return a &gt; 0 ? a : -a;&#125;void add(int l, int r, long long v)&#123; ans[l] += v, ans[r] -= v;&#125;int main()&#123; m = read(), n = read(); for (register int i = 0; i &lt; n; ++i) a[i].v = read(), a[i].id = i; for (register int i = 0; i &lt; n; ++i) b[i].v = read(), b[i].id = i; std :: sort(a, a + n), std :: sort(b, b + n); for (register int i = 0; i &lt; n; ++i) a[i].v += m; for (register int i = 0; i &lt; (n &lt;&lt; 1); ++i) b[i + n] = b[i], b[i + n].v += m; for (register int i = 0; i &lt; n; ++i) ans[0] += a[i].v; for (register int i = 0; i &lt; n; ++i)&#123; int j = std :: lower_bound(b, b + 3 * n, a[i]) - b; if (j &gt; i &amp;&amp; j &lt;= i + (n &lt;&lt; 1)) ans[j - i] -= 2 * a[i].v; &#125; for (register int j = 0; j &lt; 3 * n; ++j)&#123; if (j &lt; n)&#123; add(0, j + 1, -b[j].v); continue; &#125; if (j &gt;= (n &lt;&lt; 1))&#123; add(j - n + 1, (n &lt;&lt; 1) + 1, b[j].v); continue; &#125; int i = std :: upper_bound(a, a + n, b[j]) - a; add(j - i + 1, j + 1, b[j].v), add(j - n + 1, j - i + 1, -b[j].v); &#125; Ans = ans[0], ansi = 0; for (register int i = 1; i &lt;= (n &lt;&lt; 1); ++i)&#123; ans[i] += ans[i - 1]; if (ans[i] &lt; Ans) Ans = ans[i], ansi = i; &#125; for (register int i = 0; i &lt; n; ++i) ansid[a[i].id] = b[(i + ansi) % n].id; printf(&quot;%lld\\n&quot;, Ans); for (register int i = 0; i &lt; n; ++i) printf(&quot;%d &quot;, ansid[i] + 1);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"差分","slug":"差分","permalink":"https://autumnkite.github.io/tags/%E5%B7%AE%E5%88%86/"}]},{"title":"「Codeforces 1214E」Petya and Construction Set","slug":"cf1214e-sol","date":"2019-09-16T11:21:00.000Z","updated":"2020-03-26T07:22:57.189Z","comments":true,"path":"cf1214e-sol/","link":"","permalink":"https://autumnkite.github.io/cf1214e-sol/","excerpt":"题目传送门 题意 构造一个 \\(2n-1\\) 个节点的树，满足 \\(\\forall i\\in [1,n] : dis(2i-1,2i)=d_i\\)，\\(dis(x,y)\\) 表示树上 \\(x\\) 到 \\(y\\) 的距离，\\(d_i\\) 是给定的。 \\(n\\le 10^5\\)","text":"题目传送门 题意 构造一个 \\(2n-1\\) 个节点的树，满足 \\(\\forall i\\in [1,n] : dis(2i-1,2i)=d_i\\)，\\(dis(x,y)\\) 表示树上 \\(x\\) 到 \\(y\\) 的距离，\\(d_i\\) 是给定的。 \\(n\\le 10^5\\) 题解 将 \\(d_i\\) 从大到小排序，然后依次把所有奇数连成一条链（按对应的 \\(d_i\\) 从大到小的顺序）。 然后依次考虑链上每个点对应的偶数点的位置。假设这个点是链上第 \\(k\\) 个点，对应的 \\(d_i\\) 记为 \\(D\\)，那么显然只要把这个偶数点挂在链上第 \\(k+D-1\\) 个点下面即可。要注意的是，如果第 \\(k+D-1\\) 个点是链上最后一个点，那么再挂一个点要把链进行“扩充”。可以证明，在处理第 \\(k\\) 个点时，链上一定存在 \\(k+D-1\\) 个点（根据 \\(d_i\\) 从大到小进行证明）。 代码 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char ch = getchar(), f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;int n, cnt, id[100005];std :: pair&lt;int, int&gt; d[100005];int main()&#123; n = read(); for (register int i = 1; i &lt;= n; ++i) d[i].first = -read(), d[i].second = i; std :: sort(d + 1, d + 1 + n); for (register int i = 1; i &lt;= n; ++i)&#123; if (i &lt; n) printf(&quot;%d %d\\n&quot;, 2 * d[i].second - 1, 2 * d[i + 1].second - 1); int x = i - d[i].first - 1; if (x &lt;= n) printf(&quot;%d %d\\n&quot;, 2 * d[x].second - 1, 2 * d[i].second); else printf(&quot;%d %d\\n&quot;, id[x - n], 2 * d[i].second); if (x - n == cnt) id[++cnt] = 2 * d[i].second; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"}]},{"title":"「Codeforces 1214D」Treasure Island","slug":"cf1214d-sol","date":"2019-09-16T11:13:00.000Z","updated":"2020-03-26T07:22:57.188Z","comments":true,"path":"cf1214d-sol/","link":"","permalink":"https://autumnkite.github.io/cf1214d-sol/","excerpt":"题目传送门 题意 给定一个 \\(n\\times m\\) 的地图，每个格子要么是障碍，要么是空格。你可以把除 \\((1,1)\\) 和 \\((n,m)\\) 外的若干个格子变成障碍，求使得 \\((1,1)\\) 到 \\((n,m)\\) 没有路径最少需要把几个格子变成障碍。 \\(3\\le n\\cdot m\\le 10^6\\)","text":"题目传送门 题意 给定一个 \\(n\\times m\\) 的地图，每个格子要么是障碍，要么是空格。你可以把除 \\((1,1)\\) 和 \\((n,m)\\) 外的若干个格子变成障碍，求使得 \\((1,1)\\) 到 \\((n,m)\\) 没有路径最少需要把几个格子变成障碍。 \\(3\\le n\\cdot m\\le 10^6\\) 题解 答案只可能是 \\(0,1,2\\) 中的一种。 \\(0\\) 可以直接判；\\(1\\) 就是 \\((1,1)\\) 能走到 \\((n,m)\\) 但必须都经过某个格子 \\((x,y)\\)；否则就是 \\(2\\)。 那么只要找出一条路径，若找不到就是 \\(0\\)；然后再找一条强制不经过第一条路径中的点的路径，若找不到就是 \\(1\\)；否则就是 \\(2\\)。 吐槽一句：我一开始写了个求起点、终点到某个点的路径数量，然后用乘法原理判断，只可惜这东西要取模，于是愉快地 WA on 233 了（Submission #60334654） 代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;int n, m, a[1000005];char t[1000005];int get(int *a, int i, int j)&#123; if (i &lt; 1 || j &lt; 1 || i &gt; n || j &gt; m) return 0; return a[(i - 1) * m + j];&#125;void set(int *a, int i, int j, int v)&#123; a[(i - 1) * m + j] = v;&#125;void GG(int x)&#123; printf(&quot;%d\\n&quot;, x), exit(0);&#125;void dfs2(int i, int j)&#123; if (i &gt; n || j &gt; m) return; if ((i != 1 || (j != 1)) &amp;&amp; get(a, i, j)) return; if (i == n &amp;&amp; j == m) GG(2); set(a, i, j, 1); dfs2(i + 1, j), dfs2(i, j + 1);&#125;void dfs1(int i, int j)&#123; if (i &gt; n || j &gt; m) return; if ((i != 1 || (j != 1)) &amp;&amp; get(a, i, j)) return; if (i == n &amp;&amp; j == m) dfs2(1, 1), GG(1); set(a, i, j, 1); dfs1(i + 1, j), dfs1(i, j + 1);&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (register int i = 1; i &lt;= n; ++i)&#123; scanf(&quot;%s&quot;, t + 1); for (register int j = 1; j &lt;= m; ++j) if (t[j] == &#x27;#&#x27;) set(a, i, j, 1); &#125; dfs1(1, 1), GG(0);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://autumnkite.github.io/tags/DFS/"}]},{"title":"「AtCoder」「JSC 2019 Qual F」Candy Retribution","slug":"atcoder-jsc19qualF-sol","date":"2019-08-27T08:17:00.000Z","updated":"2021-05-29T10:26:33.977Z","comments":true,"path":"atcoder-jsc19qualF-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-jsc19qualF-sol/","excerpt":"题目传送门 题意 求满足以下条件的长度为 \\(n\\) 的非负整数序列 \\(a_1,a_2,a_3,\\cdots,a_n\\) 的方案数 \\(\\bmod 10^9+7\\) 的值： \\(l\\le \\sum_{i=1}^n a_i\\le r\\)； 将序列从大到小排序后，记为 \\(a_1&#39;,a_2&#39;,a_3&#39;,\\cdots,a_n&#39;\\)，满足 \\(a_m&#39;=a_{m+1}&#39;\\)。 \\(1\\le m &lt; n\\le 3\\times 10^5,1\\le l,r\\le 3\\times 10^5\\)","text":"题目传送门 题意 求满足以下条件的长度为 \\(n\\) 的非负整数序列 \\(a_1,a_2,a_3,\\cdots,a_n\\) 的方案数 \\(\\bmod 10^9+7\\) 的值： \\(l\\le \\sum_{i=1}^n a_i\\le r\\)； 将序列从大到小排序后，记为 \\(a_1&#39;,a_2&#39;,a_3&#39;,\\cdots,a_n&#39;\\)，满足 \\(a_m&#39;=a_{m+1}&#39;\\)。 \\(1\\le m &lt; n\\le 3\\times 10^5,1\\le l,r\\le 3\\times 10^5\\) 题解 显然第一个条件可以差分，假设总和的上界为 \\(S\\)，用隔板法得到不考虑第二个条件的方案数为 \\(C_{S+n}^n\\)。直接算满足第二个条件的不好算，我们考虑算不满足第二个条件的方案数，然后用总方案数减去即可。 我们枚举从大到小排序后的第 \\(m\\) 个数为 \\(x\\)，那么不满足条件的方案数等于在 \\(n\\) 个位置中选出 \\(m\\) 个位置使得这 \\(m\\) 个位置的值 \\(\\ge x\\)，其余 \\(n-m\\) 个位置的值 \\(&lt; x\\)，\\(n\\) 个数总和 \\(\\le S\\) 的方案数，减去在 \\(n\\) 个位置中选出 \\(m\\) 个位置使得这 \\(m\\) 个位置的值 \\(\\ge x+1\\)，其余 \\(n-m\\) 个位置的值 \\(&lt; x\\)，\\(n\\) 个数总和 \\(\\le S\\) 的方案数。 于是问题变成了求在 \\(n\\) 个位置中选出 \\(m\\) 个位置使得这 \\(m\\) 个位置的值 \\(\\ge a\\)，其余 \\(n-m\\) 个位置的值 \\(&lt; b\\)，\\(n\\) 个数总和 \\(\\le S\\) 的方案数。 发现隔板法可以解决的问题的条件是形如 \\(a_i\\ge lim_i\\) 这样的，于是我们把 \\(&lt; b\\) 的部分容斥成这个形式。于是我们强制 \\(i\\) 个位置 \\(\\ge b\\)，其他位置随便选。 问题变成了求在 \\(n\\) 个位置中选出 \\(m\\) 个位置使得这 \\(m\\) 个位置的值 \\(\\ge a\\)，在剩余 \\(n-m\\) 个位置中选 \\(i\\) 个，使得这 \\(i\\) 个位置的值 \\(\\ge b\\)，其他 \\(n-m-i\\) 个位置的值 \\(\\ge 0\\)，总和 \\(\\le S\\) 的方案数。这个问题的答案就是 \\(C_{n-m}^i\\times C_{S-ma-ib+n}^n\\)。再乘上容斥系数 \\((-1)^i\\) 即可。 由于需要保证 \\(ix\\le S\\)，复杂度是一个调和级数的形式，所以复杂度是 \\(O(S\\log S)\\)。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 600005#define P 1000000007int n, m, l, r, fac[N], inv[N];void inc(int &amp;a, int b)&#123; (a += b) &gt;= P ? a -= P : 0; &#125;void dec(int &amp;a, int b)&#123; (a -= b) &lt; 0 ? a += P : 0; &#125;int plus(int a, int b)&#123; return (a += b) &gt;= P ? a - P : a; &#125;int minus(int a, int b)&#123; return (a -= b) &lt; 0 ? a + P : a; &#125;int qpow(int a, int b = P - 2)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if (b &amp; 1) s = 1ll * s * a % P; return s;&#125;void init(int n)&#123; fac[0] = 1; for (register int i = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % P; inv[n] = qpow(fac[n]); for (register int i = n; i; --i) inv[i - 1] = 1ll * inv[i] * i % P;&#125;int C(int n, int m)&#123; if (n &lt; m) return 0; return 1ll * fac[n] * inv[m] % P * inv[n - m] % P;&#125;int get(int S, int r)&#123; if (S &lt; 0) return 0; int res = 0; for (register int i = 0, t = 0; i &lt;= n - m &amp;&amp; t &lt;= S; t += r, ++i)&#123; int s = 1ll * C(n - m, i) * C(S - t + n, n) % P; if (i &amp; 1) dec(res, s); else inc(res, s); &#125; return 1ll * res * C(n, m) % P;&#125;int solve(int S)&#123; int res = C(S + n, n); for (register int i = 1; i * m &lt;= S; ++i) dec(res, minus(get(S - i * m, i), get(S - (i + 1) * m, i))); return res;&#125;int main()&#123; n = read(), m = read(), l = read(), r = read(); init(n + r); printf(&quot;%d\\n&quot;, minus(solve(r), solve(l - 1)));&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"JSC 2019 Qual","slug":"题解/AtCoder/JSC-2019-Qual","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/JSC-2019-Qual/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"「AtCoder」「JSC 2019 Qual E」Card Collector","slug":"atcoder-jsc19qualE-sol","date":"2019-08-27T07:54:00.000Z","updated":"2020-03-26T07:22:57.171Z","comments":true,"path":"atcoder-jsc19qualE-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-jsc19qualE-sol/","excerpt":"题目传送门 题意 一个 \\(H\\times W\\) 的矩阵，有 \\(n\\) 个位置有卡片，每张卡片上有个数字 \\(a_i\\)。你可以在每行拿走一张卡片，然后在每列拿走一张卡片，求拿走的卡片的 \\(a_i\\) 之和的最大值。 \\(1\\le H,W,n,a_i\\le 10^5\\)","text":"题目传送门 题意 一个 \\(H\\times W\\) 的矩阵，有 \\(n\\) 个位置有卡片，每张卡片上有个数字 \\(a_i\\)。你可以在每行拿走一张卡片，然后在每列拿走一张卡片，求拿走的卡片的 \\(a_i\\) 之和的最大值。 \\(1\\le H,W,n,a_i\\le 10^5\\) 题解 假设有 \\(H+W\\) 个点，第 \\(1\\sim H\\) 个点表示行，第 \\(H+1\\sim H+W\\) 个点表示列。第 \\(i\\) 行第 \\(j\\) 列的卡片对应一条 \\(i\\) 到 \\(H+j\\) 的边，边权为卡片上的数字。我们把所有拿走的卡片对应的边拿出来，显然会形成一个环套树森林。简单证明一下： 假设边是有向的，在第 \\(i\\) 行选了第 \\(j\\) 列的卡片，则选择 \\(i\\) 到 \\(H+j\\) 的有向边；在第 \\(i\\) 列选了第 \\(j\\) 行的卡片，则选择 \\(H+i\\) 到 \\(j\\) 的有向边。那么每个点有且仅有一条出边，所以这是一个环套内向树森林。忽略边的方向，则是环套树森林。 相当于我们要求出一个原图的边权之和最大的“生成环套树森林”。用类似于求最大生成树的 Kruskal 算法贪心选边即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;int n, h, w, fa[200005], g[200005];long long ans;struct node&#123; int r, c, v; bool operator &lt; (const node &amp;rhs) const &#123; return v &gt; rhs.v; &#125;&#125;a[100005];int find(int x)&#123; return fa[x] == x ? x : (fa[x] = find(fa[x]));&#125;bool merge(int x, int y)&#123; x = find(x), y = find(y); if (x == y) if (g[x]) return 0; else return g[x] = 1, 1; if (g[x] &amp;&amp; g[y]) return 0; return fa[y] = x, g[x] |= g[y], 1;&#125;int main()&#123; n = read(), h = read(), w = read(); for (register int i = 1; i &lt;= n; ++i) a[i].r = read(), a[i].c = read(), a[i].v = read(); std :: sort(a + 1, a + 1 + n); for (register int i = 1; i &lt;= h + w; ++i) fa[i] = i, g[i] = 0; for (register int i = 1; i &lt;= n; ++i) if (merge(a[i].r, a[i].c + h)) ans += a[i].v; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"JSC 2019 Qual","slug":"题解/AtCoder/JSC-2019-Qual","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/JSC-2019-Qual/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"并查集","slug":"并查集","permalink":"https://autumnkite.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"「AtCoder」「JSC 2019 Qual D」Classified","slug":"atcoder-jsc19qualD-sol","date":"2019-08-27T07:08:00.000Z","updated":"2020-03-26T07:22:57.170Z","comments":true,"path":"atcoder-jsc19qualD-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-jsc19qualD-sol/","excerpt":"题目传送门 题意 有一张 \\(n\\) 个点的无向完全图 \\(G=(V,E)\\)，你需要给每条边定一个正整数权值，使得不存在一条回路满足这条回路上的所有边权相等且回路长度为奇数。 你需要最小化最大的权值。请你输出一个解。 \\(n\\le 500\\)","text":"题目传送门 题意 有一张 \\(n\\) 个点的无向完全图 \\(G=(V,E)\\)，你需要给每条边定一个正整数权值，使得不存在一条回路满足这条回路上的所有边权相等且回路长度为奇数。 你需要最小化最大的权值。请你输出一个解。 \\(n\\le 500\\) 题解 题目里的条件相当于对于每一个权值 \\(x\\)，记 \\(E&#39;\\) 为所有边权等于 \\(x\\) 的边组成的边集，满足 \\(G&#39;=(V,E&#39;)\\) 是二分图。我们把 \\(G&#39;\\) 叫做权值为 \\(x\\) 的子图。 先猜一个结论，假设边权的最大值为 \\(k\\)，则最大的有解的 \\(n\\) 为 \\(2^k\\)。用数学归纳法可以证明： 显然 \\(k=1,n=2\\) 是有解的，\\(k=1,n=3\\) 是无解的。 假设我们已经证明了 \\(k=t-1,n=2^{t-1}\\) 是有解的，\\(k=t-1,n=2^{t-1}+1\\) 是无解的，我们要证明 \\(k=t,n=2^t\\) 是有解的，\\(k=t,n=2^t+1\\) 是无解的。 \\(k=t,n=2^t\\) 是有解的很好证明，我们只要把这 \\(n\\) 个点分成两个大小为 \\(2^{t-1}\\) 的集合，两个集合之间的边边权为 \\(t\\)，然后只要使得两个集合内部的边边权最大值为 \\(t-1\\)，则权值为 \\(t\\) 的子图已经符合条件。而对于两个集合，变成了两个相同的子问题，即 \\(k=t-1,n=2^{t-1}\\)，我们已经证明了这是有解的，所以 \\(k=t,n=2^t\\) 也是有解的。 \\(k=t,n=2^t+1\\) 是无解的也很好证明。假设它是有解的，那么答案中权值为 \\(t\\) 的子图一定是二分图且这个二分图的两个集合分别有解。由于总点数是 \\(2^t+1\\)，那么这个二分图的两个集合中一定有一个集合大小 \\(\\ge 2^{t-1}+1\\)。已经证明 \\(k=t-1,n=2^{t-1}+1\\) 是无解的，与“这个二分图的两个集合分别有解”矛盾，所以 \\(k=t,n=2^t+1\\) 是无解的。 所以答案为 \\(\\lceil \\log_2 n\\rceil\\)。考虑构造一个解。我们只要按照一个点的编号二进制下从右往左的第 \\(\\lceil \\log_2 n\\rceil\\) 位是 \\(0\\) 还是 \\(1\\) 分成两个集合，这两个集合之间的边边权设为 \\(\\lceil \\log_2 n\\rceil\\)，然后递归处理。 我们发现，两个点 \\(i,j\\) 的边的边权其实就是 \\(i\\) 与 \\(j\\) 最高的不同的位从右往左的编号，也就是 \\(\\lfloor \\log_2 (i \\text{ xor }j)\\rfloor+1\\)。 时间复杂度 \\(O(n^2)\\)。 代码 12345678910#include &lt;cstdio&gt;int n, Log[1005];int main()&#123; scanf(&quot;%d&quot;, &amp;n); Log[1] = 0; for (register int i = 2; i &lt;= n * 2; ++i) Log[i] = Log[i &gt;&gt; 1] + 1; for (register int i = 0; i &lt; n; ++i) for (register int j = i + 1; j &lt; n; ++j) printf(&quot;%d&quot;, Log[i ^ j] + 1), putchar(&quot; \\n&quot;[j == n - 1]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"JSC 2019 Qual","slug":"题解/AtCoder/JSC-2019-Qual","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/JSC-2019-Qual/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"}]},{"title":"「AtCoder」「JSC 2019 Qual C」Cell Inversion","slug":"atcoder-jsc19qualC-sol","date":"2019-08-27T06:34:00.000Z","updated":"2020-03-26T07:22:57.168Z","comments":true,"path":"atcoder-jsc19qualC-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-jsc19qualC-sol/","excerpt":"题目传送门 题意 有 \\(2n\\) 个格子，每个格子初始为黑色或白色。你需要执行恰好 \\(n\\) 次操作，使得最后所有格子变成白色。每次操作你可以选择两个从未选择过的格子 \\(l,r (l &lt; r)\\)，然后将区间 \\([l,r]\\) 的所有格子的颜色取反，即黑色的格子变成白色，白色的格子变成黑色。求方案数 \\(\\bmod 10^9+7\\) 的值。 两个方案不同当且仅当存在一个 \\(i\\in [1,n]\\)，满足第 \\(i\\) 次操作选择的两个格子至少有一个不同。 \\(n\\le 10^5\\)","text":"题目传送门 题意 有 \\(2n\\) 个格子，每个格子初始为黑色或白色。你需要执行恰好 \\(n\\) 次操作，使得最后所有格子变成白色。每次操作你可以选择两个从未选择过的格子 \\(l,r (l &lt; r)\\)，然后将区间 \\([l,r]\\) 的所有格子的颜色取反，即黑色的格子变成白色，白色的格子变成黑色。求方案数 \\(\\bmod 10^9+7\\) 的值。 两个方案不同当且仅当存在一个 \\(i\\in [1,n]\\)，满足第 \\(i\\) 次操作选择的两个格子至少有一个不同。 \\(n\\le 10^5\\) 题解 我们发现，操作的顺序与最后结果无关，于是我们强制 \\(l\\) 从小到大，最后乘上 \\(m!\\) 即可。 从左往右对于每个格子 \\(i\\)，设 \\(m\\) 次操作中有 \\(x\\) 个操作 \\(l &lt; r &lt; i\\)，有 \\(y\\) 个操作 \\(l &lt; i\\le r\\)，那么有 \\(y=i-1-2x\\)，所以 \\(y\\) 与 \\(i-1\\) 的奇偶性相同，于是可以直接判断 \\(y\\) 的奇偶性。若 \\(y\\) 是偶数，那么执行完所有 \\(l &lt; i\\) 的操作后，\\(i\\) 的颜色不会变化，此时若 \\(i\\) 是黑色，那么一定存在一个操作 \\(l = i &lt; r\\)，否则一定不存在，即一定存在一个操作 \\(l &lt; i = r\\)。\\(y\\) 为偶数同理。 经过上述处理，我们已经知道了每个格子是作为 \\(l\\) 被选择还是作为 \\(r\\) 被选择。 我们又发现，两个操作 \\(l_1,r_1\\) 和 \\(l_2,r_2\\)（\\(l_1 &lt; r_2,l_2 &lt; r_1\\)），变成 \\(l_1,r_2\\) 和 \\(l_2,r_1\\) 结果也是不变的。 那么我们只要把所有左端点和右端点任意匹配即可。对于每个作为右端点的 \\(i\\)，记 \\([1,i-1]\\) 中作为左端点的点的数量减去作为右端点的点的数量为 \\(d\\)，即多余的左端点个数，那么 \\(i\\) 可以与这 \\(d\\) 个左端点中的任意一个进行匹配，答案乘上 \\(d\\)。最后再乘上 \\(m!\\) 即可。 时间复杂度 \\(O(n)\\)。 代码 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define P 1000000007int n, d, ans;char s[200005];int main()&#123; scanf(&quot;%d%s&quot;, &amp;n, s + 1); for (register int i = 1; i &lt;= (n &lt;&lt; 1); ++i) if ((i &amp; 1) ^ (s[i] == &#x27;B&#x27;)) s[i] = &#x27;R&#x27;; else s[i] = &#x27;L&#x27;; ans = 1; for (register int i = 1; i &lt;= (n &lt;&lt; 1); ++i) if (s[i] == &#x27;L&#x27;) ++d; else&#123; if (!d) return printf(&quot;0\\n&quot;), 0; ans = 1ll * ans * d % P, --d; &#125; if (d) return printf(&quot;0\\n&quot;), 0; for (register int i = 1; i &lt;= n; ++i) ans = 1ll * ans * i % P; printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"JSC 2019 Qual","slug":"题解/AtCoder/JSC-2019-Qual","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/JSC-2019-Qual/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"「LOJ 6079」「2017 山东一轮集训 Day7」养猫","slug":"loj6079-sol","date":"2019-08-22T13:16:00.000Z","updated":"2020-03-26T07:22:57.226Z","comments":true,"path":"loj6079-sol/","link":"","permalink":"https://autumnkite.github.io/loj6079-sol/","excerpt":"LOJ 6079","text":"LOJ 6079 题解 \\(n\\le 1000\\)，还要输出方案，容易想到网络流。首先我们假设每个时刻都选 S，记 \\(a_i=s_i-e_i\\)，那么问题变成了调整若干个时刻 \\(j\\)，对于每个长度为 \\(k\\) 的区间，调整的时刻数量 \\(x\\) 应该满足 \\(me\\le x\\le k-ms\\)，在这个前提下，使得 \\(a_j\\) 之和尽量小。 考虑这样一个建模方法：源点 \\(S\\) 向某个点 \\(P\\) 连 \\((k-ms,0)\\) 的边（\\((x,y)\\) 表示流量上界为 \\(x\\)，费用为 \\(y\\) 的边，下同），点 \\(P\\) 向 \\([1,k]\\) 的点连 \\((\\infty,0)\\) 的边，点 \\(i\\) 向 \\(i+1\\) 连 \\((k-ms-me,0)\\) 的边，\\(i\\) 向 \\(i+k\\) 连 \\((1,a_i)\\) 的边（\\(i+1,i+k&gt;n\\) 时则向汇点 \\(T\\) 连边）。然后跑最小费用最大流的结果就是答案。 考虑这样建模为什么是对的。显然流只会从编号小的点流向编号大的点。我们假设从小到大处理每一个点 \\(i\\)，处理过的点已经满足流量平衡，未处理的点则把入流先“屯”着。有入流的点说明这个点需要调整。对于当前要处理的点 \\(i\\)，我们发现这个点“屯”着的流量就是 \\([i,i+k-1]\\) 这个区间中还能放的点数，已经有入流的点属于已经确定的点。由于总流量是 \\(k-ms\\)，而每个长度为 \\(k\\) 的区间只考虑 \\(i\\) 到 \\(i+1\\) 的边只能流出 \\(k-ms-me\\) 的流量，所以一定会有至少 \\(me\\) 个点被调整。（这一段是我自己yy的） 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;struct Graph&#123; const static int N = 2005, M = 10005, INF = 0x3f3f3f3f; int S, T, edge, to[M], pr[M], cap[M], cost[M], hd[N]; Graph()&#123; edge = 0, memset(hd, -1, sizeof hd); &#125; void addedge(int u, int v, int w, int c)&#123; to[edge] = v, cap[edge] = w, cost[edge] = c, pr[edge] = hd[u], hd[u] = edge++; to[edge] = u, cap[edge] = 0, cost[edge] = -c, pr[edge] = hd[v], hd[v] = edge++; &#125; int h, t, Q[1000005], vis[N], mn[N], pre[N]; long long dis[N]; bool SPFA()&#123; memset(dis, 0x3f, sizeof dis), memset(vis, 0, sizeof vis); h = 0, t = 1, Q[t] = S, dis[S] = 0, vis[S] = 1, pre[S] = 0, mn[S] = INF; while (h &lt; t)&#123; int u = Q[++h]; vis[u] = 0; for (register int i = hd[u], v; ~i; i = pr[i]) if (cap[i] &amp;&amp; dis[u] + cost[i] &lt; dis[v = to[i]])&#123; dis[v] = dis[u] + cost[i], mn[v] = std :: min(mn[u], cap[i]), pre[v] = i; if (!vis[v]) Q[++t] = v, vis[v] = 1; &#125; &#125; return dis[T] != dis[N - 1]; &#125; long long MinCostMaxFlow(int _S, int _T)&#123; long long res = 0; S = _S, T = _T; while (SPFA())&#123; res += mn[T] * dis[T]; for (register int i = T; i != S; i = to[pre[i] ^ 1]) cap[pre[i]] -= mn[T], cap[pre[i] ^ 1] += mn[T]; &#125; return res; &#125;&#125;G;int n, k, ms, me, a[1005], E[1005];long long sum;int main()&#123; n = read(), k = read(), ms = read(), me = read(); for (register int i = 1; i &lt;= n; ++i) a[i] = read(), sum += a[i]; for (register int i = 1; i &lt;= n; ++i) a[i] -= read(); for (register int i = 1; i &lt;= n; ++i)&#123; G.addedge(i, i + 1, k - ms - me, 0); E[i] = G.edge; G.addedge(i, std :: min(i + k, n + 1), 1, a[i]); &#125; for (register int i = 1; i &lt;= k; ++i) G.addedge(0, i, Graph :: INF, 0); G.addedge(n + 2, 0, k - ms, 0); printf(&quot;%lld\\n&quot;, sum - G.MinCostMaxFlow(n + 2, n + 1)); for (register int i = 1; i &lt;= n; ++i) if (G.cap[E[i]]) putchar(&#x27;S&#x27;); else putchar(&#x27;E&#x27;);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"LOJ","slug":"题解/LOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/LOJ/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"https://autumnkite.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}]},{"title":"「LOJ 6068」「2017 山东一轮集训 Day4」棋盘","slug":"loj6068-sol","date":"2019-08-22T01:18:00.000Z","updated":"2020-03-26T07:22:57.221Z","comments":true,"path":"loj6068-sol/","link":"","permalink":"https://autumnkite.github.io/loj6068-sol/","excerpt":"LOJ 6068","text":"LOJ 6068 题解 这类棋盘上放棋子的问题，且根据这个数据范围，很容易想到网络流。 棋子的攻击方式有两种，我们先考虑同一行。我们把一行中极大的连续的 . 组成的区间叫做行连通块。显然不同的行连通块之间是互不影响的。对于同一个行连通块，假设当前已经有 \\(x\\) 个棋子，那么再放入一个棋子后就会对答案产生 \\(x\\) 的贡献。同理我们可以定义列连通块，也同样具有行连通块的性质。显然，每个 . 唯一地属于一个行连通块和列连通块。 那么就有一个初步的建模思路：建立两排点，左边是所有行连通块，右边是所有列连通块，源点 \\(S\\) 向行连通块连边，列连通块向汇点 \\(T\\) 连边，对于每个是 . 的位置，我们把包含它的行连通块向包含它的列连通块连边。 假设放入一个棋子对应 \\(S\\) 到 \\(T\\) 的一个单位的流量，那么这条路径上边上的费用之和应该是放入这个棋子对答案产生的贡献。对于一个行连通块 \\(i\\)，假设它的大小为 \\(sz_i\\)，那么应该从 \\(S\\) 向 \\(i\\) 连 \\(sz_i\\) 条边，第 \\(j\\) 条边的费用是 \\(j-1\\)，流量上界是 \\(1\\)，这样就能保证第 \\(j\\) 次在这个行连通块放旗子时贡献是 \\(j-1\\)。列连通块同理。行连通块向列连通块连的边费用为 \\(0\\)，流量上界为 \\(1\\)。 于是问题变成了求流量恰好为 \\(k\\) 时的最小费用。可以发现，在跑费用流时，每次跑 SPFA 增广流量只会恰好增加 \\(1\\)，于是在跑费用流时从小到大求出每个 \\(k\\) 的答案即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;struct Graph&#123; const static int N = 5005, M = 100005, INF = 0x3f3f3f3f; int S, T, edge, to[M], pr[M], cap[M], cost[M], hd[N]; Graph()&#123; edge = 0, memset(hd, -1, sizeof hd); &#125; void addedge(int u, int v, int w, int c)&#123; to[edge] = v, cap[edge] = w, cost[edge] = c, pr[edge] = hd[u], hd[u] = edge++; to[edge] = u, cap[edge] = 0, cost[edge] = -c, pr[edge] = hd[v], hd[v] = edge++; &#125; int h, t, Q[1000005], dis[N], vis[N], mn[N], pre[N]; bool SPFA()&#123; memset(dis, 0x3f, sizeof dis), memset(vis, 0, sizeof vis); h = 0, t = 1, Q[t] = S, dis[S] = 0, vis[S] = 1, pre[S] = 0, mn[S] = INF; while (h &lt; t)&#123; int u = Q[++h]; vis[u] = 0; for (register int i = hd[u], v; ~i; i = pr[i]) if (cap[i] &amp;&amp; dis[u] + cost[i] &lt; dis[v = to[i]])&#123; dis[v] = dis[u] + cost[i], mn[v] = std :: min(mn[u], cap[i]), pre[v] = i; if (!vis[v]) Q[++t] = v, vis[v] = 1; &#125; &#125; return dis[T] != INF; &#125; std :: vector&lt;int&gt; MinCostMaxFlow(int _S, int _T)&#123; std :: vector&lt;int&gt; res; res.push_back(0), S = _S, T = _T; while (SPFA())&#123; res.push_back(res[res.size() - 1] + dis[T]); for (register int i = T; i != S; i = to[pre[i] ^ 1]) cap[pre[i]] -= mn[T], cap[pre[i] ^ 1] += mn[T]; &#125; return res; &#125;&#125;G;int n, q, cnt, cntr, cntc, rbel[55][55], cbel[55][55], sz[5005];char a[55][55];std :: vector&lt;int&gt; ans;int main()&#123; n = read(); for (register int i = 1; i &lt;= n; ++i) scanf(&quot;%s&quot;, a[i] + 1); cntr = 1; for (register int i = 1; i &lt;= n; ++i)&#123; if (sz[cntr]) ++cntr; for (register int j = 1; j &lt;= n; ++j) if (a[i][j] == &#x27;.&#x27;) rbel[i][j] = cntr, ++sz[cntr]; else if (sz[cntr]) ++cntr; &#125; cntc = cntr + 1; for (register int i = 1; i &lt;= n; ++i)&#123; if (sz[cntc]) ++cntc; for (register int j = 1; j &lt;= n; ++j) if (a[j][i] == &#x27;.&#x27;) cbel[j][i] = cntc, ++sz[cntc]; else if (sz[cntc]) ++cntc; &#125; for (register int i = 1; i &lt;= cntr; ++i) for (register int j = 0; j &lt; sz[i]; ++j) G.addedge(0, i, 1, j); for (register int i = cntr + 1; i &lt;= cntc; ++i) for (register int j = 0; j &lt; sz[i]; ++j) G.addedge(i, cntc + 1, 1, j); for (register int i = 1; i &lt;= n; ++i) for (register int j = 1; j &lt;= n; ++j) if (a[i][j] == &#x27;.&#x27;) G.addedge(rbel[i][j], cbel[i][j], 1, 0); ans = G.MinCostMaxFlow(0, cntc + 1); q = read(); while (q--) printf(&quot;%d\\n&quot;, ans[read()]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"LOJ","slug":"题解/LOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/LOJ/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"https://autumnkite.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}]},{"title":"「LOJ 6073」「2017 山东一轮集训 Day5」距离","slug":"loj6073-sol","date":"2019-08-21T12:58:00.000Z","updated":"2020-03-26T07:22:57.222Z","comments":true,"path":"loj6073-sol/","link":"","permalink":"https://autumnkite.github.io/loj6073-sol/","excerpt":"LOJ 6073","text":"LOJ 6073 题解 建议先做下这题的弱弱弱弱弱化版：LOJ #2558. 「LNOI2014」LCA。 设 \\(dis_i\\) 表示根到 \\(i\\) 的路径上的边权之和，\\(dep_i\\) 表示根到 \\(i\\) 的路径上的点数，答案可以表示成 \\[\\begin{aligned}\\sum_{i\\in \\text{path}(u,v)}\\text{dist}(p_i,k)&amp;=\\sum_{i\\in \\text{path}(u,v)} \\left(dis_{p_i}+dis_k-2dis_{\\text{LCA}(p_i,k)}\\right)\\\\&amp;=\\left(dep_u+dep_v-2dep_{\\text{LCA}(u,v)}+1\\right)dis_k\\\\&amp;+\\sum_{i\\in \\text{path}(u,v)} dis_{p_i}-2\\sum_{i\\in \\text{path}(u,v)}dis_{\\text{LCA}(p_i,k)}\\end{aligned}\\] 这个式子的第一项可以在预处理 \\(dep_i,dis_i\\) 后快速计算，第二项可以预处理根到 \\(i\\) 的路径上所有 \\(dis_j\\) 之和（记为 \\(sumd_i\\)）然后快速计算，关键是最后一项，即计算 \\[\\sum_{i\\in \\text{path}(u,v)}dis_{\\text{LCA}(p_i,k)}\\] 的值。 联系 LOJ #2558. 「LNOI2014」LCA 的做法，我们有了一个初步的暴力做法： 我们设 \\(w_i\\) 表示 \\(i\\) 与它父亲的边的边权，对于 \\(u\\) 到 \\(v\\) 路径上的每个点 \\(i\\)，我们把 \\(p_i\\) 到根的路径上所有点 \\(j\\) 的“点权”加 \\(w_j\\)，某个点的“点权”初始为 \\(0\\)。然后，我们查询根到 \\(k\\) 路径上所有点的“点权和”，这个值即为上面式子的值。 考虑优化这个暴力。与 LOJ #2558. 「LNOI2014」LCA 相似，我们可以差分。我们把 \\(p_i\\) 到根的路径上所有点 \\(j\\) 的“点权”加 \\(w_j\\) 这样的一次操作叫做对点 \\(i\\) 的一次操作。那么显然答案可以差分成对 \\(u\\) 到根路径上每个点进行一次操作后的 \\(k\\) 到根路径上的“点权”和，加上对 \\(v\\) 到根路径上每个点进行一次操作后的 \\(k\\) 到根路径上的“点权”和，减去对 \\(\\text{LCA}(u,v)\\) 到根路径上每个点进行一次操作后的 \\(k\\) 到根路径上的“点权”和，减去对 \\(\\text{LCA}(u,v)\\) 的父亲到根路径上每个点进行一次操作后的 \\(k\\) 到根路径上的“点权”和。注意上面四个操作都是在初始状态下进行的，并不是从上一个操作继承下来的。 四个操作我们可以对每个节点维护一棵线段树，第 \\(i\\) 个点的线段树维护对 \\(i\\) 到根路径上每个点进行一次操作后的区间的“点权”之和，注意这里的区间是指树剖后 DFS 序上的区间。求 \\(k\\) 到根路径上的点权和可以树链剖分后在线段树上 \\(O(\\log^2n)\\) 得到。每个点的线段树可以从它父亲那里继承过来，即可持久化线段树，注意这里需要支持可持久化的区间修改、区间查询，线段树的写法与普通线段树有一些区别。 时间复杂度 \\(O(n\\log^2n)\\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;long long read()&#123; register long long x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 200005int type, n, q, p[N];int edge, to[N &lt;&lt; 1], tw[N &lt;&lt; 1], pr[N &lt;&lt; 1], hd[N];void addedge(int u, int v, int w)&#123; to[++edge] = v, tw[edge] = w, pr[edge] = hd[u], hd[u] = edge;&#125;long long dis[N], pre[N], sumd[N], ans;int fa[N], sz[N], dep[N], son[N], top[N], idx, dfn[N], id[N];void dfs(int u)&#123; dep[u] = dep[fa[u]] + 1, sz[u] = 1; for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa[u]) fa[v] = u, dis[v] = dis[u] + tw[i], dfs(v), sz[u] += sz[v], !son[u] || sz[v] &gt; sz[son[u]] ? son[u] = v : 0;&#125;void dfs(int u, int tp)&#123; top[u] = tp, dfn[u] = ++idx, id[idx] = u, pre[idx] = dis[u] - dis[fa[u]]; if (son[u]) dfs(son[u], tp); for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa[u] &amp;&amp; v != son[u]) dfs(v, v);&#125;struct Chairman_Tree&#123; int cnt, ls[N * 150], rs[N * 150], lz[N * 150]; long long sum[N * 150]; void modify(int &amp;u, int _u, int l, int r, int L, int R)&#123; u = ++cnt, ls[u] = ls[_u], rs[u] = rs[_u], sum[u] = sum[_u], lz[u] = lz[_u]; if (L == l &amp;&amp; r == R) return ++lz[u], void(0); sum[u] += pre[R] - pre[L - 1]; int md = (l + r) &gt;&gt; 1; if (R &lt;= md) modify(ls[u], ls[_u], l, md, L, R); else if (L &gt; md) modify(rs[u], rs[_u], md + 1, r, L, R); else modify(ls[u], ls[_u], l, md, L, md), modify(rs[u], rs[_u], md + 1, r, md + 1, R); &#125; long long query(int u, int l, int r, int L, int R)&#123; if (!u) return 0; if (L == l &amp;&amp; r == R) return sum[u] + 1ll * lz[u] * (pre[R] - pre[L - 1]); long long tmp = 1ll * lz[u] * (pre[R] - pre[L - 1]); int md = (l + r) &gt;&gt; 1; if (R &lt;= md) return tmp + query(ls[u], l, md, L, R); else if (L &gt; md) return tmp + query(rs[u], md + 1, r, L, R); else return tmp + query(ls[u], l, md, L, md) + query(rs[u], md + 1, r, md + 1, R); &#125;&#125;T;int rt[N];void update(int u)&#123; int _u = u; u = p[u]; while (top[u] != 1)&#123; T.modify(rt[_u], rt[_u], 1, n, dfn[top[u]], dfn[u]); u = fa[top[u]]; &#125; T.modify(rt[_u], rt[_u], 1, n, 1, dfn[u]);&#125;void build(int u)&#123; rt[u] = rt[fa[u]], update(u), sumd[u] = sumd[fa[u]] + dis[p[u]]; for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa[u]) build(v);&#125;int lca(int u, int v)&#123; while (top[u] != top[v])&#123; if (dep[top[u]] &lt; dep[top[v]]) std :: swap(u, v); u = fa[top[u]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;long long query(int rt, int u)&#123; long long res = 0; while (top[u] != 1)&#123; res += T.query(rt, 1, n, dfn[top[u]], dfn[u]); u = fa[top[u]]; &#125; res += T.query(rt, 1, n, 1, dfn[u]); return res;&#125;int main()&#123; type = read(); n = read(), q = read(); for (register int i = 1, u, v, w; i &lt; n; ++i) u = read(), v = read(), w = read(), addedge(u, v, w), addedge(v, u, w); for (register int i = 1; i &lt;= n; ++i) p[i] = read(); dfs(1), dfs(1, 1); for (register int i = 1; i &lt;= n; ++i) pre[i] += pre[i - 1]; build(1); while (q--)&#123; int u = read() ^ (type * ans), v = read() ^ (type * ans), k = read() ^ (type * ans); int l = lca(u, v); ans = sumd[u] + sumd[v] - sumd[l] - sumd[fa[l]]; ans += 1ll * (dep[u] + dep[v] - dep[l] - dep[fa[l]]) * dis[k]; ans -= 2 * (query(rt[u], k) + query(rt[v], k) - query(rt[l], k) - query(rt[fa[l]], k)); printf(&quot;%lld\\n&quot;, ans); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"LOJ","slug":"题解/LOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/LOJ/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"https://autumnkite.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"可持久化线段树","slug":"可持久化线段树","permalink":"https://autumnkite.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"「LOJ 6077」「2017 山东一轮集训 Day7」逆序对","slug":"loj6077-sol","date":"2019-08-20T10:16:00.000Z","updated":"2020-03-26T07:22:57.223Z","comments":true,"path":"loj6077-sol/","link":"","permalink":"https://autumnkite.github.io/loj6077-sol/","excerpt":"LOJ 6077","text":"LOJ 6077 题解 考虑已经有一个 \\([1,i-1]\\) 的排列，我们把 \\(i\\) 这个数插进去，会使得逆序对数量加 \\(x_i\\)，其中 \\(x_i\\in [0,i)\\)。那么问题转化成求 \\(\\sum_{i=1}^n x_i=k\\) 的解的数量，满足 \\(\\forall i\\in [1,n]:0\\le x_i &lt; i\\)。 考虑容斥，枚举不满足条件的位置个数 \\(i\\) 和位置 \\(p_1,p_2,p_3,\\cdots,p_i\\)，那么问题变成了有若干个有 \\(n\\) 个条件，其中有 \\(i\\) 个条件是 \\(x_{p_j}\\ge p_j\\)，其他条件是 \\(x_j\\ge 0\\)。我们让 \\(k\\) 减去 \\(p_1+p_2+p_3+\\cdots+p_i\\) 的值，就变成了一个经典的隔板法求不定方程非负整数解的数量的问题。即答案是 \\[ans=\\sum_{i=0}^{n}(-1)^i\\sum_{p_1 &lt; p_2 &lt; p_3 &lt; \\cdots &lt; p_i} C_{n-1+k-\\sum_{j=1}^i p_j}^{n-1}\\] 我们发现后面的组合数式子不需要关心 \\(p_j\\) 具体的值，只需要知道 \\(\\sum_{j=1}^i p_j\\) 即可。于是我们枚举这个值，式子变成了 \\[ans=\\sum_{i=0}^n(-1)^i\\sum_{j=0}^{k}F_{i,j}C_{k-j+n-1}^{n-1}\\] 其中 \\(F_{i,j}\\) 表示选 \\(i\\) 个互不相同的数，且这些数在 \\([1,n]\\) 的范围内，使得这 \\(i\\) 个数和为 \\(j\\) 的方案数。又可以注意到，因为 \\(i\\) 个数要互不相同，所以当 \\(j &lt; \\frac{i(i+1)}{2}\\) 时，\\(F_{i,j}=0\\)。又因为 \\(j\\) 不能超过 \\(k\\)，所以 \\(i\\) 只需要枚举到 \\(\\lfloor\\sqrt{2k}\\rfloor\\) 即可。而组合数可以 \\(O(n+k)\\) 预处理阶乘及阶乘的逆元，然后 \\(O(1)\\) 计算。那么关键问题是如何求 \\(F_{i,j}\\)。 这是经典的整数划分问题。假设当前有 \\(i\\) 个数，和为 \\(j\\)，那么有两种决策： 把所有数加 \\(1\\)，和变成了 \\(i+j\\)； 在最前面加上一个数 \\(1\\)，并把其他所有数加 \\(1\\)，个数变成 \\(i+1\\)，和变成 \\(i+j+1\\)。 可以证明所有方案都可以通过这两种变换唯一的遍历到。但是有些方案中会存在某个数大于 \\(n\\) 的情况，需要减去。又因为所有数互不相同，且变换之前的方案是合法的，所以这个不合法的方案一定只会存在一个大于 \\(n\\) 的数且这个数是 \\(n+1\\)。那么这种不合法的方案数一定与去掉 \\(n+1\\) 这个数后序列的方案数相等，直接减去即可。DP 的转移方程是 \\[F_{i,j}=F_{i,j-i}+F_{i-1,j-i}-F_{i-1,j-n-1}\\] 可以直接带上容斥系数，变成 \\[F_{i,j}=F_{i,j-i}-F_{i-1,j-i}+F_{i-1,j-n-1}\\] 处理完后直接计算即可。时间复杂度 \\(O(n\\sqrt{n})\\)。 还有一种用生成函数推导答案式子的方法，可以参考 Trisolaris's Blog。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 100005#define P 1000000007int n, k, fac[N &lt;&lt; 1], inv[N &lt;&lt; 1], t, F[455][N], f[N], ans;void inc(int &amp;a, int b)&#123; (a += b) &gt;= P ? a -= P : 0;&#125;void dec(int &amp;a, int b)&#123; (a -= b) &lt; 0 ? a += P : 0;&#125;int qpow(int a, int b = P - 2)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if (b &amp; 1) s = 1ll * s * a % P; return s;&#125;void init(int n, int k)&#123; fac[0] = 1; for (register int i = 1; i &lt;= n + k; ++i) fac[i] = 1ll * fac[i - 1] * i % P; inv[n + k] = qpow(fac[n + k]); for (register int i = n + k; i; --i) inv[i - 1] = 1ll * inv[i] * i % P; t = std :: min(n, int(sqrt(2 * k)) + 1); F[0][0] = 1, f[0] = 1; for (register int i = 1; i &lt;= t; ++i) for (register int j = i * (i + 1) &gt;&gt; 1; j &lt;= k; ++j)&#123; dec(F[i][j], F[i - 1][j - i]), inc(F[i][j], F[i][j - i]); if (j &gt;= n + 1) inc(F[i][j], F[i - 1][j - n - 1]); inc(f[j], F[i][j]); &#125;&#125;int C(int n, int m)&#123; return 1ll * fac[n] * inv[m] % P * inv[n - m] % P;&#125;int main()&#123; n = read(), k = read(); init(n, k); for (register int i = 0; i &lt;= k; ++i) inc(ans, 1ll * f[i] * C(k - i + n - 1, n - 1) % P); printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"LOJ","slug":"题解/LOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/LOJ/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"「LOJ 6066」「2017 山东一轮集训 Day3」第二题","slug":"loj6066-sol","date":"2019-08-19T12:51:00.000Z","updated":"2020-03-26T07:22:57.220Z","comments":true,"path":"loj6066-sol/","link":"","permalink":"https://autumnkite.github.io/loj6066-sol/","excerpt":"LOJ 6066","text":"LOJ 6066 题解 答案具有单调性，于是二分 \\(k\\)，问题转化成： 是否存在两个点 \\(u,v\\) 满足 \\(u\\) 的 \\(k-\\) 子树与 \\(v\\) 的 \\(k-\\) 子树形态相同。 解决这样的问题可以使用哈希，那么我们需要找到一种哈希的方式使得“形态”相同的树的哈希值相同，“形态”不同的树的哈希值不同。 由于节点标号与树的形态无关，儿子的顺序与树的形态有关，容易想到括号序列。于是问题变成： 在以 \\(u\\) 为根的子树对应的括号序列中，删去所有与 \\(u\\) 距离 \\(k+1\\) 的点为根的子树对应的括号序列后，求哈希值。 由于每个点只会在 \\(k+1\\) 级祖先处被遍历，所以求所有 \\(k-\\) 子树的哈希值是 \\(O(n)\\) 的。 求每个点的 \\(k+1\\) 级祖先可以使用倍增做到 \\(O(n\\log n)\\) 或用长链剖分做到 \\(O(n)\\)。 总时间复杂度 \\(O(n\\log^2 n)\\)。 代码 我使用了双哈希 + set 的方式进行判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;namespace Double_Hash&#123; static const int N = 200005, B1 = 233, P1 = 382538579, B2 = 331, P2 = 952959323; int pw1[N], pw2[N]; struct node&#123; int H1, H2; node(int _H1 = 0, int _H2 = 0)&#123; H1 = _H1, H2 = _H2; &#125; bool operator == (const node &amp;rhs) const &#123; return H1 == rhs.H1 &amp;&amp; H2 == rhs.H2; &#125; bool operator &lt; (const node &amp;rhs) const &#123; return H1 &lt; rhs.H1 || (H1 == rhs.H1 &amp;&amp; H2 &lt; rhs.H2); &#125; node operator + (const char ch) const &#123; return node((1ll * H1 * B1 + ch) % P1, (1ll * H2 * B2 + ch) % P2); &#125; node operator + (const node &amp;rhs) const &#123; return node((H1 + rhs.H1) % P1, (H2 + rhs.H2) % P2); &#125; node operator - (const node &amp;rhs) const &#123; return node((H1 - rhs.H1 + P1) % P1, (H2 - rhs.H2 + P2) % P2); &#125; node operator &lt;&lt; (const int x) const &#123; return node(1ll * H1 * pw1[x] % P1, 1ll * H2 * pw2[x] % P2); &#125; &#125;h[N]; void pre(int n = N - 1)&#123; pw1[0] = 1, pw2[0] = 1; for (register int i = 1; i &lt;= n; ++i) pw1[i] = 1ll * pw1[i - 1] * B1 % P1, pw2[i] = 1ll * pw2[i - 1] * B2 % P2; &#125; node hash(int l, int r)&#123; return h[r] - (h[l - 1] &lt;&lt; (r - l + 1)); &#125; void build(char *a, int n)&#123; for (register int i = 1; i &lt;= n; ++i) h[i] = h[i - 1] + a[i]; &#125;&#125;using namespace Double_Hash;#define N 100005int n, fa[N][20], idx, l[N], r[N], dis[N];char a[N &lt;&lt; 1];std :: vector&lt;int&gt; son[N], po[N];std :: set&lt;node&gt; S;void dfs(int u)&#123; dis[u] = 0, l[u] = ++idx, a[idx] = 23; for (register int i = 1; i &lt;= 18; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (register int i = 0, v; i &lt; son[u].size(); ++i) v = son[u][i], fa[v][0] = u, dfs(v), dis[u] = std :: max(dis[u], dis[v] + 1); r[u] = ++idx, a[idx] = 97;&#125;int kth_fa(int u, int k)&#123; for (register int i = 0; i &lt;= 18; ++i) if (k &gt;&gt; i &amp; 1) u = fa[u][i]; return u;&#125;bool check(int k)&#123; for (register int i = 1; i &lt;= n; ++i) po[i].clear(); for (register int i = 1; i &lt;= n; ++i) po[i].push_back(l[i]), po[i].push_back(r[i] + 1); for (register int i = 1; i &lt;= n; ++i)&#123; int p = kth_fa(i, k + 1); if (p) po[p].push_back(l[i]), po[p].push_back(r[i] + 1); &#125; for (register int i = 1; i &lt;= n; ++i) std :: sort(po[i].begin(), po[i].end()); S.clear(); for (register int i = 1; i &lt;= n; ++i) if (dis[i] &gt;= k)&#123; node tmp; for (register int j = 0; j &lt; po[i].size(); j += 2) tmp = (tmp &lt;&lt; (po[i][j + 1] - po[i][j])) + hash(po[i][j], po[i][j + 1] - 1); if (S.count(tmp)) return 1; S.insert(tmp); &#125; return 0;&#125;int main()&#123; n = read(); for (register int i = 1; i &lt;= n; ++i)&#123; int k = read(); for (register int j = 1; j &lt;= k; ++j) son[i].push_back(read()); &#125; dfs(1); pre(n &lt;&lt; 1), build(a, n &lt;&lt; 1); int l = 0, r = n, md, ans = 0; while (l &lt;= r) if (check(md = (l + r) &gt;&gt; 1)) l = md + 1, ans = md; else r = md - 1; printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"LOJ","slug":"题解/LOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/LOJ/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://autumnkite.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"括号序列","slug":"括号序列","permalink":"https://autumnkite.github.io/tags/%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"},{"name":"哈希","slug":"哈希","permalink":"https://autumnkite.github.io/tags/%E5%93%88%E5%B8%8C/"}]},{"title":"「LOJ 6074」「2017 山东一轮集训 Day6」子序列","slug":"loj6074-sol","date":"2019-08-19T12:51:00.000Z","updated":"2020-03-26T07:22:57.222Z","comments":true,"path":"loj6074-sol/","link":"","permalink":"https://autumnkite.github.io/loj6074-sol/","excerpt":"LOJ 6074","text":"LOJ 6074 题解 设字符集大小为 \\(m\\)，这里 \\(m=9\\)，假设字符从 \\(0\\) 开始标号。 显然可以 DP，设 \\(dp_{i,j}\\) 表示前 \\(i\\) 个字符中，以字符 \\(j\\) 结尾的本质不同的子序列个数。特殊地，\\(j=m\\) 表示子序列为空。有方程： \\[dp_{i,j}=\\begin{cases}dp_{i-1,j} &amp; \\text{ if } j\\ne S_i \\\\ \\sum_{k=0}^{m} dp_{i-1,k} &amp; \\text{ if }j=S_i\\end{cases}\\] 初始值是 \\(dp_{0,m}=1\\)。 发现 \\(dp\\) 数组可以写成行向量，记 \\[F_i=\\begin{pmatrix}dp_{i,0} &amp; dp_{i,1} &amp; dp_{i,2} &amp; \\cdots &amp; dp_{i,m}\\end{pmatrix}\\] 而转移可以表示为一个行向量乘上转移矩阵 \\(M_i\\) 的形式： \\[\\begin{aligned}M_i &amp;= \\begin{pmatrix}1 &amp; &amp; 1 &amp; &amp; \\\\ &amp; 1 &amp; 1 &amp; &amp; \\\\ &amp; &amp; 1 &amp; &amp; \\\\ &amp; &amp; \\vdots &amp; \\ddots &amp; \\\\ &amp; &amp; 1 &amp; &amp; 1 \\end{pmatrix} \\\\ F_i &amp;= F_{i-1}M_i\\end{aligned}\\] \\(M_i\\) 是一个主对角线为 \\(1\\)，\\(S_i\\) 这一列为 \\(1\\)，其余为 \\(0\\) 的矩阵。 初始的行向量为 \\[A=\\begin{pmatrix}0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 1\\end{pmatrix}\\] 最后由于是求 \\[\\left(\\sum_{i=0}^m dp_{n,i}\\right)-1\\] 所以最后需要乘上列向量 \\[B=\\begin{pmatrix}1 \\\\ 1 \\\\ 1 \\\\ \\vdots \\\\ 1\\end{pmatrix}\\] 于是对于每个询问，答案可以表示成 \\[\\begin{aligned}ans&amp;=AM_lM_{l+1}M_{l+2}\\cdots M_{r}B\\\\&amp;=AM_{l-1}^{-1}M_{l-2}^{-1}\\cdots M_1^{-1}M_1M_2\\cdots M_{r}B\\end{aligned}\\] 直接维护 \\(M_i\\) 和 \\(M_i^{-1}\\) 的前缀积（注意顺序），时间复杂度 \\(O(nm^3+qm^3)\\)。 在维护完 \\(M_i\\) 和 \\(M_i^{-1}\\) 后，分别右乘一个 \\(B\\) 和左乘一个 \\(A\\)，这样询问部分的复杂度可以降到 \\(O(qm)\\)。 预处理部分，我们来观察一些特殊性质。对于 \\(M_i\\) 的前缀积，我们发现每次要算 \\[\\begin{aligned}CM_i&amp;=\\begin{pmatrix}C_{0,0} &amp; C_{0,1} &amp; C_{0,2} &amp; \\cdots &amp; C_{0,m} \\\\ C_{1,0} &amp; C_{1,1} &amp; C_{1,2} &amp; \\cdots &amp; C_{1,m} \\\\ C_{2,0} &amp; C_{2,1} &amp; C_{2,2} &amp; \\cdots &amp; C_{2,m} \\\\ &amp; &amp; &amp; \\ddots &amp; \\\\ C_{m,0} &amp; C_{m,1} &amp; C_{m,2} &amp; \\cdots &amp; C_{m,m} \\end{pmatrix}\\begin{pmatrix}1 &amp; &amp; 1 &amp; &amp; \\\\ &amp; 1 &amp; 1 &amp; &amp; \\\\ &amp; &amp; 1 &amp; &amp; \\\\ &amp; &amp; \\vdots &amp; \\ddots &amp; \\\\ &amp; &amp; 1 &amp; &amp; 1 \\end{pmatrix} \\\\ &amp;= \\begin{pmatrix}C_{0,0} &amp; C_{0,1} &amp; \\sum_{j=0}^m C_{0,j} &amp; \\cdots &amp; C_{0,m} \\\\ C_{1,0} &amp; C_{1,1} &amp; \\sum_{j=0}^m C_{1,j} &amp; \\cdots &amp; C_{1,m} \\\\ C_{2,0} &amp; C_{2,1} &amp; \\sum_{j=0}^m C_{2,j} &amp; \\cdots &amp; C_{2,m} \\\\ &amp; &amp; &amp; \\ddots &amp; \\\\ C_{m,0} &amp; C_{m,1} &amp; \\sum_{j=0}^m C_{m,j} &amp; \\cdots &amp; C_{m,m} \\end{pmatrix}\\end{aligned}\\] 相当于把 \\(C\\) 的第 \\(S_i\\) 列改成对应行的 \\(C_{k,j}\\) 之和。且最后乘上 \\(B\\) 相当于求每行的和。那么只要维护 \\(C\\) 的每一行之和即可。于是维护 \\(M_i\\) 的前缀积乘上 \\(B\\) 的复杂度变成了 \\(O(nm)\\)。 对于 \\(M_i^{-1}\\) 的前缀积，我们先根据矩阵求逆的过程手动求出 \\(M_i^{-1}\\)，发现 \\[M_i^{-1}=\\begin{pmatrix}1 &amp; &amp; -1 &amp; &amp; \\\\ &amp; 1 &amp; -1 &amp; &amp; \\\\ &amp; &amp; 1 &amp; &amp; \\\\ &amp; &amp; \\vdots &amp; \\ddots &amp; \\\\ &amp; &amp; -1 &amp; &amp; 1 \\end{pmatrix}\\] 即 \\(M_i^{-1}\\) 是主对角线为 \\(1\\)，第 \\(S_i\\) 列除了第 \\(S_i\\) 行外是 \\(-1\\) 的矩阵。 维护 \\(M_i^{-1}\\) 的前缀积时，我们要算 \\[\\begin{aligned}M_i^{-1}C&amp;=\\begin{pmatrix}1 &amp; &amp; -1 &amp; &amp; \\\\ &amp; 1 &amp; -1 &amp; &amp; \\\\ &amp; &amp; 1 &amp; &amp; \\\\ &amp; &amp; \\vdots &amp; \\ddots &amp; \\\\ &amp; &amp; -1 &amp; &amp; 1 \\end{pmatrix}\\begin{pmatrix}C_{0,0} &amp; C_{0,1} &amp; C_{0,2} &amp; \\cdots &amp; C_{0,m} \\\\ C_{1,0} &amp; C_{1,1} &amp; C_{1,2} &amp; \\cdots &amp; C_{1,m} \\\\ C_{2,0} &amp; C_{2,1} &amp; C_{2,2} &amp; \\cdots &amp; C_{2,m} \\\\ &amp; &amp; &amp; \\ddots &amp; \\\\ C_{m,0} &amp; C_{m,1} &amp; C_{m,2} &amp; \\cdots &amp; C_{m,m} \\end{pmatrix} \\\\ &amp;= \\begin{pmatrix}C_{0,0}-C_{2,0} &amp; C_{0,1}-C_{2,1} &amp; C_{0,2}-C_{2,2} &amp; \\cdots &amp; C_{0,m}-C_{2,m} \\\\ C_{1,0}-C_{2,0} &amp; C_{1,1}-C_{2,1} &amp; C_{1,2}-C_{2,2} &amp; \\cdots &amp; C_{1,m}-C_{2,m} \\\\ C_{2,0} &amp; C_{2,1} &amp; C_{2,2} &amp; \\cdots &amp; C_{2,m} \\\\ &amp; &amp; &amp; \\ddots &amp; \\\\ C_{m,0}-C_{2,0} &amp; C_{m,1}-C_{2,1} &amp; C_{m,2}-C_{2,2} &amp; \\cdots &amp; C_{m,m}-C_{2,m} \\end{pmatrix}\\end{aligned}\\] 可以发现，每一列除了 \\(S_i\\) 这一行以外都减去的是同一个数，于是我们维护每一列减去的数，例如对于某一列 \\[\\begin{pmatrix}x_0-v \\\\ x_1-v \\\\ x_2-v \\\\ \\vdots \\\\ x_m-v \\end{pmatrix}\\] 要变成 \\[\\begin{pmatrix}x_0-v-(x_2-v) \\\\ x_1-v-(x_2-v) \\\\ x_2-v \\\\ \\vdots \\\\ x_m-v-(x_2-v) \\end{pmatrix}==\\begin{pmatrix}x_0-x_2 \\\\ x_1-x_2 \\\\ (2x_2-v)-x_2 \\\\ \\vdots \\\\ x_m-x_2 \\end{pmatrix}\\] 于是只需要修改第 \\(S_i\\) 那一行的值，并且更新每一列减去的值即可。 最后左乘 \\(A\\) 相当于求最后一行的值。由于最后一行不会修改，始终是 \\[\\begin{pmatrix}0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 1\\end{pmatrix}\\] 所以直接减去对应列需要减的数即可。这一部分的时间复杂度也变成了 \\(O(nm)\\)。 总时间复杂度 \\(O(nm+qm)\\)。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 100005#define P 1000000007int n, q, a[10][10], av[10][10], f[N][10], fv[N][10];char s[N];int plus(int a, int b)&#123; return (a += b) &gt;= P ? a - P : a;&#125;int minus(int a, int b)&#123; return (a -= b) &lt; 0 ? a + P : a;&#125;void init(int n)&#123; for (register int i = 0; i &lt;= 9; ++i) a[i][i] = av[i][i] = f[0][i] = 1; for (register int i = 1; i &lt;= n; ++i)&#123; int t = s[i] - &#x27;a&#x27;; for (register int j = 0; j &lt;= 9; ++j)&#123; f[i][j] = plus(minus(f[i - 1][j], a[j][t]), f[i - 1][j]); a[j][t] = f[i - 1][j]; fv[i][j] = av[t][j]; av[t][j] = minus(plus(av[t][j], av[t][j]), fv[i - 1][j]); &#125; &#125; for (register int i = 0; i &lt;= n; ++i) for (register int j = 0; j &lt;= 9; ++j) fv[i][j] = minus(j == 9, fv[i][j]);&#125;int main()&#123; while (islower(s[++n] = getchar())) ; --n; init(n); q = read(); while (q--)&#123; int l = read(), r = read(), ans = 0; for (register int i = 0; i &lt;= 9; ++i) ans = plus(ans, 1ll * fv[l - 1][i] * f[r][i] % P); printf(&quot;%d\\n&quot;, minus(ans, 1)); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"LOJ","slug":"题解/LOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/LOJ/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"https://autumnkite.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"},{"name":"矩阵求逆","slug":"矩阵求逆","permalink":"https://autumnkite.github.io/tags/%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86/"}]},{"title":"「LOJ 6065」「2017 山东一轮集训 Day3」第一题","slug":"loj6065-sol","date":"2019-08-19T12:16:00.000Z","updated":"2020-03-26T07:22:57.219Z","comments":true,"path":"loj6065-sol/","link":"","permalink":"https://autumnkite.github.io/loj6065-sol/","excerpt":"LOJ 6065","text":"LOJ 6065 题解 总的分为两种情况：\\(1+1+2+2\\) 和 \\(1+1+1+3\\)。 对于第一种情况，我们假设边长为 \\(k\\)，\\(6\\) 根棒子长度为 \\(k,k,x_1,k-x_1,x_2,k-x_2\\)，并且强制 \\(x_1\\ge x_2\\ge k-x_2\\ge k-x_1\\)。 我们记 \\(cnt_i\\) 表示长度为 \\(i\\) 的棒子的数量，我们从小到大枚举 \\(x_1\\)，同时维护 \\(cntt_i\\) 表示在长度小于 \\(x_1\\) 的棒子中选出两根拼成长度为 \\(i\\) 的方案数。 具体计算的时候，为了避免算重，我们分三种情况进行计算： \\(x_1 &gt; x_2 &gt; k-x_2 &gt; k-x_1\\)，枚举 \\(k\\)，方案数为 \\(cnt_{x_1}\\times cnt_{k-x_1}\\times cntt_{k}\\times C_{cnt_k}^2\\)； \\(x_1 = x_2 &gt; k-x_2 = k-x_1\\)，同样枚举 \\(k\\)，方案数为 \\(C_{cnt_{x_1}}^2\\times C_{cnt_{k-x_1}}^2\\times C_{cnt_k}^2\\)； \\(x_1 = x_2 = k-x_2 = k-x_1\\)，此时 \\(k=2x_1\\)，方案数为 \\(C_{cnt_{x_1}}^4\\times C_{cnt_{2x_1}}^2\\)。 对于第二种情况，假设棒子长度为 \\(k,k,k,x_1,x_2,k-x_1-x_2\\)，强制 \\(x_1\\ge x_2\\ge k-x_1-x_2\\)。 同样记录 \\(cnt_i\\)，然后从小到大枚举 \\(x_1\\)，同时记录 \\(cntt_i\\)。 也分为三种情况： \\(x_1 &gt; x_2 &gt; k-x_1-x_2\\)，枚举 \\(k\\)，方案数为 \\(cnt_{x_1}\\times cntt_{k-x_1}\\times C_{cnt_k}^3\\)； \\(x_1 = x_2 &gt; k-x_1-x_2\\)，枚举 \\(k\\)，方案数为 \\(C_{cnt_{x_1}}^2\\times cnt_{k-2x_1}\\times C_{cnt_k}^3\\)； \\(x_1 = x_2 = k-x_1-x_2\\)，此时 \\(k=3x_1\\)，方案数为 \\(C_{cnt_{x_1}}^3\\times C_{cnt_{3x_1}}^3\\)。 时间复杂度 \\(O(n^2)\\)。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;int read()&#123; register int x = 0; register char ch = getchar(), f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 5005#define M 10000005int n, m, a[N], cnt[M], cntt[M];long long ans;long long C2(long long x)&#123; return x &lt; 2 ? 0 : x * (x - 1) / 2; &#125;long long C3(long long x)&#123; return x &lt; 3 ? 0 : x * (x - 1) * (x - 2) / 6; &#125;long long C4(long long x)&#123; return x &lt; 4 ? 0 : x * (x - 1) * (x - 2) * (x - 3) / 24; &#125;int main()&#123; n = read(); for (register int i = 1; i &lt;= n; ++i) a[i] = read(), ++cnt[a[i]]; std :: sort(a + 1, a + 1 + n); m = a[n]; n = std :: unique(a + 1, a + 1 + n) - a - 1; for (register int i = 1; i &lt;= n; ++i)&#123; for (register int j = i + 1; j &lt;= n &amp;&amp; a[j] - a[i] &lt; a[i]; ++j) ans += 1ll * cntt[a[j]] * cnt[a[i]] * cnt[a[j] - a[i]] * C2(cnt[a[j]]), ans += 1ll * C2(cnt[a[i]]) * C2(cnt[a[j] - a[i]]) * C2(cnt[a[j]]); if (a[i] * 2 &lt;= m) ans += 1ll * C4(cnt[a[i]]) * C2(cnt[a[i] * 2]); for (register int j = i + 1; j &lt;= n; ++j)&#123; ans += 1ll * C3(cnt[a[j]]) * cnt[a[i]] * cntt[a[j] - a[i]]; if ((a[i] &lt;&lt; 1) &lt; a[j] &amp;&amp; a[j] &lt; a[i] * 3) ans += 1ll * C3(cnt[a[j]]) * C2(cnt[a[i]]) * cnt[a[j] - (a[i] &lt;&lt; 1)]; if (a[j] == a[i] * 3) ans += 1ll * C3(cnt[a[j]]) * C3(cnt[a[i]]); &#125; for (register int j = 1; j &lt; i; ++j) if (a[i] + a[j] &lt;= m) cntt[a[i] + a[j]] += cnt[a[i]] * cnt[a[j]]; if ((a[i] &lt;&lt; 1) &lt;= m) cntt[a[i] &lt;&lt; 1] += C2(cnt[a[i]]); &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"LOJ","slug":"题解/LOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/LOJ/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"「LOJ 6062」「2017 山东一轮集训 Day2」Pair","slug":"loj6062-sol","date":"2019-08-18T11:38:00.000Z","updated":"2020-03-26T07:22:57.217Z","comments":true,"path":"loj6062-sol/","link":"","permalink":"https://autumnkite.github.io/loj6062-sol/","excerpt":"LOJ 6062","text":"LOJ 6062 题解 我们令 \\(c_i=h-b_i\\)，并将序列 \\(c\\) 从小到大排序。我们遍历 \\(a\\) 的所有长度为 \\(m\\) 的区间，将这个区间中的数从小到大排序后的第 \\(i\\) 个数记为 \\(d_i\\)。一个区间满足题目中的条件当且仅当 \\(d_i\\ge c_i\\)。 考虑离散，然后用权值线段树维护。记最大值为 \\(t\\)，对于所有 \\(c_i\\)，把线段树上 \\([c_i,t]\\) 这段区间加 \\(1\\)；对于当前区间中的所有 \\(a_i\\)，把线段树上 \\([a_i,t]\\) 这段区间减 \\(1\\)，判断是否满足条件只需要判断线段树上是否有 \\(&lt; 0\\) 的位置即可，这个可以维护最小值判断。正确性显然。 时间复杂度 \\(O(n\\log n)\\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 300005struct Segment_Tree&#123; int val[N &lt;&lt; 2], lz[N &lt;&lt; 2]; void up(int u)&#123; val[u] = std :: min(val[u &lt;&lt; 1], val[u &lt;&lt; 1 | 1]); &#125; void add(int u, int x)&#123; lz[u] += x, val[u] += x; &#125; void down(int u)&#123; if (lz[u]) add(u &lt;&lt; 1, lz[u]), add(u &lt;&lt; 1 | 1, lz[u]), lz[u] = 0; &#125; void modify(int u, int l, int r, int L, int R, int x)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return add(u, x), void(0); int md = (l + r) &gt;&gt; 1; down(u); if (L &lt;= md) modify(u &lt;&lt; 1, l, md, L, R, x); if (R &gt; md) modify(u &lt;&lt; 1 | 1, md + 1, r, L, R, x); up(u); &#125; bool query()&#123; return val[1] &gt;= 0; &#125;&#125;T;int n, m, h, a[N], b[N], t, c[N], ans;int main()&#123; n = read(), m = read(), h = read(); for (register int i = 1; i &lt;= m; ++i) b[i] = h - read(), c[++t] = b[i]; for (register int i = 1; i &lt;= n; ++i) a[i] = read(), c[++t] = a[i]; std :: sort(c + 1, c + 1 + t); t = std :: unique(c + 1, c + 1 + t) - c - 1; for (register int i = 1; i &lt;= m; ++i) b[i] = std :: lower_bound(c + 1, c + 1 + t, b[i]) - c; for (register int i = 1; i &lt;= n; ++i) a[i] = std :: lower_bound(c + 1, c + 1 + t, a[i]) - c; for (register int i = 1; i &lt;= m; ++i) T.modify(1, 1, t, b[i], t, 1), T.modify(1, 1, t, a[i], t, -1); ans = T.query(); for (register int i = m + 1; i &lt;= n; ++i) T.modify(1, 1, t, a[i], t, -1), T.modify(1, 1, t, a[i - m], t, 1), ans += T.query(); printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"LOJ","slug":"题解/LOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/LOJ/"}],"tags":[{"name":"离散","slug":"离散","permalink":"https://autumnkite.github.io/tags/%E7%A6%BB%E6%95%A3/"},{"name":"线段树","slug":"线段树","permalink":"https://autumnkite.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"「LOJ 6060」「2017 山东一轮集训 Day1 / SDWC2018 Day1」Set","slug":"loj6060-sol","date":"2019-08-18T11:24:00.000Z","updated":"2020-03-26T07:22:57.216Z","comments":true,"path":"loj6060-sol/","link":"","permalink":"https://autumnkite.github.io/loj6060-sol/","excerpt":"LOJ 6060","text":"LOJ 6060 题解 我们发现，\\(x_1\\text{ xor }x_2\\) 的值是固定的，也就是整个集合的异或和，我们记为 \\(s\\)。 很显然 \\(x_1+x_2\\ge s\\)，我们把 \\(x_1+x_2-s\\) 的值叫做“差值”。显然我们需要使差值最大化。 考虑 \\(s\\) 第 \\(i\\) 位（从右往左，从 \\(0\\) 开始标号，下同），若是 \\(1\\)，则 \\(x_1\\) 和 \\(x_2\\) 的这一位上有且仅有一个 \\(1\\)，那么显然对差值的贡献为 \\(0\\)；否则，\\(x_1\\) 和 \\(x_2\\) 的这一位要么都是 \\(0\\)，要么都是 \\(1\\)，显然最好是两个都为 \\(1\\)，那么会对差值产生 \\(2^{i+1}\\) 的贡献。 题目同时又规定，需要在最大化 \\(x_1+x_2\\) 的前提下，最小化 \\(x_1\\)，也就是要最大化 \\(x_2\\)。 自然想到线性基。通常我们在线性基中插入、查询时直接从最高位遍历到最低位，因为我们可以认为高位的优先级高于低位。 但是，在本题中，由于要优先最大化差值，所以我们需要先最大化 \\(x_2\\) 的所有在 \\(s\\) 中为 \\(0\\) 的那些位置。 于是，我们在插入、查询时，强制这些位置的优先级高于其他位置，而内部仍然按照从高位到低位的顺序进行遍历。这样就能保证先最大化差值，在这个前提下最大化 \\(x_2\\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;long long read()&#123; register long long x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 100005int n;long long sum, a[N], b[65], ans;void insert(long long x)&#123; for (register int i = 60; ~i; --i) if (!(sum &gt;&gt; i &amp; 1)) if (x &gt;&gt; i &amp; 1)&#123; if (!b[i]) return b[i] = x, void(0); x ^= b[i]; &#125; for (register int i = 60; ~i; --i) if (sum &gt;&gt; i &amp; 1) if (x &gt;&gt; i &amp; 1)&#123; if (!b[i]) return b[i] = x, void(0); x ^= b[i]; &#125;&#125;int main()&#123; n = read(); for (register int i = 1; i &lt;= n; ++i) a[i] = read(), sum ^= a[i]; for (register int i = 1; i &lt;= n; ++i) insert(a[i]); for (register int i = 60; ~i; --i) if (!(sum &gt;&gt; i &amp; 1)) if (!(ans &gt;&gt; i &amp; 1)) ans ^= b[i]; for (register int i = 60; ~i; --i) if (sum &gt;&gt; i &amp; 1) if (!(ans &gt;&gt; i &amp; 1)) ans ^= b[i]; printf(&quot;%lld\\n&quot;, sum ^ ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"LOJ","slug":"题解/LOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/LOJ/"}],"tags":[{"name":"线性基","slug":"线性基","permalink":"https://autumnkite.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"}]},{"title":"「LOJ 6059」「2017 山东一轮集训 Day1」Sum","slug":"loj6059-sol","date":"2019-08-18T10:56:00.000Z","updated":"2020-03-26T07:22:57.215Z","comments":true,"path":"loj6059-sol/","link":"","permalink":"https://autumnkite.github.io/loj6059-sol/","excerpt":"LOJ 6059","text":"LOJ 6059 题解 一眼 DP。并且很显然可以倍增优化。\\(dp_{i,j,k}\\) 表示 \\(2^i\\) 位，数字之和恰好为 \\(j\\)，模 \\(p\\) 为 \\(k\\) 时的方案数。有如下转移： \\[dp_{i,j,k}=\\sum_{j_1+j_2=j}\\sum_{k_1\\times 10^{2^{i-1}}+k_2\\equiv k\\pmod p}dp_{i-1,j_1,k_1}\\times dp_{i-1,j_2,k_2}\\] 直接这样做是 \\(O(p^2m^2\\log n)\\) 的。 只考虑 \\(j\\) 这一维，很显然可以用 FFT 优化，于是复杂度变为 \\(O(p^2m\\log m\\log n)\\)，但是常数较大，比较难卡过。 如果我们记 \\[tmp_{j,k}=\\sum_{t\\times 10^{2^{i-1}}\\equiv k\\pmod p} dp_{i-1,j,t}\\] 则原式变成了 \\[dp_{i,j,k}=\\sum_{j_1+j_2=j}\\sum_{(k_1+k_2)\\bmod p=k}tmp_{j_1,k_1}\\times dp_{i-1,j_2,k_2}\\] 然而这个 \\(\\bmod\\) 还是不太舒服，我们考虑把第二维值域扩充到 \\([0,2p)\\)，然后再把 \\([p,2p)\\) 这部分加到 \\([0,p)\\)。则式子变得十分美观： \\[dp_{i,j,k}=\\sum_{j_1+j_2=j}\\sum_{k_1+k_2=k}tmp_{j_1,k_1}\\times dp_{i-1,j_2,k_2}\\] 我们把 \\(j,k\\) 两维拍到一起，发现这个式子仍然是个卷积的形式。于是直接用 FFT 优化。 时间复杂度 \\(O(mp\\log (mp)\\log n)\\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define N 70005#define P 998244353int n, p, m, pw[35], dp[35][N], s[N], tmp[N], len;void upd(int &amp;x, int y)&#123; (x += y) &gt;= P ? x -= P : 0;&#125;int add(int x, int y)&#123; return (x += y) &gt;= P ? x - P : x;&#125;int del(int x, int y)&#123; return (x -= y) &lt; 0 ? x + P : x;&#125;int qpow(int a, int b = P - 2, int p = P)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % p) if (b &amp; 1) s = 1ll * s * a % p; return s;&#125;struct Number_Theory_Transform&#123; int n, rev[N], omega[N]; void init(int m)&#123; n = m; register int k = 0; while ((1 &lt;&lt; k) &lt; n) ++k; for (register int i = 1; i &lt; n; ++i) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; k &gt;&gt; 1; &#125; void NTT(int* a, int o)&#123; for (register int i = 0; i &lt; n; ++i) i &lt; rev[i] ? std :: swap(a[i], a[rev[i]]), 0 : 0; for (register int m = 1; m &lt; n; m &lt;&lt;= 1)&#123; register int l = m &lt;&lt; 1, omega1 = qpow(o == 1 ? 3 : 332748118, (P - 1) / l); omega[0] = 1; for (register int i = 1; i &lt; m; ++i) omega[i] = 1ll * omega[i - 1] * omega1 % P; for (register int* p = a; p &lt; a + n; p += l) for (register int i = 0; i &lt; m; ++i)&#123; register int t = 1ll * omega[i] * p[m + i] % P; p[m + i] = del(p[i], t), upd(p[i], t); &#125; &#125; if (o == -1)&#123; register int _n = qpow(n); for (register int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * _n % P; &#125; &#125;&#125;T;void multiply(int na, int *A, int nb, int *B, int *C)&#123; int n; if (na &lt;= 20 &amp;&amp; nb &lt;= 20)&#123; n = std :: max(na, nb); for (register int i = 0; i &lt; n; ++i) C[i] = 0; for (register int i = 0; i &lt; na; ++i) for (register int j = 0; j &lt; nb; ++j) if (i + j &lt; n) upd(C[i + j], 1ll * A[i] * B[j] % P); return; &#125; int a[N], b[N]; n = 1; while (n &lt; na + nb - 1) n &lt;&lt;= 1; for (register int i = 0; i &lt; na; ++i) a[i] = A[i]; for (register int i = 0; i &lt; nb; ++i) b[i] = B[i]; for (register int i = na; i &lt; n; ++i) a[i] = 0; for (register int i = nb; i &lt; n; ++i) b[i] = 0; T.init(n), T.NTT(a, 1), T.NTT(b, 1); for (register int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * b[i] % P; T.NTT(a, -1); for (register int i = 0; i &lt; std :: max(na, nb); ++i) C[i] = a[i];&#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;p, &amp;m); len = (m + 1) * p * 2; for (register int i = 0; i &lt;= 9 &amp;&amp; i &lt;= m; ++i) ++dp[0][i * p * 2 + i % p]; pw[0] = 1; for (register int i = 1; i &lt;= 30; ++i) pw[i] = pw[i - 1] &lt;&lt; 1; for (register int i = 0; i &lt;= 30; ++i) pw[i] = qpow(10, pw[i], p); for (register int i = 0; i &lt; 30; ++i)&#123; for (register int j = 0; j &lt; len; ++j) tmp[j] = 0; for (register int j = 0; j &lt;= m; ++j) for (register int k = 0; k &lt; p; ++k) upd(tmp[j * p * 2 + 1ll * k * pw[i] % p], dp[i][j * p * 2 + k]); multiply(len, tmp, len, dp[i], dp[i + 1]); for (register int j = 0; j &lt;= m; ++j) for (register int k = 0; k &lt; p; ++k) upd(dp[i + 1][j * p * 2 + k], dp[i + 1][j * p * 2 + k + p]), dp[i + 1][j * p * 2 + k + p] = 0; &#125; s[0] = 1; for (register int i = 30; ~i; --i) if ((1 &lt;&lt; i) &lt;= n)&#123; for (register int j = 0; j &lt; len; ++j) tmp[j] = 0; for (register int j = 0; j &lt;= m; ++j) for (register int k = 0; k &lt; p; ++k) upd(tmp[j * p * 2 + 1ll * k * pw[i] % p], s[j * p * 2 + k]), s[j * p * 2 + k] = 0; multiply(len, tmp, len, dp[i], s); for (register int j = 0; j &lt;= m; ++j) for (register int k = 0; k &lt; p; ++k) upd(s[j * p * 2 + k], s[j * p * 2 + k + p]), s[j * p * 2 + k + p] = 0; n -= (1 &lt;&lt; i); &#125; int sum = 0; for (register int i = 0; i &lt;= m; ++i) upd(sum, s[i * p * 2]), printf(&quot;%d &quot;, sum);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"LOJ","slug":"题解/LOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/LOJ/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"FFT","slug":"FFT","permalink":"https://autumnkite.github.io/tags/FFT/"},{"name":"倍增","slug":"倍增","permalink":"https://autumnkite.github.io/tags/%E5%80%8D%E5%A2%9E/"}]},{"title":"「Codeforces 1204D2」Kirk and a Binary String (hard version)","slug":"cf1204d2-sol","date":"2019-08-07T08:33:00.000Z","updated":"2020-03-26T07:22:57.187Z","comments":true,"path":"cf1204d2-sol/","link":"","permalink":"https://autumnkite.github.io/cf1204d2-sol/","excerpt":"题目传送门 题意 给定一个长度为 \\(n\\) 的 \\(01\\) 字符串 \\(s\\)，求一个长度为 \\(n\\) 的 \\(01\\) 字符串 \\(t\\)，满足 \\(\\forall 1\\le l\\le r\\le n:f(s[l,r])=f(t[l,r])\\)，其中 \\(f(s[l,r])\\) 表示 \\(s\\) 中第 \\(l\\) 个字符到第 \\(r\\) 个字符组成的子串的最长不下降子序列的长度，\\(f(t[l,r])\\) 同理。 在满足以上条件的同时，你需要最大化 \\(t\\) 中 \\(0\\) 的数量。 \\(n\\le 10^5\\)","text":"题目传送门 题意 给定一个长度为 \\(n\\) 的 \\(01\\) 字符串 \\(s\\)，求一个长度为 \\(n\\) 的 \\(01\\) 字符串 \\(t\\)，满足 \\(\\forall 1\\le l\\le r\\le n:f(s[l,r])=f(t[l,r])\\)，其中 \\(f(s[l,r])\\) 表示 \\(s\\) 中第 \\(l\\) 个字符到第 \\(r\\) 个字符组成的子串的最长不下降子序列的长度，\\(f(t[l,r])\\) 同理。 在满足以上条件的同时，你需要最大化 \\(t\\) 中 \\(0\\) 的数量。 \\(n\\le 10^5\\) 题解 显然一定是把 \\(s\\) 中的若干个 \\(1\\) 改成 \\(0\\)，且每段连续的 \\(1\\) 一定是修改它的一个前缀。 我们发现，一个区间的最长不下降子序列一定可以表示成在区间的某个位置断开（特殊地，也可以在左端点的前面或右端点的后面），然后选断点左边的 \\(0\\) 和断点右边的 \\(1\\)，显然这个断点需要满足左边 \\(0\\) 的个数加上右边 \\(1\\) 的个数等于这个区间的最长不下降子序列长度。我们称这样的断点为这个区间的答案断点。显然答案断点必须满足右边 \\(1\\) 的个数大于等于 \\(0\\) 的个数，左边 \\(0\\) 的个数大于等于 \\(1\\) 的个数。但这个不是充要条件。 考虑一个 \\(1\\) 能变成 \\(0\\) 的条件，假设这个位置为 \\(i\\)，那就是所有 \\(i+1\\) 开始的所有区间必须存在一个最长不下降子序列是全为 \\(1\\) 的。 我们又发现，只要 \\([i+1,n]\\) 这个区间满足条件，所有区间就一定满足条件。 先给出做法：从后往前扫，记 \\(cnt_i\\) 表示 \\(i\\sim n\\) 没有改变的位置中 \\(0\\) 的个数减去 \\(1\\) 的个数的值，那么 \\(cnt_{i+1}=0\\) 时把 \\(i\\) 这个位置改成 \\(0\\)。 考虑这样为什么是对的（以下内容纯属口胡）。对于 \\([i+1,n]\\) 的某个点 \\(j\\)，我们把 \\(j\\sim n\\) 的所有位置中 \\(0\\) 的个数减去 \\(1\\) 的个数的值记为 \\(sum_j\\)。由于改变只会是 \\(1\\) 变成 \\(0\\)，所以有 \\(cnt_j\\le sum_j\\)。又因为只要碰到 \\(1\\) 且 \\(cnt_j=0\\) 就会改变，所以 \\(sum_j\\ge cnt_j\\ge 0\\)。要 \\(j\\) 前面的位置要成为答案断点，必须有 \\(sum_j\\le 0\\)，所以 \\(sum_j\\) 只能等于 \\(0\\)，即 \\(0\\) 的个数等于 \\(1\\) 的个数。因为 \\(j\\sim n\\) 满足这个条件，当前的 \\(cnt_{i+1}=0\\)，所以 \\(i+1\\sim j-1\\) 所有位置中 \\(0\\) 的个数一定小于等于 \\(1\\) 的个数，要符合答案断点的必要条件，又只能是取等于。于是我们可以把 \\(i+1\\sim j-1\\) 的决策替换成 \\(1\\)，于是 \\(i+1\\sim n\\) 就一定存在一个全为 \\(1\\) 的最长不下降子序列。 差不多口胡完了，直接做就可以了。 代码 12345678910111213#include &lt;cstdio&gt;#include &lt;cstring&gt;#define N 100005char s[N];int n;int main()&#123; scanf(&quot;%s&quot;, s + 1), n = strlen(s + 1); for (register int i = n, cnt = 0; i; --i) if (s[i] == &#x27;0&#x27;) ++cnt; else if (cnt) --cnt; else s[i] = &#x27;0&#x27;; printf(&quot;%s\\n&quot;, s + 1);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"「Codeforces 1067A」Array Without Local Maximums","slug":"cf1067a-sol","date":"2019-08-07T08:33:00.000Z","updated":"2020-03-26T07:22:57.185Z","comments":true,"path":"cf1067a-sol/","link":"","permalink":"https://autumnkite.github.io/cf1067a-sol/","excerpt":"题目传送门 题意 给定长度为 \\(n\\) 的序列 \\(a\\)，有些位置是 \\(-1\\)，其余位置是 \\(1\\) 到 \\(200\\) 的一个整数。你需要在 \\(-1\\) 的位置填上\\(1\\) 到 \\(200\\) 的一个整数，使得序列 \\(a\\) 是好的。一个序列 \\(a\\) 是好的当且仅当满足以下三个条件： \\(a_1\\le a_2\\) \\(a_n\\le a_{n-1}\\) \\(\\forall i\\in [2,n-1],a_i\\le \\max(a_{i-1},a_{i+1})\\) 求方案数 \\(\\bmod 998244353\\) 的值。 \\(n\\le 10^5\\)","text":"题目传送门 题意 给定长度为 \\(n\\) 的序列 \\(a\\)，有些位置是 \\(-1\\)，其余位置是 \\(1\\) 到 \\(200\\) 的一个整数。你需要在 \\(-1\\) 的位置填上\\(1\\) 到 \\(200\\) 的一个整数，使得序列 \\(a\\) 是好的。一个序列 \\(a\\) 是好的当且仅当满足以下三个条件： \\(a_1\\le a_2\\) \\(a_n\\le a_{n-1}\\) \\(\\forall i\\in [2,n-1],a_i\\le \\max(a_{i-1},a_{i+1})\\) 求方案数 \\(\\bmod 998244353\\) 的值。 \\(n\\le 10^5\\) 题解 考虑 DP，\\(dp_{i,j,0/1}\\) 表示前 \\(i\\) 个数，\\(a_i\\) 为 \\(j\\)，\\(a_{i-1}&lt; a_i\\) / \\(a_{i-1}\\ge a_i\\) 时的方案数。有转移 \\[\\begin{aligned} dp_{i,j,0}&amp;=\\sum_{k=1}^{j-1} dp_{i-1,k,0}+dp_{i-1,k,1}\\\\ dp_{i,j,1}&amp;=dp_{i-1,j,0}+\\sum_{k=j}^{200} dp_{i-1,k,1}\\end{aligned}\\] 可以发现这个式子可以用前缀和优化。 时间复杂度 \\(O(nm)\\)，其中 \\(m=200\\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cctype&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 100005#define P 998244353int n, a[N], dp[N][205][2], pre[N][205][2];int add(int x, int y)&#123; return (x += y) &gt;= P ? x - P : x;&#125;int del(int x, int y)&#123; return (x -= y) &lt; 0 ? x + P : x;&#125;int suf(int i, int j, int k)&#123; return del(pre[i][200][k], pre[i][j - 1][k]);&#125;int main()&#123; n = read(); for (register int i = 1; i &lt;= n; ++i) a[i] = read(); for (register int i = 1; i &lt;= 200; ++i)&#123; if (a[1] == -1 || i == a[1]) dp[1][i][0] = 1; pre[1][i][0] = add(pre[1][i - 1][0], dp[1][i][0]); &#125; for (register int i = 2; i &lt;= n; ++i) for (register int j = 1; j &lt;= 200; ++j)&#123; if (a[i] == -1 || a[i] == j)&#123; dp[i][j][0] = add(pre[i - 1][j - 1][0], pre[i - 1][j - 1][1]); dp[i][j][1] = add(dp[i - 1][j][0], suf(i - 1, j, 1)); &#125; pre[i][j][0] = add(pre[i][j - 1][0], dp[i][j][0]); pre[i][j][1] = add(pre[i][j - 1][1], dp[i][j][1]); &#125; printf(&quot;%d\\n&quot;, pre[n][200][1]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"}]},{"title":"「模拟赛20190705 T1」第一题","slug":"vc190705A-sol","date":"2019-07-07T05:14:00.000Z","updated":"2020-03-27T09:42:41.558Z","comments":true,"path":"vc190705A-sol/","link":"","permalink":"https://autumnkite.github.io/vc190705A-sol/","excerpt":"题意 给定一棵 \\(n\\) 个点的有根树，每个点有一个正整数\\(b_i\\)，这个点的权值是 \\([0,b_i]\\) 的一个随机实数。 求每个点的权值严格小于这个点所有儿子的权值的概率，模 \\(10^9+7\\)。 \\(n\\le 300,b_i\\le 10^9\\)。","text":"题意 给定一棵 \\(n\\) 个点的有根树，每个点有一个正整数\\(b_i\\)，这个点的权值是 \\([0,b_i]\\) 的一个随机实数。 求每个点的权值严格小于这个点所有儿子的权值的概率，模 \\(10^9+7\\)。 \\(n\\le 300,b_i\\le 10^9\\)。 所谓题解 旺仔的方法 考虑暴力。实数显然不能直接枚举。然而 \\(b_i\\) 只有 \\(n\\) 个，我们考虑离散，枚举每个点的权值在哪一段内。 我们按权值所属段是否相同分出一些联通块。树上的联通块还是一棵树，我们考虑求出每个联通块内部的概率。 由于一个联通块内的权值都属于同一段，也就是权值取值范围相同，那么问题转化成了： 给定一棵树，每个点的权值是 \\([0,1)\\) 的随机实数，求每个点权值严格小于这个点每个儿子的权值的概率。 这个问题是一个经典问题，答案是 \\(\\prod\\limits_{i=1}^{n} \\frac{1}{sz_i}\\)，可以感性理解一下。我不会证明 枚举每个点太慢，我们考虑 DP。用 \\(dp_{i,j,k}\\) 表示以 \\(i\\) 为根的子树，\\(i\\) 的取值范围为 \\(j\\)，以 \\(i\\) 为根的联通块大小为 \\(k\\) 时的概率。可以通过枚举每个儿子的取值范围是否与 \\(i\\) 相同，枚举每个儿子的联通块大小进行转移。 相当于 \\(n\\) 次树上背包，每次 \\(O(n^2)\\)，复杂度为 \\(O(n^3)\\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 305#define P 1000000007int n, m, a[N], b[N], fa[N], rt, inv[N], inva[N], sz[N], dp[N][N][N], tmp[N];std :: vector&lt;int&gt; E[N];int qpow(int a, int b)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if (b &amp; 1) s = 1ll * s * a % P; return s;&#125;void add(int &amp;x, int y)&#123; (x += y) &gt;= P ? x -= P : 0;&#125;void dfs(int u)&#123; sz[u] = 1; for (register int i = 0; i &lt; b[u]; ++i) dp[u][i][1] = 1ll * (a[i + 1] - a[i]) * inva[b[u]] % P; for (register int i = 0; i &lt; E[u].size(); ++i)&#123; int v = E[u][i], sum = 0; dfs(v); for (register int j = b[v] - 1; j &gt;= b[u]; --j) for (register int k = 1; k &lt;= sz[v]; ++k) add(sum, dp[v][j][k]); for (register int j = b[u] - 1; ~j; --j)&#123; for (register int k = 1; k &lt;= sz[u] + sz[v]; ++k) tmp[k] = 0; for (register int k = 1; k &lt;= sz[u]; ++k) for (register int l = 1; l &lt;= sz[v]; ++l) add(tmp[k + l], 1ll * dp[u][j][k] * dp[v][j][l] % P); for (register int k = 1; k &lt;= sz[u] + sz[v]; ++k) dp[u][j][k] = (1ll * dp[u][j][k] * sum + tmp[k]) % P; for (register int k = 1; k &lt;= sz[v]; ++k) add(sum, dp[v][j][k]); &#125; sz[u] += sz[v]; &#125; for (register int j = 0; j &lt; b[u]; ++j) for (register int k = 1; k &lt;= sz[u]; ++k) dp[u][j][k] = 1ll * dp[u][j][k] * inv[k] % P;&#125;int main()&#123; freopen(&quot;a.in&quot;, &quot;r&quot;, stdin); freopen(&quot;a.out&quot;, &quot;w&quot;, stdout); n = read(); for (register int i = 1; i &lt;= n; ++i)&#123; a[i] = b[i] = read(), fa[i] = read(); if (fa[i]) E[fa[i]].push_back(i); else rt = i; &#125; std :: sort(a + 1, a + 1 + n); m = std :: unique(a + 1, a + 1 + n) - a - 1; for (register int i = 1; i &lt;= n; ++i) b[i] = std :: lower_bound(a + 1, a + 1 + m, b[i]) - a; for (register int i = 1; i &lt;= n; ++i) inv[i] = qpow(i, P - 2); for (register int i = 1; i &lt;= m; ++i) inva[i] = qpow(a[i], P - 2); dfs(rt); int ans = 0; for (register int i = 0; i &lt; b[rt]; ++i) for (register int j = 1; j &lt;= n; ++j) add(ans, dp[rt][i][j]); printf(&quot;%d&quot;, ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"模拟赛","slug":"题解/模拟赛","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"概率","slug":"概率","permalink":"https://autumnkite.github.io/tags/%E6%A6%82%E7%8E%87/"},{"name":"树形DP","slug":"树形DP","permalink":"https://autumnkite.github.io/tags/%E6%A0%91%E5%BD%A2DP/"}]},{"title":"「AT1736」「Xmas Contest 2015」Destroy the Duplicated Poem","slug":"atcoder-xmas15D-sol","date":"2019-05-20T12:31:00.000Z","updated":"2020-03-27T09:42:50.835Z","comments":true,"path":"atcoder-xmas15D-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-xmas15D-sol/","excerpt":"题目传送门 题意 有 \\(n+1\\) 个字符串 \\(S_0,S_1,S_2,\\cdots,S_n\\)。\\(S_0\\) 是空串，\\(S_i\\) 是 \\(S_{a_i}\\) 后加上字符 \\(c_i\\) 的字符串。\\(a_i,c_i\\) 都是给定的且 \\(0\\le a_i&lt; i\\)，\\(c_i\\) 是小写字母。 定义字符串 \\(T\\) 的周期是所有满足 \\(T\\) 是 \\(X\\) 重复无穷多次后的字符串的前缀的字符串 \\(X\\) 中最短的。例如 abcabca 的周期是 abc。 求 \\(S_1,S_2,S_3,\\cdots,S_n\\) 的周期的长度。 \\(n\\le 500\\,000\\)","text":"题目传送门 题意 有 \\(n+1\\) 个字符串 \\(S_0,S_1,S_2,\\cdots,S_n\\)。\\(S_0\\) 是空串，\\(S_i\\) 是 \\(S_{a_i}\\) 后加上字符 \\(c_i\\) 的字符串。\\(a_i,c_i\\) 都是给定的且 \\(0\\le a_i&lt; i\\)，\\(c_i\\) 是小写字母。 定义字符串 \\(T\\) 的周期是所有满足 \\(T\\) 是 \\(X\\) 重复无穷多次后的字符串的前缀的字符串 \\(X\\) 中最短的。例如 abcabca 的周期是 abc。 求 \\(S_1,S_2,S_3,\\cdots,S_n\\) 的周期的长度。 \\(n\\le 500\\,000\\) 题解 由题目给定的字符串生成方式，可以想到字典树。所有字符串对应字典树上根到某个点的路径。 可以发现，字符串的周期一定是字符串的某个前缀。且这个前缀的长度一定是 \\(T[1,m-x]=T[m-x+1,m]\\) 的 \\(x\\) 中的最小值（\\(T[l..r]\\) 表示 \\(T\\) 中 \\(l\\) 到 \\(r\\) 的子串，\\(m\\) 表示 \\(T\\) 的长度）。\\(x\\) 最小，那么 \\(m-x\\) 是最大的，所以这是一个求所有前缀=后缀中最长的前缀的形式，那么很自然地能想到 KMP。 在 trie 上做 KMP，不能直接跳 fail，如下图所示的情况就可以卡成 \\(O(n^2)\\) 的复杂度： 因为都是小写字母，所以用 \\(go_{i,c}\\)（在节点 \\(i\\) 表示的字符串后加入字符 \\(c\\) 后最长的前缀=后缀所在的节点） 记下这个跳 fail 的过程即可（有点像 AC 自动机，但不完全一样）。 时间复杂度 \\(O(nk)\\)，\\(k\\) 是字符集大小，这里为 \\(26\\)。 代码 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#define N 500005int n, dep[N], fail[N], go[N][26];char a[N];int edge, hd[N], to[N], pr[N];void addedge(int u, int v)&#123; to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;&#125;void dfs(int u, int fa = -1)&#123; int tmp; if (~fa)&#123; dep[u] = dep[fa] + 1, fail[u] = go[fa][a[u]]; for (register int i = 0; i &lt; 26; ++i) go[u][i] = go[fail[u]][i]; if (fail[u] == fa) go[u][a[u]] = u; tmp = go[fa][a[u]], go[fa][a[u]] = u; &#125; for (register int i = hd[u]; i; i = pr[i]) dfs(to[i], u); if (~fa) go[fa][a[u]] = tmp;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (register int i = 1, fa; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;fa), addedge(fa, i); // 建树 scanf(&quot;%s&quot;, a + 1); for (register int i = 1; i &lt;= n; ++i) a[i] -= &#x27;a&#x27;; dep[0] = 0, dfs(0); for (register int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, dep[i] - dep[fail[i]]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"Xmas Contest 2015","slug":"题解/AtCoder/Xmas-Contest-2015","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/Xmas-Contest-2015/"}],"tags":[{"name":"trie","slug":"trie","permalink":"https://autumnkite.github.io/tags/trie/"},{"name":"KMP","slug":"KMP","permalink":"https://autumnkite.github.io/tags/KMP/"}]},{"title":"「AT1735」「Xmas Contest 2015」Colored Tiles","slug":"atcoder-xmas15C-sol","date":"2019-05-18T12:39:00.000Z","updated":"2020-03-27T09:42:22.964Z","comments":true,"path":"atcoder-xmas15C-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-xmas15C-sol/","excerpt":"题目传送门 题意 这是一道交互题。 交互库中生成了一个 \\(n\\times m\\) 的每个格子有颜色的矩阵。颜色可以有任意多种。给定的是 \\(n,m\\)。记矩阵中第 \\(x\\) 行第 \\(y\\) 列的颜色为 \\(col(x,y)\\)（矩阵的行列下标从 \\(1\\) 开始）。 你可以进行询问，询问的格式是 ? x1 y1 x2 y2，交互库会告诉你 \\(col(x1,y1)=col(x2,y2)\\) 并且 \\(col(x1,y2)=col(x2,y1)\\) 是否成立。询问次数不能超过 \\(4\\,500\\)。 最后你应该输出 ! ans，\\(ans\\) 表示中心对称的子矩阵的数量。 \\(n\\le 5,m\\le 100\\)","text":"题目传送门 题意 这是一道交互题。 交互库中生成了一个 \\(n\\times m\\) 的每个格子有颜色的矩阵。颜色可以有任意多种。给定的是 \\(n,m\\)。记矩阵中第 \\(x\\) 行第 \\(y\\) 列的颜色为 \\(col(x,y)\\)（矩阵的行列下标从 \\(1\\) 开始）。 你可以进行询问，询问的格式是 ? x1 y1 x2 y2，交互库会告诉你 \\(col(x1,y1)=col(x2,y2)\\) 并且 \\(col(x1,y2)=col(x2,y1)\\) 是否成立。询问次数不能超过 \\(4\\,500\\)。 最后你应该输出 ! ans，\\(ans\\) 表示中心对称的子矩阵的数量。 \\(n\\le 5,m\\le 100\\) 题解 上图这个矩阵如果是中心对称的，那么 \\(A\\) 反转一下一定与 \\(B\\) 相等，且 \\(C\\) 也是中心对称的。 那么考虑 \\(A,B\\) 两行，设他们的行号分别为 \\(i,j\\)，中间位置为 \\(k\\)，两边为 \\(l,r\\)，那么 \\(A\\) 反转一下与 \\(B\\) 相等可以转化成 \\(\\forall 0\\le x\\le k-l,col(i,k-x)=col(j,k+x)\\text{ and }col(i,k+x)=col(j,k-x)\\)。这个与询问的格式就一样了。 并且可以发现，这是一个“类回文”的形式，所以可以用 manacher 解决，这样就可以减少询问次数。为了解决奇偶性问题，可以当作把每行扩展一倍，在相邻两个格子之间插入其他字符，注意询问时候要变回原来的下标。 就是说，对于任意两行 \\(i,j(1\\le i\\le j\\le n)\\)，求出每列向左右可以扩展的最多的列数。然后枚举矩阵的上下两行和对称中心所在的列数，求出在该条件下的极大中心对称的矩阵的列数，然后直接统计。 可以用 map 减少一定量的询问次数。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;map&gt;int n, m, len[6][6][205];struct node&#123; int a, b, c, d; bool operator &lt; (const node &amp;res) const &#123; return a &lt; res.a || (a == res.a &amp;&amp; b &lt; res.b) || (a == res.a &amp;&amp; b == res.b &amp;&amp; c &lt; res.c) || (a == res.a &amp;&amp; b == res.b &amp;&amp; c == res.c &amp;&amp; d &lt; res.d); &#125;&#125;;std :: map&lt;node, int&gt; M;bool check(int x1, int y1, int x2, int y2)&#123; if (x1 &gt; x2 || y1 &gt; y2 || x1 &lt; 1 || x2 &gt; n || y1 &lt; 1 || y2 &gt; (m &gt;&gt; 1)) return 0; if (x1 == x2 &amp;&amp; y1 == y2) return 1; if (M.count((node)&#123;x1, y1, x2, y2&#125;)) return M[(node)&#123;x1, y1, x2, y2&#125;]; printf(&quot;? %d %d %d %d\\n&quot;, x1, y1, x2, y2), fflush(stdout); char opt[5]; scanf(&quot;%s&quot;, opt); return M[(node)&#123;x1, y1, x2, y2&#125;] = (opt[0] == &#x27;y&#x27;);&#125;void manacher(int x, int y, int *hw)&#123; int mr = 0, mid = 0, n = m; hw[0] = 1; for (register int i = 1; i &lt;= n; ++i)&#123; hw[i] = i &lt;= mr ? std :: min(hw[(mid &lt;&lt; 1) - i], mr - i + 1) : 0; if (i + hw[i] &lt;= mr) continue; while ((i - hw[i]) % 2 == 0 || check(x, (i - hw[i] + 1) / 2, y, (i + hw[i] + 1) / 2)) ++hw[i]; if (i + hw[i] - 1 &gt; mr) mid = i, mr = i + hw[i] - 1; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); m &lt;&lt;= 1; for (register int i = 1; i &lt;= n; ++i) for (register int j = i; j &lt;= n; ++j) manacher(i, j, len[i][j]); int ans = 0; for (register int i = 1; i &lt;= n; ++i) for (register int j = i; j &lt;= n; ++j) for (register int k = 1; k &lt;= m; ++k)&#123; int s = 1e9; for (register int l = i, r = j; l &lt;= r; ++l, --r) s = std :: min(s, len[l][r][k]); ans += s &gt;&gt; 1; &#125; printf(&quot;! %d\\n&quot;, ans), fflush(stdout);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"Xmas Contest 2015","slug":"题解/AtCoder/Xmas-Contest-2015","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/Xmas-Contest-2015/"}],"tags":[{"name":"交互","slug":"交互","permalink":"https://autumnkite.github.io/tags/%E4%BA%A4%E4%BA%92/"},{"name":"manacher","slug":"manacher","permalink":"https://autumnkite.github.io/tags/manacher/"}]},{"title":"「Codeforces 1156E」Special Segments of Permutation","slug":"cf1156e-sol","date":"2019-05-08T13:32:00.000Z","updated":"2020-03-26T07:22:57.187Z","comments":true,"path":"cf1156e-sol/","link":"","permalink":"https://autumnkite.github.io/cf1156e-sol/","excerpt":"题目传送门 题意 给定一个长度为 \\(n\\) 的排列 \\(a\\)，求有多少区间 \\([l,r]\\) 满足 \\(a_l+a_r=\\max\\limits_{i=l}^{r}a_i\\)。 \\(n\\le 200\\,000\\)","text":"题目传送门 题意 给定一个长度为 \\(n\\) 的排列 \\(a\\)，求有多少区间 \\([l,r]\\) 满足 \\(a_l+a_r=\\max\\limits_{i=l}^{r}a_i\\)。 \\(n\\le 200\\,000\\) 题解 用单调栈对每一个 \\(a_i\\) 求出 \\(l_i=j+1\\)，\\(j\\) 是从 \\(i\\) 向左第一个满足 \\(a_j&gt;a_i\\) 的位置，\\(r_i\\) 同理。 那么题目变为对于每个 \\(i\\) 求在 \\([l_i,i-1]\\) 和 \\([i+1,r_i]\\) 中各选出一个数使得这两个数之和为 \\(a_i\\) 的方案数。 结论是，我们只要枚举这两个区间中短的那个区间的每个数 \\(a_j\\)，然后在另一个区间中查询 \\(a_i-a_j\\) 是否存在即可。 看起来是 \\(O(n^2)\\)，其实是 \\(O(n\\log n)\\) 的，因为每个数最多会被枚举到 \\(\\log n\\) 次。假设某个数被枚举到的所有区间 \\([l_i,r_i]\\) 中，最大的区间长度为 \\(m\\)，那么由于枚举的是短的区间，短的区间长度不会超过 \\(\\frac{m}{2}\\)。而如果这个数要被另一个区间枚举到，这个区间一定被之前那个短的区间包含，所以这个区间总长度不会超过 \\(\\frac{m}{2}\\)，而且又是短的区间，所以变成了 \\(\\frac{m}{4}\\)……感性理解一下，每个数枚举到的次数不会超过 \\(\\log n\\)。 代码 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define N 200005int n, a[N], p[N], l[N], r[N], top, sta[N], ans;bool in(int x, int l, int r)&#123; return l &lt;= p[x] &amp;&amp; p[x] &lt;= r;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (register int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i), p[a[i]] = i; for (register int i = 1; i &lt;= n; ++i)&#123; while (top &gt; 0 &amp;&amp; a[i] &gt; a[sta[top]]) --top; l[i] = sta[top] + 1; sta[++top] = i; &#125; sta[top = 0] = n + 1; for (register int i = n; i; --i)&#123; while (top &gt; 0 &amp;&amp; a[i] &gt; a[sta[top]]) --top; r[i] = sta[top] - 1; sta[++top] = i; &#125; for (register int i = 1; i &lt;= n; ++i)&#123; int l1 = l[i], r1 = i - 1, l2 = i + 1, r2 = r[i]; if (r1 - l1 &gt; r2 - l2) std :: swap(l1, l2), std :: swap(r1, r2); for (register int j = l1; j &lt;= r1; ++j) if (in(a[i] - a[j], l2, r2)) ++ans; &#125; printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"复杂度分析","slug":"复杂度分析","permalink":"https://autumnkite.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"},{"name":"单调栈","slug":"单调栈","permalink":"https://autumnkite.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"「AT1734」「Xmas Contest 2015」Broken Christmas Tree","slug":"atcoder-xmas15B-sol","date":"2019-04-27T13:26:00.000Z","updated":"2020-03-26T07:22:57.173Z","comments":true,"path":"atcoder-xmas15B-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-xmas15B-sol/","excerpt":"题目传送门 题意 \\(n\\) 个点的完全图中去掉给定的 \\(m\\) 条边后，问是否存在一个生成树。若是，求出一种方案。 \\(n,m\\le 2\\times 10^5\\)","text":"题目传送门 题意 \\(n\\) 个点的完全图中去掉给定的 \\(m\\) 条边后，问是否存在一个生成树。若是，求出一种方案。 \\(n,m\\le 2\\times 10^5\\) 题解 显然贪心。假定以 \\(1\\) 为根节点，把 \\(1\\) 能连的点都与 \\(1\\) 相连，然后对这些点进行同样的操作，直到所有点都相互连通。 用 set 记录每个点不能连的点，以及当前还有哪些点没有加入最小生成树（记做 \\(num\\)）。用队列记录已经加入的点，对于队列中的点 \\(u\\)，遍历 \\(num\\)，若可以连则连，加入队列，并且从 \\(num\\) 中删除；否则跳过。 关键是复杂度分析。对于遍历 \\(num\\) 时可以连的情况，这种情况一定不会超过 \\(n-1\\) 次，因为每次都会从 \\(num\\) 中删除一个点；对于不可以连的情况，一定不会超过 \\(m\\) 次，因为一条不能连的边不会重复遍历。所以总次数为 \\(O(n+m)\\) 次。由于判断一个点与另一个点能否连接需要 \\(O(\\log n)\\)，所以总复杂度为 \\(O((n+m)\\log n)\\)。 代码 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;set&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 200005int n, m, h, t, Q[N], cnt, x[N], y[N];std :: set&lt;int&gt; num, E[N];int main()&#123; n = read(), m = read(); for (register int i = 1; i &lt;= m; ++i)&#123; int x = read(), y = read(); E[x].insert(y), E[y].insert(x); &#125; for (register int i = 2; i &lt;= n; ++i) num.insert(i); h = 0, t = 1, Q[t] = 1; while (h &lt; t)&#123; int u = Q[++h]; for (auto it = num.begin(), It = it; it != num.end(); ) // 遍历，注意 auto 需要 C++11 if (!E[u].count(*it)) x[++cnt] = u, y[cnt] = *it, Q[++t] = *it, It = it, ++it, num.erase(It); else ++it; &#125; if (num.size()) printf(&quot;No\\n&quot;); else&#123; printf(&quot;Yes\\n&quot;); for (register int i = 1; i &lt;= cnt; ++i) printf(&quot;%d %d\\n&quot;, x[i], y[i]); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"Xmas Contest 2015","slug":"题解/AtCoder/Xmas-Contest-2015","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/Xmas-Contest-2015/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"复杂度分析","slug":"复杂度分析","permalink":"https://autumnkite.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"}]},{"title":"「AT1733」「Xmas Contest 2015」Accumulation","slug":"atcoder-xmas15A-sol","date":"2019-04-27T07:23:00.000Z","updated":"2020-03-26T07:22:57.172Z","comments":true,"path":"atcoder-xmas15A-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-xmas15A-sol/","excerpt":"题目传送门 题意 123456input ninput x, t, a, b, cfor i = 1 .. n : s_i = x for j = 1 .. t : x = (a * x + b) mod c 求 \\(\\sum\\limits_{i=1}^{n} s_i\\) 的值（不需要对 \\(c\\) 取模）。 \\(n\\le 10^6, t\\le 10^9,0\\le x,a,b&lt; c\\le 10^9\\)","text":"题目传送门 题意 123456input ninput x, t, a, b, cfor i = 1 .. n : s_i = x for j = 1 .. t : x = (a * x + b) mod c 求 \\(\\sum\\limits_{i=1}^{n} s_i\\) 的值（不需要对 \\(c\\) 取模）。 \\(n\\le 10^6, t\\le 10^9,0\\le x,a,b&lt; c\\le 10^9\\) 题解 考虑快速进行 for j = 1 .. t : x = (a * x + b) mod c 这段操作。 \\[\\begin{aligned} j=1: &amp;\\quad ax+b \\\\ j=2: &amp;\\quad a(ax+b)+b=a^2x+ab+b \\\\ j=3: &amp; \\quad a(a^2x+ab+b)+b=a^3x+a^2b+ab+b \\\\ j=4: &amp; \\quad a^4x+a^3b+a^2b+ab+b\\\\ \\vdots&amp; \\\\ j=t:&amp;\\quad a^tx+\\sum_{k=0}^{t-1} a^kb=a^tx+b\\sum_{k=0}^{t-1}a^k\\end{aligned}\\] 如果 \\(c\\) 为质数，则这个式子可以直接用快速幂和等比数列求和公式进行计算。然而并没有保证 \\(c\\) 是质数，怎么办呢？可以发现，\\(x\\) 和 \\(b\\) 在这个式子中是常数，而 \\(a^t\\) 和 \\(\\sum\\limits_{k=0}^{t-1}a^k\\) 有某种联系…… 考虑用矩阵表示（记 \\(f(t)=\\sum\\limits_{k=0}^{t-1}a^k\\)） \\[A=\\begin{bmatrix} a^t &amp; f(t) \\end{bmatrix},B=\\begin{bmatrix} a^{t+1} &amp; f(t+1) \\end{bmatrix}\\] \\(A\\) 如何才能转化为 \\(B\\)，通过计算发现：\\(a^{t+1}=a\\cdot a^t,f(t+1)=a^t+f(t)\\)，那么很显然转移矩阵为 \\[C=\\begin{bmatrix} a &amp; 1\\\\ 0 &amp; 1\\end{bmatrix}\\] 可以再验证一下 \\(A\\times C=B\\)。于是直接用矩阵快速幂进行优化即可。 可以发现，最后 \\(x\\) 的转移一定可以表示为 \\(px+q\\) 的形式，所以只要一开始预处理 \\(p,q\\)，不需要每次进行矩阵快速幂。 时间复杂度 \\(O(n+\\log t)\\)。 代码 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;int n, x, m, a, b, P;long long ans;struct Matrix&#123; int a[2][2]; Matrix operator * (const Matrix &amp;res) const &#123; Matrix ret; memset(ret.a, 0, sizeof ret.a); for (register int i = 0; i &lt; 2; ++i) for (register int k = 0; k &lt; 2; ++k) for (register int j = 0; j &lt; 2; ++j) ret.a[i][j] = (ret.a[i][j] + 1ll * a[i][k] * res.a[k][j]) % P; return ret; &#125;&#125;A, B;Matrix qpow(Matrix a, int b)&#123; // 矩阵快速幂 Matrix s = a; for (--b; b; b &gt;&gt;= 1, a = a * a) if (b &amp; 1) s = s * a; return s;&#125;int main()&#123; scanf(&quot;%d%d%d%d%d%d&quot;, &amp;n, &amp;x, &amp;m, &amp;a, &amp;b, &amp;P); A.a[0][0] = a, A.a[0][1] = 1; // 初始矩阵 B.a[0][0] = a, B.a[0][1] = 1, B.a[1][0] = 0, B.a[1][1] = 1; // 转移矩阵 if (m &gt; 1) A = A * qpow(B, m - 1); a = A.a[0][0], b = 1ll * b * A.a[0][1] % P; for (register int i = 1; i &lt;= n; ++i) ans += x, x = (1ll * a * x + b) % P; printf(&quot;%lld\\n&quot;, ans);&#125; upd: 修复了代码中的一个漏洞","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"Xmas Contest 2015","slug":"题解/AtCoder/Xmas-Contest-2015","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/Xmas-Contest-2015/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"矩阵","slug":"矩阵","permalink":"https://autumnkite.github.io/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"「Codeforces 1119F」Niyaz and Small Degrees","slug":"cf1119f-sol","date":"2019-04-21T11:35:00.000Z","updated":"2020-03-26T07:22:57.186Z","comments":true,"path":"cf1119f-sol/","link":"","permalink":"https://autumnkite.github.io/cf1119f-sol/","excerpt":"题目传送门 题意 给定一棵 \\(n\\) 个节点的树，有边权，对于所有 \\(x\\ (0\\le x &lt; n)\\)，可以删去一些边，求使得所有节点的度数 \\(\\le x\\) 的删掉的边的边权之和的最小值。 节点的度数指以该点为某一端点的边的数量。 \\(n\\le 250\\,000\\)","text":"题目传送门 题意 给定一棵 \\(n\\) 个节点的树，有边权，对于所有 \\(x\\ (0\\le x &lt; n)\\)，可以删去一些边，求使得所有节点的度数 \\(\\le x\\) 的删掉的边的边权之和的最小值。 节点的度数指以该点为某一端点的边的数量。 \\(n\\le 250\\,000\\) 暴力——独立求解 显然是树形 DP，记 \\(dp_{u,0/1}\\) 表示 \\(u\\) 与父亲的连边不删/删时，以 \\(u\\) 为根的子树满足所有节点度数 \\(\\le x\\) 的删掉的边的最小值。 不考虑度数限制，显然有 \\(dp_{u,0}=dp_{u,1}=\\sum \\min(dp_{v,0},dp_{v,1}+w)\\)（\\(v\\) 是 \\(u\\) 的儿子，\\(w\\) 表示对应边的边权）。记 \\(d_i\\) 表示 \\(i\\) 的度数，把 \\(dp_{v,1}+w\\le dp_{v,0}\\) 的儿子 \\(v\\) 叫做好儿子，其余叫做坏儿子。考虑度数限制，假设求 \\(dp_{u,0}\\)（\\(dp_{u,1}\\) 同理），记 \\(cnt\\) 为好儿子数量，我们需要把 \\(\\max(0,d_i-x-cnt)\\) 个坏儿子变成好儿子。 只需要维护一个堆，将所有坏儿子 \\(dp_{v,1}+w-dp_{v,0}\\) 的值压入堆中，将前 \\(\\max(0,d_i-x-cnt)\\) 小的值之和记为 \\(sum\\)，则 \\(dp_{u,0}=sum+\\sum dp_{v,0}\\)。 时间复杂度 \\(O(n^2\\log n)\\)。 暴力代码 注意代码实现与上述有很大差别，但思想一致。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 250005#define INF 0x3f3f3f3f3f3f3f3fllint n;int edge, to[N &lt;&lt; 1], pr[N &lt;&lt; 1], tw[N &lt;&lt; 1], hd[N];void addedge(int u, int v, int w)&#123; to[++edge] = v, tw[edge] = w, pr[edge] = hd[u], hd[u] = edge;&#125;long long dp[N][2];void dfs(int X, int u, int fa = 0)&#123; std :: vector&lt;long long&gt; val; dp[u][0] = dp[u][1] = 0; for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa) dfs(X, v, u), val.push_back(dp[v][1] + tw[i] - dp[v][0]), dp[u][0] += dp[v][0]; dp[u][1] = dp[u][0]; std :: sort(val.begin(), val.end()); int d = val.size(); for (register int i = 0; i &lt; d &amp;&amp; (i &lt; d - X || val[i] &lt; 0); ++i) dp[u][1] += val[i]; if (!X) return dp[u][0] = INF, void(0); ++d; for (register int i = 0; i &lt; d - 1 &amp;&amp; (i &lt; d - X || val[i] &lt; 0); ++i) dp[u][0] += val[i];&#125;int main()&#123; n = read(); for (register int i = 1, u, v, w; i &lt; n; ++i) u = read(), v = read(), w = read(), addedge(u, v, w), addedge(v, u, w); for (register int i = 0; i &lt; n; ++i) dfs(i, 1), printf(&quot;%lld &quot;, dp[1][1]);&#125; 正解 可以发现对于某个 \\(x\\)，若一个节点 \\(u\\) 的度数 \\(\\le x\\)，那这个点本身就不需要考虑了，只需要将 \\(w(u,v)\\) 加入与 \\(v\\) 的堆中。 也就是说，我们把 \\(u\\) 当做叶子节点来看待，即： 1234 /\\ /\\/__\\ /__\\ \\ / u 也相当于把 \\(u\\) “删去”，不同的是，与 \\(u\\) 相连的点的度数不会改变。 如果我们可以每次在把所有度数 \\(\\le x\\) 的点删去后的森林中进行 DP（对每棵树进行 DP 然后把每棵树根节点的 \\(dp\\) 值加起来，具体是加 \\(dp_{i,0}\\) 还是 \\(dp_{i,1}\\) 要看写法），点数之和为 \\(\\sum_{x=0}^{n-1}\\sum_{i=1}^{n} [d_i&gt;x]=\\sum_{i=1}^{n} d_i=2n-2=O(n)\\)，总时间复杂度就变为 \\(O(n\\log n)\\) 了。 具体实现时，可以用两个普通堆实现一个支持删除的堆。每次“删去”一个点 \\(u\\) 时，在所有与该点相连的点 \\(v\\) 对应的堆中加入 \\(w(u,v)\\)；DP 时，假设需要把 \\(cnt\\) 个坏儿子变为好儿子，则我们强制使得堆中只有 \\(cnt\\) 个值，同时记录堆中所有值之和，这样 \\(dp\\) 值就可以很容易地求出；求出 \\(dp\\) 值之后，为了避免每次重新执行所有“删点操作”，我们需要将堆中由“删点”得来的值保留，即把强制删去的值重新插入堆中，把 DP 时得来的值从堆中删去。 正解代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 250005#define INF 0x3f3f3f3f3f3f3f3fllint n, d[N], X, vis[N];long long sum;std :: vector&lt; std :: pair&lt;int, int&gt; &gt; E[N];std :: pair&lt;int, int&gt; D[N];void addedge(int u, int v, int w)&#123; E[u].push_back(std :: make_pair(v, w)), ++d[u];&#125;bool cmp(std :: pair&lt;int, int&gt; x, std :: pair&lt;int, int&gt; y)&#123; return d[x.first] &gt; d[y.first];&#125;struct Normal_Heap&#123; // 普通大根堆 std :: vector&lt;long long&gt; a; void push(long long x)&#123; a.push_back(x), std :: push_heap(a.begin(), a.end()); &#125; long long top()&#123; return a[0]; &#125; void pop()&#123; std :: pop_heap(a.begin(), a.end()), a.pop_back(); &#125; long long popn()&#123; long long x; return std :: pop_heap(a.begin(), a.end()), x = a[a.size() - 1], a.pop_back(), x; &#125; int size()&#123; return a.size(); &#125;&#125;;struct Erase_Heap&#123; // 用两个普通堆实现的支持删除的大根堆 Normal_Heap a, b; int sz; long long sum; void push(long long x)&#123; a.push(x), ++sz, sum += x; &#125; void erase(long long x)&#123; b.push(x), --sz, sum -= x; &#125; void pre()&#123; while (a.size() &amp;&amp; b.size() &amp;&amp; a.top() == b.top()) a.pop(), b.pop(); &#125; long long top()&#123; return pre(), a.top(); &#125; void pop()&#123; pre(), --sz, sum -= a.top(), a.pop(); &#125; int size()&#123; return sz; &#125;&#125;H[N];void die(int u)&#123; // “删点”操作 for (auto to : E[u])&#123; register int v = to.first, w = to.second; if (d[v] &lt;= X) break; H[v].push(w); &#125;&#125;long long dp[N][2];std :: vector&lt;long long&gt; tmp, del;void dfs(int u, int fa = 0)&#123; vis[u] = X; int num = d[u] - X; long long res = 0; for (; H[u].size() &gt; num; H[u].pop()) ; for (auto to : E[u])&#123; register int v = to.first, w = to.second; if (v == fa) continue; if (d[v] &lt;= X) break; dfs(v, u); &#125; tmp.clear(), del.clear(); for (auto to : E[u])&#123; register int v = to.first, w = to.second; if (v == fa) continue; if (d[v] &lt;= X) break; long long x = dp[v][1] + w - dp[v][0]; if (x &lt;= 0)&#123; --num, res += dp[v][1] + w; continue; &#125; res += dp[v][0], H[u].push(x), del.push_back(x); &#125; for (; H[u].size() &amp;&amp; H[u].size() &gt; num; H[u].pop()) tmp.push_back(H[u].top()); // 强制弹堆 dp[u][0] = res + H[u].sum; for (; H[u].size() &amp;&amp; H[u].size() &gt; num - 1; H[u].pop()) tmp.push_back(H[u].top()); // 强制弹堆 dp[u][1] = res + H[u].sum; for (auto i : tmp) H[u].push(i); // 还原强制弹堆时删除的值 for (auto i : del) H[u].erase(i); // 删除 DP 得来的值&#125;int main()&#123; n = read(); for (register int i = 1, u, v, w; i &lt; n; ++i) u = read(), v = read(), w = read(), addedge(u, v, w), addedge(v, u, w), sum += w; printf(&quot;%lld&quot;, sum); for (register int i = 1; i &lt;= n; ++i) D[i] = std :: make_pair(d[i], i), std :: sort(E[i].begin(), E[i].end(), cmp); std :: sort(D + 1, D + 1 + n); register int i = 1; for (X = 1; X &lt; n; ++X)&#123; while (i &lt;= n &amp;&amp; D[i].first == X) die(D[i].second), ++i; long long ans = 0; for (register int j = i; j &lt;= n; ++j)&#123; register int v = D[j].second; if (vis[v] == X) continue; dfs(v), ans += dp[v][0]; &#125; printf(&quot; %lld&quot;, ans); &#125; putchar(&#x27;\\n&#x27;);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://autumnkite.github.io/tags/%E5%A0%86/"},{"name":"树形DP","slug":"树形DP","permalink":"https://autumnkite.github.io/tags/%E6%A0%91%E5%BD%A2DP/"}]},{"title":"「AT1732」「CODE FESTIVAL 2015 OKINAWA OPEN」Jungle","slug":"atcoder-cfoo15J-sol","date":"2019-03-09T05:34:00.000Z","updated":"2020-03-26T07:22:57.167Z","comments":true,"path":"atcoder-cfoo15J-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-cfoo15J-sol/","excerpt":"题目传送门 题意 有 \\(n\\) 棵树，第 \\(i\\) 棵树高度为 \\(a_i\\)。你需要砍掉一些树，砍树规则如下： 只能砍最多 \\(m\\) 棵树。 对于每个 \\(i\\ (1\\le i\\le n-k+1)\\)，满足 \\([i,i+k-1]\\) 中被砍掉的树的数量不超过 \\(1\\)。 被砍掉的树的位置的高度都变为 \\(0\\)。 求砍树后 \\(\\max\\limits_{1\\le i\\le n-k+1}\\sum\\limits_{j=i}^{i+k-1} a_j\\) 的最小值，即最小化所有长度为 \\(k\\) 的区间的树的高度之和的最大值。 \\(n\\le 10^5,a_i\\le 10^9\\)","text":"题目传送门 题意 有 \\(n\\) 棵树，第 \\(i\\) 棵树高度为 \\(a_i\\)。你需要砍掉一些树，砍树规则如下： 只能砍最多 \\(m\\) 棵树。 对于每个 \\(i\\ (1\\le i\\le n-k+1)\\)，满足 \\([i,i+k-1]\\) 中被砍掉的树的数量不超过 \\(1\\)。 被砍掉的树的位置的高度都变为 \\(0\\)。 求砍树后 \\(\\max\\limits_{1\\le i\\le n-k+1}\\sum\\limits_{j=i}^{i+k-1} a_j\\) 的最小值，即最小化所有长度为 \\(k\\) 的区间的树的高度之和的最大值。 \\(n\\le 10^5,a_i\\le 10^9\\) 一个错误但可以 AC 的贪心解法 求出 \\(sum_i\\) 表示以 \\(i\\) 结尾的长度为 \\(k\\) 的区间的 \\(a_i\\) 之和。然后求出 \\(mx_i\\) 表示所有包含 \\(i\\) 的长度为 \\(k\\) 的区间中，最大的 \\(sum_j\\) 减去 \\(a_i\\) 的值，即 \\(mx_i=\\max\\limits_{i\\le j&lt; i+k}sum_j-a_i\\)。 显然可以二分。二分答案 \\(x\\) 后，问题变成了一个判定性问题。 是否存在一种砍树的方法，使得所有长度为 \\(k\\) 的区间的树的高度之和都不超过 \\(x\\)。 可以发现，若一棵树 \\(i\\) 能砍，必须满足 \\(mx_i\\le x\\)。对于每个不符合要求的区间，选择该区间中最后一棵能砍的树砍掉。可以发现，优先选最后一棵有时候是不优的，例如 1[O X X O] X [O X X X] 这种情况（O 表示可以砍的树，X 表示不能砍的树，[...] 表示不符合条件的区间），显然方案是选两个区间的第一棵树。若优先选最后一棵，如果不考虑前后两个区间选择的树的距离，虽然也能得到“能”的答案，但方案是不满足要求的，可以用 [X X X O] X [O X X X] 的数据卡掉；如果考虑前后两个区间选择的树的距离，则会得到“不能”的答案，也是错误的。 我没有考虑前后两个区间选择的树的距离，所以 [X X X O] X [O X X X] 这种数据会得到一个偏小的答案，然而可以 AC。 附 hack 数据： 1210 5 42 2 2 5 1 5 1 1 2 10 答案是 \\(9\\)，我的代码会输出 \\(8\\)。 贪心算法代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define N 100005int n, m, k, a[N], h, t, Q[N];long long sum[N], id[N];void push(int x, long long *cp)&#123; // 单调队列 while (h &lt;= t &amp;&amp; cp[Q[t]] &lt;= cp[x]) --t; Q[++t] = x;&#125;bool check(long long x)&#123; h = 1, t = 1, Q[t] = k; for (register int i = 1; i &lt;= n; i + k &lt;= n ? push(i + k, sum) : void(0), ++i)&#123; if (Q[h] &lt; i) ++h; if (sum[Q[h]] - a[i] &lt;= x) id[i] = i; else id[i] = 0; &#125; h = 1, t = 0; for (register int i = 1; i &lt;= k; ++i) push(i, id); int s = 0; for (register int i = 1, p = 0; i &lt;= n - k + 1; push(i + k, id), ++i)&#123; if (Q[h] &lt; i) ++h; if (i &lt;= p) continue; if (sum[i + k - 1] &lt;= x) continue; p = int(id[Q[h]]), ++s; if (p == 0) return 0; &#125; return s &lt;= m;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for (register int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); for (register int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + a[i] - (i &gt; k ? a[i - k] : 0); // 求 sum long long l = 0, r = 100000000000000ll, md, ans; while (l &lt;= r) if (check(md = (l + r) &gt;&gt; 1)) ans = md, r = md - 1; else l = md + 1; printf(&quot;%lld\\n&quot;, ans);&#125; 正确的解法 一个正确但效率较低的二分 +DP 解法 仍然求出 \\(sum_i,mx_i\\)，考虑二分。 考虑用 \\(O(nk)\\) 的时间进行一个 DP 来判断。 首先考虑这样一个 DP 状态：\\(dp_i\\) 表示前 \\(i\\) 棵树（不包括 \\(i\\)），满足所有长度为 \\(k\\) 的区间的和都不超过 \\(x\\)，且第 \\(i-k\\) 棵树必砍时，最少需要砍多少棵树。 考虑主动转移，枚举下一棵砍的树 \\(i+j\\ (j\\ge 0)\\)，若可以砍 \\(i+j\\)（即满足 \\(mx_{i+j}\\le x\\) 且 \\(\\max\\limits_{i\\le p&lt; i+j} sum_p\\le x\\)），则 \\(dp_{i+j+k}\\gets \\min(dp_{i+j+k},dp_{i}+1)\\)。 然而直接这样做是 \\(O(n^2)\\) 的。通过观察发现，若 \\(j\\ge k\\)，则可以把 \\(dp_i\\) 先转移到 \\(dp_{i+k}\\)，再把 \\(dp_{i+k}\\) 向前转移。于是，我们只需要考虑 \\(0\\le j&lt; k\\) 即可。时间复杂度优化为 \\(O(nk)\\)。 总的时间复杂度为 \\(O(nk\\log ans)\\)。 另一个正确但效率较低的 DP 解法 仍然求出 \\(sum_i,mx_i\\)，但不二分，直接进行 DP。 \\(dp_{i,j}\\) 表示前 \\(j\\) 棵树，砍了 \\(i\\) 棵，\\(j\\) 必须砍时 \\(\\max\\limits_{k\\le p&lt; j+k}sum_p\\) 的最小值。 当 \\(i\\) 确定时，记 \\(Mx_j\\) 表示前 \\(j\\) 棵树（不包括 \\(j\\)），砍了 \\(i-1\\) 棵树且最后一棵砍的树 \\(t\\) 满足 \\(j-t\\ge k\\) 的 \\(\\max\\limits_{k\\le p&lt; j} sum_p\\) 的最小值。 其实求 \\(Mx_j\\) 的过程相当于一个 DP 的过程，显然有两种决策：当 \\(t&lt; j-k\\) 时，\\(Mx_j=\\max(Mx_{j-1},sum_{j-1})\\)；当 \\(t=j-k\\) 时，\\(Mx_j=dp_{i-1,j-k}\\)。所以有 \\(Mx_j=\\min(\\max(Mx_{j-1},sum_{j-1}),dp_{i-1,j-k})\\)。 求出 \\(Mx_j\\) 后，求 \\(dp_{i,j}\\) 就变得很显然：\\(dp_{i,j}=\\max(Mx_j,mx_j)\\)，分别表示 \\(\\max\\limits_{k\\le p&lt; j}sum_p\\) 的最小值，以及 \\(\\max\\limits_{j\\le p&lt; j+k}sum_p\\) 的最小值，这两部分互不影响，所以可以独立计算。 求出 \\(dp_{i,j}\\) 后，求答案也变得很显然：由于 \\(dp_{m,j}\\) 并没有包括 \\(\\max\\limits_{j+k\\le p\\le n}sum_p\\)，把这部分与 \\(dp_{m,j}\\) 取 \\(\\max\\) 即可。 可以使用滚动数组优化内存。时间复杂度为 \\(O(nm)\\)。 正解——两者之并 可以发现，\\(m&gt; \\lceil \\frac{n}{k}\\rceil\\) 与 \\(m= \\lceil \\frac{n}{k}\\rceil\\) 的情况答案是相同的。所以 \\(m\\) 最大为 \\(\\lceil \\frac{n}{k}\\rceil\\)。 上面的两个 DP，可以发现当 \\(k\\le 50\\) 时第一个 DP 是可以过的。而 \\(k&gt;50\\) 时，由于 \\(m\\) 的级别是 \\(\\frac{n}{k}\\)，第二个 DP 可以过。 那么把两者合并一下就可以通过此题。 正解代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define N 100005int n, m, k, a[N], h, t, Q[N];long long sum[N], mx[N];void push(int x)&#123; // 单调队列维护 while (h &lt;= t &amp;&amp; sum[Q[t]] &lt;= sum[x]) --t; Q[++t] = x;&#125;namespace Subtask1&#123; // 二分+DP O(nk log ans) int dp[N]; void upd(int i, int j)&#123; if (i &gt; n + 1) i = n + 1; dp[i] = std :: min(dp[i], j); &#125; bool check(long long x)&#123; for (register int i = 1; i &lt;= n + 1; ++i) dp[i] = 1e9; dp[1] = 0; for (register int i = 1; i &lt;= n; ++i)&#123; long long Mx = 0; for (register int j = 0; j &lt; k &amp;&amp; i + j &lt;= n; ++j)&#123; if (Mx &lt;= x &amp;&amp; mx[i + j] &lt;= x) upd(i + j + k, dp[i] + 1); Mx = std :: max(Mx, sum[i + j]); &#125; // if (x == 0) printf(&quot;%d %lld\\n&quot;, i, Mx); if (Mx &lt;= x) upd(i + k, dp[i]); &#125; return dp[n + 1] &lt;= m; &#125; void Main()&#123; long long l = 0, r = 1e14, md, ans; while (l &lt;= r) if (check(md = (l + r) &gt;&gt; 1)) ans = md, r = md - 1; else l = md + 1; printf(&quot;%lld\\n&quot;, ans); &#125;&#125;namespace Subtask2&#123; // DP O(nm)=O(n^2/k) long long dp[2][N]; void Main()&#123; long long Mx = 0; for (register int i = 1; i &lt;= n; ++i)&#123; if (i &gt; k) Mx = std :: max(Mx, sum[i - 1]); dp[1][i] = std :: max(Mx, mx[i]); &#125; for (register int i = 2; i &lt;= m; ++i)&#123; int t = i &amp; 1; long long Mx = 0; for (register int j = 1; j &lt;= n; ++j)&#123; if (j &gt; k) Mx = std :: max(Mx, sum[j - 1]); if (j &gt; k) Mx = std :: min(Mx, dp[!t][j - k]); dp[t][j] = std :: max(Mx, mx[j]); &#125; &#125; long long ans = 0x3f3f3f3f3f3f3f3fll; Mx = 0; for (register int i = n; i; --i)&#123; if (i + k &lt;= n) Mx = std :: max(Mx, sum[i + k]); ans = std :: min(ans, std :: max(dp[m &amp; 1][i], Mx)); &#125; printf(&quot;%lld\\n&quot;, ans); &#125;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); m = std :: min(m, n / k + 1); for (register int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); for (register int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + a[i] - (i &gt; k ? a[i - k] : 0); h = 1, t = 1, Q[t] = k; for (register int i = 1; i &lt;= n; i + k &lt;= n ? push(i + k) : void(0), ++i)&#123; if (Q[h] &lt; i) ++h; mx[i] = sum[Q[h]] - a[i]; &#125; if (m &lt;= 2005) return Subtask2 :: Main(), 0; if (k &lt;= 55) return Subtask1 :: Main(), 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"CODE FESTIVAL 2015 OKINAWA OPEN","slug":"题解/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"二分","slug":"二分","permalink":"https://autumnkite.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"单调队列","slug":"单调队列","permalink":"https://autumnkite.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"RMQ","slug":"RMQ","permalink":"https://autumnkite.github.io/tags/RMQ/"}]},{"title":"「AT1731」「CODE FESTIVAL 2015 OKINAWA OPEN」Implementation Addict","slug":"atcoder-cfoo15I-sol","date":"2019-03-03T12:21:00.000Z","updated":"2020-03-26T07:22:57.166Z","comments":true,"path":"atcoder-cfoo15I-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-cfoo15I-sol/","excerpt":"题目传送门 题意 有 \\(n\\) 天，每天有一个值 \\(a_i\\)（未确定的值），其中 \\(a_i=0\\) 的天数称为“休息”，其他的称为“工作”。 若第 \\(i\\) 天为“工作”，设第 \\(i\\) 天之前（不包含第 \\(i\\) 天）连续“工作”的天数为 \\(k\\)，则 \\(a_i=\\max(0,A-kB)\\)（\\(A,B\\) 给定）；若第 \\(i\\) 天为“休息”，则 \\(a_i=0\\)。 现已经确定 \\(m\\) 天为“休息”，求 \\(\\sum_{i=1}^{n} a_i\\) 的最大值。 \\(n,A,B\\le 10^9,m\\le 10^5\\)","text":"题目传送门 题意 有 \\(n\\) 天，每天有一个值 \\(a_i\\)（未确定的值），其中 \\(a_i=0\\) 的天数称为“休息”，其他的称为“工作”。 若第 \\(i\\) 天为“工作”，设第 \\(i\\) 天之前（不包含第 \\(i\\) 天）连续“工作”的天数为 \\(k\\)，则 \\(a_i=\\max(0,A-kB)\\)（\\(A,B\\) 给定）；若第 \\(i\\) 天为“休息”，则 \\(a_i=0\\)。 现已经确定 \\(m\\) 天为“休息”，求 \\(\\sum_{i=1}^{n} a_i\\) 的最大值。 \\(n,A,B\\le 10^9,m\\le 10^5\\) 题解 \\(m\\) 天“休息”，相当于把 \\(n\\) 分成了 \\(m+1\\) 份，每份是独立的，所以可以分别进行计算。所以，现在不再需要考虑 \\(m\\) 天“休息”。假设当前子问题的天数为 \\(n\\)。 为了使得和最大，一定是等分更优。例如 \\(n=7\\)，分成 \\(3\\) 块（即“休息” \\(2\\) 天），则一定是分别工作 \\(1,2,2\\) 天。为方便处理，可以将 \\(n\\) 加 \\(1\\)，钦定最后一天为“休息”。 假设分成 \\(x\\) 块，设 \\(t=\\left\\lfloor \\frac{n}{x}\\right\\rfloor-1\\)，则一定是 \\(n\\bmod x\\) 块工作 \\(t+1\\) 天，\\(x-n\\bmod x\\) 块工作 \\(t\\) 天。这个可以直接用等差数列求和公式进行计算。 至于如何确定 \\(x\\)，可以发现，答案是一个单峰函数，所以直接三分 \\(x\\) 即可。 代码 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int n, m, x[100005];long long A, B, ans;long long get(int n, int x)&#123; // 计算 n 天分成 x 块的答案 if (x &gt; n) return 0; int m = n / x - 1; return ((A + A - (m - 1) * B) * m &gt;&gt; 1) * x + (A - m * B) * (n % x);&#125;long long solve(int n)&#123; // 三分求 n 天的答案 int l = 1, r = n, ans = 0; while (l &lt;= r)&#123; int md = (l + r) &gt;&gt; 1; // 写的有点像二分，其实是三分 if (get(n, md) &gt;= get(n, md + 1)) ans = md, r = md - 1; else l = md + 1; &#125; return get(n, ans);&#125;int main()&#123; scanf(&quot;%d%lld%lld%d&quot;, &amp;n, &amp;A, &amp;B, &amp;m), x[m + 1] = n + 1; for (register int i = 1; i &lt;= m; ++i) scanf(&quot;%d&quot;, x + i); for (register int i = 0; i &lt;= m; ++i) ans += solve(x[i + 1] - x[i]); // n 在这里已经加 1 printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"CODE FESTIVAL 2015 OKINAWA OPEN","slug":"题解/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"三分","slug":"三分","permalink":"https://autumnkite.github.io/tags/%E4%B8%89%E5%88%86/"}]},{"title":"「AT1730」「CODE FESTIVAL 2015 OKINAWA OPEN」Happy 2015","slug":"atcoder-cfoo15H-sol","date":"2019-03-03T09:30:00.000Z","updated":"2020-03-26T07:22:57.165Z","comments":true,"path":"atcoder-cfoo15H-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-cfoo15H-sol/","excerpt":"题目传送门 题意 给定 \\(n\\) 个区间 \\((l_r,r_i]\\)（注意原题中虽然写着 \\([l_i,r_i]\\)，但通过转化后相当于 \\((l_i,r_i]\\)），每个区间有存在和不存在两种状态。求所有 \\(2^n\\) 种方案中，本质不同的方案的数量 \\(\\bmod (10^9+7)\\) 的值。 记一个方案的点集合为数轴上至少被一个区间覆盖的整数组成的集合，则两个方案本质不同当且仅当这两个方案的点集合不同。 \\(n\\le 2000,0\\le l_i&lt; r_i\\le 10^9\\)","text":"题目传送门 题意 给定 \\(n\\) 个区间 \\((l_r,r_i]\\)（注意原题中虽然写着 \\([l_i,r_i]\\)，但通过转化后相当于 \\((l_i,r_i]\\)），每个区间有存在和不存在两种状态。求所有 \\(2^n\\) 种方案中，本质不同的方案的数量 \\(\\bmod (10^9+7)\\) 的值。 记一个方案的点集合为数轴上至少被一个区间覆盖的整数组成的集合，则两个方案本质不同当且仅当这两个方案的点集合不同。 \\(n\\le 2000,0\\le l_i&lt; r_i\\le 10^9\\) 题解 为方便处理，我们把 \\(l_i\\) 加 \\(1\\) 使得区间变为闭区间。 显然，\\(l_i,r_i\\) 可以离散，所以坐标变为 \\(O(n)\\) 级别。 然后考虑一个 DP，\\(dp_{i,0/1}\\) 表示覆盖前 \\(i\\) 个点，且第 \\(i\\) 个点必须覆盖/不覆盖的本质不同的方案数。 那么可以写出一个 \\(O(n^2)\\) 的 DP，方程如下：\\[dp_{i,j}=\\begin{cases} dp_{i-1,0}+dp_{i-1,1} &amp; \\text{ if } j=0 \\\\ \\sum\\limits_{cov(k,i)=1} dp_{k-1,0} &amp; \\text{ if } j=1 \\end{cases}\\] 其中 \\(cov(k,i)=0/1\\) 表示是否存在一种区间覆盖方案使得刚好覆盖 \\([k,i]\\)。 \\(cov(i,j)\\) 可以用如下方式处理： 记 \\(p_i\\)（一个 vector） 表示所有右端点为 \\(i\\) 的区间的左端点。 枚举 \\(i\\)（被覆盖部分的左端点），首先枚举所有左端点为 \\(i\\) 的区间 \\([i,r_j]\\)，使得 \\(cov(i,r_j)=1\\)。 然后枚举所有右端点 \\(j\\)，再枚举所有右端点为 \\(j\\) 的区间（即 \\([p_{j,k},j]\\) ），若 \\(p_{j,k}&gt; i\\) 且存在一个 \\(x\\in [p_{j,k},j]\\) 满足 \\(cov(i,x)=1\\)，则 \\(cov(i,j)=1\\)。 至于如何判断“存在一个 \\(x\\in [p_{j,k},j]\\) 满足 \\(cov(i,x)=1\\)”，可以在枚举右端点求 \\(cov(i,j)\\) 的同时用前缀和进行判断，具体实现见代码。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define P 1000000007int n, m, pos[4005], sum[4005], dp0[4005], dp1[4005];bool cov[4005][4005];std :: vector&lt;int&gt; p[4005];struct node&#123; int l, r;&#125;a[2005];void add(int &amp;x, int y)&#123; (x += y) &gt;= P ? x -= P : 0;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (register int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d&quot;, &amp;a[i].l, &amp;a[i].r), pos[++m] = a[i].l, pos[++m] = a[i].r; std :: sort(pos + 1, pos + 1 + m); m = std :: unique(pos + 1, pos + 1 + m) - pos - 1; for (register int i = 1; i &lt;= n; ++i)&#123; a[i].l = std :: lower_bound(pos + 1, pos + 1 + m, a[i].l) - pos + 1; a[i].r = std :: lower_bound(pos + 1, pos + 1 + m, a[i].r) - pos; p[a[i].r].push_back(a[i].l); &#125; // 以上分别为：转为闭区间、离散、处理 p for (register int i = 1; i &lt;= m; ++i)&#123; sum[i] = 0; for (register int j = 1; j &lt;= n; ++j) if (a[j].l == i) cov[i][a[j].r] = 1; for (register int j = i; j &lt;= m; ++j)&#123; for (register int k = 0; k &lt; p[j].size(); ++k) if (p[j][k] &gt; i &amp;&amp; sum[j] &gt; sum[p[j][k] - 1])&#123; cov[i][j] = 1; break; &#125; // 根据前缀和判断 sum[j + 1] = sum[j] + cov[i][j]; // 同时处理前缀和 &#125; &#125; // 以上为处理 cov dp0[0] = 1; for (register int i = 1; i &lt;= m; ++i)&#123; add(dp0[i], dp0[i - 1]), add(dp0[i], dp1[i - 1]); for (register int j = 1; j &lt;= i; ++j) if (cov[j][i]) add(dp1[i], dp0[j - 1]); &#125; // 以上为 dp add(dp0[m], dp1[m]), printf(&quot;%d\\n&quot;, dp0[m]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"CODE FESTIVAL 2015 OKINAWA OPEN","slug":"题解/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"离散","slug":"离散","permalink":"https://autumnkite.github.io/tags/%E7%A6%BB%E6%95%A3/"}]},{"title":"「AT1729」「CODE FESTIVAL 2015 OKINAWA OPEN」Gorgeous Vases","slug":"atcoder-cfoo15G-sol","date":"2019-02-21T13:07:00.000Z","updated":"2021-05-29T10:26:33.972Z","comments":true,"path":"atcoder-cfoo15G-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-cfoo15G-sol/","excerpt":"题目传送门 题意 有两个有序二元组 \\((A,B),(C,D)\\)，\\(A,B\\) 给定且保证 \\(A\\ge B\\)，\\(C,D\\) 一开始为 \\(0\\)。另外给定 \\(n\\) 个有序二元组 \\((p_i,q_i)\\)，有两种操作： \\(A\\gets A-1,C\\gets C+1\\) \\(B\\gets B-1,D\\gets D+1\\) 不断执行这两种操作，直到二元组变为 \\((0,0),(A&#39;,B&#39;)\\)，其中 \\(A&#39;,B&#39;\\) 表示最初的 \\(A,B\\)。但任意时刻都需要满足： \\(A\\ge B,C\\ge D\\) \\(\\forall i\\in [1,n],(A,B)\\ne (p_i,q_i),(C,D)\\ne (p_i,q_i)\\)。 求方案数 \\(\\bmod (10^9+7)\\) 的值。 记操作序列为由每次的操作编号组成的长度为 \\(A&#39;+B&#39;\\) 的序列，则两个方案不同当且仅当两个方案的操作序列不同。 \\(1\\le B\\le A\\le 10^5,0\\le n\\le 20\\)","text":"题目传送门 题意 有两个有序二元组 \\((A,B),(C,D)\\)，\\(A,B\\) 给定且保证 \\(A\\ge B\\)，\\(C,D\\) 一开始为 \\(0\\)。另外给定 \\(n\\) 个有序二元组 \\((p_i,q_i)\\)，有两种操作： \\(A\\gets A-1,C\\gets C+1\\) \\(B\\gets B-1,D\\gets D+1\\) 不断执行这两种操作，直到二元组变为 \\((0,0),(A&#39;,B&#39;)\\)，其中 \\(A&#39;,B&#39;\\) 表示最初的 \\(A,B\\)。但任意时刻都需要满足： \\(A\\ge B,C\\ge D\\) \\(\\forall i\\in [1,n],(A,B)\\ne (p_i,q_i),(C,D)\\ne (p_i,q_i)\\)。 求方案数 \\(\\bmod (10^9+7)\\) 的值。 记操作序列为由每次的操作编号组成的长度为 \\(A&#39;+B&#39;\\) 的序列，则两个方案不同当且仅当两个方案的操作序列不同。 \\(1\\le B\\le A\\le 10^5,0\\le n\\le 20\\) 题解 可以发现，题目可以转化为： 从 \\((0,0)\\) 走到 \\((A,B)\\)，每次只能走 \\((+1,0)\\) 或 \\((0,+1)\\)（即只能向上、向右走），求满足以下条件的方案数： 1. 对于所有经过的点 \\((x,y)\\)，\\(x\\ge y,A-x\\ge B-y\\) 2. 不能经过点 \\((p_i,q_i),(A-p_i,B-q_i)\\)。 把 \\((A,B)\\) 和所有不能经过的点称为障碍点，把障碍点按一定顺序排序后，可以很轻松地写出一个 DP： \\(dp_i\\) 表示到达障碍点 \\(i\\) 的方案数，则 \\(dp_i=solve(0,i)-\\sum dp_j+solve(j,i)\\)，其中 \\(j\\) 在 \\(i\\) 的左下方，\\(solve(j,i)\\) 表示 \\(j\\) 到 \\(i\\) 的方案数，\\(solve(0,i)\\) 表示 \\((0,0)\\) 到 \\(i\\) 的方案数。 发现关键在于如何求 \\(solve(i,j)\\) 的值。那么问题又转化为： 从 \\((x_1,y_1)\\) 走到 \\((x_2,y_2)\\)，只能向上、向右走，满足所有经过的点 \\((x,y)\\) 在直线 \\(y=x\\) 和 \\(y=x-(A-B)\\) 之间（包括这两条直线上的点），求方案数。 图 1 类似上图中的情况，求 \\((x_1,y_2)\\) 到 \\((x_2,y_2)\\) 的方案数。 首先，为方便起见，把两条直线分别向上、向下移动一个单位，这样我们就不能碰到这两条直线，碰到即算不符合。 考虑所有情况减去不符合要求的情况，所有情况可以用组合数直接计算，那么我们要计算下图中的两种情况的方案数。 图 2 我们先考虑左图的情况，可以发现，左图的情况可以把剩余部分按直线 \\(y=x+1\\) 对称，如下图所示： 图 3 此时 \\((x_1,y_1)\\) 到 \\((x_2,y_2)\\) 一定会碰到 \\(y=x+1\\)，即图 2 中左图的情况。 可是会发现，如果一个方案穿过了 \\(y=x+1\\)，然后又穿过了 \\(y=x-(A-B)-1\\)，则这个方案会被重复计算，需要减去。 可以发现，对称后，\\(y=x-(A-B)-1\\) 这条直线到了最上面，即此时的情况为（下图中的左图）： 图 4 那么同样，对称后计算（如上图右图所示）。 如果还有重复情况（即上下上、上下上下等情况），则继续对称即可。 具体实现及细节见代码。 代码 注意，代码并不是每次作对称然后判断正负的，而是把所有负的都减掉，再把所有正的加上，所以与上面的分析有所出入，请仔细理解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define P 1000000007int A, B, n, m, fac[200005], inv[200005], dp[50];struct node&#123; int x, y; bool operator &lt; (const node &amp;res) const &#123; return x &lt; res.x || x == res.x &amp;&amp; y &lt; res.y; &#125; bool operator == (const node &amp;res) const &#123; return x == res.x &amp;&amp; y == res.y; &#125;&#125;p[50];bool check(int m)&#123; return p[m].y &lt;= p[m].x &amp;&amp; p[m].y &gt;= p[m].x - A + B;&#125;int qpow(int a, int b)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if (b &amp; 1) s = 1ll * s * a % P; return s;&#125;void pre(int n)&#123; fac[0] = 1; for (register int i = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % P; inv[n] = qpow(fac[n], P - 2); for (register int i = n; i; --i) inv[i - 1] = 1ll * inv[i] * i % P;&#125;int F(node a, node b)&#123; if (a.x &gt; b.x || a.y &gt; b.y) return 0; return 1ll * fac[b.x - a.x + b.y - a.y] * inv[b.x - a.x] % P * inv[b.y - a.y] % P;&#125;void add(int &amp;x, int y)&#123; (x += y) &gt;= P ? x -= P : 0; &#125;void del(int &amp;x, int y)&#123; (x -= y) &lt; 0 ? x += P : 0; &#125;int calc(node a, node b)&#123; // 计算 a 到 b 的方案数，主要难在这个函数 int res = F(a, b), w = A - B + 2; for (register node c = (node)&#123;b.y - 1, b.x + 1&#125;; c.x &gt;= a.x; c.x -= w, c.y += w) del(res, F(a, c)); for (register node c = (node)&#123;b.x - w, b.y + w&#125;; c.x &gt;= a.x; c.x -= w, c.y += w) add(res, F(a, c)); for (register node c = (node)&#123;b.y + w - 1, b.x - w + 1&#125;; c.y &gt;= a.y; c.x += w, c.y -= w) del(res, F(a, c)); for (register node c = (node)&#123;b.x + w, b.y - w&#125;; c.y &gt;= a.y; c.x += w, c.y -= w) add(res, F(a, c)); return res;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;A, &amp;B, &amp;n), pre(A + B); if (A == B) return printf(&quot;0\\n&quot;), 0; for (register int i = 1, x, y; i &lt;= n; ++i)&#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if (!x &amp;&amp; !y) return printf(&quot;0\\n&quot;), 0; if (x == A &amp;&amp; x == B) return printf(&quot;0\\n&quot;), 0; p[++m] = (node)&#123;x, y&#125;, !check(m) ? --m : 0; p[++m] = (node)&#123;A - x, B - y&#125;, !check(m) ? --m : 0; &#125; p[0] = (node)&#123;0, 0&#125;, p[++m] = (node)&#123;A, B&#125;; std :: sort(p + 1, p + 1 + m); m = std :: unique(p + 1, p + 1 + m) - p - 1; for (register int i = 1; i &lt;= m; ++i)&#123; dp[i] = calc(p[0], p[i]); for (register int j = 1; j &lt; i; ++j) (dp[i] -= 1ll * dp[j] * calc(p[j], p[i]) % P) &lt; 0 ? dp[i] += P : 0; &#125; printf(&quot;%d\\n&quot;, dp[m]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"CODE FESTIVAL 2015 OKINAWA OPEN","slug":"题解/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"「AT1728」「CODE FESTIVAL 2015 OKINAWA OPEN」Falconry","slug":"atcoder-cfoo15F-sol","date":"2019-02-21T12:08:00.000Z","updated":"2020-03-26T07:22:57.163Z","comments":true,"path":"atcoder-cfoo15F-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-cfoo15F-sol/","excerpt":"题目传送门 题意 给定平面上 \\(n\\) 个点 \\((x_i,y_i)\\)，以及三只鸟的初始坐标 \\((x_a,y_a),(x_b,y_b),(x_c,y_c)\\)。现在三只鸟要从初始点开始，依次飞到一些点（不需要回到起点），要求每个点至少被一只鸟飞到。求三只鸟总飞行距离之和的最小值。 从一个点 \\((x_s,y_s)\\) 飞到另一个点 \\((x_t,y_t)\\) 的飞行距离为这两个点的欧几里得距离，即 \\[\\sqrt{(x_s - x_t)^2 + (y_s - y_t)^2}\\] \\(n\\le 18\\)，所有横纵坐标的绝对值 \\(\\le 10^4\\)，时限 \\(8s\\)。","text":"题目传送门 题意 给定平面上 \\(n\\) 个点 \\((x_i,y_i)\\)，以及三只鸟的初始坐标 \\((x_a,y_a),(x_b,y_b),(x_c,y_c)\\)。现在三只鸟要从初始点开始，依次飞到一些点（不需要回到起点），要求每个点至少被一只鸟飞到。求三只鸟总飞行距离之和的最小值。 从一个点 \\((x_s,y_s)\\) 飞到另一个点 \\((x_t,y_t)\\) 的飞行距离为这两个点的欧几里得距离，即 \\[\\sqrt{(x_s - x_t)^2 + (y_s - y_t)^2}\\] \\(n\\le 18\\)，所有横纵坐标的绝对值 \\(\\le 10^4\\)，时限 \\(8s\\)。 方法一 三只鸟很难考虑，考虑一只鸟飞遍某个点集所需的最少时间。 记 \\(dp_{t,i,j}\\) 表示第 \\(t\\) 只鸟，飞遍点集 \\(i\\)，最后停留在点 \\(j\\) 的最小距离和。 转移很显然，只要在点集 \\(i\\) 中枚举上一个点 \\(k\\)，然后直接转移即可。 最后枚举每只鸟飞到的点集即可，因为两只鸟飞到的点集不会有交，所以复杂度为 \\(O(3^n)\\)。具体实现时，可以枚举一个集合 \\(A\\)，再枚举这个集合的子集 \\(B\\)，假设全集为 \\(C\\)，则三个集合分别为 \\(B,A-B,C-A\\)。 时间复杂度 \\(O(3n^22^n+3^n)\\)，常数不大，最大点 \\(2898ms\\)（评测记录）。 方法二 发现上面的方法比较慢，且主要在于 \\(3^n\\) 的统计答案。考虑直接在第二只鸟、第三只鸟 DP 时，直接合并答案。 记 \\(dp_{t,i,j}\\) 表示前 \\(i\\) 只鸟，飞遍点集 \\(i\\)，第 \\(i\\) 只鸟停留在点 \\(j\\) 时的最小距离和。 主要转移方程与方法一差不多，但是有一些细节需要注意，例如飞到第一个点时需要特殊转移，具体参见代码。也许有更好的、细节更少的写法，欢迎分享。 时间复杂度 \\(O(3n^22^n)\\)，最大点 \\(535ms\\)（评测记录）。 代码 方法一 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int n;struct point&#123; int x, y;&#125;a[20], b[3];double Dp[3][300000][20];double dis(point a, point b)&#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (register int i = 0; i &lt; n; ++i) scanf(&quot;%d%d&quot;, &amp;a[i].x, &amp;a[i].y); for (register int i = 0; i &lt; 3; ++i) scanf(&quot;%d%d&quot;, &amp;b[i].x, &amp;b[i].y); for (register int t = 0; t &lt; 3; ++t)&#123; double (*dp)[20] = Dp[t]; for (register int i = 0; i &lt; (1 &lt;&lt; n); ++i) for (register int j = 0; j &lt;= n; ++j) dp[i][j] = 1e100; dp[0][n] = 0; for (register int i = 0; i &lt; n; ++i) dp[1 &lt;&lt; i][i] = dis(b[t], a[i]); for (register int i = 0; i &lt; (1 &lt;&lt; n); ++i) for (register int j = 0; j &lt; n; ++j) if (i &gt;&gt; j &amp; 1)&#123; for (register int k = 0; k &lt; n; ++k) if (i &gt;&gt; k &amp; 1 &amp;&amp; k != j) dp[i][j] = std :: min(dp[i][j], dp[1 &lt;&lt; j ^ i][k] + dis(a[k], a[j])); dp[i][n] = std :: min(dp[i][n], dp[i][j]); // 这个状态记录0~n-1的最小值 &#125; &#125; double ans = 1e100; for (register int i = 0; i &lt; (1 &lt;&lt; n); ++i) for (register int j = i; j &gt;= 0; j = (j - 1) &amp; i)&#123; int A = j, B = i ^ j, C = ((1 &lt;&lt; n) - 1) ^ i; ans = std :: min(ans, Dp[0][A][n] + Dp[1][B][n] + Dp[2][C][n]); if (!j) break; &#125; printf(&quot;%.12lf\\n&quot;, ans);&#125; 方法二 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int n;struct point&#123; int x, y;&#125;a[20], b;double dp[3][300000][20], d[20][20];double dis(point a, point b)&#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (register int i = 0; i &lt; n; ++i) scanf(&quot;%d%d&quot;, &amp;a[i].x, &amp;a[i].y); for (register int t = 0; t &lt; 3; ++t)&#123; scanf(&quot;%d%d&quot;, &amp;b.x, &amp;b.y); for (register int i = 0; i &lt; (1 &lt;&lt; n); ++i) for (register int j = 0; j &lt;= n; ++j) dp[t][i][j] = 1e100; for (register int i = 0; i &lt; n; ++i) for (register int j = 0; j &lt; n; ++j) d[i][j] = dis(a[i], a[j]); dp[t][0][n] = 0; for (register int i = 0; i &lt; n; ++i) dp[t][1 &lt;&lt; i][i] = dis(b, a[i]); for (register int i = 0; i &lt; (1 &lt;&lt; n); ++i) for (register int j = 0; j &lt; n; ++j) if (i &gt;&gt; j &amp; 1)&#123; dp[t][i][n] = std :: min(t ? dp[t - 1][i][n] : 1e100, dp[t][i][n]); // 特殊转移 1 for (register int k = 0; k &lt; n; ++k) if (i &gt;&gt; k &amp; 1 &amp;&amp; k != j) dp[t][i][j] = std :: min(dp[t][i][j], dp[t][1 &lt;&lt; j ^ i][k] + d[k][j]); dp[t][i][j] = std :: min(dp[t][i][j], t ? dp[t - 1][1 &lt;&lt; j ^ i][n] + dis(b, a[j]) : 1e100); // 特殊转移 2 dp[t][i][n] = std :: min(dp[t][i][n], dp[t][i][j]); &#125; &#125; printf(&quot;%.12lf\\n&quot;, dp[2][(1 &lt;&lt; n) - 1][n]);&#125; 有更好的写法或复杂度更优的做法请在评论中分享！","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"CODE FESTIVAL 2015 OKINAWA OPEN","slug":"题解/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"状压DP","slug":"状压DP","permalink":"https://autumnkite.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"}]},{"title":"「AT1727」「CODE FESTIVAL 2015 OKINAWA OPEN」Enormous XOR Rectangle","slug":"atcoder-cfoo15E-sol","date":"2019-02-18T06:54:00.000Z","updated":"2020-03-26T07:22:57.160Z","comments":true,"path":"atcoder-cfoo15E-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-cfoo15E-sol/","excerpt":"题目传送门 题意 \\(H\\times W\\) 的矩阵，第 \\(i(0\\le i&lt; H)\\) 行第 \\(j(0\\le j&lt; W)\\) 列的数为 \\(iW+j\\)。 选一个子矩阵，使得该子矩阵中所有元素 xor 的值最大。输出这个值。 \\(H,W\\le 10^9\\)","text":"题目传送门 题意 \\(H\\times W\\) 的矩阵，第 \\(i(0\\le i&lt; H)\\) 行第 \\(j(0\\le j&lt; W)\\) 列的数为 \\(iW+j\\)。 选一个子矩阵，使得该子矩阵中所有元素 xor 的值最大。输出这个值。 \\(H,W\\le 10^9\\) 分析 记 \\(n\\) 为满足 \\(2^{n-1} \\le H\\times W-1 &lt; 2^n\\) 的值。所以答案一定 \\(&lt; 2^n\\)。 当 \\(2^{n-1}-1\\) 与 \\(2^{n-1}\\) 左右相邻时，由于 \\((2^{n-1}-1)\\text{ xor }(2^{n-1})=2^n-1\\)，所以答案显然为 \\(2^n-1\\)。 否则，此时的情况一定是 \\(2^{n-1}-1\\) 在某行的最后一列，\\(2^{n-1}\\) 在这一行下面一行的第一列，所以 \\(W\\) 此时一定能表示为 \\(2^m(0\\le m\\le n-1)\\)。例如： 12345678 0 1 2 3 4 5 6 7 8 9 10 1112 13 14 15-----------16 17 18 1920 21 22 2324 25 26 27 图中 \\(n=5,2^{n-1}-1=15,2^{n-1}=16\\)。 这种情况下，下界显然是 \\(2^n-2^m=2^n-W\\)，即 \\((2^{n-1}-1)\\text{ xor }(2^{n-1}-1+2^m)\\)。记这个下界为 \\(d\\)，考虑是否有答案超过 \\(d\\) 的情况。 通过观察可以发现： 一行中所有数的最高 \\(n-m\\) 位都相同。 一列中所有数的最后 \\(m\\) 位都相同。 继续分析可以得到： 若选偶数行，xor 值的最后 \\(m\\) 位都是 \\(0\\)，答案 \\(\\le d\\)。 若选偶数列，xor 值的最高 \\(n-m\\) 位都是 \\(0\\)，答案 \\(\\le d\\)。 若选奇数列，考虑每一行，一定在该行中存在一个数与该行的 xor 值相等，且每一行的这个数一定在同一列，所以选奇数列的所有情况相当于选 \\(1\\) 列的所有情况。那么，为了得到最优的答案，一定选择最后一列。 综上，我们选择的范围变成了最后一列，选奇数行。并且，若存在这样的答案，答案最后的 \\(m\\) 位一定都为 \\(1\\)。那么超过 \\(d\\) 的答案只可能是 \\(2^n-1\\)。 所以，问题变成了以一个序列上的问题： \\(H\\) 个数，第 \\(i(0\\le i&lt; H)\\) 个数为 \\(i\\)，问是否存在一个区间，使得这个区间的 xor 值为 \\(2^{n-m}-1\\)。 例如： 10 1 2 3 | 4 5 6 分界线左边最高位为 \\(0\\)，右边最高位为 \\(1\\)。由于要达到 \\(2^{n-m}-1\\)，分界线右边必须选奇数个，才能保证最高位为 \\(1\\)。 根据 \\((2n)\\text{ xor }(2n+1)=1\\ (n\\ge 0)\\)，可以证明分界线左边的数不需要选择。 根据 \\(0\\text{ xor }1\\text{ xor }2\\text{ xor }\\cdots\\text{ xor }(2^n-1)=0 \\ (n\\ge 2)\\)，可以证明右边若要选出 \\(2^{n-m}-1\\)，必须选择 \\(2^{n-m-1}\\sim 2^{n-m}-2\\) 的所有数。 注意上述结论是一般情况，\\(n-m\\) 特别小时可以特殊处理，不过仍然可以证明下面总结中的结论是正确的。 结论 根据上面的分析、推导和转化，可以得到如下结论： 若 \\(W\\) 不是 \\(2\\) 的幂次，或者 \\(H\\) 是 \\(2\\) 的幂次，或者 \\(H+1\\) 是 \\(2\\) 的幂次，则答案为 \\(2^n-W\\)，否则答案为 \\(2^n-1\\)。 技巧 判断一个数是否是 \\(2\\) 的幂次，可以根据 \\(lowbit\\) 与该数本身是否相等来判断。 代码 12345678910#include &lt;cstdio&gt;bool check(int x)&#123; return (x &amp; -x) == x; &#125; // 技巧int H, W, n;int main()&#123; scanf(&quot;%d%d&quot;, &amp;H, &amp;W); long long tmp = 1ll * H * W - 1; while (tmp) ++n, tmp &gt;&gt;= 1; // 求 n if (!check(W) || check(H) || check(H + 1)) printf(&quot;%lld\\n&quot;, (1ll &lt;&lt; n) - 1); else printf(&quot;%lld\\n&quot;, (1ll &lt;&lt; n) - W);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"CODE FESTIVAL 2015 OKINAWA OPEN","slug":"题解/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN/"}],"tags":[{"name":"分类讨论","slug":"分类讨论","permalink":"https://autumnkite.github.io/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/"}]},{"title":"「LuoguP3846」「TJOI2007」可爱的质数 / BSGS 学习笔记","slug":"luogu3846-sol-bsgs-notes","date":"2019-02-15T07:10:00.000Z","updated":"2020-03-26T07:22:57.232Z","comments":true,"path":"luogu3846-sol-bsgs-notes/","link":"","permalink":"https://autumnkite.github.io/luogu3846-sol-bsgs-notes/","excerpt":"大步小步法（Baby Step Giant Step, BSGS），用于解决求形如 \\(a^x\\equiv b \\pmod P\\) 的最小非负整数解，其中\\((a,P)=1\\)。","text":"大步小步法（Baby Step Giant Step, BSGS），用于解决求形如 \\(a^x\\equiv b \\pmod P\\) 的最小非负整数解，其中\\((a,P)=1\\)。 求解 显然 \\(x\\) 可以表示为 \\(i\\cdot t-j\\) 的形式，其中 \\(t\\) 是常数。那么原方程化为 \\[\\begin{aligned} a^{it-j} &amp;\\equiv b &amp;\\pmod P \\\\ \\frac{a^{it}}{a^j} &amp;\\equiv b &amp;\\pmod P \\\\ a^{it}&amp;\\equiv ba^j &amp;\\pmod P \\end{aligned}\\] 又根据欧拉定理可得，\\(a^b\\equiv a^{b\\bmod \\varphi(P)}\\pmod P\\)，所以最小非负整数解一定满足 \\(0\\le x &lt; \\varphi(P)\\)。 那么 \\(t\\) 取 \\(\\lfloor \\sqrt{\\varphi(P)}\\rfloor\\) 时，\\(i,j\\) 的数量都是 \\(\\mathcal O(\\sqrt{P})\\) 的。所以我们只要对于所有的 \\(i\\) 求出 \\(a^{it}\\)，对于所有的 \\(j\\) 求出 \\(ba^j\\)，然后匹配即可。 具体实现时，可以用 map 或 hashmap 实现快速查找。 代码 「TJOI2007」可爱的质数 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;map&gt;int P, a, b;int BSGS(int a, int b)&#123; a %= P, b %= P; if (a == 0) return b == 0 ? 1 : -1; std :: map&lt;int, int&gt; M; int t = sqrt(P) + 1, x = 1, y; for (register int i = 0; i &lt; t; ++i, x = 1ll * x * a % P) M[1ll * x * b % P] = i; y = x; if (M.count(1) &amp;&amp; M[1] == 0) return 0; for (register int i = 1; i &lt;= t; ++i, x = 1ll * x * y % P) if (M.count(x)) return i * t - M[x]; return -1;&#125;void write_ans(int x)&#123; if (x &lt; 0) printf(&quot;no solution\\n&quot;); else printf(&quot;%d\\n&quot;, x);&#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;P, &amp;a, &amp;b); write_ans(BSGS(a, b));&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://autumnkite.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"TJOI","slug":"TJOI","permalink":"https://autumnkite.github.io/tags/TJOI/"},{"name":"BSGS","slug":"BSGS","permalink":"https://autumnkite.github.io/tags/BSGS/"}]},{"title":"「AT1726」「CODE FESTIVAL 2015 OKINAWA OPEN」Dictionary for Shiritori Game","slug":"atcoder-cfoo15D-sol","date":"2019-02-13T06:18:00.000Z","updated":"2020-03-26T07:22:57.156Z","comments":true,"path":"atcoder-cfoo15D-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-cfoo15D-sol/","excerpt":"题目传送门 题意 给定大小为 \\(n\\) 的字符集和 \\(m\\) 个单词，第 \\(i\\) 个单词以字符 \\(a_i\\) 开头，以字符 \\(b_i\\) 结尾。 Snuke 和 Sothe 轮流玩单词接龙游戏（Snuke 先手）。每次游戏那个人必须说出一个以上个单词的末尾字符开头的单词，第一个人必须说出一个以字符 1 开头的单词。若轮到该人进行游戏时，说不出符合条件的单词，则该人失败。 假设两人绝对聪明，判断谁是胜者或者游戏会永远进行下去。 \\(n\\le 10^5,m\\le 2\\times 10^5\\)","text":"题目传送门 题意 给定大小为 \\(n\\) 的字符集和 \\(m\\) 个单词，第 \\(i\\) 个单词以字符 \\(a_i\\) 开头，以字符 \\(b_i\\) 结尾。 Snuke 和 Sothe 轮流玩单词接龙游戏（Snuke 先手）。每次游戏那个人必须说出一个以上个单词的末尾字符开头的单词，第一个人必须说出一个以字符 1 开头的单词。若轮到该人进行游戏时，说不出符合条件的单词，则该人失败。 假设两人绝对聪明，判断谁是胜者或者游戏会永远进行下去。 \\(n\\le 10^5,m\\le 2\\times 10^5\\) 题解 每个字符当作一个状态，建出游戏图（\\(a_i\\to b_i\\)）。若游戏图中某个点的所有儿子都是必胜态，则当前点必败；若当前点的所有儿子中有一个状态是必败，则当前点必胜；否则为平局。 直接用 dfs 会因为有环而变得很难搞（求助路过的 dalao 帮蒟蒻看一下 代码，WA 3个点 QAQ），所以考虑建反图，倒着推。 代码 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;int read()&#123; register int x = 0, ch = getchar(); for (; !isdigit(ch); ch = getchar()) ; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return x;&#125;#define N 100005#define M 200005int n, m, f[N], h, t, Q[N], d[N];int edge, to[M], pr[M], hd[N];void addedge(int u, int v)&#123; // 连边 to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;&#125;int main()&#123; n = read(), m = read(); for (register int i = 1, x, y; i &lt;= m; ++i) x = read(), y = read(), addedge(y, x), ++d[x]; // 倒推，反向连边 h = 0, t = 0; for (register int i = 1; i &lt;= n; ++i) if (!d[i]) Q[++t] = i, f[i] = 2; // 边界状态 while (h &lt; t)&#123; int u = Q[++h]; if (f[u] == 2) // 当前状态必败 for (register int i = hd[u]; i; i = pr[i]) !f[to[i]] ? Q[++t] = to[i] : 0, f[to[i]] = 1; // 则父状态必胜 else // 当前状态必胜 for (register int i = hd[u]; i; i = pr[i]) if (!(--d[to[i]])) Q[++t] = to[i], f[to[i]] = 2; // 所有后继状态都是必胜，则必败 &#125; if (f[1] == 0) printf(&quot;Draw\\n&quot;); else if (f[1] == 1) printf(&quot;Snuke\\n&quot;); else if (f[1] == 2) printf(&quot;Sothe\\n&quot;);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"CODE FESTIVAL 2015 OKINAWA OPEN","slug":"题解/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN/"}],"tags":[{"name":"博弈","slug":"博弈","permalink":"https://autumnkite.github.io/tags/%E5%8D%9A%E5%BC%88/"},{"name":"建图","slug":"建图","permalink":"https://autumnkite.github.io/tags/%E5%BB%BA%E5%9B%BE/"}]},{"title":"「AT1725」「CODE FESTIVAL 2015 OKINAWA OPEN」Cat versus Wolf","slug":"atcoder-cfoo15C-sol","date":"2019-02-12T05:59:00.000Z","updated":"2020-03-27T09:41:53.829Z","comments":true,"path":"atcoder-cfoo15C-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-cfoo15C-sol/","excerpt":"题目传送门 题意 给定一个初始状态如图所示的建筑，共 \\(n\\) 层（不包括 Daruma），自底向上编号 \\(1\\sim n\\)。 下图分别表示建筑的初始状态、奇数层的放置和偶数层的放置。 Snuke 和 Sothe 轮流进行游戏，Snuke 先手，每次游戏可以拿走建筑中的任意一块砖头，但不允许拿走砖头后建筑变得不平衡。如果不存在砖头可以被拿走，那么该玩家输。 给定一个未结束的游戏，判断两人在绝对聪明的情况下，谁是必胜者（需要根据以拿走的砖块数量确定先手）。 不平衡的定义是，\\(n\\)层中，存在某层没有砖块，或只有一块砖且这块砖在两侧。 \\(n\\le 50000\\)","text":"题目传送门 题意 给定一个初始状态如图所示的建筑，共 \\(n\\) 层（不包括 Daruma），自底向上编号 \\(1\\sim n\\)。 下图分别表示建筑的初始状态、奇数层的放置和偶数层的放置。 Snuke 和 Sothe 轮流进行游戏，Snuke 先手，每次游戏可以拿走建筑中的任意一块砖头，但不允许拿走砖头后建筑变得不平衡。如果不存在砖头可以被拿走，那么该玩家输。 给定一个未结束的游戏，判断两人在绝对聪明的情况下，谁是必胜者（需要根据以拿走的砖块数量确定先手）。 不平衡的定义是，\\(n\\)层中，存在某层没有砖块，或只有一块砖且这块砖在两侧。 \\(n\\le 50000\\) 题解 显然是个博弈问题。且层与层之间独立，所以可以看作是 \\(n\\) 个单独的游戏的和。那么我们只要求出每一层的 SG 函数值，然后 xor 起来即可。 每一层只有 \\(2^3-3=5\\) 种可能的情况，分类讨论每种情况的 SG 函数值即可。 游戏图如下（0 表示没有砖块，1 表示有砖块，括号内的数表示该状态的 SG 函数值）： 代码 12345678910111213141516#include &lt;bits/stdc++.h&gt;int n, S, ans;char s[3][3];int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (register int i = 1; i &lt;= n; ++i)&#123; for (register int j = 0; j &lt; 3; ++j) scanf(&quot;%s&quot;, s[j]); if (s[0][0] == &#x27;#&#x27; &amp;&amp; s[1][1] == &#x27;#&#x27; &amp;&amp; s[2][2] == &#x27;#&#x27;) ans ^= 2; if (s[0][0] == &#x27;.&#x27; &amp;&amp; s[1][1] == &#x27;#&#x27; &amp;&amp; s[2][2] == &#x27;#&#x27;) ans ^= 1, ++S; if (s[0][0] == &#x27;#&#x27; &amp;&amp; s[1][1] == &#x27;#&#x27; &amp;&amp; s[2][2] == &#x27;.&#x27;) ans ^= 1, ++S; if (s[0][0] == &#x27;.&#x27; &amp;&amp; s[1][1] == &#x27;#&#x27; &amp;&amp; s[2][2] == &#x27;.&#x27;) S += 2; if (s[0][0] == &#x27;#&#x27; &amp;&amp; s[1][1] == &#x27;.&#x27; &amp;&amp; s[2][2] == &#x27;#&#x27;) ++S; // 五种情况分类讨论 &#125; printf((!ans) == (S &amp; 1) ? &quot;Snuke\\n&quot; : &quot;Sothe\\n&quot;); // 注意判断先后手&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"CODE FESTIVAL 2015 OKINAWA OPEN","slug":"题解/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN/"}],"tags":[{"name":"SG函数","slug":"SG函数","permalink":"https://autumnkite.github.io/tags/SG%E5%87%BD%E6%95%B0/"}]},{"title":"「AT1724」「CODE FESTIVAL 2015 OKINAWA OPEN」Beware of the Sogginess!","slug":"atcoder-cfoo15B-sol","date":"2019-02-09T15:43:00.000Z","updated":"2020-03-26T07:22:57.155Z","comments":true,"path":"atcoder-cfoo15B-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-cfoo15B-sol/","excerpt":"题目传送门 题意 给定 \\(n\\) 个二元组 \\((a_i,b_i)\\)。一个二元组 \\((a,b)\\) 可以变为 \\((a+t,b-t)\\ (0\\le t\\le b)\\)。你现在可以选择一些二元组并将它们分别进行（即互相独立）一次变换，使得变换后你选择的所有二元组 \\((a_j,b_j)\\)，\\(\\sum a_j\\ge A,\\sum b_j\\ge B\\)。求最少需要选择并变换的二元组数量。 \\(1\\le n\\le 50,1\\le A,B,a_i,b_i\\le 10^4\\)","text":"题目传送门 题意 给定 \\(n\\) 个二元组 \\((a_i,b_i)\\)。一个二元组 \\((a,b)\\) 可以变为 \\((a+t,b-t)\\ (0\\le t\\le b)\\)。你现在可以选择一些二元组并将它们分别进行（即互相独立）一次变换，使得变换后你选择的所有二元组 \\((a_j,b_j)\\)，\\(\\sum a_j\\ge A,\\sum b_j\\ge B\\)。求最少需要选择并变换的二元组数量。 \\(1\\le n\\le 50,1\\le A,B,a_i,b_i\\le 10^4\\) 题解 转化题意：给定 \\(n\\) 个二元组 \\((b_i,a_i+b_i)\\)，选择最少的二元组使得所有选择的二元组 \\(\\sum b_j\\ge B,\\sum (a_j+b_j)\\ge A+B\\)。 于是就可以 DP 了。\\(dp_{i,j}\\) 表示选择 \\(i\\) 个二元组，\\(\\sum b_i=j\\) 时，\\(\\sum (a_i+b_i)\\) 的最大值。 考虑把 \\(n\\) 个二元组依次加入，DP 方程很容易写出。 发现直接写，第二维有百万级别，怎么办？\\(j&gt;B\\) 的状态都合并到 \\(j=B\\) 处即可。 代码 1234567891011121314#include &lt;bits/stdc++.h&gt;int n, A, B, a[55], b[55], dp[55][10005];void cmx(int &amp;x, int y)&#123; x = std :: max(x, y); &#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;B, &amp;A), B += A; // 与上面的 A,B 有区别，注意区分 for (register int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d&quot;, b + i, a + i), b[i] += a[i]; // 与上面的 ai,bi 有区别，注意区分 memset(dp, -1, sizeof dp), dp[0][0] = 0; for (register int i = 1; i &lt;= n; ++i) // 依次加入 for (register int j = i - 1; ~j; --j) // 倒着做，与 01 背包同理 for (register int k = 0; k &lt;= A; ++k) if (~dp[j][k]) cmx(dp[j + 1][k + a[i] &gt; A ? A : k + a[i]], dp[j][k] + b[i]); for (register int i = 1; i &lt;= n; ++i) if (dp[i][A] &gt;= B) return printf(&quot;%d\\n&quot;, i), 0; return printf(&quot;-1\\n&quot;), 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"CODE FESTIVAL 2015 OKINAWA OPEN","slug":"题解/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"}]},{"title":"「AT1723」「CODE FESTIVAL 2015 OKINAWA OPEN」Automatic Map Generator","slug":"atcoder-cfoo15A-sol","date":"2019-02-09T15:29:35.000Z","updated":"2020-03-26T07:22:57.154Z","comments":true,"path":"atcoder-cfoo15A-sol/","link":"","permalink":"https://autumnkite.github.io/atcoder-cfoo15A-sol/","excerpt":"题目传送门 题意 构造一张 \\(H\\times W\\) 的由岛屿#、海洋.组成的地图，岛屿为八连通，满足恰好包含 \\(K\\) 个联通块。 \\(1\\le H,W\\le 100,1\\le K\\le 10000\\)","text":"题目传送门 题意 构造一张 \\(H\\times W\\) 的由岛屿#、海洋.组成的地图，岛屿为八连通，满足恰好包含 \\(K\\) 个联通块。 \\(1\\le H,W\\le 100,1\\le K\\le 10000\\) 题解 为了放置更多的联通块，每个联通块恰好为一个单位时显然最优。 所以放一张类似于下图所示的地图即可（即在奇数行奇数列放置#，直到放满 \\(K\\) 个）。 123#.#.#.#.........#.#.#.#. 代码 1234567891011121314#include &lt;cstdio&gt;int n, m, t;char a[105][105];int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t); for (register int i = 1; i &lt;= n; ++i) for (register int j = 1; j &lt;= m; ++j) if (t &amp;&amp; (i &amp; 1) &amp;&amp; (j &amp; 1)) a[i][j] = &#x27;#&#x27;, --t; else a[i][j] = &#x27;.&#x27;; if (t) return printf(&quot;IMPOSSIBLE\\n&quot;), 0; for (register int i = 1; i &lt;= n; ++i)&#123; for (register int j = 1; j &lt;= m; ++j) putchar(a[i][j]); putchar(&#x27;\\n&#x27;); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"CODE FESTIVAL 2015 OKINAWA OPEN","slug":"题解/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"}]},{"title":"NOIP2018 题解","slug":"noip2018-sol","date":"2019-02-09T07:35:55.000Z","updated":"2020-03-27T09:42:33.737Z","comments":true,"path":"noip2018-sol/","link":"","permalink":"https://autumnkite.github.io/noip2018-sol/","excerpt":"蒟蒻写的 NOIP2018 题解，欢迎吐槽。","text":"蒟蒻写的 NOIP2018 题解，欢迎吐槽。","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"NOIP2018","slug":"NOIP2018","permalink":"https://autumnkite.github.io/tags/NOIP2018/"}]},{"title":"PKUWC2019 自闭记","slug":"pkuwc2019","date":"2019-01-23T12:22:07.000Z","updated":"2020-03-26T07:22:57.236Z","comments":true,"path":"pkuwc2019/","link":"","permalink":"https://autumnkite.github.io/pkuwc2019/","excerpt":"评（tu）价（cao）：如何评价PKUWC 2019？ - 知乎 Day -N 联赛没考好。不过最后还是能去PKUWC。于是就又去某强者聚集的高中被吊锤了。","text":"评（tu）价（cao）：如何评价PKUWC 2019？ - 知乎 Day -N 联赛没考好。不过最后还是能去PKUWC。于是就又去某强者聚集的高中被吊锤了。 Day -1 晚上。吃完晚饭以后就到了火车站，大概7点左右到的吧。然后就是等人、取票、进站…… 先乘高铁到杭州，然后在杭州转车（动卧）。在杭州也等了好一会吧，20:55，动车开了…… 基本就是整理行李、玩手机以及各种探索（大雾。 Day 0 凌晨2点醒了一次，好像是被冷醒的，因为房间里吹出来的风是冷的。盖好被子以后就又睡着了，早上5:10就被fy吵醒了……总的来说睡眠质量极差。 8点就到中山了，有专车来接，直接到中山纪念中学报到了。纪中占地面积是真的大，850亩，风景挺好的。 没事干，就去旁边的孙中山故居逛了一圈，fy和ykl都去参加了那个答题，得到了一个胸章。 天气很好，气温很高，穿着棉袄、线衫、加绒裤，热到不行。 回酒店，在旁边的餐馆吃中饭，可惜的是烧鹅没了，只能吃烧鸭。4点回学校，试机，吃晚饭。这里的食堂不是很好，饭没有浙江的好吃。试机T2都不会做。 晚上逛学校，还好袋子里有地图，差点迷路…… Day 1 上午开营仪式，看了一下宣传片，听了纪中的校长、北大的两个教授的讲话。门开得正可海星。然后是营员合影。 下午的上机爆炸。T1就是个状压，我想到正解感觉好麻烦就放弃了……最后还是只有35的暴力。 T2想了好一会\\(m=2\\)和链的做法，想了没多久也放弃了。 T3地主斗，写了2.5h一分未得。考后和同学的方法比较，感觉细节应该都判了啊。 最后35+0+0=35……自闭了，还是策略不对吧。 Day 2 早上突然想到地主斗那题，排的顺序是无关的，搜索的时候要判一下…… 上午数学考试，实质是提答十合一，貌似是py优势场。我这种菜鸡只会写暴力，大概只对了两道？ 下午的上机仍然爆炸，T1第一个包一眼，第二个包想了好久，不过还好搞出来了。 T2当时好像\\(n,m\\le 10\\)都不会，最后40分钟感觉没事干就写了个很fake的dfs，竟然过了。 T3不说了，计算几何告辞（知道前两个包怎么做，不会实现）。 当场自闭，T1满分想不出来，T2根本不会，为了防止跟昨天一样，我果断（其实还是很犹豫地）放弃了T3。 最后得分48+21+0=69。自闭了。 Day 3 这种分数显然进不了面试，滚粗。还是太菜了啊。 于是我和zyk就在ll的带领下去珠海旅游了（另外两人比较颓，没来）。 ll说我们主要是因为数学考太差，然而我觉得我都考太差…… 先到海滨公园，看了珠海渔女。海岸线确实挺曲折的。然后就差不多要吃饭了，沿海岸线走到了一家海鲜餐厅，点了大概6碗菜吧，味道还不错。 饭吃完我们骑共享单车沿海岸线骑，一直骑到边防管理区（通往澳门的桥的桥头），大概骑了7km。发现那里离珠海站很近，就直接乘轻轨回到南朗，买了六点半的票。发现还早，于是提议去圆明新园逛一圈。 又骑了5km，在圆明新园里面逛了一圈，感觉就是个横店影视城的弱化版？去坐了一下缆车，但是观景体验极差，感觉浪费了150块钱。 差不多时间了就去珠海站附近，逛了一圈决定吃煲仔饭，吃完就去进站候车了。 基本一下午都在骑车、走路，心态崩。 Day 4 打算8点起床的，结果9点才醒，还是因为窗帘没拉好透出了光被亮醒的……起床之后去吃了早饭，然后洗了个澡，等ykl也完了以后就下去了。 退房，上大巴。大部分人都是去机场的，就我们四个人，变成包车了。一路上qq和司机聊得挺欢。 中饭吃车站里的麦当劳，高铁15:38开，就在车站里找了个位置玩手机。车站人很多，大概是因为春运？好不容易才找到位置。 晚饭在高铁上吃盒饭，拿了个鸡翅和鱼，竟然要￥60……而且不是很好吃…… 到义乌，fy爸爸来接，到家23:00，等睡着就00:00了。 还是太菜了，省选根本没戏，正月要恶补文化课了。班主任还强迫我把期末考试补起来，啥都没复习，还没有状态……凉凉。","categories":[{"name":"游记","slug":"游记","permalink":"https://autumnkite.github.io/categories/%E6%B8%B8%E8%AE%B0/"},{"name":"PKUWC","slug":"游记/PKUWC","permalink":"https://autumnkite.github.io/categories/%E6%B8%B8%E8%AE%B0/PKUWC/"}],"tags":[]},{"title":"「LuoguP3723」「AHOI / HNOI2017」礼物","slug":"luogu3723-sol","date":"2019-01-19T06:04:16.000Z","updated":"2020-03-26T07:22:57.230Z","comments":true,"path":"luogu3723-sol/","link":"","permalink":"https://autumnkite.github.io/luogu3723-sol/","excerpt":"题目传送门 题意 给定两个长度为\\(n\\)的正整数序列\\(a_0,a_1,a_2,\\cdots,a_{n-1}\\)和\\(b_0,b_1,b_2,\\cdots,b_{n-1}\\)，满足\\(a_i,b_i\\le m\\)。 求\\[\\sum_{i=0}^{n-1} ((a_i+c_0)-(b_{(i+k)\\bmod n}+c_1))^2\\]的最小值，其中\\(k,c_0,c_1\\)是非负整数。 \\(n\\le 5\\times 10^4,m\\le 100\\)。","text":"题目传送门 题意 给定两个长度为\\(n\\)的正整数序列\\(a_0,a_1,a_2,\\cdots,a_{n-1}\\)和\\(b_0,b_1,b_2,\\cdots,b_{n-1}\\)，满足\\(a_i,b_i\\le m\\)。 求\\[\\sum_{i=0}^{n-1} ((a_i+c_0)-(b_{(i+k)\\bmod n}+c_1))^2\\]的最小值，其中\\(k,c_0,c_1\\)是非负整数。 \\(n\\le 5\\times 10^4,m\\le 100\\)。 题解 观察上式，可以发现我们并不关心\\(c_0,c_1\\)具体的值，只关心\\(c_0-c_1\\)的值。记\\(c=c_0-c_1\\)，显然有\\(-m\\le c\\le m\\)。于是变成了求\\[\\sum_{i=0}^{n-1} (a_i-b_{(i+k)\\bmod n}+c)^2\\]的最小值，其中\\(0\\le k\\le n-1,-m\\le c\\le m\\)。 最朴素的做法是直接枚举\\(k,c\\)计算答案，时间复杂度\\(O(n^2m)\\)。 这个和的平方的形式很难优化，考虑把它展开： \\[\\begin{aligned} &amp;\\quad \\sum_{i=0}^{n-1}(a_i-b_{(i+k)\\bmod n}+c)^2 \\\\ &amp;=\\sum_{i=0}^{n-1}(a_i^2+b_{(i+k)\\bmod n}^2+c^2-2a_ib_{(i+k)\\bmod n}+2a_ic-2b_{(i+k)\\bmod n}c) \\\\ &amp;=-2\\sum a_ib_{(i+k)\\bmod n}+\\sum a_i^2+\\sum b_i^2+2c\\sum (a_i-b_i)+nc^2 \\end{aligned}\\] 然后我们发现，\\(k,c\\)并没有同时影响答案中的某一项。第一项为与\\(k\\)有关的式子，显然后面部分为关于\\(c\\)的一个二次函数。后面部分可以直接用二次函数的顶点公式计算（注意\\(c\\)是整数，需要讨论两种情况），也可以直接枚举\\(c\\)进行计算。 如果前面部分也直接枚举\\(k\\)进行计算的话，时间复杂度为\\(\\mathcal O(n^2)\\)，仍不能通过。 先不考虑系数。\\(\\bmod\\)很难处理，考虑把\\(b\\)倍长，原式变成了\\(\\sum a_ib_{i+k}\\)。联系卷积的基本形式\\(c_i=\\sum_{j=0}^{i} a_jb_{i-j}\\)，可以发现需要满足\\(a,b\\)的下标之和为\\(c\\)的下标，即一个与\\(j\\)无关的值。那么我们考虑把\\(a\\)翻转，原式变成了\\(\\sum a_{n-i-1}b_{i+k}\\)，此时\\(n-i-1+i+k=n+k-1\\)，是一个与\\(i\\)无关的值。于是就可以FFT了。由于\\(0\\le k\\le n-1\\)，所以对应的答案（假设\\(c=a*b\\)）就是\\(c_{n-1},c_{n},c_{n+1},\\cdots,c_{2n-2}\\)。 啥？FFT精度爆了？因为\\(m\\le 100\\)，所以\\(0\\le c_i\\le nm^2\\le 5\\times 10^8&lt; 998244353\\)，直接用NTT即可。 时间复杂度\\(O(n\\log n)\\)。 代码 评测记录，开O2，总时间170ms，目前在第一页。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 300005#define INF 0x3f3f3f3f3f3f3f3fllint n, m, a[N], b[N], c[N];namespace Polynomial&#123; #define P 998244353 int omega[N], rev[N]; int qpow(int a, int b)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if (b &amp; 1) s = 1ll * s * a % P; return s; &#125; void init(int n)&#123; int k = 0; while ((1 &lt;&lt; k) &lt; n) ++k; for (register int i = 0; i &lt; n; ++i) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; k &gt;&gt; 1; &#125; void add(int &amp;x, int y)&#123; (x += y) &gt;= P ? x -= P : 0; &#125; int sub(int x, int y)&#123; return (x -= y) &lt; 0 ? x + P : x; &#125; void NTT(int n, int *a, int o = 1)&#123; for (register int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) std :: swap(a[i], a[rev[i]]); for (register int m = 1, l; m &lt; n; m = l)&#123; l = m &lt;&lt; 1, omega[0] = 1, omega[1] = qpow(~o ? 3 : 332748118, (P - 1) / l); for (register int i = 2; i &lt; m; ++i) omega[i] = 1ll * omega[i - 1] * omega[1] % P; for (register int *p = a, t; p &lt; a + n; p += l) for (register int k = 0; k &lt; m; ++k) t = 1ll * p[k + m] * omega[k] % P, p[k + m] = sub(p[k], t), add(p[k], t); &#125; if (o == -1) for (register int _n = qpow(n, P - 2), i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * _n % P; &#125; void Multiply(int na, int *a, int nb, int *b, int nc, int *c)&#123; int n = 1; while (n &lt; nc) n &lt;&lt;= 1; init(n), NTT(n, a), NTT(n, b); for (register int i = 0; i &lt; n; ++i) c[i] = 1ll * a[i] * b[i] % P; NTT(n, c, -1); &#125;&#125;int main()&#123; long long s1 = 0, s2 = 0, s = INF, ans = INF; n = read(), m = read(); for (register int i = 0; i &lt; n; ++i) a[n - i - 1] = read(); for (register int i = 0; i &lt; n; ++i) b[i + n] = b[i] = read(); for (register int i = 0; i &lt; n; ++i) s1 += 1ll * a[i] * a[i] + 1ll * b[i] * b[i], s2 += (a[i] &lt;&lt; 1) - (b[i] &lt;&lt; 1); Polynomial :: Multiply(n, a, n &lt;&lt; 1, b, n &lt;&lt; 1, c); for (register int i = n - 1; i &lt; (n &lt;&lt; 1) - 1; ++i) s = std :: min(s, -2ll * c[i]); for (register int i = -m; i &lt;= m; ++i) ans = std :: min(ans, 1ll * n * i * i + s2 * i + s1); printf(&quot;%lld\\n&quot;, ans + s);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Luogu","slug":"题解/Luogu","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Luogu/"}],"tags":[{"name":"AHOI","slug":"AHOI","permalink":"https://autumnkite.github.io/tags/AHOI/"},{"name":"HNOI","slug":"HNOI","permalink":"https://autumnkite.github.io/tags/HNOI/"},{"name":"NTT","slug":"NTT","permalink":"https://autumnkite.github.io/tags/NTT/"}]},{"title":"「模拟赛20190116 T3」MEX","slug":"vc190116C-sol","date":"2019-01-17T03:27:52.000Z","updated":"2020-03-26T07:22:57.239Z","comments":true,"path":"vc190116C-sol/","link":"","permalink":"https://autumnkite.github.io/vc190116C-sol/","excerpt":"题意 原题链接 给定一个长度为\\(n\\)的序列，\\(q\\)次询问\\(l,r\\)，求原序列\\([l,r]\\)中每个数的出现次数组成的集合\\(S\\)的\\(\\text{MEX}\\)。 集合\\(S\\)的\\(\\text{MEX}\\)是指最小的没有在集合\\(S\\)中出现的正整数。 \\(n,q\\le 1.5\\times 10^5\\)。","text":"题意 原题链接 给定一个长度为\\(n\\)的序列，\\(q\\)次询问\\(l,r\\)，求原序列\\([l,r]\\)中每个数的出现次数组成的集合\\(S\\)的\\(\\text{MEX}\\)。 集合\\(S\\)的\\(\\text{MEX}\\)是指最小的没有在集合\\(S\\)中出现的正整数。 \\(n,q\\le 1.5\\times 10^5\\)。 题解 一个简单的暴力实现 首先离散，对于每个询问，按题意求出每个数的出现次数，再求出每个出现次数是否出现，然后枚举求出答案即可。 时间复杂度\\(\\mathcal O(nq)\\)。 基于暴力思想的分块做法 显然答案不会超过\\(\\sqrt{2n}\\)，那么一个显然的优化是只需要记录所有\\(\\le \\sqrt{2n}\\)的出现次数。 于是就可以很自然地想到分块了。分成\\(\\sqrt{n}\\)个块（在代码中为了卡常、卡内存可以作微调），直接暴力求出两块之间所有数的出现次数的出现次数（注意不是是否出现），记为\\(V[x][y][i]\\)，表示\\(x\\)块到\\(y\\)块中出现次数\\(i\\)的出现次数。这个可以很轻松的在扫的过程中求出来（--c[b[a[i]]],++b[a[i]],++c[b[a[i]]]，\\(b[i]\\)表示数\\(i\\)的出现次数，\\(c[i]\\)表示出现次数\\(i\\)的出现次数。即把原来的出现次数去掉，出现次数加一，把新的出现次数加入）。这一部分时间复杂度是\\(\\mathcal O(n\\sqrt{n})\\)的。 可是我们发现，只求出这个好像还是有点难回答询问。为什么？因为这只求出了整块的答案，而旁边的两小块没有被处理。 我们再求出\\(L[x][y][i]\\)表示\\(x\\)块到\\(y\\)块中，\\(x\\)块向左\\(i\\)个位置的数出现了多少次，同理\\(R[x][y][i]\\)表示\\(x\\)块到\\(y\\)块中，\\(y\\)块向右\\(i\\)个位置的数出现了多少次。这两个数组也很好求，可以与之前的\\(V\\)数组放在一起处理。 处理出这三个数组后，相当于持续了之前的\\(b,c\\)数组。直接在两边的小块扫一遍即可。对于\\(l,r\\)在同一块中的情况，直接暴力扫一遍即可。单次询问时间复杂度\\(\\mathcal O(\\sqrt{n})\\)。 注意\\(b[i]\\)的下标是\\(\\mathcal O(n)\\)级别，不能每次清零，可以额外记一下\\(vis[i]\\)表示\\(b[i]\\)的使用情况，若\\(vis[i]=0\\)，则表示未使用，否则\\(vis[i]\\)表示\\(b[i]\\)在哪一次询问被使用，若是当前询问则可以直接加，否则需要用\\(L\\)或\\(R\\)数组中的值覆盖。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 150005const int B = 420, C = 360, P = 550;int n, q, k, a[N], b[N], c[N], vis[N];int L[365][365][425], R[365][365][425], V[365][365][555];void pre()&#123; for (register int i = 0; i &lt; n; i += B)&#123; for (register int j = 0; j &lt; n; ++j) b[j] = 0; for (register int j = 0; j &lt; P; ++j) c[j] = 0; for (register int j = i; j &lt; n; ++j)&#123; --c[b[a[j]]], ++b[a[j]], ++c[b[a[j]]]; if ((j + 1) % B == 0)&#123; register int bi = i / B, bj = j / B; for (register int k = 0; k &lt; P; ++k) V[bi][bj][k] = c[k]; for (register int k = 0; k &lt; B &amp;&amp; i - k - 1 &gt;= 0; ++k) L[bi][bj][k] = b[a[i - k - 1]]; for (register int k = 0; k &lt; B &amp;&amp; j + k + 1 &lt; n; ++k) R[bi][bj][k] = b[a[j + k + 1]]; &#125; &#125; &#125;&#125;int solve(int q, int l, int r)&#123; register int bl = (l - 1) / B + 1, br = (r + 1) / B - 1; register int pl = B * bl, pr = B * (br + 1) - 1; if (bl &lt;= br)&#123; for (register int i = 0; i &lt; P; ++i) c[i] = V[bl][br][i]; for (register int i = 0; i &lt; pl - l; ++i)&#123; register int j = pl - i - 1; if (vis[a[j]] != q) vis[a[j]] = q, b[a[j]] = L[bl][br][i]; --c[b[a[j]]], ++b[a[j]], ++c[b[a[j]]]; &#125; for (register int i = 0; i &lt; r - pr; ++i)&#123; register int j = pr + i + 1; if (vis[a[j]] != q) vis[a[j]] = q, b[a[j]] = R[bl][br][i]; --c[b[a[j]]], ++b[a[j]], ++c[b[a[j]]]; &#125; &#125; else&#123; for (register int i = 0; i &lt; P; ++i) c[i] = 0; for (register int i = l; i &lt;= r; ++i)&#123; if (vis[a[i]] != q) vis[a[i]] = q, b[a[i]] = 0; --c[b[a[i]]], ++b[a[i]], ++c[b[a[i]]]; &#125; &#125; for (register int i = 0; i &lt; P; ++i) if (!c[i]) return i; return -1;&#125;int main()&#123; freopen(&quot;mex.in&quot;, &quot;r&quot;, stdin); freopen(&quot;mex.out&quot;, &quot;w&quot;, stdout); n = read(), q = read(), k = read(); for (register int i = 0; i &lt; n; ++i) a[i] = b[i] = read(); std :: sort(b, b + n); int m = std :: unique(b, b + n) - b; for (register int i = 0; i &lt; n; ++i) a[i] = std :: lower_bound(b, b + m, a[i]) - b; pre(); int ans = 0, l, r; for (register int _ = 1; _ &lt;= q; ++_)&#123; l = (read() ^ (k * ans)) - 1, r = (read() ^ (k * ans)) - 1; ans = solve(_, l, r), printf(&quot;%d\\n&quot;, ans); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"模拟赛","slug":"题解/模拟赛","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[{"name":"分块","slug":"分块","permalink":"https://autumnkite.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"MEX","slug":"MEX","permalink":"https://autumnkite.github.io/tags/MEX/"}]},{"title":"「模拟赛20190116 T2」序列","slug":"vc190116B-sol","date":"2019-01-16T13:12:00.000Z","updated":"2020-03-26T07:22:57.239Z","comments":true,"path":"vc190116B-sol/","link":"","permalink":"https://autumnkite.github.io/vc190116B-sol/","excerpt":"题意 原题链接 给定一个序列的前\\(n\\)项（\\(a_0,a_1,a_2,\\cdots,a_{n-1}\\)），保证对于所有\\(0\\le i\\le n-1\\)，\\(a_i\\in \\{n-1,n,n+1\\}\\)。对于\\(i\\ge n\\)，\\(a_i\\)的值为满足\\(0\\le j&lt; i\\)且\\(a_j\\ge i-j\\)的整数\\(j\\)的数量。 \\(q\\)个询问，每次询问一个\\(x\\)，求\\(a_x\\)的值。 \\(1\\le n,q\\le 10^5,0\\le x\\le 10^{15}\\)。","text":"题意 原题链接 给定一个序列的前\\(n\\)项（\\(a_0,a_1,a_2,\\cdots,a_{n-1}\\)），保证对于所有\\(0\\le i\\le n-1\\)，\\(a_i\\in \\{n-1,n,n+1\\}\\)。对于\\(i\\ge n\\)，\\(a_i\\)的值为满足\\(0\\le j&lt; i\\)且\\(a_j\\ge i-j\\)的整数\\(j\\)的数量。 \\(q\\)个询问，每次询问一个\\(x\\)，求\\(a_x\\)的值。 \\(1\\le n,q\\le 10^5,0\\le x\\le 10^{15}\\)。 题解 首先，我们可以利用归纳法证明对于任意\\(i\\)，\\(a_i\\in \\{n-1,n,n+1\\}\\)： 假设对于\\(0\\le j&lt; i\\)都满足该性质，则有\\[a_i=n-[a_{i-n}=n-1]+[a_{i-n-1}=n+1]\\]显然仍有\\(a_i\\in \\{n-1,n,n+1\\}\\)。 为方便讨论，用\\(0,1,2\\)分别代替\\(n-1,n,n+1\\)。 可以发现，假设初始时对于所有\\(i\\ge n\\)，\\(a_i=0\\)。然后对于一个\\(a_i\\)，若\\(a_i=0\\)，则不产生贡献；若\\(a_i=1\\)，则对\\(a_{i+n}\\)产生\\(1\\)的贡献；若\\(a_i=2\\)，则对\\(a_{i+n},a_{i+n+1}\\)各产生\\(1\\)的贡献。 然后我们先考虑一些子问题。 若初始时\\(a_i\\in \\{0,1\\}\\)，由于不存在\\(2\\)，一定有\\(a_{i+n}=a_i\\)，所以直接\\(\\bmod n\\)即可。 若初始时\\(a_i\\in \\{1,2\\}\\)，由于不存在\\(0\\)，即不存在没有贡献的情况，所以对于\\(a_i=2\\)，一定会导致\\(a_{i+n}=1,a_{i+n+1}=2\\)，观察一下可以发现，此时\\(a_{i+n+1}=a_i\\)，所以直接\\(\\bmod (n+1)\\)即可。 考虑原问题，由于存在\\(0\\)，将会导致有些位置没有贡献，那么对于\\(a_i=2\\)，可能会导致\\(a_{i+n}=1,a_{i+n+1}=1\\)（即\\(a_{i+1}=0\\)时）。联系之前的两个问题，当不存在\\(2\\)时，这种情况下一定会导致\\(a_{i+n+1}=0\\)；当不存在\\(0\\)时，这种情况下一定会导致\\(a_{i+n+1}=2\\)。可是，当\\(2,0\\)同时存在时，就会导致\\(a_{i+n+1}=1\\)。 更形象一点地讲，把\\(2\\)当作石头，把\\(1\\)当作平地，把\\(0\\)当作洞，这种情况就是石头调入洞里形成平地的情况。 假设初始数组中第\\(i\\)个位置是洞，第\\(j\\)个位置是石头，石头\\(j\\)会在\\(x\\)位置与洞\\(i\\)重合，掉入洞中。又因为将会在所有满足\\(p\\equiv j\\pmod{(n+1)}\\)且\\(p\\le x\\)的位置\\(p\\)出现石头，洞同理。所以\\(x\\)一定是满足下列同余方程组的最小正整数： \\[\\begin{cases} x\\equiv i\\pmod{n}\\\\x\\equiv j\\pmod{(n+1)} \\end{cases}\\] 这个求解想怎么做怎么做吧... 然后由于会首尾拼接，我们把初始数组想成一个环，显然对于每个洞\\(i\\)，一定是在环上与\\(i\\)有向距离最短的石子最终掉落在洞\\(i\\)。那么我们直接扫两遍，用栈维护当前的石子（第二遍不清空栈，就相当于成了环），每次遇到洞就取出栈顶元素——石头\\(j\\)（如果栈为空则跳过），算出\\(x\\)的值，记录\\(mat[i]=mat[j]=x\\)，一个点若没有\\(mat\\)值，则记为\\(INF\\)。 \\(mat\\)的定义显而易见，\\(mat[i]\\)表示与\\(i\\)有向距离最近的石子/洞与\\(i\\)抵消的位置。 有了\\(mat\\)以后对于询问就可以\\(\\mathcal O(1)\\)求了，可以根据\\(mat[x\\bmod n],mat[x\\bmod (n+1)]\\)与\\(x\\)的大小关系来计算贡献，注意除了比较\\(mat\\)和\\(x\\)的大小外，还需判断初始是否为石子/洞。 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;long long read()&#123; register long long x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f ^= 1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 200005int n, q, a[N], top, sta[N];long long x, mat[N]; // 注意long longint main()&#123; freopen(&quot;sequence.in&quot;, &quot;r&quot;, stdin); freopen(&quot;sequence.out&quot;, &quot;w&quot;, stdout); int T = 1; // CC原题是多组数据，为了方便修改 while (T--)&#123; n = read(), q = read(); for (register int i = 0; i &lt; n; ++i) a[i] = read(); for (register int i = 0; i &lt; n; ++i) mat[i] = 0x3f3f3f3f3f3f3f3fll; top = 0; for (register int k = 0; k &lt; 2; ++k) for (register int i = 0; i &lt; n; ++i) if (a[i] == n - 1 &amp;&amp; top)&#123; // 是洞，且栈非空 int j = sta[top--]; // 取出栈顶元素 mat[j] = mat[i] = (1ll * (i + n) * (n + 1) - 1ll * j * n) % (1ll * n * (n + 1)); // 根据中国剩余定理计算mat &#125; else if (a[i] == n + 1) sta[++top] = i; // 石子入栈 while (q--)&#123; x = read(); int ho = x % n, st = x % (n + 1); printf(&quot;%d &quot;, n - (a[ho] == n - 1 &amp;&amp; mat[ho] &gt; x) + (a[st] == n + 1 &amp;&amp; mat[st] &gt; x)); // O(1)计算答案，注意特判 &#125; putchar(&#x27;\\n&#x27;); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"模拟赛","slug":"题解/模拟赛","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[{"name":"中国剩余定理","slug":"中国剩余定理","permalink":"https://autumnkite.github.io/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"},{"name":"栈","slug":"栈","permalink":"https://autumnkite.github.io/tags/%E6%A0%88/"},{"name":"同余","slug":"同余","permalink":"https://autumnkite.github.io/tags/%E5%90%8C%E4%BD%99/"}]},{"title":"「LuoguP2042」「NOI2005」维护数列","slug":"luogu2042-sol","date":"2019-01-15T12:37:39.000Z","updated":"2020-03-26T07:22:57.229Z","comments":true,"path":"luogu2042-sol/","link":"","permalink":"https://autumnkite.github.io/luogu2042-sol/","excerpt":"题目传送门 题意 维护一个序列，支持插入序列、区间删除、区间覆盖、区间翻转、区间求和、求序列最大子段和（至少包含一个元素）。 插入总数\\(\\le 4\\times 10^6\\)，任意时刻序列长度\\(\\le 5\\times 10^5\\)。 题解 \\(Splay\\)板子题。","text":"题目传送门 题意 维护一个序列，支持插入序列、区间删除、区间覆盖、区间翻转、区间求和、求序列最大子段和（至少包含一个元素）。 插入总数\\(\\le 4\\times 10^6\\)，任意时刻序列长度\\(\\le 5\\times 10^5\\)。 题解 \\(Splay\\)板子题。 不会\\(Splay\\)的同学出门左转文艺平衡树。 由于插入数量太大，直接开4000000的数组显得不现实，我们考虑建立回收栈（雾），删除时遍历子树，回收被删除的节点，新建节点时优先从回收栈里取点，但是要注意各个数组都要初始化。 总体思路是，对每个节点维护：\\(val,sz,sum,la,ra,ma\\)，分别表示这个点本身的值、子树大小、子树的\\(val\\)之和、该区间（以这个点为根的子树所表示的区间，下同）中包含最左边元素的最长子段和（可以不包含元素）、包含最右边元素的最长子段和（可以不包含元素）、整个区间的最大子段和（至少包含一个元素，即答案）；懒标记\\(cov=0/1,rev=0/1\\)，分别表示该区间是否被覆盖、是否被翻转。 接下来我们仔细分析每一步操作。 新建节点 已经讲过，若回收栈里有点，则优先拿来用，否则新建节点。 123456int new_node(int _val)&#123; int x = top ? rb[top--] : ++cnt; // rb即回收栈 son[x][0] = son[x][1] = fa[x] = rev[x] = cov[x] = 0, sz[x] = 1; // 注意别忘记初始化 val[x] = ma[x] = sum[x] = _val, la[x] = ra[x] = std :: max(_val, 0); // la,ra可以不包含元素 return x;&#125; 上传 主要是\\(la,ra,ma\\)的更新。\\(la\\)和\\(ra\\)同理，以\\(la\\)为例，当前节点的\\(la\\)值就是max(左子树的la,左子树的sum+当前节点的val+右子树的la)，分别表示跨过当前节点和不跨过当前节点两种情况。对于\\(ma\\)，也差不多，不跨过的情况是max(左子树的ma,右子树的ma)，跨过的情况是左子树的ra+当前节点的val+右子树的la，在这两种情况中再取个\\(max\\)即可。 1234567void up(int u)&#123; int ls = son[u][0], rs = son[u][1]; sz[u] = sz[ls] + sz[rs] + 1, sum[u] = sum[ls] + sum[rs] + val[u]; la[u] = std :: max(la[ls], sum[ls] + val[u] + la[rs]); ra[u] = std :: max(ra[rs], sum[rs] + val[u] + ra[ls]); ma[u] = std :: max(std :: max(ma[ls], ma[rs]), ra[ls] + val[u] + la[rs]);&#125; 下传懒标记 比较简单，不需要考虑标记下传的顺序。 对于\\(cov\\)标记，直接把左右儿子的\\(val\\)设为当前节点的\\(val\\)，\\(sum\\)设为\\(val\\times sz\\)。而\\(la,ra,ma\\)则需要分类讨论，若\\(val&gt;0\\)，显然直接把整个区间选上更优，否则\\(la,ra\\)不选，\\(ma\\)只选一个点。 对于\\(rev\\)标记，直接交换左右儿子的左右子树、左右儿子的\\(la,ra\\)（注意不是交换当前节点的左右子树、\\(la,ra\\)，这种写法在文艺平衡树可以过，但是在本题中会出错）。 12345678910111213141516171819202122void down(int u)&#123; int ls = son[u][0], rs = son[u][1]; if (cov[u])&#123; if (ls) val[ls] = val[u], cov[ls] = 1, sum[ls] = sz[ls] * val[u]; if (rs) val[rs] = val[u], cov[rs] = 1, sum[rs] = sz[rs] * val[u]; if (val[u] &gt; 0)&#123; // 分类讨论 if (ls) la[ls] = ra[ls] = ma[ls] = sum[ls]; if (rs) la[rs] = ra[rs] = ma[rs] = sum[rs]; &#125; else&#123; if (ls) la[ls] = ra[ls] = 0, ma[ls] = val[u]; if (rs) la[rs] = ra[rs] = 0, ma[rs] = val[u]; &#125; cov[u] = 0; &#125; if (rev[u])&#123; if (ls) rev[ls] ^= 1, std :: swap(son[ls][0], son[ls][1]), std :: swap(la[ls], ra[ls]); if (rs) rev[rs] ^= 1, std :: swap(son[rs][0], son[rs][1]), std :: swap(la[rs], ra[rs]); // 交换左右儿子的左右子树和la,ra rev[u] = 0; &#125;&#125; 建树 直接按照原序列的顺序建树（注意不是按数的大小建树）。 可是直接插入是\\(\\mathcal O(n\\log n)\\)的，且常数较大。我们直接取序列中点作为根，然后递归调用左边和右边，分别作为根的左儿子和右儿子。 这样我们可以做到\\(\\mathcal O(n)\\)建树，\\(n\\)是序列长度。 123456789int build(int l, int r, int *a)&#123; if (l &gt; r) return 0; if (l == r) return new_node(a[l]); int mid = (l + r) &gt;&gt; 1, u = new_node(a[mid]); // 以mid为该子树的根，递归处理左右两边 son[u][0] = build(l, mid - 1, a), son[u][1] = build(mid + 1, r, a); fa[son[u][0]] = fa[son[u][1]] = u; return up(u), u; // 注意更新&#125; Splay的基本操作：\\(rotate(x)\\)和\\(splay(x,g)\\) \\(rotate(x)\\)表示将\\(x\\)向上旋转，\\(splay(x,g)\\)表示将\\(x\\)旋转到\\(g\\)的儿子。 注意\\(rotate(x)\\)时需要上传操作，且要注意操作顺序。\\(splay(x,g)\\)需要双旋。 123456789101112131415int dir(int x)&#123; return son[fa[x]][1] == x; &#125; // 返回x是他父亲的哪个儿子void set(int x, int k, int y)&#123; son[x][k] = y, fa[y] = x; &#125; // 将x的k儿子变成yvoid rotate(int x)&#123; int y = fa[x], d = dir(x); set(fa[y], dir(y), x), set(y, d, son[x][!d]), set(x, !d, y); up(y), up(x); // 注意上传以及上传的顺序&#125;void splay(int x, int g = 0)&#123; // g=0相当于旋转到根上 while (fa[x] != g)&#123; int y = fa[x]; if (fa[y] != g) dir(y) == dir(x) ? rotate(y) : rotate(x); rotate(x); // 双旋 &#125; if (!g) rt = x; // 更新rt&#125; 求当前序列中第\\(k\\)个位置在Splay中对应的节点 这是下面前五个操作中必需的一个操作，即把序列中的位置转化为树上的节点编号。 这是一个经典的求第\\(k\\)小的问题，直接按照左子树的\\(sz\\)和当前的\\(k\\)的大小关系决定往左、往右还是直接返回当前节点。 注意，此时由于需要用到儿子的信息，我们必须把\\(u\\)的标记下传。 且因为这样做会把根到要求的那个节点的路径上的所有节点都\\(down\\)一遍，所以在其余操作中不需要再进行\\(down\\)操作。 1234567int kth(int u, int k)&#123; down(u); // 下传标记 int ls = son[u][0], rs = son[u][1]; if (k == sz[ls] + 1) return u; // 直接返回 else if (k &lt;= sz[ls]) return kth(ls, k); // 向左走 else return kth(rs, k - sz[ls] - 1); // 向右走&#125; 插入操作 对于插入操作，我们直接把\\(pos\\)对应的节点\\(splay\\)到根上（记为\\(u\\)），把\\(pos+1\\)的位置旋转到根下面（记为\\(v\\)，即此时\\(fa[v]=u\\)）。此时\\(v\\)的左子树一定为空（不存在一个整数\\(x\\)满足\\(pos&lt;x&lt;pos+1\\)）。那么直接把需要插入的序列\\(\\mathcal O(n)\\)建树，把根节点连到\\(v\\)上，作为\\(v\\)的左子树即可。 1234567void insert(int x, int tot, int *a)&#123; int t = build(1, tot, a); int u = kth(rt, x); splay(u); int v = kth(rt, x + 1); splay(v, u); son[v][0] = t, fa[t] = v, up(v), up(u); // 注意别忘记fa[t]=v和上传标记，不要习惯性打成up(u),up(v)&#125; 删除操作 假设我们要删除的是区间\\([l,r]\\)，那么同理，我们把\\(l-1\\)对应的节点旋转到根上（记为\\(u\\)），把\\(r+1\\)的位置旋转到根下面（记为\\(v\\)，即此时\\(fa[v]=u\\)）。 此时\\(v\\)的左子树所表示的区间即为\\([l,r]\\)，那么我们直接把\\(v\\)的左子树删除即可。 1234567891011void recycle(int u)&#123; // 回收以u为根的子树 int ls = son[u][0], rs = son[u][1]; if (ls) recycle(ls); if (rs) recycle(rs); rb[++top] = u;&#125;void erase(int l, int r)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); // 提区间操作 recycle(son[v][0]), son[v][0] = 0, up(v), up(u); // 更新&#125; 覆盖操作 与删除同理，提取区间\\([l,r]\\)，打上\\(cov\\)标记，更新即可。 123456789void cover(int l, int r, int c)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); int t = son[v][0]; // 提区间 val[t] = c, cov[t] = 1, sum[t] = sz[t] * c; if (c &gt; 0) la[t] = ra[t] = ma[t] = sum[t]; else la[t] = ra[t] = 0, ma[t] = c; // 打标记，与down中同理 up(v), up(u); // 更新&#125; 翻转操作 同理，提取区间后，打上\\(rev\\)标记并更新。 12345678void reverse(int l, int r)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); int t = son[v][0]; // 提区间 rev[t] ^= 1, std :: swap(son[t][0], son[t][1]), std :: swap(la[t], ra[t]); // 打标记，与down中同理 up(v), up(u); // 更新&#125; 求和操作 提取区间后直接输出\\(sum\\)值即可，不需要更新。 12345void query_sum(int l, int r)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); printf(&quot;%d\\n&quot;, sum[son[v][0]]);&#125; 最大子段和 直接输出\\(ma[rt]\\)即可。 一些细节 由于\\(pos,l-1\\)可能会\\(&lt;1\\)，\\(pos+1,r\\)可能会\\(&gt;n\\)，所以要考虑边界问题。我的代码中是直接把整个数组向右移动一位，并且使\\(a[1]=a[n+2]=-\\text{INF}\\)。个人觉得这个方法比较简单，只要在主程序中做一些简单的处理即可。 由于\\(up\\)中没有判断左儿子或右儿子为空的情况（判起来会变得很鬼畜），所以我们令\\(ma[0]=-\\text{INF}\\)。 代码实现 总的再发一次吧。吸氧后最快的一次共1111ms。评测记录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0, f = 1; register char ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f = !f; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 500005#define INF 500000000int n, m, a[N];char opt[15];int k, x, tot, c[N];struct Splay&#123; int rt, cnt, son[N][2], fa[N], sz[N], val[N]; int rev[N], cov[N], sum[N], la[N], ra[N], ma[N]; int top, rb[5000005]; Splay()&#123; rt = 0, cnt = 0, top = 0; fa[0] = son[0][0] = son[0][1] = sz[0] = rev[0] = cov[0] = 0; val[0] = sum[0] = la[0] = ra[0] = 0, ma[0] = -INF; &#125; int new_node(int _val)&#123; int x = top ? rb[top--] : ++cnt; son[x][0] = son[x][1] = fa[x] = rev[x] = cov[x] = 0, sz[x] = 1; val[x] = ma[x] = sum[x] = _val, la[x] = ra[x] = std :: max(_val, 0); return x; &#125; void recycle(int u)&#123; int ls = son[u][0], rs = son[u][1]; if (ls) recycle(ls); if (rs) recycle(rs); rb[++top] = u; &#125; void up(int u)&#123; int ls = son[u][0], rs = son[u][1]; sz[u] = sz[ls] + sz[rs] + 1, sum[u] = sum[ls] + sum[rs] + val[u]; la[u] = std :: max(la[ls], sum[ls] + val[u] + la[rs]); ra[u] = std :: max(ra[rs], sum[rs] + val[u] + ra[ls]); ma[u] = std :: max(std :: max(ma[ls], ma[rs]), ra[ls] + val[u] + la[rs]); &#125; void down(int u)&#123; int ls = son[u][0], rs = son[u][1]; if (cov[u])&#123; if (ls) val[ls] = val[u], cov[ls] = 1, sum[ls] = sz[ls] * val[u]; if (rs) val[rs] = val[u], cov[rs] = 1, sum[rs] = sz[rs] * val[u]; if (val[u] &gt; 0)&#123; if (ls) la[ls] = ra[ls] = ma[ls] = sum[ls]; if (rs) la[rs] = ra[rs] = ma[rs] = sum[rs]; &#125; else&#123; if (ls) la[ls] = ra[ls] = 0, ma[ls] = val[u]; if (rs) la[rs] = ra[rs] = 0, ma[rs] = val[u]; &#125; cov[u] = 0; &#125; if (rev[u])&#123; if (ls) rev[ls] ^= 1, std :: swap(son[ls][0], son[ls][1]), std :: swap(la[ls], ra[ls]); if (rs) rev[rs] ^= 1, std :: swap(son[rs][0], son[rs][1]), std :: swap(la[rs], ra[rs]); rev[u] = 0; &#125; &#125; int dir(int x)&#123; return son[fa[x]][1] == x; &#125; void set(int x, int k, int y)&#123; son[x][k] = y, fa[y] = x; &#125; void rotate(int x)&#123; int y = fa[x], d = dir(x); set(fa[y], dir(y), x), set(y, d, son[x][!d]), set(x, !d, y); up(y), up(x); &#125; void splay(int x, int g = 0)&#123; while (fa[x] != g)&#123; int y = fa[x]; if (fa[y] != g) dir(y) == dir(x) ? rotate(y) : rotate(x); rotate(x); &#125; if (!g) rt = x; &#125; int build(int l, int r, int *a)&#123; if (l &gt; r) return 0; if (l == r) return new_node(a[l]); int mid = (l + r) &gt;&gt; 1, u = new_node(a[mid]); son[u][0] = build(l, mid - 1, a), son[u][1] = build(mid + 1, r, a); fa[son[u][0]] = fa[son[u][1]] = u; return up(u), u; &#125; int kth(int u, int k)&#123; down(u); int ls = son[u][0], rs = son[u][1]; if (k == sz[ls] + 1) return u; else if (k &lt;= sz[ls]) return kth(ls, k); else return kth(rs, k - sz[ls] - 1); &#125; void insert(int x, int tot, int *a)&#123; int t = build(1, tot, a); int u = kth(rt, x); splay(u); int v = kth(rt, x + 1); splay(v, u); son[v][0] = t, fa[t] = v, up(v), up(u); &#125; void erase(int l, int r)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); recycle(son[v][0]), son[v][0] = 0, up(v), up(u); &#125; void cover(int l, int r, int c)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); int t = son[v][0]; val[t] = c, cov[t] = 1, sum[t] = sz[t] * c; if (c &gt; 0) la[t] = ra[t] = ma[t] = sum[t]; else la[t] = ra[t] = 0, ma[t] = c; up(v), up(u); &#125; void reverse(int l, int r)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); int t = son[v][0]; rev[t] ^= 1, std :: swap(son[t][0], son[t][1]), std :: swap(la[t], ra[t]); up(v), up(u); &#125; void query_sum(int l, int r)&#123; int u = kth(rt, l - 1); splay(u); int v = kth(rt, r + 1); splay(v, u); printf(&quot;%d\\n&quot;, sum[son[v][0]]); &#125; void query_max_sum()&#123; printf(&quot;%d\\n&quot;, ma[rt]); &#125;&#125;T;int main()&#123; n = read(), m = read(), n += 2, a[1] = a[n] = -INF; for (register int i = 2; i &lt; n; ++i) a[i] = read(); // 整体右移 T.rt = T.build(1, n, a); while (m--)&#123; scanf(&quot;%s&quot;, opt); if (opt[0] == &#x27;M&#x27; &amp;&amp; opt[2] == &#x27;X&#x27;) T.query_max_sum(); else x = read() + 1, tot = read(); // +1是因为数组整体右移 if (opt[0] == &#x27;I&#x27;)&#123; for (register int i = 1; i &lt;= tot; ++i) c[i] = read(); T.insert(x, tot, c); &#125; if (opt[0] == &#x27;D&#x27;) T.erase(x, x + tot - 1); if (opt[0] == &#x27;M&#x27; &amp;&amp; opt[2] == &#x27;K&#x27;) T.cover(x, x + tot - 1, read()); if (opt[0] == &#x27;R&#x27;) T.reverse(x, x + tot - 1); if (opt[0] == &#x27;G&#x27;) T.query_sum(x, x + tot - 1); &#125;&#125; 如发现代码有问题请在评论中指出，谢谢！","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Luogu","slug":"题解/Luogu","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Luogu/"}],"tags":[{"name":"NOI","slug":"NOI","permalink":"https://autumnkite.github.io/tags/NOI/"},{"name":"Splay","slug":"Splay","permalink":"https://autumnkite.github.io/tags/Splay/"}]},{"title":"后缀数组 学习笔记","slug":"suffix-array-notes","date":"2019-01-15T03:28:08.000Z","updated":"2020-03-26T07:22:57.238Z","comments":true,"path":"suffix-array-notes/","link":"","permalink":"https://autumnkite.github.io/suffix-array-notes/","excerpt":"后缀数组（Suffix Array, SA）是处理字符串的有力工具。它可以解决一些与字符串后缀LCP有关的问题。","text":"后缀数组（Suffix Array, SA）是处理字符串的有力工具。它可以解决一些与字符串后缀LCP有关的问题。 一些记号和约定 在字符串\\(S\\)中，第\\(i\\)个字符到第\\(j\\)个字符（包括\\(i,j\\)）组成的子串记作\\(S[i,j]\\)。 在字符串\\(S\\)中，第\\(i\\)个字符开始的后缀记作\\(\\text{Suffix}(i)\\)。 记\\(SA[i]\\)表示字符串\\(S\\)的所有后缀从小到大排序后，第\\(i\\)个后缀的开始位置。\\(SA\\)即后缀数组。 记\\(rank[i]\\)表示字符串\\(S\\)的第\\(i\\)个后缀从小到大的排名，即\\(SA\\)的逆数组。 下面给出一个例子（字符串下标从\\(1\\)开始）： 1234567891011String S: a a b a a a a b Rank: 4 6 8 1 2 3 5 7--------------------------SA[1]=4 -&gt; a a a a bSA[2]=5 -&gt; a a a bSA[3]=6 -&gt; a a bSA[4]=1 -&gt; a a b a a a a bSA[5]=7 -&gt; a bSA[6]=2 -&gt; a b a a a a bSA[7]=8 -&gt; bSA[8]=3 -&gt; b a a a a b 由于\\(rank\\)是\\(SA\\)的逆数组，在求出\\(SA\\)数组后，我们可以\\(\\mathcal O(|S|)\\)求出\\(rank\\)数组，即rank[sa[i]]=i。 一个简单的实现 设字符串长度为\\(n\\)且下标从\\(1\\)开始。 我们直接把\\(S\\)的每个后缀求出，然后用任意一种排序方法，在比较时暴力\\(\\mathcal O(n)\\)比较两个后缀的大小即可。 这种方法的复杂度太劣，我们尝试优化。 倍增算法 前置知识 倍增，基数排序。 由于基数排序较为简单，这里不详细讲。 算法思想 倍增算法的主要思想是：用倍增的方法对每个字符开始长度为\\(2^k\\)的子串进行排序，求出排名。\\(k\\)从\\(0\\)开始，直到\\(2^k&gt;n\\)时，这些子串就是\\(S\\)的所有后缀。 可以发现，如果我们能\\(\\mathcal O(n)\\)求出每个字符开始长度为\\(2^k\\)的子串排序后的结果，那么此算法的复杂度就是\\(\\mathcal O(n\\log n)\\)的。 考虑利用\\(k-1\\)时的排序结果快速求出当前结果。 由于我们已经求出每个字符开始长度为\\(2^{k-1}\\)的子串的排名，那么字符串的比较变成了排名的比较。 这是一个双关键字排序，设当前字符为\\(i\\)，则第一关键字为\\(i\\)开始长度为\\(2^{k-1}\\)的子串的排名，第二关键字为\\(i+2^k\\)开始长度为\\(2^{k-1}\\)的子串的排名。 如果用快速排序，则总复杂度为\\(\\mathcal O(n\\log^2 n)\\)。 由于排名的值不会超过\\(n\\)，我们考虑用基数排序做到总复杂度为\\(\\mathcal O(n\\log n)\\)。 双关键字的基数排序只要先按照第二关键字从小到大排序，再按照第一关键字从小到大排序即可，都可以做到\\(\\mathcal O(n)\\)的复杂度。 算法实现 技巧 直接基数排序的常数较大，我们考虑每次把排序后的结果暂存在\\(SA\\)数组中，即当前的\\(SA[i]\\)表示每个字符开始长度为\\(2^k\\)的子串进行排序后，排名为\\(i\\)的子串的起始位置。 这样一来，我们可以利用\\(k-1\\)时求出来的\\(SA\\)数组，直接按第二关键字排好序，再按第一关键字排序。 代码 123456789101112131415161718192021222324int sa[N], tx[N], ty[N], cnt[N];void Radix_Sort(int n, int m, int *x, int *y, int *sa)&#123; for (register int i = 0; i &lt;= m; ++i) cnt[i] = 0; for (register int i = 1; i &lt;= n; ++i) ++cnt[x[i]]; for (register int i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1]; for (register int i = n; i; --i) sa[cnt[x[y[i]]]--] = y[i];&#125;bool cmp(int *a, int x, int y, int l)&#123; return a[x] == a[y] &amp;&amp; a[x + l] == a[y + l];&#125;void Get_SA(int n, int m, int *a, int *sa)&#123; int *x = tx, *y = ty; for (register int i = 1; i &lt;= n; ++i) x[i] = a[i], y[i] = i; Radix_Sort(n, m, x, y, sa); for (register int j = 1, p = 0; p &lt; n; j &lt;&lt;= 1, m = p)&#123; p = 0; for (register int i = n - j + 1; i &lt;= n; ++i) y[++p] = i; for (register int i = 1; i &lt;= n; ++i) if (sa[i] &gt; j) y[++p] = sa[i] - j; Radix_Sort(n, m, x, y, sa); std :: swap(x, y), p = 1, x[sa[1]] = 1; for (register int i = 2; i &lt;= n; ++i) x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p : ++p; &#125;&#125; 代码解释 代码中的\\(x[i]\\)表示\\(i\\)开始长度为\\(j=2^k\\)的子串排序后的排名，\\(y[i]\\)在前半部分表示按第二关键字排序后，排名为\\(i\\)的子串的起始位置。 Radix_Sort函数即基数排序，不详细阐述。 123int *x = tx, *y = ty;for (register int i = 1; i &lt;= n; ++i) x[i] = a[i], y[i] = i;Radix_Sort(n, m, x, y, sa); 这三行是初始化，由于长度为\\(1\\)，直接按照字符本身为第一关键字进行排序，\\(y[i]=i\\)时表示没有第二关键字。 12345for (register int j = 1, p = 0; p &lt; n; j &lt;&lt;= 1, m = p)&#123; p = 0; for (register int i = n - j + 1; i &lt;= n; ++i) y[++p] = i; for (register int i = 1; i &lt;= n; ++i) if (sa[i] &gt; j) y[++p] = sa[i] - j; Radix_Sort(n, m, x, y, sa); \\(j\\)枚举的是\\(\\frac{2^k}{2}\\)的值，即当前需要排序的子串长度的一半。首先把第二关键字为\\(0\\)的位置加入\\(y\\)。然后按第二关键字从小到大的加入\\(y\\)。为什么可以这样写？因为\\(sa[i]\\)表示排名为\\(i\\)的子串的初始位置，即\\(sa[i]\\)的排名一定是除\\(0\\)外第\\(i\\)小的，而以\\(sa[i]\\)的排名作为第二关键字的位置就是\\(sa[i]-j\\)，所以这样做就是把位置按第二关键字从小到大的加入\\(y\\)。 1234 std :: swap(x, y), p = 1, x[sa[1]] = 1; for (register int i = 2; i &lt;= n; ++i) x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p : ++p;&#125; 这一段代码中，由于前面的\\(y\\)数组毫无用处了，就交换\\(x,y\\)，使得\\(y\\)表示上一个\\(j\\)时的排名，把\\(x\\)更新为当前\\(j\\)时的排名。这里不能直接写x[sa[i]]=i的原因是有些子串可能会相等，那么它们的排名也应该相等。\\(p\\)记录的是排名不同的子串数量，如果\\(p=n\\)则直接退出循环。 另一种算法 还有一种求后缀数组的算法，叫做\\(\\text{DC3}\\)。该算法可以做到复杂度\\(\\mathcal O(n)\\)建立后缀数组，但由于常数较大且代码复杂度较高，不推荐使用。 有兴趣的同学可以查阅参考资料\\([1]\\)。 \\(height\\)数组 在具体应用中，\\(SA\\)数组的应用并不多，更多的是另一个可以利用\\(SA,rank\\)数组求出的数组——\\(height\\)数组。 定义 \\(height[i]\\)表示\\(\\text{Suffix}(SA[i])\\)和\\(\\text{Suffix}(SA[i-1])\\)的最长公共前缀（Longest Common Prefix, LCP）。即排名相邻的两个后缀的\\(\\text{LCP}\\)。 性质 性质一 对于任意\\(i,j(rank[i]&lt;rank[j])\\)，\\(\\text{Suffix}(i)\\)与\\(\\text{Suffix}(j)\\)的\\(\\text{LCP}\\)为\\(\\min\\limits_{rank[i]&lt;k\\le rank[j]} height[k]\\)。 这个性质比较显然，证明略。 性质二 记\\(H[i]=height[rank[i]]\\)。对于任意\\(i&gt;1\\)，有\\(H[i]\\ge H[i-1]-1\\)。 证明：当\\(H[i-1]\\le 1\\)时显然。当\\(H[i]&gt;1\\)时，假设排\\(\\text{Suffix}(i-1)\\)前一名的后缀是\\(\\text{Suffix}(k)\\)，则\\(\\text{Suffix}(i)\\)与\\(\\text{Suffix}(k+1)\\)的\\(\\text{LCP}\\)为\\(H[i-1]-1\\)（相当于都去掉了第一位），且\\(\\text{Suffix}(k+1)\\)也排\\(\\text{Suffix}(i)\\)前面，则根据性质一，\\(H[i]\\)不会小于这个值，得证。 求法及代码实现 根据性质二，直接按照\\(height[rank[1]],height[rank[2]],\\cdots,height[rank[n]]\\)的顺序求即可。 123456void Get_Height(int n, int *a, int *sa, int *rank, int *height)&#123; for (register int i = 1; i &lt;= n; ++i) rank[sa[i]] = i; for (register int i = 1, k = 0, j; i &lt;= n; height[rank[i]] = k, ++i) if (rank[i] &gt; 1) for (k ? --k : 0, j = sa[rank[i] - 1]; a[i + k] == a[j + k]; ++k) height[1] = 0;&#125; 由于\\(k\\)最多减少\\(n\\)次，且不会超过\\(n\\)，所以时间复杂度为\\(\\mathcal O(n)\\)。 例题 给定一个字符串，\\(q\\)次询问某两后缀的最长公共前缀的长度。 解法 建出\\(height\\)数组后，根据\\(height\\)数组的性质一，原问题可以转化为区间最小值问题，直接用\\(\\text{ST}\\)表维护即可。 时间复杂度\\(\\mathcal O(n\\log n+q)\\)。 若使用\\(\\text{DC3}\\)算法求\\(\\text{SA}\\)，\\(\\text{RMQ}\\)问题\\(\\mathcal O(n)\\)预处理，则时间复杂度为\\(\\mathcal O(n+q)\\)。 更多的例题可以查阅参考资料\\([1]\\)。 参考资料 IOI2009国家集训队论文《后缀数组——处理字符串的有力工具》，罗穗骞","categories":[{"name":"笔记","slug":"笔记","permalink":"https://autumnkite.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"https://autumnkite.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"}]},{"title":"Manacher 学习笔记","slug":"manacher-notes","date":"2019-01-11T04:44:12.000Z","updated":"2020-03-26T07:22:57.233Z","comments":true,"path":"manacher-notes/","link":"","permalink":"https://autumnkite.github.io/manacher-notes/","excerpt":"问题形式 给定一个字符串，求该字符串的最长回文子串。 洛谷传送门 一个简单的暴力实现 由于回文串是对称的，我们枚举对称轴（注意奇偶分类讨论）。然后从该对称轴向左向右扩展，直到两字母不相等。此时的字符串长度一定是以当前对称轴作为中心的最长回文子串。 时间复杂度\\(\\mathcal O(n^2)\\)。","text":"问题形式 给定一个字符串，求该字符串的最长回文子串。 洛谷传送门 一个简单的暴力实现 由于回文串是对称的，我们枚举对称轴（注意奇偶分类讨论）。然后从该对称轴向左向右扩展，直到两字母不相等。此时的字符串长度一定是以当前对称轴作为中心的最长回文子串。 时间复杂度\\(\\mathcal O(n^2)\\)。 Manacher - 暴力的优化 为了避免奇偶分类讨论，我们现在字符之间以及字符串两端插入一个特殊字符（与字符串中所有字符都不相等）。 例如：ababaab -&gt; #a#b#a#b#a#a#b#，显然，原来是回文串的还是回文串，原来不是回文串的仍然不是回文串，长度稍做处理即可。 通过观察发现，暴力主要慢在相同的状态被重复枚举，没有利用回文串的性质。 记\\(hw_i\\)表示以\\(i\\)为对称轴时，最长的回文串的右端距离\\(i\\)（包括最右端的字符和\\(i\\)）的长度为\\(hw_i\\)。栗子： 12345char: # a # b # a # hw : 1 2 1 4 1 2 1char: # a # b # b # a # hw : 1 2 1 2 5 2 1 2 1 如何快速求出\\(hw_i\\)？ 考虑根据回文串的性质，利用已经求出的\\(hw\\)值来求出当前的\\(hw_i\\)。 引入两个辅助变量\\(MaxRight,Mid\\)。\\(MaxRight\\)表示当前访问到的所有回文子串，所能触及的最右一个字符的位置，\\(Mid\\)表示对应的对称轴。 为方便观察，下面的图示中记\\(x\\)为\\(MaxRight\\)关于\\(Mid\\)对称的位置，\\(r\\)表示\\(MaxRight\\)，\\(m\\)表示\\(Mid\\)，\\(*\\)表示未触及的位置。 1| | | | |x| | | | | |m| | | | | |r|*|*|*| 当前要求\\(hw_i\\)的位置\\(i\\)一定在\\(Mid\\)右边。那么我们根据\\(i\\le MaxRight\\)和\\(i&gt;MaxRight\\)讨论： 当\\(i\\le MaxRight\\)时 1| | | | |x| | |j| | |m| | |i| | |r|*|*|*| 记\\(j\\)为\\(i\\)关于\\(m\\)的对称点。由于\\(hw_j\\)已知，我们尝试利用\\(hw_j\\)得出\\(hw_i\\)的下界。 又分成两种小情况： \\(hw_j\\)比较小，向左没有超过\\(x\\) 大概情况如图所示： 1| | | | |x| |-|j|-| |m| |-|i|-| |r|*|*|*| 此时显然\\(hw_i\\)的下界为\\(hw_j\\)。如图所示的情况一定也是上界，但如果\\(i+hw_i-1\\)刚好等于\\(MaxRight\\)，那么有可能可以继续扩展。由于不影响复杂度，为方便起见，无论哪一种情况都尝试扩展。 \\(hw_j\\)比较大，向左超过\\(x\\) 大概情况如图所示： 12345 | | /-------j----|--\\ || | | | |x| | |j| | |m| | |i| | |r|*|*|*| \\|------i------|/ | | 此时暂时只能确定两根较长的线之间的部分时回文的，所以\\(hw_i\\)的下界是\\(MaxRight-i+1\\)。然后同样地直接继续扩展即可。 实际实现中，这两种情况不需要特殊判断，只要在\\(hw_j\\)和\\(MaxRight-i+1\\)中取\\(min\\)即可。 当\\(i&gt;MaxRight\\)时 此时显然\\(hw_i\\)的求值不能利用之前的任意值，所以定下界为\\(1\\)，也直接扩展即可。 总结 步骤 综上所述，从左到右枚举\\(i\\)的过程中，对于每个\\(i\\)，算法步骤如下： 若\\(i\\le MaxRight\\)，则令\\(hw_i=min(hw_{2*Mid-i}, MaxRight-i+1)\\)，否则令\\(hw_i=1\\)（显然，\\(i\\)关于\\(Mid\\)的对称点\\(j\\)为\\(2*Mid-i\\)）。 以\\(i\\)为中心扩展回文串，直到左右两边字符不同，或者到达边界。 更新\\(MaxRight\\)和\\(Mid\\)。 更新答案。扩展出来的子串在原串中的长度一定为\\(hw_i-1\\)。因为在添加字符后的串中该子串长度为\\(2hw_i-1\\)，由于首尾一定是特殊字符，所以特殊字符数量比其他字符多\\(1\\)，所以特殊字符数量为\\(hw_i\\)，其他字符为\\(hw_i-1\\)。 一个小技巧 如果你的字符串下标从\\(1\\)开始，你可以令\\(s_0\\)为那个特殊字符，这样就省去了判断边界的问题。 复杂度分析 根据上面三种情况的分析，在继续扩展\\(hw_i\\)时，每一次的扩展都可以更新\\(MaxRight\\)，而\\(MaxRight\\)最多变化\\(n\\)次，所以总的时间复杂度为\\(\\mathcal O(n)\\)的。 代码实现 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;algorithm&gt;char buf[11000005], *ps = buf;int n, hw[22000005], mr = 0, mid = 0, ans = 0;char s[22000005];int main()&#123; buf[fread(buf, 1, 11000005, stdin)] = &#x27;\\0&#x27;, s[0] = &#x27;#&#x27;; // 小技巧 while (*ps &gt;= &#x27;a&#x27; &amp;&amp; *ps &lt;= &#x27;z&#x27;) s[++n] = &#x27;#&#x27;, s[++n] = *ps, ++ps; s[++n] = &#x27;#&#x27;; // 插入特殊字符 for (register int i = 1; i &lt;= n; ++i)&#123; hw[i] = i &lt;= mr ? std :: min(hw[(mid &lt;&lt; 1) - i], mr - i + 1) : 1; // 得出下界 while (s[i - hw[i]] == s[i + hw[i]]) ++hw[i]; // 继续扩展 if (i + hw[i] - 1 &gt; mr) mid = i, mr = i + hw[i] - 1; // 更新mr,mid ans = std :: max(ans, hw[i] - 1); // 更新答案 &#125; printf(&quot;%d\\n&quot;, ans);&#125; 参考资料 最长回文子串——Manacher 算法","categories":[{"name":"笔记","slug":"笔记","permalink":"https://autumnkite.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"manacher","slug":"manacher","permalink":"https://autumnkite.github.io/tags/manacher/"}]},{"title":"「模拟赛20190105 T1」松","slug":"vc190105A-sol","date":"2019-01-08T07:04:00.000Z","updated":"2020-03-26T07:22:57.238Z","comments":true,"path":"vc190105A-sol/","link":"","permalink":"https://autumnkite.github.io/vc190105A-sol/","excerpt":"题意 给定两个长度为\\(n\\)的数组\\(A,B\\)，下标范围\\([0,n-1]\\)。 求所有整数\\(k\\in [0,n-1]\\)，满足存在一个\\(m\\)次多项式\\(C\\)，使得对于所有\\(i\\in [0,n-1]\\)，都有\\(C(i)\\equiv A_i-B_{(i+k)\\bmod n} \\pmod{998244353}\\)。","text":"题意 给定两个长度为\\(n\\)的数组\\(A,B\\)，下标范围\\([0,n-1]\\)。 求所有整数\\(k\\in [0,n-1]\\)，满足存在一个\\(m\\)次多项式\\(C\\)，使得对于所有\\(i\\in [0,n-1]\\)，都有\\(C(i)\\equiv A_i-B_{(i+k)\\bmod n} \\pmod{998244353}\\)。 题解 先附上PPT： 这完全看不懂啊 首先，\\(B\\)数组可以看成一个环，每次选环上的长度为\\(n\\)的一段。所以我们直接把B数组复制接在末尾，变为原来的两倍长度。 然后，我们来理解这个差分。 对于任意一个\\(m\\)次多项式\\(f(x)\\)，当\\(x\\)分别取\\(0,1,2,\\cdots,n(n\\ge m+1)\\)时，将会得到\\(n+1\\)个点值。将这\\(n+1\\)个点值不断差分，\\(m+1\\)次后会都变成\\(0\\)。 例如，当\\(f(x)=x^3+x^2-2x+1\\)时，分别取\\(0,1,2,3,4,5\\)代入，得到\\(6\\)个点值（第\\(0\\)行）。 123456x 0 1 2 3 4 50 1 1 9 31 73 1411 0 8 22 42 682 8 14 20 263 6 6 64 0 0 然后可以发现，按表格中的排列，\\(t\\)次差分以后（第\\(k\\)行第\\(i\\)列）\\(c_i=\\sum\\limits_{j=0}^i (-1)^j C_k^j f(i-j)\\) 例如，表中第二行第四个数\\(20=(73-31)-(31-9)=73-2\\times 31+9=C_2^0\\times 73-C_2^1\\times 31+C_2^2\\times 9\\)。 又可以发现，\\(c_i=\\sum\\limits_{j=0}^i (-1)^j C_k^j f(i-j)\\)是卷积的形式，所以直接用FFT/NTT优化。 这样，我们对\\(A\\)和\\(B\\)分别做一遍卷积，然后把\\(A[m+1,n-1]\\)与\\(B[m+1,2n-1]\\)做一次\\(KMP\\)即可。 由于数据较水，直接\\(hash\\)也能过。 注意特判\\(m\\ge n-1\\)的情况，此时任意\\(k\\)都满足条件。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char ch = getchar(); for (; !isdigit(ch); ch = getchar()) ; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return x;&#125;#define N 1100005#define P 998244353int n, m, a[N], b[N], c[N], fac[N], inv[N], cnt, ans[N];int qpow(int a, int b)&#123; int s = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if (b &amp; 1) s = 1ll * s * a % P; return s;&#125;void pre(int n)&#123; fac[0] = 1; for (register int i = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % P; inv[n] = qpow(fac[n], P - 2); for (register int i = n; i; --i) inv[i - 1] = 1ll * inv[i] * i % P;&#125;int C(int n, int m)&#123; return n &lt; m ? 0 : 1ll * fac[n] * inv[m] % P * inv[n - m] % P;&#125;namespace Polynomial&#123; int omega[N], rev[N]; void init(int n)&#123; register int k = 0; while ((1 &lt;&lt; k) &lt; n) ++k; for (register int i = 0; i &lt; n; ++i) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; k &gt;&gt; 1; &#125; void NTT(int n, int *a, int o = 1)&#123; for (register int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) std :: swap(a[i], a[rev[i]]); for (register int m = 1, l; m &lt; n; m = l)&#123; l = m &lt;&lt; 1, omega[0] = 1, omega[1] = qpow(~o ? 3 : 332748118, (P - 1) / l); for (register int i = 2; i &lt; m; ++i) omega[i] = 1ll * omega[i - 1] * omega[1] % P; for (register int *p = a, t; p &lt; a + n; p += l) for (register int k = 0; k &lt; m; ++k) t = 1ll * omega[k] * p[m + k] % P, (p[m + k] = p[k] - t) &lt; 0 ? p[m + k] += P : 0, (p[k] += t) &gt;= P ? p[k] -= P : 0; &#125; if (o == -1) for (register int i = 0, _n = qpow(n, P - 2); i &lt; n; ++i) a[i] = 1ll * a[i] * _n % P; &#125; void Trans(int nt, int *a, int *b, int *c)&#123; int n = 1; while (n &lt; nt) n &lt;&lt;= 1; init(n), NTT(n, a), NTT(n, b), NTT(n, c); for (register int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * c[i] % P, b[i] = 1ll * b[i] * c[i] % P; NTT(n, a, -1), NTT(n, b, -1); &#125;&#125;int fail[N];int KMP(int n, int *S, int m, int *T)&#123; fail[1] = 0; for (register int i = 2, j = 0; i &lt;= m; ++i)&#123; while (j &amp;&amp; T[j] != T[i - 1]) j = fail[j]; fail[i] = j += (T[j] == T[i - 1]); &#125; for (register int i = 1, j = 0; i &lt;= n; ++i)&#123; while (j &amp;&amp; T[j] != S[i - 1]) j = fail[j]; j += (T[j] == S[i - 1]); if (j == m) ans[++cnt] = i - m, j = fail[j]; &#125;&#125;int main()&#123; freopen(&quot;pine.in&quot;, &quot;r&quot;, stdin); freopen(&quot;pine.out&quot;, &quot;w&quot;, stdout); n = read(), m = read() + 1; if (m &gt;= n)&#123; printf(&quot;%d\\n&quot;, n); for (register int i = 0; i &lt; n; ++i) printf(&quot;%d\\n&quot;, i); return 0; &#125; pre(n); for (register int i = 0; i &lt; n; ++i) a[i] = read(); for (register int i = 0; i &lt; n; ++i) b[i] = read(), b[i + n] = b[i]; for (register int i = 0; i &lt; n; ++i) c[i] = i &amp; 1 ? P - C(m, i) : C(m, i); Polynomial :: Trans(2 * n, a, b, c);// for (register int i = 0; i &lt; n; ++i) printf(&quot;%d &quot;, a[i]); putchar(&#x27;\\n&#x27;);// for (register int i = 0; i &lt; n; ++i) printf(&quot;%d &quot;, b[i]); putchar(&#x27;\\n&#x27;); KMP(2 * n - 1 - m, b + m, n - m, a + m); printf(&quot;%d\\n&quot;, cnt); for (register int i = 1; i &lt;= cnt; ++i) printf(&quot;%d\\n&quot;, ans[i]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"模拟赛","slug":"题解/模拟赛","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://autumnkite.github.io/tags/KMP/"},{"name":"差分","slug":"差分","permalink":"https://autumnkite.github.io/tags/%E5%B7%AE%E5%88%86/"},{"name":"NTT","slug":"NTT","permalink":"https://autumnkite.github.io/tags/NTT/"}]},{"title":"线性递推求1~n的逆元 学习笔记","slug":"linear-inv-notes","date":"2018-11-07T13:24:00.000Z","updated":"2020-03-26T07:22:57.214Z","comments":true,"path":"linear-inv-notes/","link":"","permalink":"https://autumnkite.github.io/linear-inv-notes/","excerpt":"题目传送门 题意 求\\(1\\sim n\\)中所有整数在模\\(p\\)意义下的乘法逆元。 题解 设\\(a=\\left\\lfloor\\frac{P}{i}\\right\\rfloor,b=P\\bmod i\\)，则\\(ai+b=P\\) 即\\(ai+b\\equiv 0 \\pmod P\\)","text":"题目传送门 题意 求\\(1\\sim n\\)中所有整数在模\\(p\\)意义下的乘法逆元。 题解 设\\(a=\\left\\lfloor\\frac{P}{i}\\right\\rfloor,b=P\\bmod i\\)，则\\(ai+b=P\\) 即\\(ai+b\\equiv 0 \\pmod P\\) \\[\\begin{align*} &amp;\\therefore \\frac{ai+b}{ib}\\equiv 0 \\pmod P \\\\ &amp;\\therefore ab^{-1}+i^{-1}\\equiv 0 \\pmod P \\\\ &amp;\\therefore\\ i^{-1}\\equiv -ab^{-1} \\pmod P \\end{align*}\\] 即\\[inv(i)=\\left(P-\\left\\lfloor\\frac{P}{i}\\right\\rfloor\\right)\\cdot inv(P\\bmod i)\\bmod P\\] 于是\\(O(n)\\)递推求一下就可以了。 代码 1234567891011#include &lt;cstdio&gt;int n, P, inv[3000005];void print(int x)&#123; if (x &lt; 10) putchar(x + 48); else print(x / 10), putchar(x % 10 + 48);&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;P); inv[1] = 1; for (register int i = 2; i &lt;= n; ++i) inv[i] = 1ll * (P - P / i) * inv[P % i] % P; for (register int i = 1; i &lt;= n; ++i) print(inv[i]), putchar(&#x27;\\n&#x27;);&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://autumnkite.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"逆元","slug":"逆元","permalink":"https://autumnkite.github.io/tags/%E9%80%86%E5%85%83/"}]},{"title":"「Codeforces 505E」Mr. Kitayuta vs. Bamboos","slug":"cf505e-sol","date":"2018-11-04T03:26:00.000Z","updated":"2020-03-26T07:22:57.204Z","comments":true,"path":"cf505e-sol/","link":"","permalink":"https://autumnkite.github.io/cf505e-sol/","excerpt":"题目传送门 题意 有\\(n\\)根竹子，竹子\\(i\\)初始高度为\\(h_i\\)，每天晚上会长高\\(a_i\\)。 每天白天，你可以选择\\(k\\)根竹子（同一根竹子在同一个白天可以多次选择），把他们的高度减少\\(p\\)，若竹子当前高度\\(-p\\)后\\(&lt;0\\)，则竹子高度变为\\(0\\)。 最小化\\(m\\)天后最高的竹子的高度。","text":"题目传送门 题意 有\\(n\\)根竹子，竹子\\(i\\)初始高度为\\(h_i\\)，每天晚上会长高\\(a_i\\)。 每天白天，你可以选择\\(k\\)根竹子（同一根竹子在同一个白天可以多次选择），把他们的高度减少\\(p\\)，若竹子当前高度\\(-p\\)后\\(&lt;0\\)，则竹子高度变为\\(0\\)。 最小化\\(m\\)天后最高的竹子的高度。 题解 首先最小化最大的...这种问题，显然可以用二分答案。 二分\\(m\\)天后最高的竹子的高度\\(H\\)，然后问题就变成了判定性问题：是否存在一种方案，使得\\(m\\)天后竹子高度都\\(\\le H\\)。 考虑怎么解决这个判定性问题。 如果按照题意一天一天模拟，就需要考虑把竹子高度减\\(p\\)后\\(&lt;0\\)的情况，会比较麻烦。 所以我们尝试倒着模拟这一过程。 即：竹子初始高度都设为\\(H\\)，每根竹子每天会减少\\(a_i\\)的高度，然后你可以选择\\(k\\)根竹子，把它们“拔高”\\(p\\)。问\\(m\\)天后竹子高度是否都\\(\\ge h_i\\)。 此时你必须保证竹子减少\\(a_i\\)的高度后不会\\(&lt;0\\)。 这样就好做了。我们用一个堆维护 当前状态下继续减少高度而不“拔高”，第\\(m\\)天结束后竹子高度会\\(&lt;h_i\\)的竹子 一直减少高度 多少天后的高度会\\(&lt;0\\)。 （不理解这句话可以尝试看代码理解） 每次取出最快\\(&lt;0\\)的竹子，对它“拔高”即可。注意中间可能会出现无论怎么“拔高”还是会\\(&lt;0\\)的竹子，此时直接返回错误即可。 最后判断堆是否为空即可，因为堆中维护的是\\(m\\)天后竹子高度会\\(&lt;h_i\\)的竹子，所以堆空即代表所有竹子高度都\\(\\ge h_i\\)。 时间复杂度\\(O((n+mk)\\log n\\log mx)\\)，其中\\(mx\\)表示\\(\\max\\limits_{1\\le i\\le n} h_i+a_im\\)（二分的上界）。 代码 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f = 0; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;int n, m, k, c[100005];long long p, a[100005], h[100005], l = 0, r, mid, ans;struct node&#123; int day, id; // 表示当前状态下（二分的高度+c[id]*p）day+1天后竹子id的高度会&lt;0 bool operator &lt; (const node &amp;b) const &#123; // 默认大根堆，所以重载&lt;时写的是&gt; return day &gt; b.day; &#125;&#125;;struct Heap&#123; // 用algorithm中的堆相关的算法封装实现。 node h[200005]; int sz; void clear()&#123; sz = 0; &#125; bool empty()&#123; return !sz; &#125; void push(node x)&#123; h[++sz] = x, std :: push_heap(h + 1, h + 1 + sz); &#125; node pop()&#123; return std :: pop_heap(h + 1, h + 1 + sz), h[sz--]; &#125; node top()&#123; return h[1]; &#125;&#125;H;bool check(long long x)&#123; H.clear(), memset(c, 0, sizeof c); // c[i]表示竹子i被“拔高”了几次 for (register int i = 1; i &lt;= n; ++i) if (x - a[i] * m &lt; h[i]) H.push((node)&#123;x / a[i], i&#125;); // 初始堆的状态 for (register int i = 1; !H.empty() &amp;&amp; i &lt;= m; ++i) // i表示倒着的第几天 for (register int j = 1; !H.empty() &amp;&amp; j &lt;= k; ++j)&#123; // 拔高k根竹子 node u = H.pop(); if (u.day &lt; i) return 0; // 无论怎么“拔高”都不能满足条件 ++c[u.id]; // “拔高” if (x + c[u.id] * p - a[u.id] * m &lt; h[u.id]) // 还是不满足条件，就插入堆中 H.push((node)&#123;(x + c[u.id] * p) / a[u.id], u.id&#125;); &#125; return H.empty();&#125;int main()&#123; n = read(), m = read(), k = read(), p = read(); for (register int i = 1; i &lt;= n; ++i) h[i] = read(), a[i] = read(), r = std :: max(r, h[i] + a[i] * m); // 二分上界 while (l &lt;= r) check(mid = l + r &gt;&gt; 1) ? ans = mid, r = mid - 1 : l = mid + 1; printf(&quot;%lld&quot;, ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分","slug":"二分","permalink":"https://autumnkite.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"堆","slug":"堆","permalink":"https://autumnkite.github.io/tags/%E5%A0%86/"}]},{"title":"「Codeforces 295D」Greg and Caves","slug":"cf295d-sol","date":"2018-10-29T11:11:00.000Z","updated":"2020-03-26T07:22:57.203Z","comments":true,"path":"cf295d-sol/","link":"","permalink":"https://autumnkite.github.io/cf295d-sol/","excerpt":"标签：DP 题目传送门 题意 给定\\(n,m\\)，你需要对一个\\(n\\times m\\)的矩阵黑白染色，满足： 存在一个区间\\([l,r]\\)，满足\\(l\\sim r\\)这些行有且仅有两个黑色格子，其他行不存在黑色格子。 存在一个\\(t\\ (l\\le t\\le r)\\)，使得对于所有的\\(i,j\\ (l\\le i\\le j\\le t)\\)，满足第\\(i\\)行以两个黑色格子为端点的区间（以下简称“区间”）被\\(j\\)行的区间包含；同样地，对于所有的\\(i,j\\ (t\\le i\\le j\\le r)\\)，第\\(j\\)行的区间被第\\(i\\)行的区间包含。 求染色方案数\\(\\bmod (10^9+7)\\)的值。","text":"标签：DP 题目传送门 题意 给定\\(n,m\\)，你需要对一个\\(n\\times m\\)的矩阵黑白染色，满足： 存在一个区间\\([l,r]\\)，满足\\(l\\sim r\\)这些行有且仅有两个黑色格子，其他行不存在黑色格子。 存在一个\\(t\\ (l\\le t\\le r)\\)，使得对于所有的\\(i,j\\ (l\\le i\\le j\\le t)\\)，满足第\\(i\\)行以两个黑色格子为端点的区间（以下简称“区间”）被\\(j\\)行的区间包含；同样地，对于所有的\\(i,j\\ (t\\le i\\le j\\le r)\\)，第\\(j\\)行的区间被第\\(i\\)行的区间包含。 求染色方案数\\(\\bmod (10^9+7)\\)的值。 题解 比较简单的\\(\\mathrm{DP}\\)，设\\(dp_{i,j}\\)表示上半部分（即\\(l\\)到\\(t\\)部分）的高度至多为\\(i\\)，底边宽度（包含两个黑色格子）为\\(j\\)且底边位置固定时的方案数。 转移方程 \\[dp_{i,j}=dp_{i,j-1}+\\sum\\limits_{k=2}^j dp_{i-1,k}\\] 应该还是比较好理解的。初始值\\(dp_{1,i}=dp_{i,1}=1\\)。 直接转移是\\(O(n^3)\\)的，但是\\(\\sum\\limits_{k=2}^j dp_{i-1,k}\\)可以在枚举\\(j\\)的同时计算（即前缀和优化），时间复杂度可以做到\\(O(n^2)\\)。 答案 下半部分的方案与上半部分同理。 注意如果下半部分的底边长度和上半部分的底边长度相等，会有重复，所以应该减去。 \\[ans=\\sum\\limits_{i=1}^n \\sum\\limits_{j=2}^m (dp_{i,j}-dp_{i-1,j})\\times dp_{n-i+1,j}\\times (m-j+1)\\bmod 1000000007\\] \\(i\\)枚举的是下半部分的起始位置，\\(j\\)枚举的是下半部分的底边宽度，第一项是上半部分减去长度相等的方案，第二项是下半部分的方案，第三项是计算底边在矩阵中的位移。 注意需要随时取模。 代码 Code 1234567891011121314151617#include &lt;cstdio&gt;#define P 1000000007int n, m, dp[2005][2005], ans;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (register int i = 1; i &lt;= m; ++i) dp[1][i] = 1; for (register int i = 2; i &lt;= n; ++i)&#123; int s = 0; dp[i][1] = 1; for (register int j = 2; j &lt;= m; ++j) (s += dp[i - 1][j]) %= P, dp[i][j] = (dp[i][j - 1] + s) % P; // 前缀和优化 &#125; for (register int i = 1; i &lt;= n; ++i) for (register int j = 2; j &lt;= m; ++j) (ans += 1ll * (dp[i][j] - dp[i - 1][j] + P) * dp[n - i + 1][j] % P * (m - j + 1) % P) %= P; // 计算答案，随时取模 printf(&quot;%d&quot;, ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"}]},{"title":"「Codeforces 599E」Sandy and Nuts","slug":"cf599e-sol","date":"2018-10-29T03:14:00.000Z","updated":"2020-03-26T07:22:57.205Z","comments":true,"path":"cf599e-sol/","link":"","permalink":"https://autumnkite.github.io/cf599e-sol/","excerpt":"题目传送门 题意 有一棵\\(n\\)个节点的以1为根的树，有\\(m\\)条边已知，并且有\\(q\\)个限制\\(a_i,b_i,c_i\\)，需要满足\\(\\mathrm{LCA}(a_i,b_i)=c_i\\)。求满足条件的树的数量。 \\(m&lt; n\\le 13,q\\le 100\\)。","text":"题目传送门 题意 有一棵\\(n\\)个节点的以1为根的树，有\\(m\\)条边已知，并且有\\(q\\)个限制\\(a_i,b_i,c_i\\)，需要满足\\(\\mathrm{LCA}(a_i,b_i)=c_i\\)。求满足条件的树的数量。 \\(m&lt; n\\le 13,q\\le 100\\)。 题解 树形状压DP。DP状态很显然，\\(dp_{u,mask}\\)表示以\\(u\\)为根，由\\(mask\\)这些点组成的子树的方案数。\\(mask\\)是一个二进制状态。 为方便讨论，以下题解和代码节点编号从\\(0\\)开始。 转移方程 \\[dp_{u,mask}=\\sum dp_{v,submask}\\times dp_{u,mask\\oplus submask}\\] \\(\\oplus\\)表示的是异或(\\(xor\\))运算。 但是，我们直接枚举\\(v,submask\\)会有重复，例如一棵二叉树，根为\\(root\\)，左右儿子分别为\\(leftson,rightson\\)。当枚举\\(v=leftson\\)时会计算这棵树，\\(v=rightson\\)时又会计算这棵树，就会出现重复。 所以，我们规定一个点\\(pos\\in mask\\ (pos\\ne u)\\)，强制\\(pos\\)在\\(submask\\)中才能转移。 转移条件 题目中有两种限制条件，分别为边和\\(\\mathrm{LCA}\\)。 对于\\(\\mathrm{LCA}\\)的限制： 1.1. 对于限制\\((a,b,c)\\)，如果\\(c=u\\)，但是\\(a,b\\in submask\\)，那么\\(\\mathrm{LCA}\\)一定不为\\(c\\)，不满足条件。 1.2. 对于限制\\((a,b,c)\\)， 如果\\(c\\in submask\\)，但\\(a,b\\)中有至少一个不在\\(submask\\)中，则\\(\\mathrm{LCA}\\)一定不为\\(c\\)，不满足条件。 对于边的限制： 2.1. 对于边\\((x,y)\\)，如果\\(x,y\\ne u\\)，但是\\(x,y\\)其中一个在\\(submask\\)中，另一个不在，则这条边不可能在树上，不满足条件。 2.2. 如果\\(u\\)与\\(i\\)有边且\\(i\\in submask\\)的\\(i\\)的数量大于1，则不可能有满足条件的树，不满足条件。 在2.2中，如果这样的\\(i\\)的数量等于1，则转移时\\(v\\)不用枚举，\\(v\\)只能是那个\\(i\\)。否则\\(v\\)需要在\\(submask\\)中枚举。 关于复杂度 子集枚举可以用for (register int submask = mask; submask; submask = (submask - 1) &amp; mask)。 此时复杂度并不是\\(O(4^n)\\)，而是\\(O(3^n)\\)，因为每次枚举到的\\(submask\\)一定是\\(mask\\)的子集。状态数为\\(3^n\\)。 因为此时\\(n\\)个数有三种状态：不在\\(mask\\)中，在\\(mask\\)但不在\\(submask\\)中，在\\(submask\\)中。所以是\\(3^n\\)。 所以复杂度为\\(O(3^nn(n+q+m))\\)。 观察代码可以发现这个复杂度非常不满，很多状态和子集是没用的。加上CF的评测机速度，还是可以过的。 代码 Code 实测93ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;int n, m, q, edge[15][15];struct Edge&#123; int x, y; &#125; E[15];struct node&#123; int x, y, z; &#125; a[105];long long dp[15][100005];bool in(int x, int s)&#123; return s &amp; (1 &lt;&lt; x); &#125;long long dfs(int u, int mask)&#123; // 用记搜实现 long long &amp;res = dp[u][mask]; if (~res) return res; res = 0, mask -= 1 &lt;&lt; u; int pos; for (pos = 0; pos &lt; n; ++pos) if (in(pos, mask)) break; // 强制pos在submask中 for (register int submask = mask; submask; submask = (submask - 1) &amp; mask) // 枚举子集 if (in(pos, submask))&#123; int flag = 1, v, cnt = 0; // 条件1.1 for (register int i = 1; i &lt;= q; ++i) if (a[i].z == u &amp;&amp; in(a[i].x, submask) &amp;&amp; in(a[i].y, submask)) &#123; flag = 0; break; &#125; if (!flag) continue; // 条件1.2 for (register int i = 1; i &lt;= q; ++i) if (in(a[i].z, submask) &amp;&amp; (!in(a[i].x, submask) || !in(a[i].y, submask))) &#123; flag = 0; break; &#125; if (!flag) continue; // 条件2.1 for (register int i = 1; i &lt;= m; ++i) if (E[i].x != u &amp;&amp; E[i].y != u &amp;&amp; (in(E[i].x, submask) ^ in(E[i].y, submask))) &#123; flag = 0; break; &#125; if (!flag) continue; // 条件2.2 for (register int i = 0; i &lt; n; ++i) if (edge[u][i] &amp;&amp; in(i, submask))&#123; ++cnt; v = i; &#125; if (cnt &gt; 1) continue; if (cnt == 1) res += dfs(v, submask) * dfs(u, mask ^ submask ^ (1 &lt;&lt; u)); else&#123; for (v = 0; v &lt; n; ++v) if (in(v, submask)) res += dfs(v, submask) * dfs(u, mask ^ submask ^ (1 &lt;&lt; u)); // 转移方程 &#125; &#125; return res;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for (register int i = 1; i &lt;= m; ++i) scanf(&quot;%d%d&quot;, &amp;E[i].x, &amp;E[i].y), --E[i].x, --E[i].y, // 编号从0开始 edge[E[i].x][E[i].y] = edge[E[i].y][E[i].x] = 1; for (register int i = 1; i &lt;= q; ++i) scanf(&quot;%d%d%d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z), --a[i].x, --a[i].y, --a[i].z; // 同上 memset(dp, -1, sizeof dp); for (register int i = 0; i &lt; n; ++i) dp[i][1 &lt;&lt; i] = 1; // 初始化 printf(&quot;%lld&quot;, dfs(0, (1 &lt;&lt; n) - 1));&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"状压DP","slug":"状压DP","permalink":"https://autumnkite.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"树形DP","slug":"树形DP","permalink":"https://autumnkite.github.io/tags/%E6%A0%91%E5%BD%A2DP/"}]},{"title":"「BZOJ2753」「SCOI2012」滑雪与时间胶囊","slug":"bzoj2753-sol","date":"2018-10-22T06:09:00.000Z","updated":"2020-03-26T07:22:57.183Z","comments":true,"path":"bzoj2753-sol/","link":"","permalink":"https://autumnkite.github.io/bzoj2753-sol/","excerpt":"题目传送门 题意 给定一个\\(n\\)个点，\\(m\\)条边的有权无向图，每个点有一个高度，求一个以\\(1\\)为根的树，满足父亲的高度大于等于儿子的高度。在树的节点数最多的情况下，树上的边权之和最小。","text":"题目传送门 题意 给定一个\\(n\\)个点，\\(m\\)条边的有权无向图，每个点有一个高度，求一个以\\(1\\)为根的树，满足父亲的高度大于等于儿子的高度。在树的节点数最多的情况下，树上的边权之和最小。 题解 如果没有高度限制，直接\\(Kruskal\\)一遍就好了。 有了高度呢？其实变成了有向图，求一个点最多，边权值和最小的生成树。 第一问很好做，直接对这个有向图从\\(1\\)开始\\(bfs/dfs\\)一遍就好了。 \\(bfs/dfs\\)之后，原来的有向图就变成了从1开始能到达的所有点组成的一个有向图。 显然，如果两个点高度相同，那么这两个点之间连的边可以看成无向边，直接按边权排序做即可。 再考虑一个问题，两个点\\(x,y\\)需要在树上联通，一定不会通过另一个高度比它们小的点进行联通的。 所以我们对于新图中的每条边\\(u\\to v\\)，优先按\\(h_v\\)从大到小，\\(h_v\\)相等按边权从小到大排序即可。 然后就是最简单的Kruskal了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/************************************************************** Problem: 2753 User: rill7747 Language: C++ Result: Accepted Time:6972 ms Memory:84612 kb****************************************************************/ #include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f = 0; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 2000005int n, m, h[N], fa[N], cnt;int edge, to[N], tw[N], pr[N], hd[N], vis[N];void addedge(int u, int v, int w)&#123; to[++edge] = v, tw[edge] = w, pr[edge] = hd[u], hd[u] = edge;&#125;struct node&#123; int u, v, w; bool operator &lt; (const node &amp;res) const &#123; return h[v] &gt; h[res.v] || h[v] == h[res.v] &amp;&amp; w &lt; res.w; &#125;&#125;E[N];void dfs(int u)&#123; ++cnt, vis[u] = 1; for (register int i = hd[u], v; i; i = pr[i])&#123; if (!vis[v = to[i]]) dfs(v); E[++m] = (node)&#123;u, v, tw[i]&#125;; &#125;&#125;int find(int x)&#123; return x == fa[x] ? x : (fa[x] = find(fa[x]));&#125;int merge(int x, int y)&#123; int fx = find(x), fy = find(y); if (fx == fy) return 0; return fa[fy] = fx, 1;&#125;long long Kruskal()&#123; std :: sort(E + 1, E + 1 + m); for (register int i = 1; i &lt;= n; ++i) fa[i] = i; long long ans = 0; int sum = 0; for (register int i = 1; i &lt;= m; ++i)&#123; if (merge(E[i].u, E[i].v)) ans += E[i].w, ++sum; if (sum == cnt - 1) break; &#125; return ans;&#125;int main()&#123; n = read(), m = read(); for (register int i = 1; i &lt;= n; ++i) h[i] = read(); for (register int i = 1; i &lt;= m; ++i)&#123; int u = read(), v = read(), w = read(); if (h[u] &gt;= h[v]) addedge(u, v, w); if (h[v] &gt;= h[u]) addedge(v, u, w); &#125; m = 0, dfs(1); printf(&quot;%d %lld&quot;, cnt, Kruskal());&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"BZOJ","slug":"题解/BZOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/BZOJ/"}],"tags":[{"name":"SCOI","slug":"SCOI","permalink":"https://autumnkite.github.io/tags/SCOI/"},{"name":"Kruskal","slug":"Kruskal","permalink":"https://autumnkite.github.io/tags/Kruskal/"}]},{"title":"「BZOJ1568」「JSOI2008」Blue Mary开公司","slug":"bzoj1568-sol-lcst-notes","date":"2018-10-19T07:58:00.000Z","updated":"2020-03-26T07:22:57.182Z","comments":true,"path":"bzoj1568-sol-lcst-notes/","link":"","permalink":"https://autumnkite.github.io/bzoj1568-sol-lcst-notes/","excerpt":"题目传送门 李超线段树模板题。 题意 维护一个二维平面，支持两种操作：插入一条直线（\\(y=kx+b\\)）；询问当前插入的所有直线\\(x=x_0\\)时最大的纵坐标的值。","text":"题目传送门 李超线段树模板题。 题意 维护一个二维平面，支持两种操作：插入一条直线（\\(y=kx+b\\)）；询问当前插入的所有直线\\(x=x_0\\)时最大的纵坐标的值。 题解 李超线段树。 一个节点同样表示一个区间\\([l,r]\\)，记录的是一条直线\\(id[u]\\)，这条直线是\\(x=mid\\)时纵坐标最大的直线。 插入一条直线时，流程如下： 直线\\(id[u]\\)和\\(i\\)没有交点：直接取\\(y\\)值大的，退出。 如果当\\(x=mid\\)时，直线\\(i\\)的\\(y\\)值比\\(id[u]\\)大，那么交换\\(id[u],i\\)。 如果\\(id[u]\\)和\\(i\\)的交点在mid左边，即当\\(x=l\\)时，直线\\(i\\)的\\(y\\)值大于等于\\(id[u]\\)，那么递归处理\\([l,mid]\\)，这种情况下其实\\([mid+1,r]\\)的直线要改变，但因为询问时是从叶子节点到根节点取\\(max\\)的，所以没有必要更新。 如果\\(id[u]\\)和\\(i\\)的交点在mid右边，即当\\(x=r\\)时，直线\\(i\\)的\\(y\\)值大于等于\\(id[u]\\)，那么递归处理\\([mid+1,r]\\)，此时没有3中的情况。 至于询问，已经提过，只要从叶节点到根取max就好了。 代码 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define N 500005int n, m, x;double k[N], b[N];char opt[15];struct Li_Chao_Segment_Tree&#123; int id[N]; int check(int u, int v, int x)&#123; return k[u] * (x - 1) + b[u] &lt;= k[v] * (x - 1) + b[v]; &#125; void Insert(int u, int l, int r, int x)&#123; if (check(id[u], x, l) &amp;&amp; check(id[u], x, r)) return id[u] = x, void(0); if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (check(id[u], x, mid)) std :: swap(id[u], x); if (check(id[u], x, l)) Insert(u &lt;&lt; 1, l, mid, x); if (check(id[u], x, r)) Insert(u &lt;&lt; 1 | 1, mid + 1, r, x); &#125; double Query(int u, int l, int r, int x)&#123; if (l == r) return k[l] * (x - 1) + b[l]; int mid = (l + r) &gt;&gt; 1; double ans; if (x &lt;= mid) ans = Query(u &lt;&lt; 1, l, mid, x); else ans = Query(u &lt;&lt; 1 | 1, mid + 1, r, x); return std :: max(ans, k[id[u]] * (x - 1) + b[id[u]]); &#125;&#125;T;int main()&#123; for (scanf(&quot;%d&quot;, &amp;m); m--; )&#123; scanf(&quot;%s&quot;, opt); if (opt[0] == &#x27;P&#x27;) ++n, scanf(&quot;%lf%lf&quot;, b + n, k + n), T.Insert(1, 1, 50000, n); else scanf(&quot;%d&quot;, &amp;x), printf(&quot;%d\\n&quot;, int(T.Query(1, 1, 50000, x) / 100)); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"BZOJ","slug":"题解/BZOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/BZOJ/"}],"tags":[{"name":"JSOI","slug":"JSOI","permalink":"https://autumnkite.github.io/tags/JSOI/"},{"name":"李超线段树","slug":"李超线段树","permalink":"https://autumnkite.github.io/tags/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"「BZOJ3083」遥远的国度","slug":"bzoj3083-sol","date":"2018-10-19T05:10:00.000Z","updated":"2020-03-26T07:22:57.184Z","comments":true,"path":"bzoj3083-sol/","link":"","permalink":"https://autumnkite.github.io/bzoj3083-sol/","excerpt":"题目传送门 题意 给定一棵有点权的树和初始的根，支持三种操作：换根，修改路径上的权值，查询子树权值\\(min\\)。","text":"题目传送门 题意 给定一棵有点权的树和初始的根，支持三种操作：换根，修改路径上的权值，查询子树权值\\(min\\)。 题解 如果没有换根，这就是树剖+线段树裸题了。 那么有换根呢？首先我们一开始认定初始给定的根作为根进行树剖。 换根之后，路径修改显然不产生影响，直接用线段树维护就好了。假设现在的根为\\(rt\\)，查询子树的根节点为\\(x\\)，分以下三种情况（可以脑补一下或者画个图）： \\(rt=x\\) \\(rt\\)在\\(x\\)的子树外 \\(rt\\)在\\(x\\)的子树内（不包括\\(x\\)） 注意这里的子树是相对于以初始根为根时的树而言的。 对于1，相当于查询整棵树的min，直接在整棵线段树上查询就好了。 对于2，又有两种情况：一种是\\(x\\)在\\(rt\\)的子树内（不包括\\(rt\\)），另一种是\\(x\\)的子树和\\(rt\\)的子树互不包含。 画一下图即可知道，这两种情况是一样的，即不需要考虑换根，换根之后\\(x\\)子树中的节点没有变化，直接查询以初始根为根时\\(x\\)的子树min。 对于3，就有点麻烦了。我们设\\(u\\)是\\(x\\)到\\(rt\\)这条链上除\\(x\\)外的第二个点（\\(x\\)的儿子）。那么在纸上画一下即可得知，换根后的\\(x\\)的子树变为整棵树减去换根前\\(u\\)的子树（注意不是\\(x\\)的子树减去\\(u\\)的子树）。 那么问题在于求u。算法描述如下（设树剖后节点\\(i\\)所在重链的顶端节点为\\(top[i]\\)，节点\\(i\\)的父亲为\\(fa[i]\\)，节点\\(i\\)的重儿子是\\(son[i]\\)）： \\(u\\gets rt\\) 如果\\(fa[top[u]]\\)在\\(x\\)的子树中并且不等于\\(x\\)，那么\\(u\\gets fa[top[u]]\\)。不断执行这一过程直至条件不成立。 如果\\(fa[top[u]]=x\\)，那么\\(u=top[u]\\)，否则\\(u=son[x]\\) 解释一下第三步，因为最后如果\\(fa[top[u]]=x\\)那么\\(top[u]\\)刚好就是这条链上\\(x\\)的儿子了，否则说明\\(fa[top[u]]\\)是\\(x\\)的祖先，即\\(x\\)和\\(u\\)在同一条重链上，那么这条链上\\(x\\)的儿子就是\\(x\\)的重儿子。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/************************************************************** Problem: 3083 User: rill7747 Language: C++ Result: Accepted Time:3312 ms Memory:13452 kb****************************************************************/ #include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;int read()&#123; register int x = 0; register char f = 1, ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == &#x27;-&#x27;) f = 0; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ &#x27;0&#x27;); return f ? x : -x;&#125;#define N 100005int n, m, a[N], rt;int edge, to[N &lt;&lt; 1], pr[N &lt;&lt; 1], hd[N];void addedge(int u, int v)&#123; to[++edge] = v, pr[edge] = hd[u], hd[u] = edge;&#125;int dep[N], fa[N], sz[N], son[N];void dfs(int u)&#123; sz[u] = 1; for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa[u]) fa[v] = u, dep[v] = dep[u] + 1, dfs(v), sz[u] += sz[v], !son[u] || sz[v] &gt; sz[son[u]] ? son[u] = v : 0;&#125;int top[N], idx, st[N], id[N], ed[N];void dfs(int u, int tp)&#123; top[u] = tp, id[st[u] = ++idx] = u; if (son[u]) dfs(son[u], tp); for (register int i = hd[u], v; i; i = pr[i]) if ((v = to[i]) != fa[u] &amp;&amp; v != son[u]) dfs(v, v); ed[u] = idx;&#125;int val[N &lt;&lt; 2], lz[N &lt;&lt; 2];void build(int u, int l, int r)&#123; if (l == r) return val[u] = a[id[l]], lz[u] = 0, void(0); int mid = (l + r) &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r); val[u] = std :: min(val[u &lt;&lt; 1], val[u &lt;&lt; 1 | 1]);&#125;void down(int u)&#123; if (lz[u]) val[u &lt;&lt; 1] = val[u &lt;&lt; 1 | 1] = lz[u &lt;&lt; 1] = lz[u &lt;&lt; 1 | 1] = lz[u];&#125;void modify(int u, int l, int r, int L, int R, int v)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return val[u] = lz[u] = v, void(0); int mid = (l + r) &gt;&gt; 1; down(u); if (L &lt;= mid) modify(u &lt;&lt; 1, l, mid, L, R, v); if (R &gt; mid) modify(u &lt;&lt; 1 | 1, mid + 1, r, L, R, v); val[u] = std :: min(val[u &lt;&lt; 1], val[u &lt;&lt; 1 | 1]);&#125;int query(int u, int l, int r, int L, int R)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return val[u]; int mid = (l + r) &gt;&gt; 1, ans = 2147483647; down(u); if (L &lt;= mid) ans = std :: min(ans, query(u &lt;&lt; 1, l, mid, L, R)); if (R &gt; mid) ans = std :: min(ans, query(u &lt;&lt; 1 | 1, mid + 1, r, L, R)); return ans;&#125;void Modify(int u, int v, int w)&#123; while (top[u] != top[v])&#123; if (dep[top[u]] &lt; dep[top[v]]) std :: swap(u, v); modify(1, 1, n, st[top[u]], st[u], w), u = fa[top[u]]; &#125; if (dep[u] &lt; dep[v]) std :: swap(u, v); modify(1, 1, n, st[v], st[u], w);&#125;int Query(int u)&#123; if (u == rt) return val[1]; if (st[rt] &lt; st[u] || st[rt] &gt; ed[u]) return query(1, 1, n, st[u], ed[u]); int v = rt; while (st[fa[top[v]]] &gt; st[u] &amp;&amp; st[fa[top[v]]] &lt;= ed[u]) v = fa[top[v]]; if (fa[top[v]] == u) v = top[v]; else v = son[u]; return std :: min(query(1, 1, n, 1, st[v] - 1), query(1, 1, n, ed[v] + 1, n));&#125;int main()&#123; n = read(), m = read(); for (register int i = 1, u, v; i &lt; n; ++i) u = read(), v = read(), addedge(u, v), addedge(v, u); for (register int i = 1; i &lt;= n; ++i) a[i] = read(); rt = read(); dfs(rt), dfs(rt, rt), build(1, 1, n); while (m--)&#123; int opt = read(), x, y, w; if (opt == 1) rt = read(); if (opt == 2) x = read(), y = read(), w = read(), Modify(x, y, w); if (opt == 3) printf(&quot;%d\\n&quot;, Query(read())); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"BZOJ","slug":"题解/BZOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/BZOJ/"}],"tags":[{"name":"分类讨论","slug":"分类讨论","permalink":"https://autumnkite.github.io/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://autumnkite.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"线段树","slug":"线段树","permalink":"https://autumnkite.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"NOIP2018之前","slug":"before-noip2018","date":"2018-10-19T05:07:00.000Z","updated":"2020-03-26T07:22:57.181Z","comments":true,"path":"before-noip2018/","link":"","permalink":"https://autumnkite.github.io/before-noip2018/","excerpt":"好久没更新博客了。","text":"好久没更新博客了。 10/14初赛，当时感觉凉凉……emmm不过后来答案出来以后感觉也还可以，选择题连蒙带猜地做竟然只错了1个？ 问题求解T2 想到根据二进制位分类讨论，但没往排列组合方面想。 估分93，ZJ提高，应该还可以吧。 坐等分数线。 虽然初赛还可以，但是ZJ提高组……感觉要凉啊。希望能拿一等。 只有20多天了，突然发现好像什么都不会了。","categories":[{"name":"日常","slug":"日常","permalink":"https://autumnkite.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"NOIP2018","slug":"NOIP2018","permalink":"https://autumnkite.github.io/tags/NOIP2018/"}]},{"title":"中国剩余定理 学习笔记","slug":"crt-notes","date":"2018-09-09T04:48:00.000Z","updated":"2020-03-26T07:22:57.206Z","comments":true,"path":"crt-notes/","link":"","permalink":"https://autumnkite.github.io/crt-notes/","excerpt":"问题 中国剩余定理用来解决如下问题： 求关于\\(x\\)的方程组 \\[\\begin{cases} x \\equiv a_1 \\pmod{p_1} \\\\ x \\equiv a_2 \\pmod{p_2} \\\\ \\cdots \\\\ x \\equiv a_n\\pmod{p_n}\\end{cases}\\] 的最小非负整数解。 其中\\(p_i\\)两两互质。","text":"问题 中国剩余定理用来解决如下问题： 求关于\\(x\\)的方程组 \\[\\begin{cases} x \\equiv a_1 \\pmod{p_1} \\\\ x \\equiv a_2 \\pmod{p_2} \\\\ \\cdots \\\\ x \\equiv a_n\\pmod{p_n}\\end{cases}\\] 的最小非负整数解。 其中\\(p_i\\)两两互质。 前置技能 扩展欧几里得求乘法逆元 求解 设\\(M=\\prod_{i=1}^{n} p_i,d_i=\\frac{M}{p_i}\\)，即\\(d_i\\)表示除\\(p_i\\)外所有\\(p\\)的乘积。 记\\(inv_i\\)表示\\(d_i\\)在模\\(p_i\\)域下的逆元（因为\\(p\\)两两互质，所以\\(d_i\\)一定与\\(p_i\\)互质，所以一定存在逆元），即\\(inv_i \\times d_i \\equiv 1 \\pmod{p_i}\\)。记\\(x_i=inv_i\\times d_i\\)，则： 因为\\(d_i\\)能被除\\(p_i\\)外的所有\\(p\\)整除，所以\\(x_i\\)一定能被除\\(p_i\\)外的所有\\(p\\)整除，所以\\(x_ia_i\\)一定能被除\\(p_i\\)外的所有\\(p\\)整除。 \\(x_i\\equiv 1 \\pmod{p_i}\\)，所以\\(a_ix_i\\equiv a_i \\pmod{p_i}\\)。 根据以上两条推论可得，答案为\\(\\left( \\sum_{i=1}^{n} a_ix_i \\right) \\bmod M\\)。因为对于第\\(i\\)个方程，根据推论1，对于所有的\\(j\\ne i\\)，\\(a_jx_j\\)不会对该方程组产生贡献，即\\(a_jx_j\\equiv 0 \\pmod{p_i} (j\\ne i)\\)。只有\\(a_ix_i\\)会对第\\(i\\)个方程产生贡献，且根据推论2，恰好会产生\\(a_i\\)的贡献。又因为对于所有\\(i\\)，\\(M\\equiv 0\\pmod{p_i}\\)，所以答案加上或减去若干个\\(M\\)都满足方程组。求的是最小非负整数解，所以答案\\(\\bmod M\\)。 代码 中国剩余定理模板题：[TJOI2009]猜数字 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;long long exgcd(long long a, long long b, long long &amp;x, long long &amp;y)&#123; if (!b) return x = 1, y = 0, a; long long x0, y0, g = exgcd(b, a % b, x0, y0); return x = y0, y = x0 - a / b * y0, g;&#125;int n, a[15], p[15];long long inv(long long a, long long p)&#123; long long x, y, g = exgcd(a, p, x, y); if (g != 1) return -1; return (x % p + p) % p;&#125;long long qmul(long long a, long long b, long long p)&#123; long long s = 0; for (a %= p, b %= p; b; b &gt;&gt;= 1, a = (a + a) % p) b &amp; 1 ? s = (s + a) % p : 0; return s; &#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (register int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); for (register int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, p + i); for (register int i = 1; i &lt;= n; ++i) a[i] = (a[i] % p[i] + p[i]) % p[i]; long long m = 1, ans = 0; for (register int i = 1; i &lt;= n; ++i) m = m * p[i]; for (register int i = 1; i &lt;= n; ++i)&#123; long long d = m / p[i], d_ = inv(d, p[i]); (ans += qmul(qmul(d, d_, m), a[i], m)) %= m; &#125; printf(&quot;%lld&quot;, ans);&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://autumnkite.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"中国剩余定理","slug":"中国剩余定理","permalink":"https://autumnkite.github.io/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"}]},{"title":"扩展欧几里得 学习笔记","slug":"exgcd-notes","date":"2018-09-09T04:45:00.000Z","updated":"2020-03-26T07:22:57.210Z","comments":true,"path":"exgcd-notes/","link":"","permalink":"https://autumnkite.github.io/exgcd-notes/","excerpt":"问题 形式1：求方程\\(ax+by=c\\)的任意一组整数解。 形式2：求同余方程\\(ax\\equiv c\\pmod b\\)的最小整数解。","text":"问题 形式1：求方程\\(ax+by=c\\)的任意一组整数解。 形式2：求同余方程\\(ax\\equiv c\\pmod b\\)的最小整数解。 可以发现两种形式的问题可以互相转化。 前置技能 辗转相除法求gcd 求解 根据裴蜀定理，当且仅当\\(gcd(a,b)|c\\)时，原方程有整数解。 所以我们考虑解决方程\\(ax+by=gcd(a,b)\\)，最后同乘\\(\\frac{c}{gcd(a,b)}\\)即可。 为方便描述，我们用\\(\\%\\)代替\\(\\bmod\\)。 有性质\\(gcd(a,b)=gcd(b,a\\%b)\\) 我们假设已经解出方程\\(bx&#39;+(a\\%b)y&#39;=gcd(b,a\\%b)\\)，即\\(bx&#39;+(a\\%b)y&#39;=gcd(a,b)\\)。 将\\(a\\%b\\)展开，得\\(bx&#39;+(a-\\lfloor \\frac{a}{b}\\rfloor\\times b)y&#39;=gcd(a,b)\\)。 即\\(ay&#39;+b(x&#39;-\\lfloor \\frac{a}{b}\\rfloor y&#39;)=gcd(a,b)\\)。 令\\(x=y&#39;,y=x&#39;-\\lfloor \\frac{a}{b}\\rfloor y&#39;\\)，我们得到了原方程得一组解。 所以可以递归求解，终止条件是\\(b=0\\)，此时\\(gcd(a,b)=a\\)，方程组的解是\\(x=1,y=0\\)。 求\\(x\\)最小的解： 因为如果\\((x,y)\\)是一组解，则\\((x+\\frac{b}{gcd(a,b)},y-\\frac{a}{gcd(a,b)})\\)也是一组解，可以根据这个求出最小解。 代码 1234567891011121314#include &lt;cstdio&gt;int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if (!b) return x = 1, y = 0, a; int x0, y0, g = exgcd(b, a % b, x0, y0); return x = y0, y = x0 - a / b * y0, g;&#125;int a, b, c;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); int x, y, g = exgcd(a, b, x, y); if (c % g) return printf(&quot;Impossible&quot;), 0; x *= c / g, y *= c / g; printf(&quot;%d %d&quot;, x, y);&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://autumnkite.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"https://autumnkite.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"}]},{"title":"乘法逆元 学习笔记","slug":"inv-notes","date":"2018-09-09T04:43:00.000Z","updated":"2020-03-26T07:22:57.213Z","comments":true,"path":"inv-notes/","link":"","permalink":"https://autumnkite.github.io/inv-notes/","excerpt":"问题 用来解决模域下的除法问题。 求解 乘法逆元的定义：\\(ab\\equiv 1 \\pmod p\\)，则\\(b\\)称为\\(a\\)在模\\(p\\)域下的乘法逆元。乘法逆元不一定存在，存在条件请参见下文。","text":"问题 用来解决模域下的除法问题。 求解 乘法逆元的定义：\\(ab\\equiv 1 \\pmod p\\)，则\\(b\\)称为\\(a\\)在模\\(p\\)域下的乘法逆元。乘法逆元不一定存在，存在条件请参见下文。 这样我们就可以轻松解决模域下的除法问题。即假设我们要求\\(\\frac{a}{b} \\bmod p\\)的值，用\\(inv(x)\\)表示\\(x\\)在模\\(p\\)域下的乘法逆元，则\\(\\frac{a}{b} \\bmod p=\\frac{a\\cdot b\\cdot inv(b)}{b}\\bmod p=a\\cdot inv(b) \\bmod p\\)，所以我们把除法变成了乘法，就可以利用乘法在模域下的一些性质对原问题进行求解或转化。 问题在于如何求出\\(inv(b)\\)。求乘法逆元有许多方法。 扩展欧几里得 根据乘法逆元的定义，我们要求\\(inv(a)\\)，就是求同余方程\\(ax\\equiv 1 \\pmod p\\)的最小整数解。 考虑将该同余方程转化为一般形式，即\\(ax+py=1\\)。 很容易就能求出\\(x\\)的最小整数解。 根据裴蜀定理可知，方程\\(ax+by=c\\)只有当\\(gcd(a,b)|c\\)时才有整数解。所以只有当\\(gcd(a,p)=1\\)时，逆元才唯一存在。 费马小定理 费马小定理：当\\(p\\)是质数时，\\(a^{p-1}\\equiv 1 \\pmod p\\)。即\\(a\\cdot a^{p-2}\\equiv 1\\pmod p\\)。所以\\(inv(a)=a^{p-2}\\)。 欧拉定理 欧拉定理：当\\(a,p\\)互质时，\\(a^{\\varphi(p)}\\equiv 1 \\pmod p\\)。即\\(a\\cdot a^{\\varphi(p)-1}\\equiv 1\\pmod p\\)。所以\\(inv(a)=a^{\\varphi(p)-1}\\)。 \\(\\varphi(p)\\)即欧拉函数，表示小于等于\\(p\\)的正整数中，与\\(p\\)互质的数的个数。 因为当\\(p\\)是质数时，\\(\\varphi(p)=p-1\\)，所以费马小定理是欧拉定理的特殊形式。 \\(\\varphi(p)\\)的求法不详细介绍。 特例 还有一些奇怪的特例，例如求\\(1\\)到\\(n\\)所有数在模\\(p\\)域下的逆元，还有\\(1\\)到\\(n\\)所有数的阶乘在模\\(p\\)域下的逆元，这些可以\\(O(n)\\)求出。 不详细介绍。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://autumnkite.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"逆元","slug":"逆元","permalink":"https://autumnkite.github.io/tags/%E9%80%86%E5%85%83/"}]},{"title":"「Codeforces 815D」Karen and Cards","slug":"cf815d-sol","date":"2018-09-09T04:40:00.000Z","updated":"2020-03-26T07:22:57.205Z","comments":true,"path":"cf815d-sol/","link":"","permalink":"https://autumnkite.github.io/cf815d-sol/","excerpt":"题目传送门 Karen and Cards Karen just got home from the supermarket, and is getting ready to go to sleep.","text":"题目传送门 Karen and Cards Karen just got home from the supermarket, and is getting ready to go to sleep. img After taking a shower and changing into her pajamas, she looked at her shelf and saw an album. Curious, she opened it and saw a trading card collection. She recalled that she used to play with those cards as a child, and, although she is now grown-up, she still wonders a few things about it. Each card has three characteristics: strength, defense and speed. The values of all characteristics of all cards are positive integers. The maximum possible strength any card can have is \\(p\\), the maximum possible defense is \\(q\\) and the maximum possible speed is \\(r\\). There are \\(n\\) cards in her collection. The \\(i\\)-th card has a strength \\(a_i\\), defense \\(b_i\\) and speed \\(c_i\\), respectively. A card beats another card if at least two of its characteristics are strictly greater than the corresponding characteristics of the other card. She now wonders how many different cards can beat all the cards in her collection. Two cards are considered different if at least one of their characteristics have different values. Input The first line of input contains four integers, \\(n,p,q\\) and \\(r\\) (\\(1 \\le n,p,q,r \\le 500000\\)), the number of cards in the collection, the maximum possible strength, the maximum possible defense, and the maximum possible speed, respectively. The next \\(n\\) lines each contain three integers. In particular, the \\(i\\)-th line contains \\(a_i,b_i\\) and \\(c_i\\) (\\(1\\le a_i\\le p,1\\le b_i\\le q,1\\le c_i\\le r\\)), the strength, defense and speed of the \\(i\\)-th collection card, respectively. Output Output a single integer on a line by itself, the number of different cards that can beat all the cards in her collection. Examples Input 12343 4 4 52 2 51 3 44 1 1 Output 110 Input 1234565 10 10 101 1 11 1 11 1 11 1 11 1 1 Output 1972 Note In the first test case, the maximum possible strength is 4, the maximum possible defense is 4 and the maximum possible speed is 5. Karen has three cards: The first card has strength 2, defense 2 and speed 5. The second card has strength 1, defense 3 and speed 4. The third card has strength 4, defense 1 and speed 1. There are 10 cards that beat all the cards here: The card with strength 3, defense 3 and speed 5. The card with strength 3, defense 4 and speed 2. The card with strength 3, defense 4 and speed 3. The card with strength 3, defense 4 and speed 4. The card with strength 3, defense 4 and speed 5. The card with strength 4, defense 3 and speed 5. The card with strength 4, defense 4 and speed 2. The card with strength 4, defense 4 and speed 3. The card with strength 4, defense 4 and speed 4. The card with strength 4, defense 4 and speed 5. In the second test case, the maximum possible strength is 10, the maximum possible defense is 10 and the maximum possible speed is 10. Karen has five cards, all with strength 1, defense 1 and speed 1. Any of the 972 cards which have at least two characteristics greater than 1 can beat all of the cards in her collection. Problem 给定\\(n\\)个三元组\\((a_i,b_i,c_i)\\)，以及三元组中每个数的上限\\(p,q,r\\)，定义一个三元组能击败另一个三元组当且仅当这个三元组中有任意两个数严格大于另一个三元组对应的两个数。求有多少三元组能击败所有\\(n\\)个三元组。 Solution 记满足条件的三元组为\\((x,y,z)\\)。显然如果枚举\\(x\\)，则三元组可以分为两类：\\(a_i&lt;x\\)与\\(a_i\\ge x\\)。对于\\(a_i&lt;x\\)的三元组，只需要满足\\(y&gt;b_i\\)或者\\(z&gt;c_i\\)。而对于\\(a_i\\ge x\\)的三元组，需要满足\\(y&gt;b_i\\)并且\\(z&gt;c_i\\)。 记\\(smx_j(j\\in [1,q])\\)表示\\(b_i\\ge j\\)的三元组中最大的\\(c_i\\)，\\(mx3\\)表示\\(a_i\\ge x\\)的三元组中最大的\\(c_i\\)。那么\\(z\\)的方案数就是\\(r-max(smx_y,mx3)\\)，即\\(z\\)需要满足\\(z&gt;smx_y,z&gt;mx3\\)，因为对于\\(a_i\\ge x\\)的三元组，\\(z\\)一定大于\\(c_i\\)，且对于\\(b_i\\ge y\\)的三元组，\\(z\\)也一定大于\\(c_i\\)。 记\\(mx2\\)表示\\(a_i\\ge x\\)的三元组中最大的\\(b_i\\)，那么当\\(x\\)固定时，总方案可以用for (int i=mx2+1;i&lt;=q;i++) ans+=r-max(smx[i],mx3);进行统计。 这样的话，因为我们要统计\\(a_i\\ge x\\)的三元组中最大的\\(b_i\\)（\\(mx2\\)），最大的\\(c_i\\)（\\(mx3\\)），所以我们应该倒着枚举\\(x\\)。 时间复杂度？\\(\\mathcal O(n^2)\\)。显然不能过。 考虑优化for (int i=mx2+1;i&lt;=q;i++) ans+=r-max(smx[i],mx3);这段代码。 \\(max\\)很不好处理，我们考虑把它拆开分别计算。由\\(smx_i\\)的定义可得，\\(\\{smx_i\\}\\)单调不升，也就是\\(i\\)越小，\\(smx_i\\)越大。那么我们找到一个\\(max\\)分界线，记为\\(k\\)，使得\\(i\\ge k\\)时，\\(smx_i\\le mx3\\)，\\(i&lt;k\\)时，\\(smx_i&gt;mx3\\)。于是就可以\\(\\mathcal O(1)\\)计算答案了，用前缀和维护\\(\\{smx_i\\}\\)的区间和即可。 显然，\\(\\{smx_i\\},mx2,mx3\\)很容易维护。那么\\(k\\)怎么办呢？因为\\(x\\)从大到小枚举，\\(mx3\\)会逐渐变大，而\\(\\{smx_i\\}\\)单调不升，所以\\(k\\)慢慢变小（向前），一直维护即可。 一些细节具体见代码。 Source 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int read()&#123; int x=0; int f=1,ch=getchar(); for (;!isdigit(ch)&amp;&amp;ch!=EOF;ch=getchar()) if (ch==&#x27;-&#x27;) f=-1; for (;isdigit(ch);ch=getchar()) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^&#x27;0&#x27;); return x*f;&#125;const int N=500005;int n,La,Lb,Lc,smx[N];struct card&#123; int b,c;&#125;;vector&lt;card&gt; d[N];long long ans,sum[N];int main()&#123; n=read(),La=read(),Lb=read(),Lc=read(); //La,Lb,Lc分别代表p,q,r for (register int i=1;i&lt;=n;++i)&#123; int a=min(La,read()),b=min(Lb,read()),c=min(Lc,read()); d[a].push_back((card)&#123;b,c&#125;); smx[b]=max(smx[b],c); &#125; for (register int i=Lb-1;i;--i) smx[i]=max(smx[i],smx[i+1]); for (register int i=1;i&lt;=Lb;++i) sum[i]=sum[i-1]+smx[i]; //smx[i]的前缀和 int mxb=0,mxc=0,k=Lb+1; //初始值 for (register int x=La;x;--x)&#123; //从大到小枚举 for (register int i=0;i&lt;d[x].size();++i)&#123; int y=d[x][i].b,z=d[x][i].c; mxb=max(mxb,y),mxc=max(mxc,z); //维护mx2和mx3 while (k&gt;mxb+1&amp;&amp;smx[k-1]&lt;mxc) --k; //维护k &#125; k=max(k,mxb+1); //防止越界 ans+=1ll*(Lc-mxc)*(Lb-k+1)+1ll*Lc*(k-mxb-1)-sum[k-1]+sum[mxb]; //利用前缀和O(1)统计答案 &#125; printf(&quot;%lld&quot;,ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"}],"tags":[{"name":"三维数点","slug":"三维数点","permalink":"https://autumnkite.github.io/tags/%E4%B8%89%E7%BB%B4%E6%95%B0%E7%82%B9/"},{"name":"单调性","slug":"单调性","permalink":"https://autumnkite.github.io/tags/%E5%8D%95%E8%B0%83%E6%80%A7/"}]}],"categories":[{"name":"游记","slug":"游记","permalink":"https://autumnkite.github.io/categories/%E6%B8%B8%E8%AE%B0/"},{"name":"NOI","slug":"游记/NOI","permalink":"https://autumnkite.github.io/categories/%E6%B8%B8%E8%AE%B0/NOI/"},{"name":"题解","slug":"题解","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"Codeforces","slug":"题解/Codeforces","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Codeforces/"},{"name":"公告","slug":"公告","permalink":"https://autumnkite.github.io/categories/%E5%85%AC%E5%91%8A/"},{"name":"笔记","slug":"笔记","permalink":"https://autumnkite.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"JSC 2019 Qual","slug":"题解/AtCoder/JSC-2019-Qual","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/JSC-2019-Qual/"},{"name":"LOJ","slug":"题解/LOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/LOJ/"},{"name":"模拟赛","slug":"题解/模拟赛","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"Xmas Contest 2015","slug":"题解/AtCoder/Xmas-Contest-2015","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/Xmas-Contest-2015/"},{"name":"CODE FESTIVAL 2015 OKINAWA OPEN","slug":"题解/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/AtCoder/CODE-FESTIVAL-2015-OKINAWA-OPEN/"},{"name":"PKUWC","slug":"游记/PKUWC","permalink":"https://autumnkite.github.io/categories/%E6%B8%B8%E8%AE%B0/PKUWC/"},{"name":"Luogu","slug":"题解/Luogu","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/Luogu/"},{"name":"BZOJ","slug":"题解/BZOJ","permalink":"https://autumnkite.github.io/categories/%E9%A2%98%E8%A7%A3/BZOJ/"},{"name":"日常","slug":"日常","permalink":"https://autumnkite.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://autumnkite.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"枚举","slug":"枚举","permalink":"https://autumnkite.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"构造","slug":"构造","permalink":"https://autumnkite.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"DP","slug":"DP","permalink":"https://autumnkite.github.io/tags/DP/"},{"name":"组合数学","slug":"组合数学","permalink":"https://autumnkite.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"Boruvka","slug":"Boruvka","permalink":"https://autumnkite.github.io/tags/Boruvka/"},{"name":"并查集","slug":"并查集","permalink":"https://autumnkite.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"set","slug":"set","permalink":"https://autumnkite.github.io/tags/set/"},{"name":"分治","slug":"分治","permalink":"https://autumnkite.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"数学","slug":"数学","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"网络流","slug":"网络流","permalink":"https://autumnkite.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"上下界费用流","slug":"上下界费用流","permalink":"https://autumnkite.github.io/tags/%E4%B8%8A%E4%B8%8B%E7%95%8C%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"图论","slug":"图论","permalink":"https://autumnkite.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"分类讨论","slug":"分类讨论","permalink":"https://autumnkite.github.io/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/"},{"name":"二分","slug":"二分","permalink":"https://autumnkite.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"概率","slug":"概率","permalink":"https://autumnkite.github.io/tags/%E6%A6%82%E7%8E%87/"},{"name":"期望","slug":"期望","permalink":"https://autumnkite.github.io/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"高斯消元","slug":"高斯消元","permalink":"https://autumnkite.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"name":"模拟","slug":"模拟","permalink":"https://autumnkite.github.io/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"最短路","slug":"最短路","permalink":"https://autumnkite.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"博弈","slug":"博弈","permalink":"https://autumnkite.github.io/tags/%E5%8D%9A%E5%BC%88/"},{"name":"容斥","slug":"容斥","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"差分约束","slug":"差分约束","permalink":"https://autumnkite.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"BFS","slug":"BFS","permalink":"https://autumnkite.github.io/tags/BFS/"},{"name":"树的直径","slug":"树的直径","permalink":"https://autumnkite.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"双指针","slug":"双指针","permalink":"https://autumnkite.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"DFS","slug":"DFS","permalink":"https://autumnkite.github.io/tags/DFS/"},{"name":"费用流","slug":"费用流","permalink":"https://autumnkite.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"集合幂级数","slug":"集合幂级数","permalink":"https://autumnkite.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"},{"name":"FWT","slug":"FWT","permalink":"https://autumnkite.github.io/tags/FWT/"},{"name":"数论","slug":"数论","permalink":"https://autumnkite.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"状压DP","slug":"状压DP","permalink":"https://autumnkite.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"容斥原理","slug":"容斥原理","permalink":"https://autumnkite.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"},{"name":"计算几何","slug":"计算几何","permalink":"https://autumnkite.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"bitset","slug":"bitset","permalink":"https://autumnkite.github.io/tags/bitset/"},{"name":"区间DP","slug":"区间DP","permalink":"https://autumnkite.github.io/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"堆","slug":"堆","permalink":"https://autumnkite.github.io/tags/%E5%A0%86/"},{"name":"二分图匹配","slug":"二分图匹配","permalink":"https://autumnkite.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"},{"name":"链表","slug":"链表","permalink":"https://autumnkite.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"单调队列","slug":"单调队列","permalink":"https://autumnkite.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://autumnkite.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"Min-Max容斥","slug":"Min-Max容斥","permalink":"https://autumnkite.github.io/tags/Min-Max%E5%AE%B9%E6%96%A5/"},{"name":"最小割","slug":"最小割","permalink":"https://autumnkite.github.io/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"},{"name":"交互","slug":"交互","permalink":"https://autumnkite.github.io/tags/%E4%BA%A4%E4%BA%92/"},{"name":"搜索","slug":"搜索","permalink":"https://autumnkite.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"背包","slug":"背包","permalink":"https://autumnkite.github.io/tags/%E8%83%8C%E5%8C%85/"},{"name":"Lucas定理","slug":"Lucas定理","permalink":"https://autumnkite.github.io/tags/Lucas%E5%AE%9A%E7%90%86/"},{"name":"SG函数","slug":"SG函数","permalink":"https://autumnkite.github.io/tags/SG%E5%87%BD%E6%95%B0/"},{"name":"线性规划","slug":"线性规划","permalink":"https://autumnkite.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"},{"name":"对偶","slug":"对偶","permalink":"https://autumnkite.github.io/tags/%E5%AF%B9%E5%81%B6/"},{"name":"凸包","slug":"凸包","permalink":"https://autumnkite.github.io/tags/%E5%87%B8%E5%8C%85/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://autumnkite.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"trie","slug":"trie","permalink":"https://autumnkite.github.io/tags/trie/"},{"name":"线性基","slug":"线性基","permalink":"https://autumnkite.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"},{"name":"竞赛图","slug":"竞赛图","permalink":"https://autumnkite.github.io/tags/%E7%AB%9E%E8%B5%9B%E5%9B%BE/"},{"name":"FFT","slug":"FFT","permalink":"https://autumnkite.github.io/tags/FFT/"},{"name":"树状数组","slug":"树状数组","permalink":"https://autumnkite.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"AC自动机","slug":"AC自动机","permalink":"https://autumnkite.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"manacher","slug":"manacher","permalink":"https://autumnkite.github.io/tags/manacher/"},{"name":"线段树","slug":"线段树","permalink":"https://autumnkite.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"递推","slug":"递推","permalink":"https://autumnkite.github.io/tags/%E9%80%92%E6%8E%A8/"},{"name":"meet in middle","slug":"meet-in-middle","permalink":"https://autumnkite.github.io/tags/meet-in-middle/"},{"name":"多项式","slug":"多项式","permalink":"https://autumnkite.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"差分","slug":"差分","permalink":"https://autumnkite.github.io/tags/%E5%B7%AE%E5%88%86/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://autumnkite.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"可持久化线段树","slug":"可持久化线段树","permalink":"https://autumnkite.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"括号序列","slug":"括号序列","permalink":"https://autumnkite.github.io/tags/%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"},{"name":"哈希","slug":"哈希","permalink":"https://autumnkite.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"https://autumnkite.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"},{"name":"矩阵求逆","slug":"矩阵求逆","permalink":"https://autumnkite.github.io/tags/%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86/"},{"name":"离散","slug":"离散","permalink":"https://autumnkite.github.io/tags/%E7%A6%BB%E6%95%A3/"},{"name":"倍增","slug":"倍增","permalink":"https://autumnkite.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"name":"树形DP","slug":"树形DP","permalink":"https://autumnkite.github.io/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"KMP","slug":"KMP","permalink":"https://autumnkite.github.io/tags/KMP/"},{"name":"复杂度分析","slug":"复杂度分析","permalink":"https://autumnkite.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"},{"name":"单调栈","slug":"单调栈","permalink":"https://autumnkite.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"矩阵","slug":"矩阵","permalink":"https://autumnkite.github.io/tags/%E7%9F%A9%E9%98%B5/"},{"name":"RMQ","slug":"RMQ","permalink":"https://autumnkite.github.io/tags/RMQ/"},{"name":"三分","slug":"三分","permalink":"https://autumnkite.github.io/tags/%E4%B8%89%E5%88%86/"},{"name":"TJOI","slug":"TJOI","permalink":"https://autumnkite.github.io/tags/TJOI/"},{"name":"BSGS","slug":"BSGS","permalink":"https://autumnkite.github.io/tags/BSGS/"},{"name":"建图","slug":"建图","permalink":"https://autumnkite.github.io/tags/%E5%BB%BA%E5%9B%BE/"},{"name":"NOIP2018","slug":"NOIP2018","permalink":"https://autumnkite.github.io/tags/NOIP2018/"},{"name":"AHOI","slug":"AHOI","permalink":"https://autumnkite.github.io/tags/AHOI/"},{"name":"HNOI","slug":"HNOI","permalink":"https://autumnkite.github.io/tags/HNOI/"},{"name":"NTT","slug":"NTT","permalink":"https://autumnkite.github.io/tags/NTT/"},{"name":"分块","slug":"分块","permalink":"https://autumnkite.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"MEX","slug":"MEX","permalink":"https://autumnkite.github.io/tags/MEX/"},{"name":"中国剩余定理","slug":"中国剩余定理","permalink":"https://autumnkite.github.io/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"},{"name":"栈","slug":"栈","permalink":"https://autumnkite.github.io/tags/%E6%A0%88/"},{"name":"同余","slug":"同余","permalink":"https://autumnkite.github.io/tags/%E5%90%8C%E4%BD%99/"},{"name":"NOI","slug":"NOI","permalink":"https://autumnkite.github.io/tags/NOI/"},{"name":"Splay","slug":"Splay","permalink":"https://autumnkite.github.io/tags/Splay/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://autumnkite.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"逆元","slug":"逆元","permalink":"https://autumnkite.github.io/tags/%E9%80%86%E5%85%83/"},{"name":"SCOI","slug":"SCOI","permalink":"https://autumnkite.github.io/tags/SCOI/"},{"name":"Kruskal","slug":"Kruskal","permalink":"https://autumnkite.github.io/tags/Kruskal/"},{"name":"JSOI","slug":"JSOI","permalink":"https://autumnkite.github.io/tags/JSOI/"},{"name":"李超线段树","slug":"李超线段树","permalink":"https://autumnkite.github.io/tags/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"https://autumnkite.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"},{"name":"三维数点","slug":"三维数点","permalink":"https://autumnkite.github.io/tags/%E4%B8%89%E7%BB%B4%E6%95%B0%E7%82%B9/"},{"name":"单调性","slug":"单调性","permalink":"https://autumnkite.github.io/tags/%E5%8D%95%E8%B0%83%E6%80%A7/"}]}